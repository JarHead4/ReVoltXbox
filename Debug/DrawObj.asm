; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\DrawObj.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildAllCarWorldMatrices@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildCarMatricesNew@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawAllCars@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawAllGhostCars@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawCar@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawCarGhost@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawAllCarShadows@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawCarAerial2@@YAXPAUAERIAL@@PAUMODEL@@1F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawCarBoundingBoxes@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawSkidMarks@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawObjects@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderObject@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderPlanet@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderSun@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderPlane@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderCopter@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderDragon@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawGridCollPolys@@YAXPAUCOLLGRID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderTrolley@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderTrain@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderStrobe@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderPickup@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderDissolveModel@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderLaser@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTarget@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderSplash@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderSpeedup@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?CarShadowTable@@3PAUCAR_SHADOW_TABLE@@A	; CarShadowTable
PUBLIC	?SunFacingPoly@@3UFACING_POLY@@A		; SunFacingPoly
PUBLIC	?DragonFireFacingPoly@@3UFACING_POLY@@A		; DragonFireFacingPoly
_BSS	SEGMENT
?SunFacingPoly@@3UFACING_POLY@@A DB 020H DUP (?)	; SunFacingPoly
?DragonFireFacingPoly@@3UFACING_POLY@@A DB 020H DUP (?)	; DragonFireFacingPoly
_BSS	ENDS
_DATA	SEGMENT
?CarShadowTable@@3PAUCAR_SHADOW_TABLE@@A DD 0c2140000r ; -37 ; CarShadowTable
	DD	042140000r			; 37
	DD	0429a0000r			; 77
	DD	0c28c0000r			; -70
	DD	0c1000000r			; -8
	DD	042000000r			; 32
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2140000r			; -37
	DD	042140000r			; 37
	DD	042a20000r			; 81
	DD	0c29e0000r			; -79
	DD	0c1000000r			; -8
	DD	043600000r			; 224
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2500000r			; -52
	DD	042500000r			; 52
	DD	042e60000r			; 115
	DD	0c2f80000r			; -124
	DD	0c1000000r			; -8
	DD	043000000r			; 128
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2200000r			; -40
	DD	042200000r			; 40
	DD	042aa0000r			; 85
	DD	0c2b40000r			; -90
	DD	0c1000000r			; -8
	DD	043200000r			; 160
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2300000r			; -44
	DD	042300000r			; 44
	DD	042be0000r			; 95
	DD	0c2ba0000r			; -93
	DD	0c1000000r			; -8
	DD	043000000r			; 128
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c21c0000r			; -39
	DD	0421c0000r			; 39
	DD	042b20000r			; 89
	DD	0c2ac0000r			; -86
	DD	0c1000000r			; -8
	DD	043400000r			; 192
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2300000r			; -44
	DD	042300000r			; 44
	DD	042a80000r			; 84
	DD	0c2c20000r			; -97
	DD	0c1000000r			; -8
	DD	043400000r			; 192
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c20c0000r			; -35
	DD	0420c0000r			; 35
	DD	042980000r			; 76
	DD	0c28a0000r			; -69
	DD	0c1000000r			; -8
	DD	042000000r			; 32
	DD	043400000r			; 192
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2340000r			; -45
	DD	042340000r			; 45
	DD	042980000r			; 76
	DD	0c2b80000r			; -92
	DD	0c1000000r			; -8
	DD	042c00000r			; 96
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2440000r			; -49
	DD	042440000r			; 49
	DD	042ec0000r			; 118
	DD	0c2c20000r			; -97
	DD	0c1000000r			; -8
	DD	043200000r			; 160
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c24c0000r			; -51
	DD	0424c0000r			; 51
	DD	042d60000r			; 107
	DD	0c2c80000r			; -100
	DD	0c1000000r			; -8
	DD	000000000r			; 0
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2240000r			; -41
	DD	042240000r			; 41
	DD	042a80000r			; 84
	DD	0c2a20000r			; -81
	DD	0c1000000r			; -8
	DD	043200000r			; 160
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2800000r			; -64
	DD	042800000r			; 64
	DD	043040000r			; 132
	DD	0c2fe0000r			; -127
	DD	0c1000000r			; -8
	DD	042c00000r			; 96
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2200000r			; -40
	DD	042200000r			; 40
	DD	042a40000r			; 82
	DD	0c2a40000r			; -82
	DD	0c1000000r			; -8
	DD	042800000r			; 64
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2180000r			; -38
	DD	042180000r			; 38
	DD	042bc0000r			; 94
	DD	0c2860000r			; -67
	DD	0c1000000r			; -8
	DD	042000000r			; 32
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2080000r			; -34
	DD	042080000r			; 34
	DD	0427c0000r			; 63
	DD	0c28a0000r			; -69
	DD	0c1000000r			; -8
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2180000r			; -38
	DD	042180000r			; 38
	DD	042940000r			; 74
	DD	0c2900000r			; -72
	DD	0c1000000r			; -8
	DD	043400000r			; 192
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2600000r			; -56
	DD	042600000r			; 56
	DD	043040000r			; 132
	DD	0c2d80000r			; -108
	DD	0c1000000r			; -8
	DD	042800000r			; 64
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2240000r			; -41
	DD	042240000r			; 41
	DD	042960000r			; 75
	DD	0c2aa0000r			; -85
	DD	0c1000000r			; -8
	DD	042c00000r			; 96
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2080000r			; -34
	DD	042080000r			; 34
	DD	042960000r			; 75
	DD	0c26c0000r			; -59
	DD	0c1000000r			; -8
	DD	043600000r			; 224
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c25c0000r			; -55
	DD	0425c0000r			; 55
	DD	042e60000r			; 115
	DD	0c2dc0000r			; -110
	DD	0c1000000r			; -8
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2180000r			; -38
	DD	042180000r			; 38
	DD	042ac0000r			; 86
	DD	0c29a0000r			; -77
	DD	0c1000000r			; -8
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2700000r			; -60
	DD	042700000r			; 60
	DD	042700000r			; 60
	DD	0c2700000r			; -60
	DD	0c1000000r			; -8
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	0c22c0000r			; -43
	DD	0422c0000r			; 43
	DD	042b80000r			; 92
	DD	0c2ac0000r			; -86
	DD	0c1000000r			; -8
	DD	043000000r			; 128
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2140000r			; -37
	DD	042140000r			; 37
	DD	042a40000r			; 82
	DD	0c2880000r			; -68
	DD	0c1000000r			; -8
	DD	000000000r			; 0
	DD	043400000r			; 192
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2180000r			; -38
	DD	042180000r			; 38
	DD	0428c0000r			; 70
	DD	0c2b20000r			; -89
	DD	0c1000000r			; -8
	DD	043600000r			; 224
	DD	042800000r			; 64
	DD	042000000r			; 32
	DD	042800000r			; 64
	DD	0c2280000r			; -42
	DD	042280000r			; 42
	DD	042c00000r			; 96
	DD	0c2a20000r			; -81
	DD	0c1000000r			; -8
	DD	042800000r			; 64
	DD	043000000r			; 128
	DD	042000000r			; 32
	DD	042800000r			; 64
_DATA	ENDS
PUBLIC	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
EXTRN	?ViewMatrix@@3TMatrixUnion@@A:BYTE		; ViewMatrix
EXTRN	?ViewTrans@@3UVectorStruct@@A:BYTE		; ViewTrans
EXTRN	?CameraPlaneLeft@@3UPlaneStruct@@A:BYTE		; CameraPlaneLeft
EXTRN	?CameraPlaneRight@@3UPlaneStruct@@A:BYTE	; CameraPlaneRight
EXTRN	?CameraPlaneTop@@3UPlaneStruct@@A:BYTE		; CameraPlaneTop
EXTRN	?CameraPlaneBottom@@3UPlaneStruct@@A:BYTE	; CameraPlaneBottom
EXTRN	__fltused:NEAR
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\drawobj.cpp
;	COMDAT ?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z
_TEXT	SEGMENT
_b$ = -16						; size = 4
_t$ = -12						; size = 4
_r$ = -8						; size = 4
_l$ = -4						; size = 4
_pos$ = 8						; size = 4
_rad$ = 12						; size = 4
_z$ = 16						; size = 4
?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z PROC NEAR ; TestSphereToFrustum, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 140  : 	float l, r, t, b;
; 141  : 
; 142  : // check if outside
; 143  : 
; 144  : 	*z = pos->v[X] * ViewMatrix.m[RZ] + pos->v[Y] * ViewMatrix.m[UZ] + pos->v[Z] * ViewMatrix.m[LZ] + ViewTrans.v[Z];

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?ViewMatrix@@3TMatrixUnion@@A+8
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?ViewMatrix@@3TMatrixUnion@@A+20
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?ViewMatrix@@3TMatrixUnion@@A+32
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR ?ViewTrans@@3UVectorStruct@@A+8
	mov	eax, DWORD PTR _z$[ebp]
	fstp	DWORD PTR [eax]

; 145  : 	if (*z + rad < RenderSettings.NearClip || *z - rad >= RenderSettings.FarClip) return SPHERE_OUT;

	mov	eax, DWORD PTR _z$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fadd	DWORD PTR [eax]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82502
	mov	eax, DWORD PTR _z$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _rad$[ebp]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82501
$L82502:
	xor	eax, eax
	jmp	$L82496
$L82501:

; 146  : 
; 147  : 	if ((l = PlaneDist(&CameraPlaneLeft, pos)) >= rad) return SPHERE_OUT;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneLeft@@3UPlaneStruct@@A
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneLeft@@3UPlaneStruct@@A+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneLeft@@3UPlaneStruct@@A+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR ?CameraPlaneLeft@@3UPlaneStruct@@A+12
	fst	DWORD PTR _l$[ebp]
	fcomp	DWORD PTR _rad$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82503
	xor	eax, eax
	jmp	$L82496
$L82503:

; 148  : 	if ((r = PlaneDist(&CameraPlaneRight, pos)) >= rad) return SPHERE_OUT;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneRight@@3UPlaneStruct@@A
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneRight@@3UPlaneStruct@@A+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneRight@@3UPlaneStruct@@A+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR ?CameraPlaneRight@@3UPlaneStruct@@A+12
	fst	DWORD PTR _r$[ebp]
	fcomp	DWORD PTR _rad$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82504
	xor	eax, eax
	jmp	$L82496
$L82504:

; 149  : 	if ((b = PlaneDist(&CameraPlaneBottom, pos)) >= rad) return SPHERE_OUT;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneBottom@@3UPlaneStruct@@A
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneBottom@@3UPlaneStruct@@A+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneBottom@@3UPlaneStruct@@A+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR ?CameraPlaneBottom@@3UPlaneStruct@@A+12
	fst	DWORD PTR _b$[ebp]
	fcomp	DWORD PTR _rad$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82505
	xor	eax, eax
	jmp	$L82496
$L82505:

; 150  : 	if ((t = PlaneDist(&CameraPlaneTop, pos)) >= rad) return SPHERE_OUT;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneTop@@3UPlaneStruct@@A
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneTop@@3UPlaneStruct@@A+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?CameraPlaneTop@@3UPlaneStruct@@A+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR ?CameraPlaneTop@@3UPlaneStruct@@A+12
	fst	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _rad$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82506
	xor	eax, eax
	jmp	SHORT $L82496
$L82506:

; 151  : 
; 152  : // inside, check if needs to be clipped
; 153  : 
; 154  : 	if (l > -rad || r > -rad || b > -rad || t > -rad || *z - rad < RenderSettings.NearClip || *z + rad >= RenderSettings.FarClip) return SPHERE_CLIP;

	fld	DWORD PTR _rad$[ebp]
	fchs
	fcomp	DWORD PTR _l$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82508
	fld	DWORD PTR _rad$[ebp]
	fchs
	fcomp	DWORD PTR _r$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82508
	fld	DWORD PTR _rad$[ebp]
	fchs
	fcomp	DWORD PTR _b$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82508
	fld	DWORD PTR _rad$[ebp]
	fchs
	fcomp	DWORD PTR _t$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82508
	mov	eax, DWORD PTR _z$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _rad$[ebp]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82508
	mov	eax, DWORD PTR _z$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fadd	DWORD PTR [eax]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82507
$L82508:
	mov	eax, 1
	jmp	SHORT $L82496
$L82507:

; 155  : 	return SPHERE_IN;

	mov	eax, 2
$L82496:

; 156  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ENDP	; TestSphereToFrustum
_TEXT	ENDS
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	__real@41a00000
PUBLIC	__real@43000000
PUBLIC	?BuildAllCarWorldMatrices@@YAXXZ		; BuildAllCarWorldMatrices
PUBLIC	?BuildCarMatricesNew@@YAXPAUCarStruct@@@Z	; BuildCarMatricesNew
EXTRN	?PLR_PlayerHead@@3PAUPlayerStruct@@A:DWORD	; PLR_PlayerHead
EXTRN	?GhostSineCount@@3MA:DWORD			; GhostSineCount
EXTRN	?GhostSinePos@@3MA:DWORD			; GhostSinePos
EXTRN	?TimeFactor@@3MA:DWORD				; TimeFactor
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?BuildAllCarWorldMatrices@@YAXXZ
_TEXT	SEGMENT
_player$ = -4						; size = 4
?BuildAllCarWorldMatrices@@YAXXZ PROC NEAR		; BuildAllCarWorldMatrices, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 193  : 	PLAYER *player;
; 194  : 
; 195  : // set GhostSines;
; 196  : 
; 197  : 	GhostSineCount += TimeFactor / 20;

	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fdiv	DWORD PTR __real@41a00000
	fadd	DWORD PTR ?GhostSineCount@@3MA		; GhostSineCount
	fstp	DWORD PTR ?GhostSineCount@@3MA		; GhostSineCount

; 198  : 	GhostSinePos = (float)sin(GhostSineCount) * 128;

	mov	eax, DWORD PTR ?GhostSineCount@@3MA
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fmul	DWORD PTR __real@43000000
	fstp	DWORD PTR ?GhostSinePos@@3MA		; GhostSinePos

; 199  : 
; 200  : // update world matrices
; 201  : 
; 202  : 	for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L82514
$L82515:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L82514:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L82511

; 203  : 	{
; 204  : 		BuildCarMatricesNew(&player->car);

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	?BuildCarMatricesNew@@YAXPAUCarStruct@@@Z ; BuildCarMatricesNew
	add	esp, 4

; 205  : 	}

	jmp	SHORT $L82515
$L82511:

; 206  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildAllCarWorldMatrices@@YAXXZ ENDP			; BuildAllCarWorldMatrices
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
EXTRN	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z:NEAR ; RotTransVector
EXTRN	?MulMatrix@@YAXPATMatrixUnion@@00@Z:NEAR	; MulMatrix
EXTRN	?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z:NEAR ; BuildLookMatrixForward
EXTRN	?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z:NEAR ; BuildLookMatrixDown
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?MatMulTransMat@@YAXPATMatrixUnion@@00@Z:NEAR	; MatMulTransMat
EXTRN	?BuildRotation3D@@YAXMMMMPATMatrixUnion@@@Z:NEAR ; BuildRotation3D
EXTRN	?TransMat@@YAXPATMatrixUnion@@0@Z:NEAR		; TransMat
EXTRN	?DownVec@@3UVectorStruct@@A:BYTE		; DownVec
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildCarMatricesNew@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_iWheel$ = -112						; size = 4
_scale$ = -108						; size = 4
_tmpMat2$ = -104					; size = 36
_tmpMat$ = -68						; size = 36
_fixedPos$ = -32					; size = 12
_tmpVec$ = -20						; size = 12
_susp$ = -8						; size = 4
_wheel$ = -4						; size = 4
_car$ = 8						; size = 4
?BuildCarMatricesNew@@YAXPAUCarStruct@@@Z PROC NEAR	; BuildCarMatricesNew, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi

; 217  : 	WHEEL *wheel;
; 218  : 	SUSPENSION *susp;
; 219  : 	VEC tmpVec;
; 220  : 	VEC fixedPos;
; 221  : 	MAT tmpMat, tmpMat2;
; 222  : 	REAL scale;
; 223  : 	int iWheel;
; 224  : 
; 225  : // build body world pos
; 226  : 
; 227  : 	RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &car->BodyOffset, &car->BodyWorldPos);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 772				; 00000304H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 3172				; 00000c64H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 228  : 
; 229  : // loop thru possible wheels
; 230  : 
; 231  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++)

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L82528
$L82529:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L82528:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L82519

; 232  : 	{
; 233  : 		wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 234  : 		susp = &car->Sus[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 192				; 000000c0H
	add	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR _susp$[ebp], eax

; 235  : 
; 236  : // get axle / spring fix position for this wheel
; 237  : 
; 238  : 		VecPlusScalarVec(&car->WheelOffset[iWheel], wheel->Pos, &DownVec, &fixedPos);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+3184]
	fstp	DWORD PTR _fixedPos$[ebp]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+3188]
	fstp	DWORD PTR _fixedPos$[ebp+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+3192]
	fstp	DWORD PTR _fixedPos$[ebp+8]

; 239  : 
; 240  : // set spring world matrix + pos
; 241  : 
; 242  : 		if (CarHasSpring(car, iWheel))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _iWheel$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 1
	je	$L82531

; 243  : 		{
; 244  : 			BuildLookMatrixDown(&car->SuspOffset[iWheel], &fixedPos, &tmpMat);

	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fixedPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _car$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3280]
	push	ecx
	call	?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ; BuildLookMatrixDown
	add	esp, 12					; 0000000cH

; 245  : 			SubVector(&fixedPos, &car->SuspOffset[iWheel], &tmpVec);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR _fixedPos$[ebp]
	fsub	DWORD PTR [ecx+eax+3280]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR _fixedPos$[ebp+4]
	fsub	DWORD PTR [ecx+eax+3284]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR _fixedPos$[ebp+8]
	fsub	DWORD PTR [ecx+eax+3288]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 246  : 			scale = Length(&tmpVec) / susp->SpringLen;

	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR _tmpVec$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR _tmpVec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR _tmpVec$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	mov	eax, DWORD PTR _susp$[ebp]
	fdiv	DWORD PTR [eax]
	fstp	DWORD PTR _scale$[ebp]

; 247  : 			VecMulScalar(&tmpMat.mv[U], scale);

	fld	DWORD PTR _tmpMat$[ebp+12]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR _tmpMat$[ebp+12]
	fld	DWORD PTR _tmpMat$[ebp+16]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR _tmpMat$[ebp+16]
	fld	DWORD PTR _tmpMat$[ebp+20]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR _tmpMat$[ebp+20]

; 248  : 
; 249  : 			MulMatrix(&car->Body->Centre.WMatrix, &tmpMat, &susp->SpringCarMatrix);

	mov	eax, DWORD PTR _susp$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _tmpMat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 250  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &car->SuspOffset[iWheel], &susp->SpringWorldPos);

	mov	eax, DWORD PTR _susp$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3280]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H
$L82531:

; 251  : 		}
; 252  : 
; 253  : // set axle world matrix + pos
; 254  : 
; 255  : 		if (CarHasAxle(car, iWheel))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _iWheel$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 2
	je	$L82533

; 256  : 		{
; 257  : 			BuildLookMatrixForward(&car->AxleOffset[iWheel], &fixedPos, &tmpMat);

	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fixedPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _car$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3328]
	push	ecx
	call	?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ; BuildLookMatrixForward
	add	esp, 12					; 0000000cH

; 258  : 			SubVector(&fixedPos, &car->AxleOffset[iWheel], &tmpVec);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR _fixedPos$[ebp]
	fsub	DWORD PTR [ecx+eax+3328]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR _fixedPos$[ebp+4]
	fsub	DWORD PTR [ecx+eax+3332]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR _fixedPos$[ebp+8]
	fsub	DWORD PTR [ecx+eax+3336]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 259  : 			scale = Length(&tmpVec) / susp->AxleLen;

	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR _tmpVec$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR _tmpVec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR _tmpVec$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	mov	eax, DWORD PTR _susp$[ebp]
	fdiv	DWORD PTR [eax+4]
	fstp	DWORD PTR _scale$[ebp]

; 260  : 			VecMulScalar(&tmpMat.mv[L], scale);

	fld	DWORD PTR _tmpMat$[ebp+24]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR _tmpMat$[ebp+24]
	fld	DWORD PTR _tmpMat$[ebp+28]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR _tmpMat$[ebp+28]
	fld	DWORD PTR _tmpMat$[ebp+32]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR _tmpMat$[ebp+32]

; 261  : 
; 262  : 			MulMatrix(&car->Body->Centre.WMatrix, &tmpMat, &susp->AxleCarMatrix);

	mov	eax, DWORD PTR _susp$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	lea	ecx, DWORD PTR _tmpMat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 263  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &car->AxleOffset[iWheel], &susp->AxleWorldPos);

	mov	eax, DWORD PTR _susp$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3328]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H
$L82533:

; 264  : 		}
; 265  : 
; 266  : // set pin world matrix + pos
; 267  : 
; 268  : 		if (CarHasPin(car, iWheel))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _iWheel$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 4
	je	$L82535

; 269  : 		{
; 270  : 			BuildLookMatrixDown(&car->SuspOffset[iWheel], &fixedPos, &tmpMat);

	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fixedPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _car$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3280]
	push	ecx
	call	?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ; BuildLookMatrixDown
	add	esp, 12					; 0000000cH

; 271  : 			VecMulScalar(&tmpMat.mv[U], -susp->PinLen);

	mov	eax, DWORD PTR _susp$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	fmul	DWORD PTR _tmpMat$[ebp+12]
	fstp	DWORD PTR _tmpMat$[ebp+12]
	mov	eax, DWORD PTR _susp$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	fmul	DWORD PTR _tmpMat$[ebp+16]
	fstp	DWORD PTR _tmpMat$[ebp+16]
	mov	eax, DWORD PTR _susp$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	fmul	DWORD PTR _tmpMat$[ebp+20]
	fstp	DWORD PTR _tmpMat$[ebp+20]

; 272  : 
; 273  : 			MulMatrix(&car->Body->Centre.WMatrix, &tmpMat, &susp->PinCarMatrix);

	mov	eax, DWORD PTR _susp$[ebp]
	add	eax, 156				; 0000009cH
	push	eax
	lea	ecx, DWORD PTR _tmpMat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 274  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &fixedPos, &susp->PinWorldPos);

	mov	eax, DWORD PTR _susp$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	lea	ecx, DWORD PTR _fixedPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H
$L82535:

; 275  : 		}
; 276  : 
; 277  : 		if (CarHasSpinner(car)) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR [ecx+4]
	and	edx, 1
	je	$L82536

; 278  : 			BuildRotation3D(car->Spinner.Axis.v[X], car->Spinner.Axis.v[Y], car->Spinner.Axis.v[Z], TimeStep * car->Spinner.AngVel, &tmpMat);

	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [ecx+3144]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3140]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3136]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3132]
	push	ecx
	call	?BuildRotation3D@@YAXMMMMPATMatrixUnion@@@Z ; BuildRotation3D
	add	esp, 20					; 00000014H

; 279  : 			MatMulTransMat(&tmpMat, &car->Spinner.Matrix, &tmpMat2);

	lea	eax, DWORD PTR _tmpMat2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 3084				; 00000c0cH
	push	ecx
	lea	edx, DWORD PTR _tmpMat$[ebp]
	push	edx
	call	?MatMulTransMat@@YAXPATMatrixUnion@@00@Z ; MatMulTransMat
	add	esp, 12					; 0000000cH

; 280  : 			TransMat(&tmpMat2, &car->Spinner.Matrix);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3084				; 00000c0cH
	push	eax
	lea	ecx, DWORD PTR _tmpMat2$[ebp]
	push	ecx
	call	?TransMat@@YAXPATMatrixUnion@@0@Z	; TransMat
	add	esp, 8

; 281  : 			MulMatrix(&car->Body->Centre.WMatrix, &car->Spinner.Matrix, &car->Spinner.CarMatrix);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3048				; 00000be8H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 3084				; 00000c0cH
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 282  : 
; 283  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &car->Models->OffSpinner, &car->Spinner.WorldPos);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3120				; 00000c30H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	add	edx, 260				; 00000104H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H
$L82536:

; 284  : 		}
; 285  : 	}

	jmp	$L82529
$L82519:

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildCarMatricesNew@@YAXPAUCarStruct@@@Z ENDP		; BuildCarMatricesNew
_TEXT	ENDS
PUBLIC	?DrawTarget@@YAXPAUPlayerStruct@@@Z		; DrawTarget
PUBLIC	?DrawAllCars@@YAXXZ				; DrawAllCars
PUBLIC	?DrawCar@@YAXPAUCarStruct@@@Z			; DrawCar
EXTRN	?GhostSolid@@3JA:DWORD				; GhostSolid
EXTRN	?GHO_GhostPlayer@@3PAUPlayerStruct@@A:DWORD	; GHO_GhostPlayer
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawAllCars@@YAXXZ
_TEXT	SEGMENT
_player$ = -4						; size = 4
?DrawAllCars@@YAXXZ PROC NEAR				; DrawAllCars, COMDAT

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 294  : 	PLAYER *player;
; 295  : 
; 296  : // draw cars
; 297  : 
; 298  : 	if (GhostSolid)

	cmp	DWORD PTR ?GhostSolid@@3JA, 0		; GhostSolid
	je	SHORT $L82541

; 299  : 		GHO_GhostPlayer->type = PLAYER_LOCAL;

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	DWORD PTR [eax+4], 1
$L82541:

; 300  : 
; 301  : 	for (player = PLR_PlayerHead ; player ; player = player->next) if (player->type != PLAYER_GHOST)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L82542
$L82543:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L82542:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L82544
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $L82545

; 302  : 	{
; 303  : 		DrawCar(&player->car);			// draw the car models

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	?DrawCar@@YAXPAUCarStruct@@@Z		; DrawCar
	add	esp, 4

; 304  : 		if (player->PickupTarget != NULL) 

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+10236], 0
	je	SHORT $L82545

; 305  : 		{
; 306  : 			DrawTarget(player);				// draw the weapon target

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	?DrawTarget@@YAXPAUPlayerStruct@@@Z	; DrawTarget
	add	esp, 4
$L82545:

; 307  : 		}
; 308  : 	}
; 309  : 
; 310  : 	if (GhostSolid)

	jmp	SHORT $L82543
$L82544:
	cmp	DWORD PTR ?GhostSolid@@3JA, 0		; GhostSolid
	je	SHORT $L82539

; 311  : 		GHO_GhostPlayer->type = PLAYER_GHOST;

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	DWORD PTR [eax+4], 4
$L82539:

; 312  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawAllCars@@YAXXZ ENDP				; DrawAllCars
_TEXT	ENDS
PUBLIC	?DrawAllGhostCars@@YAXXZ			; DrawAllGhostCars
PUBLIC	?DrawCarGhost@@YAXPAUCarStruct@@@Z		; DrawCarGhost
EXTRN	?FlushPolyBuckets@@YAXXZ:NEAR			; FlushPolyBuckets
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
EXTRN	?RenderStateChange@@3JA:DWORD			; RenderStateChange
EXTRN	?RenderAlpha@@3FA:WORD				; RenderAlpha
EXTRN	?RenderAlphaSrc@@3FA:WORD			; RenderAlphaSrc
EXTRN	?RenderAlphaDest@@3FA:WORD			; RenderAlphaDest
EXTRN	?RenderZwrite@@3FA:WORD				; RenderZwrite
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawAllGhostCars@@YAXXZ
_TEXT	SEGMENT
_player$ = -4						; size = 4
?DrawAllGhostCars@@YAXXZ PROC NEAR			; DrawAllGhostCars, COMDAT

; 319  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 320  : 	PLAYER *player;
; 321  : 
; 322  : // set render states
; 323  : 
; 324  : 	if (GhostSolid)

	cmp	DWORD PTR ?GhostSolid@@3JA, 0		; GhostSolid
	je	SHORT $L82552

; 325  : 		return;

	jmp	$L82550
$L82552:

; 326  : 
; 327  : 	ZWRITE_ON();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	jne	SHORT $L82553
	mov	WORD PTR ?RenderZwrite@@3FA, 1		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82553:

; 328  : 	ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L82554
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82554:

; 329  : 	ALPHA_SRC(D3DBLEND_SRCALPHA);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 5
	je	SHORT $L82555
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 5	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82555:

; 330  : 	ALPHA_DEST(D3DBLEND_INVSRCALPHA);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 6
	je	SHORT $L82556
	mov	WORD PTR ?RenderAlphaDest@@3FA, 6	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82556:

; 331  : 
; 332  : // draw cars
; 333  : 
; 334  : 	for (player = PLR_PlayerHead ; player ; player = player->next) if (player->type == PLAYER_GHOST)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L82557
$L82558:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L82557:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L82559
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 4
	jne	SHORT $L82560

; 335  : 	{
; 336  : 		DrawCarGhost(&player->car);

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	?DrawCarGhost@@YAXPAUCarStruct@@@Z	; DrawCarGhost
	add	esp, 4
$L82560:

; 337  : 	}
; 338  : 
; 339  : 	FlushPolyBuckets();

	jmp	SHORT $L82558
$L82559:
	call	?FlushPolyBuckets@@YAXXZ		; FlushPolyBuckets
$L82550:

; 340  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawAllGhostCars@@YAXXZ ENDP				; DrawAllGhostCars
_TEXT	ENDS
PUBLIC	__real@428c0000
PUBLIC	__real@43c00000
PUBLIC	__real@40000000
PUBLIC	__real@00000000
PUBLIC	__real@40800000
PUBLIC	__real@4b000000
PUBLIC	__real@437f0000
PUBLIC	__real@3f800000
PUBLIC	?DrawCarAerial2@@YAXPAUAERIAL@@PAUMODEL@@1F@Z	; DrawCarAerial2
PUBLIC	?DrawCarBoundingBoxes@@YAXPAUCarStruct@@@Z	; DrawCarBoundingBoxes
EXTRN	?ViewCameraPos@@3UVectorStruct@@A:BYTE		; ViewCameraPos
EXTRN	?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z:NEAR ; CheckObjectLight
EXTRN	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; AddModelLight
EXTRN	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z:NEAR ; AddModelLightSimple
EXTRN	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z:NEAR ; DrawModel
EXTRN	?SetEnvActive@@YAXPAUVectorStruct@@PATMatrixUnion@@1JMMM@Z:NEAR ; SetEnvActive
EXTRN	?ModelVertFog@@3MA:DWORD			; ModelVertFog
EXTRN	?ModelAddLit@@3JA:DWORD				; ModelAddLit
EXTRN	?ModelScale@@3MA:DWORD				; ModelScale
EXTRN	?TestObjectVisiboxes@@YADPAUBoundingBoxStruct@@@Z:NEAR ; TestObjectVisiboxes
EXTRN	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z:NEAR ; DrawAxis
EXTRN	?DxState@@3UDX_STATE@@A:BYTE			; DxState
EXTRN	?RenderFog@@3FA:WORD				; RenderFog
EXTRN	?GetMirrorPlane@@YAJPAUVectorStruct@@@Z:NEAR	; GetMirrorPlane
EXTRN	?MirrorHeight@@3MA:DWORD			; MirrorHeight
EXTRN	?CAR_DrawCarBBoxes@@3_NA:BYTE			; CAR_DrawCarBBoxes
EXTRN	?CAR_DrawCarAxes@@3_NA:BYTE			; CAR_DrawCarAxes
;	COMDAT __real@428c0000
CONST	SEGMENT
__real@428c0000 DD 0428c0000r			; 70
CONST	ENDS
;	COMDAT __real@43c00000
CONST	SEGMENT
__real@43c00000 DD 043c00000r			; 384
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DrawCar@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
__temp$82578 = -56					; size = 4
_lod2$ = -50						; size = 1
_lod$ = -49						; size = 1
_flag$ = -48						; size = 2
_box$ = -44						; size = 24
_flod$ = -20						; size = 4
_z$ = -16						; size = 4
_envrgb$ = -12						; size = 4
_visflag$ = -8						; size = 4
_ii$ = -4						; size = 4
_car$ = 8						; size = 4
?DrawCar@@YAXPAUCarStruct@@@Z PROC NEAR			; DrawCar, COMDAT

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 348  : 	long ii, visflag, envrgb = car->Models->EnvRGB;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR [ecx+6144]
	mov	DWORD PTR _envrgb$[ebp], edx

; 349  : 	REAL z, flod;
; 350  : 	BOUNDING_BOX box;
; 351  : 	short flag = MODEL_PLAIN;

	mov	WORD PTR _flag$[ebp], 0

; 352  : 	char lod, lod2;
; 353  : 
; 354  : // zero car rendered flag
; 355  : 
; 356  : 	car->Rendered = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3412], 0

; 357  : 
; 358  : // set whole car bounding box
; 359  : 
; 360  : 	box.Xmin = car->Body->Centre.Pos.v[X] - CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp]

; 361  : 	box.Xmax = car->Body->Centre.Pos.v[X] + CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+20]
	fadd	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+4]

; 362  : 	box.Ymin = car->Body->Centre.Pos.v[Y] - CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+8]

; 363  : 	box.Ymax = car->Body->Centre.Pos.v[Y] + CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	fadd	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+12]

; 364  : 	box.Zmin = car->Body->Centre.Pos.v[Z] - CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+16]

; 365  : 	box.Zmax = car->Body->Centre.Pos.v[Z] + CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+28]
	fadd	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+20]

; 366  : 
; 367  : // test against visicubes
; 368  : 
; 369  : 	if (TestObjectVisiboxes(&box))

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	call	?TestObjectVisiboxes@@YADPAUBoundingBoxStruct@@@Z ; TestObjectVisiboxes
	add	esp, 4
	movsx	ecx, al
	test	ecx, ecx
	je	SHORT $L82573

; 370  : 		return;

	jmp	$L82563
$L82573:

; 371  : 
; 372  : // skip if offscreen
; 373  : 
; 374  : 	visflag = TestSphereToFrustum(&car->Body->Centre.Pos, CAR_RADIUS, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	push	1116471296				; 428c0000H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 20					; 00000014H
	push	edx
	call	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _visflag$[ebp], eax

; 375  : 	if (visflag == SPHERE_OUT) return;

	cmp	DWORD PTR _visflag$[ebp], 0
	jne	SHORT $L82574
	jmp	$L82563
$L82574:

; 376  : 	if (visflag == SPHERE_IN) flag |= MODEL_DONOTCLIP;

	cmp	DWORD PTR _visflag$[ebp], 2
	jne	SHORT $L82575
	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 8
	mov	WORD PTR _flag$[ebp], ax
$L82575:

; 377  : 
; 378  : // set car rendered flag
; 379  : 
; 380  : 	car->Rendered = TRUE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3412], 1

; 381  : 
; 382  : // calc lod
; 383  : 
; 384  : 	flod = z / CAR_LOD_BIAS - 2;

	fld	DWORD PTR _z$[ebp]
	fdiv	DWORD PTR __real@43c00000
	fsub	DWORD PTR __real@40000000
	fstp	DWORD PTR _flod$[ebp]

; 385  : 	if (flod < 0) flod = 0;

	fld	DWORD PTR _flod$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82576
	mov	DWORD PTR _flod$[ebp], 0
$L82576:

; 386  : 	if (flod > MAX_CAR_LOD - 1) flod = MAX_CAR_LOD - 1;

	fld	DWORD PTR _flod$[ebp]
	fcomp	DWORD PTR __real@40800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82577
	mov	DWORD PTR _flod$[ebp], 1082130432	; 40800000H
$L82577:

; 387  : 	FTOL(flod, lod);

	fld	DWORD PTR _flod$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82578[ebp]
	mov	eax, DWORD PTR __temp$82578[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	BYTE PTR _lod$[ebp], al

; 388  : 
; 389  : // in fog?
; 390  : 
; 391  : 	if (z + CAR_RADIUS > RenderSettings.FogStart && DxState.Fog)

	fld	DWORD PTR _z$[ebp]
	fadd	DWORD PTR __real@428c0000
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+48
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82581
	cmp	DWORD PTR ?DxState@@3UDX_STATE@@A+36, 0
	je	$L82581

; 392  : 	{
; 393  : 		ModelVertFog = (car->Body->Centre.Pos.v[1] - RenderSettings.VertFogStart) * RenderSettings.VertFogMul;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+60
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+72
	fstp	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog

; 394  : 		if (ModelVertFog < 0) ModelVertFog = 0;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82582
	mov	DWORD PTR ?ModelVertFog@@3MA, 0
$L82582:

; 395  : 		if (ModelVertFog > 255) ModelVertFog = 255;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@437f0000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82583
	mov	DWORD PTR ?ModelVertFog@@3MA, 1132396544 ; 437f0000H
$L82583:

; 396  : 
; 397  : 		flag |= MODEL_FOG;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 1
	mov	WORD PTR _flag$[ebp], ax

; 398  : 		FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L82581
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82581:

; 399  : 	}
; 400  : 
; 401  : // in light?
; 402  : 
; 403  : 	if (CheckObjectLight(&car->Body->Centre.Pos, &box, CAR_RADIUS))

	push	1116471296				; 428c0000H
	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 20					; 00000014H
	push	edx
	call	?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z ; CheckObjectLight
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L82585

; 404  : 	{
; 405  : 		flag |= MODEL_LIT;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 2
	mov	WORD PTR _flag$[ebp], ax
$L82585:

; 406  : 	}
; 407  : 
; 408  : // is bomb?
; 409  : 
; 410  : 	if (car->AddLit)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3516], 0
	je	SHORT $L82586

; 411  : 	{
; 412  : 
; 413  : 		ModelAddLit = car->AddLit;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3516]
	mov	DWORD PTR ?ModelAddLit@@3JA, ecx	; ModelAddLit

; 414  : 		flag |= MODEL_ADDLIT;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 256				; 00000100H
	mov	WORD PTR _flag$[ebp], ax
$L82586:

; 415  : 	}
; 416  : 
; 417  : // scale?
; 418  : 
; 419  : 	if (car->DrawScale != 1.0f)

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR __real@3f800000
	fld	DWORD PTR [eax+3520]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L82587

; 420  : 	{
; 421  : 		ModelScale = car->DrawScale;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3520]
	mov	DWORD PTR ?ModelScale@@3MA, ecx

; 422  : 		flag |= MODEL_SCALE;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 512				; 00000200H
	mov	WORD PTR _flag$[ebp], ax
$L82587:

; 423  : 	}
; 424  : 
; 425  : // reflect?
; 426  : 
; 427  : 	if (RenderSettings.Mirror)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+80, 0
	je	SHORT $L82588

; 428  : 	{
; 429  : 		if (GetMirrorPlane(&car->Body->Centre.Pos))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?GetMirrorPlane@@YAJPAUVectorStruct@@@Z	; GetMirrorPlane
	add	esp, 4
	test	eax, eax
	je	SHORT $L82588

; 430  : 		{
; 431  : 			if (ViewCameraPos.v[Y] < MirrorHeight)

	fld	DWORD PTR ?ViewCameraPos@@3UVectorStruct@@A+4
	fcomp	DWORD PTR ?MirrorHeight@@3MA		; MirrorHeight
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82588

; 432  : 				flag |= MODEL_MIRROR;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 16					; 00000010H
	mov	WORD PTR _flag$[ebp], ax
$L82588:

; 433  : 		}
; 434  : 	}
; 435  : 
; 436  : // draw models
; 437  : 
; 438  : 	SetEnvActive(&car->Body->Centre.Pos, &car->Body->Centre.WMatrix, &car->EnvMatrix, envrgb, 0.0f, 0.0f, 1.0f);

	push	1065353216				; 3f800000H
	push	0
	push	0
	mov	eax, DWORD PTR _envrgb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 784				; 00000310H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 20					; 00000014H
	push	edx
	call	?SetEnvActive@@YAXPAUVectorStruct@@PATMatrixUnion@@1JMMM@Z ; SetEnvActive
	add	esp, 28					; 0000001cH

; 439  : //	SetEnvStatic(&car->Body->Centre.Pos, &car->Body->Centre.WMatrix, envrgb, 0.0f, 0.0f, 1.0f);
; 440  : 
; 441  : 	lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82592:

; 442  : 	while (!car->Models->Body[lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR [ecx+6064]
	movsx	ecx, WORD PTR [eax+edx+32]
	test	ecx, ecx
	jne	SHORT $L82593
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82592
$L82593:

; 443  : 	if (flag & MODEL_LIT) AddModelLight(&car->Models->Body[lod2], &car->BodyWorldPos, &car->Body->Centre.WMatrix);

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82594
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	add	edx, 772				; 00000304H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR [ecx+6064]
	push	edx
	call	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z ; AddModelLight
	add	esp, 12					; 0000000cH
$L82594:

; 444  : 	DrawModel(&car->Models->Body[lod2], &car->Body->Centre.WMatrix, &car->BodyWorldPos, flag | MODEL_ENV);

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 4
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 772				; 00000304H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR [edx+6064]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H

; 445  : 
; 446  : // loop thru possible wheels
; 447  : 
; 448  : 	for (ii = 0; ii < CAR_NWHEELS; ii++)

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82595
$L82596:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82595:
	cmp	DWORD PTR _ii$[ebp], 4
	jge	$L82597

; 449  : 	{
; 450  : 
; 451  : // draw wheel
; 452  : 
; 453  : 		if (IsWheelPresent(&car->Wheel[ii]))

	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 1
	je	$L82598

; 454  : 		{
; 455  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82600:

; 456  : 			while (!car->Models->Wheel[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6068]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82601
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82600
$L82601:

; 457  : 			if (flag & MODEL_LIT) AddModelLight(&car->Models->Wheel[ii][lod2], &car->Wheel[ii].WPos, &car->Wheel[ii].WMatrix);

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82602
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1684]
	push	edx
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1720]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+6068]
	push	edx
	call	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z ; AddModelLight
	add	esp, 12					; 0000000cH
$L82602:

; 458  : 			DrawModel(&car->Models->Wheel[ii][lod2], &car->Wheel[ii].WMatrix, &car->Wheel[ii].WPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1720]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1684]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6068]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82598:

; 459  : 		}
; 460  : 
; 461  : // draw spring
; 462  : 
; 463  : 		if (CarHasSpring(car, ii))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 1
	je	$L82603

; 464  : 		{
; 465  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82605:

; 466  : 			while (!car->Models->Spring[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6084]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82606
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82605
$L82606:

; 467  : 			if (flag & MODEL_LIT) AddModelLightSimple(&car->Models->Spring[ii][lod2], &car->Sus[ii].SpringWorldPos);

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82607
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 192				; 000000c0H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+48]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+6084]
	push	edx
	call	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ; AddModelLightSimple
	add	esp, 8
$L82607:

; 468  : 			DrawModel(&car->Models->Spring[ii][lod2], &car->Sus[ii].SpringCarMatrix, &car->Sus[ii].SpringWorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+48]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+84]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6084]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82603:

; 469  : 		}
; 470  : 
; 471  : // draw axle
; 472  : 
; 473  : 		if (CarHasAxle(car, ii))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 2
	je	$L82608

; 474  : 		{
; 475  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82610:

; 476  : 			while (!car->Models->Axle[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6100]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82611
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82610
$L82611:

; 477  : 			if (flag & MODEL_LIT) AddModelLightSimple(&car->Models->Axle[ii][lod2], &car->Sus[ii].AxleWorldPos);

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82612
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 192				; 000000c0H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+60]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+6100]
	push	edx
	call	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ; AddModelLightSimple
	add	esp, 8
$L82612:

; 478  : 			DrawModel(&car->Models->Axle[ii][lod2], &car->Sus[ii].AxleCarMatrix, &car->Sus[ii].AxleWorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+60]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+120]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6100]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82608:

; 479  : 		}
; 480  : 
; 481  : // draw pin
; 482  : 
; 483  : 		if (CarHasPin(car, ii))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 4
	je	$L82613

; 484  : 		{
; 485  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82615:

; 486  : 			while (!car->Models->Pin[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6116]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82616
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82615
$L82616:

; 487  : 			if (flag & MODEL_LIT) AddModelLightSimple(&car->Models->Pin[ii][lod2], &car->Sus[ii].PinWorldPos);

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82617
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 192				; 000000c0H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+72]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+6116]
	push	edx
	call	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ; AddModelLightSimple
	add	esp, 8
$L82617:

; 488  : 			DrawModel(&car->Models->Pin[ii][lod2], &car->Sus[ii].PinCarMatrix, &car->Sus[ii].PinWorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+72]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+156]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6116]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82613:

; 489  : 		}
; 490  : 	}

	jmp	$L82596
$L82597:

; 491  : 
; 492  : // draw spinner
; 493  : 
; 494  : 	if (CarHasSpinner(car))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR [ecx+4]
	and	edx, 1
	je	$L82618

; 495  : 	{
; 496  : 		lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82620:

; 497  : 		while (!car->Models->Spinner[lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR [ecx+6132]
	movsx	ecx, WORD PTR [eax+edx+32]
	test	ecx, ecx
	jne	SHORT $L82621
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82620
$L82621:

; 498  : 		if (flag & MODEL_LIT) AddModelLightSimple(&car->Models->Spinner[lod2], &car->Spinner.WorldPos);

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82622
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3120				; 00000c30H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR [edx+6132]
	push	eax
	call	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ; AddModelLightSimple
	add	esp, 8
$L82622:

; 499  : 		DrawModel(&car->Models->Spinner[lod2], &car->Spinner.CarMatrix, &car->Spinner.WorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 3120				; 00000c30H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	add	edx, 3048				; 00000be8H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR [ecx+6132]
	push	edx
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82618:

; 500  : 	}
; 501  : 
; 502  : // show physics info?
; 503  : 
; 504  : #if SHOW_PHYSICS_INFO
; 505  : 	if (CAR_DrawCarAxes) {

	movzx	eax, BYTE PTR ?CAR_DrawCarAxes@@3_NA	; CAR_DrawCarAxes
	test	eax, eax
	je	SHORT $L82623

; 506  : 		DrawAxis(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	call	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ; DrawAxis
	add	esp, 8
$L82623:

; 507  : 	}
; 508  : 	if (CAR_DrawCarBBoxes) {

	movzx	eax, BYTE PTR ?CAR_DrawCarBBoxes@@3_NA	; CAR_DrawCarBBoxes
	test	eax, eax
	je	$L82624

; 509  : 		ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L82625
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82625:

; 510  : 		ALPHA_SRC(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 2
	je	SHORT $L82626
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 2	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82626:

; 511  : 		ALPHA_DEST(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 2
	je	SHORT $L82627
	mov	WORD PTR ?RenderAlphaDest@@3FA, 2	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82627:

; 512  : 
; 513  : 		DrawCarBoundingBoxes(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?DrawCarBoundingBoxes@@YAXPAUCarStruct@@@Z ; DrawCarBoundingBoxes
	add	esp, 4

; 514  : 
; 515  : 		ALPHA_OFF();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	je	SHORT $L82624
	mov	WORD PTR ?RenderAlpha@@3FA, 0		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82624:

; 516  : 	}
; 517  : #endif
; 518  : 
; 519  : // draw aerial
; 520  : 
; 521  : 	if (CarHasAerial(car)) 

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR [ecx+4]
	and	edx, 2
	je	SHORT $L82629

; 522  : 	{
; 523  : 		DrawCarAerial2(&car->Aerial, car->Models->Aerial[0], car->Models->Aerial[1], flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	eax, DWORD PTR [edx+6140]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	eax, DWORD PTR [edx+6136]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 860				; 0000035cH
	push	ecx
	call	?DrawCarAerial2@@YAXPAUAERIAL@@PAUMODEL@@1F@Z ; DrawCarAerial2
	add	esp, 16					; 00000010H
$L82629:

; 524  : 	}
; 525  : 
; 526  : // reset render states?
; 527  : 
; 528  : 	if (flag & MODEL_FOG)

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 1
	je	SHORT $L82563

; 529  : 		FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L82563
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82563:

; 530  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawCar@@YAXPAUCarStruct@@@Z ENDP			; DrawCar
_TEXT	ENDS
EXTRN	?GhostSineOffset@@3MA:DWORD			; GhostSineOffset
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawCarGhost@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
__temp$82648 = -52					; size = 4
_lod2$ = -46						; size = 1
_lod$ = -45						; size = 1
_flag$ = -44						; size = 2
_box$ = -40						; size = 24
_flod$ = -16						; size = 4
_z$ = -12						; size = 4
_visflag$ = -8						; size = 4
_ii$ = -4						; size = 4
_car$ = 8						; size = 4
?DrawCarGhost@@YAXPAUCarStruct@@@Z PROC NEAR		; DrawCarGhost, COMDAT

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 538  : 	long ii, visflag;
; 539  : 	REAL z, flod;
; 540  : 	BOUNDING_BOX box;
; 541  : 	short flag = MODEL_GHOST;

	mov	WORD PTR _flag$[ebp], 32		; 00000020H

; 542  : 	char lod, lod2;
; 543  : 
; 544  : // zero car rendered flag
; 545  : 
; 546  : 	car->Rendered = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3412], 0

; 547  : 
; 548  : // set whole car bounding box
; 549  : 
; 550  : 	box.Xmin = car->Body->Centre.Pos.v[X] - CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp]

; 551  : 	box.Xmax = car->Body->Centre.Pos.v[X] + CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+20]
	fadd	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+4]

; 552  : 	box.Ymin = car->Body->Centre.Pos.v[Y] - CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+8]

; 553  : 	box.Ymax = car->Body->Centre.Pos.v[Y] + CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	fadd	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+12]

; 554  : 	box.Zmin = car->Body->Centre.Pos.v[Z] - CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+16]

; 555  : 	box.Zmax = car->Body->Centre.Pos.v[Z] + CAR_RADIUS;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+28]
	fadd	DWORD PTR __real@428c0000
	fstp	DWORD PTR _box$[ebp+20]

; 556  : 
; 557  : // test against visicubes
; 558  : 
; 559  : 	if (TestObjectVisiboxes(&box))

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	call	?TestObjectVisiboxes@@YADPAUBoundingBoxStruct@@@Z ; TestObjectVisiboxes
	add	esp, 4
	movsx	ecx, al
	test	ecx, ecx
	je	SHORT $L82643

; 560  : 		return;

	jmp	$L82634
$L82643:

; 561  : 
; 562  : // skip if offscreen
; 563  : 
; 564  : 	visflag = TestSphereToFrustum(&car->Body->Centre.Pos, CAR_RADIUS, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	push	1116471296				; 428c0000H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 20					; 00000014H
	push	edx
	call	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _visflag$[ebp], eax

; 565  : 	if (visflag == SPHERE_OUT) return;

	cmp	DWORD PTR _visflag$[ebp], 0
	jne	SHORT $L82644
	jmp	$L82634
$L82644:

; 566  : 	if (visflag == SPHERE_IN) flag |= MODEL_DONOTCLIP;

	cmp	DWORD PTR _visflag$[ebp], 2
	jne	SHORT $L82645
	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 8
	mov	WORD PTR _flag$[ebp], ax
$L82645:

; 567  : 
; 568  : // set car rendered flag
; 569  : 
; 570  : 	car->Rendered = TRUE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3412], 1

; 571  : 
; 572  : // calc lod
; 573  : 
; 574  : 	flod = z / CAR_LOD_BIAS - 2;

	fld	DWORD PTR _z$[ebp]
	fdiv	DWORD PTR __real@43c00000
	fsub	DWORD PTR __real@40000000
	fstp	DWORD PTR _flod$[ebp]

; 575  : 	if (flod < 0) flod = 0;

	fld	DWORD PTR _flod$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82646
	mov	DWORD PTR _flod$[ebp], 0
$L82646:

; 576  : 	if (flod > MAX_CAR_LOD - 1) flod = MAX_CAR_LOD - 1;

	fld	DWORD PTR _flod$[ebp]
	fcomp	DWORD PTR __real@40800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82647
	mov	DWORD PTR _flod$[ebp], 1082130432	; 40800000H
$L82647:

; 577  : 	FTOL(flod, lod);

	fld	DWORD PTR _flod$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82648[ebp]
	mov	eax, DWORD PTR __temp$82648[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	BYTE PTR _lod$[ebp], al

; 578  : 
; 579  : // in fog?
; 580  : 
; 581  : 	if (z + CAR_RADIUS > RenderSettings.FogStart && DxState.Fog)

	fld	DWORD PTR _z$[ebp]
	fadd	DWORD PTR __real@428c0000
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+48
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82651
	cmp	DWORD PTR ?DxState@@3UDX_STATE@@A+36, 0
	je	$L82651

; 582  : 	{
; 583  : 		ModelVertFog = (car->Body->Centre.Pos.v[1] - RenderSettings.VertFogStart) * RenderSettings.VertFogMul;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+60
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+72
	fstp	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog

; 584  : 		if (ModelVertFog < 0) ModelVertFog = 0;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82652
	mov	DWORD PTR ?ModelVertFog@@3MA, 0
$L82652:

; 585  : 		if (ModelVertFog > 255) ModelVertFog = 255;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@437f0000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82653
	mov	DWORD PTR ?ModelVertFog@@3MA, 1132396544 ; 437f0000H
$L82653:

; 586  : 
; 587  : 		flag |= MODEL_FOG;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 1
	mov	WORD PTR _flag$[ebp], ax

; 588  : 		FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L82651
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82651:

; 589  : 	}
; 590  : 
; 591  : // draw models
; 592  : 
; 593  : 	GhostSineOffset = car->BodyOffset.v[Z];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3180]
	mov	DWORD PTR ?GhostSineOffset@@3MA, ecx

; 594  : 	lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82656:

; 595  : 	while (!car->Models->Body[lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR [ecx+6064]
	movsx	ecx, WORD PTR [eax+edx+32]
	test	ecx, ecx
	jne	SHORT $L82657
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82656
$L82657:

; 596  : 	DrawModel(&car->Models->Body[lod2], &car->Body->Centre.WMatrix, &car->BodyWorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 772				; 00000304H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR [edx+6064]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H

; 597  : 
; 598  : // loop thru possible wheels
; 599  : 
; 600  : 	for (ii = 0; ii < CAR_NWHEELS; ii++)

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82658
$L82659:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82658:
	cmp	DWORD PTR _ii$[ebp], 4
	jge	$L82660

; 601  : 	{
; 602  : 
; 603  : // draw wheel
; 604  : 
; 605  : 		if (IsWheelPresent(&car->Wheel[ii]))

	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 1
	je	$L82661

; 606  : 		{
; 607  : 			GhostSineOffset = car->WheelOffset[ii].v[Z];

	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+3192]
	mov	DWORD PTR ?GhostSineOffset@@3MA, edx

; 608  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82663:

; 609  : 			while (!car->Models->Wheel[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6068]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82664
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82663
$L82664:

; 610  : 			DrawModel(&car->Models->Wheel[ii][lod2], &car->Wheel[ii].WMatrix, &car->Wheel[ii].WPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1720]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1684]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6068]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82661:

; 611  : 		}
; 612  : 
; 613  : // draw spring
; 614  : 
; 615  : 		if (CarHasSpring(car, ii))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 1
	je	$L82665

; 616  : 		{
; 617  : 			GhostSineOffset = car->SuspOffset[ii].v[Z];

	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+3288]
	mov	DWORD PTR ?GhostSineOffset@@3MA, edx

; 618  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82667:

; 619  : 			while (!car->Models->Spring[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6084]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82668
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82667
$L82668:

; 620  : 			DrawModel(&car->Models->Spring[ii][lod2], &car->Sus[ii].SpringCarMatrix, &car->Sus[ii].SpringWorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+48]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+84]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6084]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82665:

; 621  : 		}
; 622  : 
; 623  : // draw axle
; 624  : 
; 625  : 		if (CarHasAxle(car, ii))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 2
	je	$L82669

; 626  : 		{
; 627  : 			GhostSineOffset = car->AxleOffset[ii].v[Z];

	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+3336]
	mov	DWORD PTR ?GhostSineOffset@@3MA, edx

; 628  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82671:

; 629  : 			while (!car->Models->Axle[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6100]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82672
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82671
$L82672:

; 630  : 			DrawModel(&car->Models->Axle[ii][lod2], &car->Sus[ii].AxleCarMatrix, &car->Sus[ii].AxleWorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+60]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+120]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6100]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82669:

; 631  : 		}
; 632  : 
; 633  : // draw pin
; 634  : 
; 635  : 		if (CarHasPin(car, ii))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	and	eax, 4
	je	$L82673

; 636  : 		{
; 637  : 			GhostSineOffset = car->SuspOffset[ii].v[Z];

	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+3288]
	mov	DWORD PTR ?GhostSineOffset@@3MA, edx

; 638  : 			lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82675:

; 639  : 			while (!car->Models->Pin[ii][lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+6116]
	movsx	edx, WORD PTR [ecx+edx+32]
	test	edx, edx
	jne	SHORT $L82676
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82675
$L82676:

; 640  : 			DrawModel(&car->Models->Pin[ii][lod2], &car->Sus[ii].PinCarMatrix, &car->Sus[ii].PinWorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+72]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+156]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movsx	eax, BYTE PTR _lod2$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+6116]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82673:

; 641  : 		}
; 642  : 	}

	jmp	$L82659
$L82660:

; 643  : 
; 644  : // draw spinner
; 645  : 
; 646  : 	if (CarHasSpinner(car))

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR [ecx+4]
	and	edx, 1
	je	SHORT $L82677

; 647  : 	{
; 648  : 		GhostSineOffset = car->SpinnerOffset.v[Z];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3384]
	mov	DWORD PTR ?GhostSineOffset@@3MA, ecx

; 649  : 		lod2 = lod;

	mov	al, BYTE PTR _lod$[ebp]
	mov	BYTE PTR _lod2$[ebp], al
$L82679:

; 650  : 		while (!car->Models->Spinner[lod2].PolyNum) lod2--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR [ecx+6132]
	movsx	ecx, WORD PTR [eax+edx+32]
	test	ecx, ecx
	jne	SHORT $L82680
	mov	al, BYTE PTR _lod2$[ebp]
	sub	al, 1
	mov	BYTE PTR _lod2$[ebp], al
	jmp	SHORT $L82679
$L82680:

; 651  : 		DrawModel(&car->Models->Spinner[lod2], &car->Spinner.CarMatrix, &car->Spinner.WorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 3120				; 00000c30H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	add	edx, 3048				; 00000be8H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR _lod2$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR [ecx+6132]
	push	edx
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82677:

; 652  : 	}
; 653  : 
; 654  : // show physics info?
; 655  : 
; 656  : #if SHOW_PHYSICS_INFO
; 657  : 	if (CAR_DrawCarAxes) {

	movzx	eax, BYTE PTR ?CAR_DrawCarAxes@@3_NA	; CAR_DrawCarAxes
	test	eax, eax
	je	SHORT $L82681

; 658  : 		DrawAxis(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 100				; 00000064H
	push	eax
	call	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ; DrawAxis
	add	esp, 8
$L82681:

; 659  : 	}
; 660  : 	if (CAR_DrawCarBBoxes) {

	movzx	eax, BYTE PTR ?CAR_DrawCarBBoxes@@3_NA	; CAR_DrawCarBBoxes
	test	eax, eax
	je	$L82682

; 661  : 		ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L82683
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82683:

; 662  : 		ALPHA_SRC(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 2
	je	SHORT $L82684
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 2	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82684:

; 663  : 		ALPHA_DEST(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 2
	je	SHORT $L82685
	mov	WORD PTR ?RenderAlphaDest@@3FA, 2	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82685:

; 664  : 		ZWRITE_OFF();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	je	SHORT $L82686
	mov	WORD PTR ?RenderZwrite@@3FA, 0		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82686:

; 665  : 
; 666  : 		DrawCarBoundingBoxes(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?DrawCarBoundingBoxes@@YAXPAUCarStruct@@@Z ; DrawCarBoundingBoxes
	add	esp, 4

; 667  : 
; 668  : 		ZWRITE_ON();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	jne	SHORT $L82687
	mov	WORD PTR ?RenderZwrite@@3FA, 1		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82687:

; 669  : 		ALPHA_OFF();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	je	SHORT $L82682
	mov	WORD PTR ?RenderAlpha@@3FA, 0		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82682:

; 670  : 	}
; 671  : #endif
; 672  : 
; 673  : // draw aerial
; 674  : 
; 675  : 	GhostSineOffset = car->AerialOffset.v[Z];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3396]
	mov	DWORD PTR ?GhostSineOffset@@3MA, ecx

; 676  : 	if (CarHasAerial(car)) 

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	movsx	edx, BYTE PTR [ecx+4]
	and	edx, 2
	je	SHORT $L82689

; 677  : 	{
; 678  : 		DrawCarAerial2(&car->Aerial, car->Models->Aerial[0], car->Models->Aerial[1], flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	eax, DWORD PTR [edx+6140]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	eax, DWORD PTR [edx+6136]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	add	ecx, 860				; 0000035cH
	push	ecx
	call	?DrawCarAerial2@@YAXPAUAERIAL@@PAUMODEL@@1F@Z ; DrawCarAerial2
	add	esp, 16					; 00000010H
$L82689:

; 679  : 	}
; 680  : 
; 681  : // reset render states?
; 682  : 
; 683  : 	if (flag & MODEL_FOG)

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 1
	je	SHORT $L82634

; 684  : 		FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L82634
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82634:

; 685  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawCarGhost@@YAXPAUCarStruct@@@Z ENDP			; DrawCarGhost
_TEXT	ENDS
PUBLIC	_sinf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC NEAR					; sin, COMDAT

; 575  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sinf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
EXTRN	_sin:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sinf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sinf	PROC NEAR					; COMDAT

; 466  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	__real@43800000
PUBLIC	?DrawAllCarShadows@@YAXXZ			; DrawAllCarShadows
EXTRN	?DrawShadow@@YAXPAUVectorStruct@@000MMMMJMMJJPAUBoundingBoxStruct@@@Z:NEAR ; DrawShadow
EXTRN	?TextureStateChange@@3JA:DWORD			; TextureStateChange
EXTRN	?RenderTP@@3FA:WORD				; RenderTP
EXTRN	?TexInfo@@3PAUTEXINFO@@A:DWORD			; TexInfo
;	COMDAT __real@43800000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\drawobj.cpp
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DrawAllCarShadows@@YAXXZ
_TEXT	SEGMENT
_sh$ = -108						; size = 4
_player$ = -104						; size = 4
_car$ = -100						; size = 4
_p3$ = -96						; size = 12
_p2$ = -84						; size = 12
_p1$ = -72						; size = 12
_p0$ = -60						; size = 12
_s3$ = -48						; size = 12
_s2$ = -36						; size = 12
_s1$ = -24						; size = 12
_s0$ = -12						; size = 12
?DrawAllCarShadows@@YAXXZ PROC NEAR			; DrawAllCarShadows, COMDAT

; 692  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi

; 693  : 	VEC s0, s1, s2, s3;
; 694  : 	VEC p0, p1, p2, p3;
; 695  : 	CAR *car;
; 696  : 	PLAYER *player;
; 697  : 	CAR_SHADOW_TABLE *sh;
; 698  : 
; 699  : // not if shadows off
; 700  : 
; 701  : 	if (!RenderSettings.Shadow)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+84, 0
	jne	SHORT $L82706

; 702  : 		return;

	jmp	$L82694
$L82706:

; 703  : 
; 704  : // set render states
; 705  : 
; 706  : 	ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L82707
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82707:

; 707  : 	ALPHA_SRC(D3DBLEND_ZERO);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 1
	je	SHORT $L82708
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 1	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82708:

; 708  : 	ALPHA_DEST(D3DBLEND_INVSRCCOLOR);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 4
	je	SHORT $L82709
	mov	WORD PTR ?RenderAlphaDest@@3FA, 4	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82709:

; 709  : 
; 710  : 	ZWRITE_OFF();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	je	SHORT $L82710
	mov	WORD PTR ?RenderZwrite@@3FA, 0		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82710:

; 711  : 	SET_TPAGE(TPAGE_SHADOW);

	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, 26					; 0000001aH
	je	SHORT $L82711
	mov	WORD PTR ?RenderTP@@3FA, 26		; RenderTP, 0000001aH
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	jne	SHORT $L82712
	push	0
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
	jmp	SHORT $L82711
$L82712:
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
$L82711:

; 712  : 
; 713  : // draw all visible car shadows
; 714  : 
; 715  : 	for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L82714
$L82715:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L82714:
	cmp	DWORD PTR _player$[ebp], 0
	je	$L82694

; 716  : 	{
; 717  : 		car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 718  : 		sh = &CarShadowTable[car->CarID];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	imul	ecx, 36					; 00000024H
	add	ecx, OFFSET FLAT:?CarShadowTable@@3PAUCAR_SHADOW_TABLE@@A ; CarShadowTable
	mov	DWORD PTR _sh$[ebp], ecx

; 719  : 
; 720  : 		if (car->Rendered)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3412], 0
	je	$L82717

; 721  : 		{
; 722  : 			SetVector(&s0, sh->Left, sh->Height, sh->Front);

	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s0$[ebp], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _s0$[ebp+4], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _s0$[ebp+8], ecx

; 723  : 			SetVector(&s1, sh->Right, sh->Height, sh->Front);

	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _s1$[ebp], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _s1$[ebp+4], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _s1$[ebp+8], ecx

; 724  : 			SetVector(&s2, sh->Right, sh->Height, sh->Back);

	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _s2$[ebp], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _s2$[ebp+4], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _s2$[ebp+8], ecx

; 725  : 			SetVector(&s3, sh->Left, sh->Height, sh->Back);

	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s3$[ebp], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _s3$[ebp+4], ecx
	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _s3$[ebp+8], ecx

; 726  : 
; 727  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &s0, &p0);

	lea	eax, DWORD PTR _p0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s0$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 728  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &s1, &p1);

	lea	eax, DWORD PTR _p1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 729  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &s2, &p2);

	lea	eax, DWORD PTR _p2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 730  : 			RotTransVector(&car->Body->Centre.WMatrix, &car->Body->Centre.Pos, &s3, &p3);

	lea	eax, DWORD PTR _p3$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 731  : 
; 732  : 			DrawShadow(&p0, &p1, &p2, &p3, sh->tu / 256.0f, sh->tv / 256.0f, sh->twidth / 256.0f, sh->theight / 256.0f, 0x808080, -2.0f, 0.0f, -1, TPAGE_SHADOW, NULL);

	push	0
	push	26					; 0000001aH
	push	-1
	push	0
	push	-1073741824				; c0000000H
	push	8421504					; 00808080H
	mov	eax, DWORD PTR _sh$[ebp]
	fld	DWORD PTR [eax+32]
	fdiv	DWORD PTR __real@43800000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _sh$[ebp]
	fld	DWORD PTR [ecx+28]
	fdiv	DWORD PTR __real@43800000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _sh$[ebp]
	fld	DWORD PTR [edx+24]
	fdiv	DWORD PTR __real@43800000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _sh$[ebp]
	fld	DWORD PTR [eax+20]
	fdiv	DWORD PTR __real@43800000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _p3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _p2$[ebp]
	push	edx
	lea	eax, DWORD PTR _p1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _p0$[ebp]
	push	ecx
	call	?DrawShadow@@YAXPAUVectorStruct@@000MMMMJMMJJPAUBoundingBoxStruct@@@Z ; DrawShadow
	add	esp, 56					; 00000038H
$L82717:

; 733  : 
; 734  : 
; 735  : #if FALSE
; 736  : 			if (player == GHO_GhostPlayer) continue;
; 737  : 
; 738  : 			if (Keys[DIK_1]) sh->Left--;
; 739  : 			if (Keys[DIK_2]) sh->Left++;
; 740  : 			if (Keys[DIK_3]) sh->Right--;
; 741  : 			if (Keys[DIK_4]) sh->Right++;
; 742  : 			if (Keys[DIK_5]) sh->Front--;
; 743  : 			if (Keys[DIK_6]) sh->Front++;
; 744  : 			if (Keys[DIK_7]) sh->Back--;
; 745  : 			if (Keys[DIK_8]) sh->Back++;
; 746  : 			if (Keys[DIK_MINUS]) sh->Height--;
; 747  : 			if (Keys[DIK_EQUALS]) sh->Height++;
; 748  : 
; 749  : 			BeginTextState();
; 750  : 			char buf[128];
; 751  : 			wsprintf(buf, "%d %d %d %d %d", (long)sh->Left, (long)sh->Right, (long)sh->Front, (long)sh->Back, (long)sh->Height);
; 752  : 			DumpText(128, 128, 12, 16, 0xff00ff, buf);
; 753  : #endif
; 754  : 		}
; 755  : 	}

	jmp	$L82715
$L82694:

; 756  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawAllCarShadows@@YAXXZ ENDP				; DrawAllCarShadows
_TEXT	ENDS
PUBLIC	__real@3e800000
EXTRN	?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z:NEAR	; BuildMatrixFromUp
EXTRN	?Interpolate3D@@YAXPAUVectorStruct@@00M0@Z:NEAR	; Interpolate3D
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DrawCarAerial2@@YAXPAUAERIAL@@PAUMODEL@@1F@Z
_TEXT	SEGMENT
__mul$82731 = -68					; size = 4
_wMatrix$ = -64						; size = 36
_lastPos$ = -28						; size = 12
_thisPos$ = -16						; size = 12
_iSec$ = -4						; size = 4
_aerial$ = 8						; size = 4
_secModel$ = 12						; size = 4
_topModel$ = 16						; size = 4
_flag$ = 20						; size = 2
?DrawCarAerial2@@YAXPAUAERIAL@@PAUMODEL@@1F@Z PROC NEAR	; DrawCarAerial2, COMDAT

; 765  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 766  : 	int iSec;
; 767  : 	VEC	thisPos;
; 768  : 	VEC	lastPos;
; 769  : 	MAT	wMatrix;
; 770  : 
; 771  : 	// Calculate the positions of the non-control sections by interpolating from the control sections
; 772  : 	CopyVec(&aerial->Section[0].Pos, &lastPos);

	mov	eax, DWORD PTR _aerial$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _lastPos$[ebp], ecx
	mov	eax, DWORD PTR _aerial$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _lastPos$[ebp+4], ecx
	mov	eax, DWORD PTR _aerial$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _lastPos$[ebp+8], ecx

; 773  : 
; 774  : 	for (iSec = AERIAL_START; iSec < AERIAL_NTOTSECTIONS; iSec++) {

	mov	DWORD PTR _iSec$[ebp], 1
	jmp	SHORT $L82728
$L82729:
	mov	eax, DWORD PTR _iSec$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSec$[ebp], eax
$L82728:
	cmp	DWORD PTR _iSec$[ebp], 5
	jge	$L82723

; 775  : 		
; 776  : 		// calculate the position of the interpolated node
; 777  : 		Interpolate3D(
; 778  : 			&aerial->Section[0].Pos,
; 779  : 			&aerial->Section[AERIAL_SKIP].Pos,
; 780  : 			&aerial->Section[AERIAL_LASTSECTION].Pos,
; 781  : 			iSec * AERIAL_UNITLEN,
; 782  : 			&thisPos);

	lea	eax, DWORD PTR _thisPos$[ebp]
	push	eax
	fild	DWORD PTR _iSec$[ebp]
	fmul	DWORD PTR __real@3e800000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _aerial$[ebp]
	add	ecx, 496				; 000001f0H
	push	ecx
	mov	edx, DWORD PTR _aerial$[ebp]
	add	edx, 272				; 00000110H
	push	edx
	mov	eax, DWORD PTR _aerial$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	?Interpolate3D@@YAXPAUVectorStruct@@00M0@Z ; Interpolate3D
	add	esp, 20					; 00000014H

; 783  : 
; 784  : 		// Set the up vector of the node (already scaled to give correct length)
; 785  : 		VecMinusVec(&thisPos, &lastPos, &wMatrix.mv[U]);

	fld	DWORD PTR _thisPos$[ebp]
	fsub	DWORD PTR _lastPos$[ebp]
	fstp	DWORD PTR _wMatrix$[ebp+12]
	fld	DWORD PTR _thisPos$[ebp+4]
	fsub	DWORD PTR _lastPos$[ebp+4]
	fstp	DWORD PTR _wMatrix$[ebp+16]
	fld	DWORD PTR _thisPos$[ebp+8]
	fsub	DWORD PTR _lastPos$[ebp+8]
	fstp	DWORD PTR _wMatrix$[ebp+20]

; 786  : 
; 787  : 		// Build the world Matrix for the section
; 788  : 		BuildMatrixFromUp(&wMatrix);

	lea	eax, DWORD PTR _wMatrix$[ebp]
	push	eax
	call	?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z ; BuildMatrixFromUp
	add	esp, 4

; 789  : 		// Must normalise look vector when passed up vector was not normalised
; 790  : 		NormalizeVec(&wMatrix.mv[L]);

	fld	DWORD PTR _wMatrix$[ebp+24]
	fmul	DWORD PTR _wMatrix$[ebp+24]
	fld	DWORD PTR _wMatrix$[ebp+28]
	fmul	DWORD PTR _wMatrix$[ebp+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _wMatrix$[ebp+32]
	fmul	DWORD PTR _wMatrix$[ebp+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82731[ebp]
	fld	DWORD PTR _wMatrix$[ebp+24]
	fmul	DWORD PTR __mul$82731[ebp]
	fstp	DWORD PTR _wMatrix$[ebp+24]
	fld	DWORD PTR _wMatrix$[ebp+28]
	fmul	DWORD PTR __mul$82731[ebp]
	fstp	DWORD PTR _wMatrix$[ebp+28]
	fld	DWORD PTR _wMatrix$[ebp+32]
	fmul	DWORD PTR __mul$82731[ebp]
	fstp	DWORD PTR _wMatrix$[ebp+32]

; 791  : 
; 792  : 		// Draw the actual model
; 793  : 		if (iSec != AERIAL_NTOTSECTIONS - 1) {

	cmp	DWORD PTR _iSec$[ebp], 4
	je	SHORT $L82733

; 794  : 			if (flag & MODEL_LIT) {

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82734

; 795  : 				AddModelLightSimple(secModel, &thisPos);

	lea	eax, DWORD PTR _thisPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _secModel$[ebp]
	push	ecx
	call	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ; AddModelLightSimple
	add	esp, 8
$L82734:

; 796  : 			}
; 797  : 			DrawModel(secModel, &wMatrix, &thisPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	lea	ecx, DWORD PTR _thisPos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wMatrix$[ebp]
	push	edx
	mov	eax, DWORD PTR _secModel$[ebp]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H

; 798  : 		} else {

	jmp	SHORT $L82735
$L82733:

; 799  : 			if (flag & MODEL_LIT) {

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 2
	je	SHORT $L82736

; 800  : 				AddModelLightSimple(topModel, &thisPos);

	lea	eax, DWORD PTR _thisPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _topModel$[ebp]
	push	ecx
	call	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ; AddModelLightSimple
	add	esp, 8
$L82736:

; 801  : 			}
; 802  : 			DrawModel(topModel, &wMatrix, &thisPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	lea	ecx, DWORD PTR _thisPos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wMatrix$[ebp]
	push	edx
	mov	eax, DWORD PTR _topModel$[ebp]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H
$L82735:

; 803  : 		}
; 804  : 
; 805  : 		CopyVec(&thisPos, &lastPos);

	mov	eax, DWORD PTR _thisPos$[ebp]
	mov	DWORD PTR _lastPos$[ebp], eax
	mov	eax, DWORD PTR _thisPos$[ebp+4]
	mov	DWORD PTR _lastPos$[ebp+4], eax
	mov	eax, DWORD PTR _thisPos$[ebp+8]
	mov	DWORD PTR _lastPos$[ebp+8], eax

; 806  : 	}

	jmp	$L82729
$L82723:

; 807  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawCarAerial2@@YAXPAUAERIAL@@PAUMODEL@@1F@Z ENDP	; DrawCarAerial2
_TEXT	ENDS
EXTRN	?DrawBoundingBox@@YAXMMMMMMJJJJJJ@Z:NEAR	; DrawBoundingBox
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawCarBoundingBoxes@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_cols$ = -96						; size = 72
_nCols$ = -24						; size = 4
_iCol$ = -20						; size = 4
_pWheel$ = -16						; size = 4
_iWheel$ = -12						; size = 4
_pSkin$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_car$ = 8						; size = 4
?DrawCarBoundingBoxes@@YAXPAUCarStruct@@@Z PROC NEAR	; DrawCarBoundingBoxes, COMDAT

; 816  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi

; 817  : 	int iSkin;
; 818  : 	CONVEX *pSkin;
; 819  : 	int iWheel;
; 820  : 	WHEEL *pWheel;
; 821  : 	
; 822  : 	
; 823  : 	int iCol = 0;

	mov	DWORD PTR _iCol$[ebp], 0

; 824  : 	int nCols = 6;

	mov	DWORD PTR _nCols$[ebp], 6

; 825  : 	long cols[][3] = { 
; 826  : 		{0x000022, 0x000022, 0x000022},

	mov	DWORD PTR _cols$[ebp], 34		; 00000022H
	mov	DWORD PTR _cols$[ebp+4], 34		; 00000022H
	mov	DWORD PTR _cols$[ebp+8], 34		; 00000022H

; 827  : 		{0x002200, 0x002200, 0x002200},

	mov	DWORD PTR _cols$[ebp+12], 8704		; 00002200H
	mov	DWORD PTR _cols$[ebp+16], 8704		; 00002200H
	mov	DWORD PTR _cols$[ebp+20], 8704		; 00002200H

; 828  : 		{0x220000, 0x220000, 0x220000},

	mov	DWORD PTR _cols$[ebp+24], 2228224	; 00220000H
	mov	DWORD PTR _cols$[ebp+28], 2228224	; 00220000H
	mov	DWORD PTR _cols$[ebp+32], 2228224	; 00220000H

; 829  : 		{0x002222, 0x002222, 0x002222},

	mov	DWORD PTR _cols$[ebp+36], 8738		; 00002222H
	mov	DWORD PTR _cols$[ebp+40], 8738		; 00002222H
	mov	DWORD PTR _cols$[ebp+44], 8738		; 00002222H

; 830  : 		{0x222200, 0x222200, 0x222200},

	mov	DWORD PTR _cols$[ebp+48], 2236928	; 00222200H
	mov	DWORD PTR _cols$[ebp+52], 2236928	; 00222200H
	mov	DWORD PTR _cols$[ebp+56], 2236928	; 00222200H

; 831  : 		{0x220022, 0x220022, 0x220022},

	mov	DWORD PTR _cols$[ebp+60], 2228258	; 00220022H
	mov	DWORD PTR _cols$[ebp+64], 2228258	; 00220022H
	mov	DWORD PTR _cols$[ebp+68], 2228258	; 00220022H

; 832  : 	};
; 833  : 
; 834  : 	// Overall car BBox
; 835  : 	DrawBoundingBox(
; 836  : 		car->BBox.XMin, 
; 837  : 		car->BBox.XMax, 
; 838  : 		car->BBox.YMin, 
; 839  : 		car->BBox.YMax, 
; 840  : 		car->BBox.ZMin, 
; 841  : 		car->BBox.ZMax, 
; 842  : 		cols[iCol][0], cols[iCol][1], cols[iCol][2], 
; 843  : 		cols[iCol][0], cols[iCol][1], cols[iCol][2]);

	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3168]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3164]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3160]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3156]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3152]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3148]
	push	edx
	call	?DrawBoundingBox@@YAXMMMMMMJJJJJJ@Z	; DrawBoundingBox
	add	esp, 48					; 00000030H

; 844  : 	iCol++;

	mov	eax, DWORD PTR _iCol$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCol$[ebp], eax

; 845  : 	if (iCol == nCols) iCol = 0;

	mov	eax, DWORD PTR _iCol$[ebp]
	cmp	eax, DWORD PTR _nCols$[ebp]
	jne	SHORT $L82747
	mov	DWORD PTR _iCol$[ebp], 0
$L82747:

; 846  : 
; 847  : 	// Main body BBox
; 848  : 	DrawBoundingBox(
; 849  : 		car->Body->CollSkin.BBox.XMin, 
; 850  : 		car->Body->CollSkin.BBox.XMax, 
; 851  : 		car->Body->CollSkin.BBox.YMin, 
; 852  : 		car->Body->CollSkin.BBox.YMax, 
; 853  : 		car->Body->CollSkin.BBox.ZMin, 
; 854  : 		car->Body->CollSkin.BBox.ZMax, 
; 855  : 		cols[iCol][0], cols[iCol][1], cols[iCol][2], 
; 856  : 		cols[iCol][0], cols[iCol][1], cols[iCol][2]);

	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+452]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+448]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+444]
	push	edx
	call	?DrawBoundingBox@@YAXMMMMMMJJJJJJ@Z	; DrawBoundingBox
	add	esp, 48					; 00000030H

; 857  : 	iCol++;

	mov	eax, DWORD PTR _iCol$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCol$[ebp], eax

; 858  : 	if (iCol == nCols) iCol = 0;

	mov	eax, DWORD PTR _iCol$[ebp]
	cmp	eax, DWORD PTR _nCols$[ebp]
	jne	SHORT $L82748
	mov	DWORD PTR _iCol$[ebp], 0
$L82748:

; 859  : 
; 860  : 
; 861  : 	// Collision Skin boxes
; 862  : 	for (iSkin = 0; iSkin < car->Body->CollSkin.NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82749
$L82750:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82749:
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	movsx	edx, WORD PTR [ecx+392]
	cmp	DWORD PTR _iSkin$[ebp], edx
	jge	$L82751

; 863  : 		pSkin = &car->Body->CollSkin.WorldConvex[iSkin];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	add	edx, DWORD PTR [ecx+384]
	mov	DWORD PTR _pSkin$[ebp], edx

; 864  : 
; 865  : 		DrawBoundingBox(
; 866  : 			pSkin->BBox.XMin, 
; 867  : 			pSkin->BBox.XMax,
; 868  : 			pSkin->BBox.YMin, 
; 869  : 			pSkin->BBox.YMax,
; 870  : 			pSkin->BBox.ZMin, 
; 871  : 			pSkin->BBox.ZMax,
; 872  : 			cols[iCol][0], cols[iCol][1], cols[iCol][2], 
; 873  : 			cols[iCol][0], cols[iCol][1], cols[iCol][2]);

	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _pSkin$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pSkin$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _pSkin$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _pSkin$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pSkin$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pSkin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?DrawBoundingBox@@YAXMMMMMMJJJJJJ@Z	; DrawBoundingBox
	add	esp, 48					; 00000030H

; 874  : 		iCol++;

	mov	eax, DWORD PTR _iCol$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCol$[ebp], eax

; 875  : 		if (iCol == nCols) iCol = 0;

	mov	eax, DWORD PTR _iCol$[ebp]
	cmp	eax, DWORD PTR _nCols$[ebp]
	jne	SHORT $L82752
	mov	DWORD PTR _iCol$[ebp], 0
$L82752:

; 876  : 	}

	jmp	$L82750
$L82751:

; 877  : 
; 878  : 	// Wheel BBoxes
; 879  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L82753
$L82754:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L82753:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L82739

; 880  : 		pWheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _pWheel$[ebp], edx

; 881  : 		if (!IsWheelPresent(pWheel)) continue;

	mov	eax, DWORD PTR _pWheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	jne	SHORT $L82756
	jmp	SHORT $L82754
$L82756:

; 882  : 
; 883  : 		DrawBoundingBox(
; 884  : 			pWheel->BBox.XMin + pWheel->CentrePos.v[X], 
; 885  : 			pWheel->BBox.XMax + pWheel->CentrePos.v[X],
; 886  : 			pWheel->BBox.YMin + pWheel->CentrePos.v[Y], 
; 887  : 			pWheel->BBox.YMax + pWheel->CentrePos.v[Y],
; 888  : 			pWheel->BBox.ZMin + pWheel->CentrePos.v[Z], 
; 889  : 			pWheel->BBox.ZMax + pWheel->CentrePos.v[Z],
; 890  : 			cols[iCol][0], cols[iCol][1], cols[iCol][2], 
; 891  : 			cols[iCol][0], cols[iCol][1], cols[iCol][2]);

	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _iCol$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _cols$[ebp+eax+8]
	push	ecx
	mov	edx, DWORD PTR _iCol$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _cols$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _iCol$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cols$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _pWheel$[ebp]
	mov	ecx, DWORD PTR _pWheel$[ebp]
	fld	DWORD PTR [eax+72]
	fadd	DWORD PTR [ecx+192]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _pWheel$[ebp]
	mov	eax, DWORD PTR _pWheel$[ebp]
	fld	DWORD PTR [edx+68]
	fadd	DWORD PTR [eax+192]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pWheel$[ebp]
	mov	edx, DWORD PTR _pWheel$[ebp]
	fld	DWORD PTR [ecx+64]
	fadd	DWORD PTR [edx+188]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _pWheel$[ebp]
	mov	ecx, DWORD PTR _pWheel$[ebp]
	fld	DWORD PTR [eax+60]
	fadd	DWORD PTR [ecx+188]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _pWheel$[ebp]
	mov	eax, DWORD PTR _pWheel$[ebp]
	fld	DWORD PTR [edx+56]
	fadd	DWORD PTR [eax+184]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pWheel$[ebp]
	mov	edx, DWORD PTR _pWheel$[ebp]
	fld	DWORD PTR [ecx+52]
	fadd	DWORD PTR [edx+184]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?DrawBoundingBox@@YAXMMMMMMJJJJJJ@Z	; DrawBoundingBox
	add	esp, 48					; 00000030H

; 892  : 		iCol++;

	mov	eax, DWORD PTR _iCol$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCol$[ebp], eax

; 893  : 		if (iCol == nCols) iCol = 0;

	mov	eax, DWORD PTR _iCol$[ebp]
	cmp	eax, DWORD PTR _nCols$[ebp]
	jne	SHORT $L82757
	mov	DWORD PTR _iCol$[ebp], 0
$L82757:

; 894  : 	}

	jmp	$L82754
$L82739:

; 895  : 
; 896  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawCarBoundingBoxes@@YAXPAUCarStruct@@@Z ENDP		; DrawCarBoundingBoxes
_TEXT	ENDS
PUBLIC	__real@42800000
PUBLIC	?DrawSkidMarks@@YAXXZ				; DrawSkidMarks
EXTRN	?ViewMatrixScaled@@3TMatrixUnion@@A:BYTE	; ViewMatrixScaled
EXTRN	?ViewTransScaled@@3UVectorStruct@@A:BYTE	; ViewTransScaled
EXTRN	?WHL_NSkids@@3HA:DWORD				; WHL_NSkids
EXTRN	?WHL_SkidHead@@3HA:DWORD			; WHL_SkidHead
EXTRN	?WHL_SkidMark@@3PAUSKIDMARK@@A:BYTE		; WHL_SkidMark
EXTRN	?CamVisiMask@@3_KA:QWORD			; CamVisiMask
EXTRN	?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A:BYTE		; DrawVertsTEX1
EXTRN	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z:NEAR ; RotTransPersVector
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DrawSkidMarks@@YAXXZ
_TEXT	SEGMENT
tv295 = -92						; size = 8
_z$ = -20						; size = 4
_skid$ = -16						; size = 4
_currentSkid$ = -12					; size = 4
_j$ = -8						; size = 4
_iSkid$ = -4						; size = 4
?DrawSkidMarks@@YAXXZ PROC NEAR				; DrawSkidMarks, COMDAT

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 908  : 	int iSkid, j;
; 909  : 	int currentSkid;
; 910  : 	SKIDMARK *skid;
; 911  : 	REAL z;
; 912  : 
; 913  : 	// quit?
; 914  : 	if (!WHL_NSkids || !RenderSettings.Skid) return;

	cmp	DWORD PTR ?WHL_NSkids@@3HA, 0		; WHL_NSkids
	je	SHORT $L82766
	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+96, 0
	jne	SHORT $L82765
$L82766:
	jmp	$L82759
$L82765:

; 915  : 
; 916  : 	// render states
; 917  : 	ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L82767
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82767:

; 918  : 	ALPHA_SRC(D3DBLEND_ZERO);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 1
	je	SHORT $L82768
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 1	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82768:

; 919  : 	ALPHA_DEST(D3DBLEND_INVSRCCOLOR);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 4
	je	SHORT $L82769
	mov	WORD PTR ?RenderAlphaDest@@3FA, 4	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82769:

; 920  : 
; 921  : 	ZWRITE_OFF();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	je	SHORT $L82770
	mov	WORD PTR ?RenderZwrite@@3FA, 0		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82770:

; 922  : 	SET_TPAGE(TPAGE_SHADOW);

	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, 26					; 0000001aH
	je	SHORT $L82771
	mov	WORD PTR ?RenderTP@@3FA, 26		; RenderTP, 0000001aH
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	jne	SHORT $L82772
	push	0
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
	jmp	SHORT $L82771
$L82772:
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
$L82771:

; 923  : 
; 924  : 	DrawVertsTEX1[0].tu = 224.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+24, 1063256064 ; 3f600000H

; 925  : 	DrawVertsTEX1[0].tv = 194.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+28, 1061289984 ; 3f420000H

; 926  : 
; 927  : 	DrawVertsTEX1[1].tu = 256.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+56, 1065353216 ; 3f800000H

; 928  : 	DrawVertsTEX1[1].tv = 194.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+60, 1061289984 ; 3f420000H

; 929  : 
; 930  : 	DrawVertsTEX1[2].tu = 256.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+88, 1065353216 ; 3f800000H

; 931  : 	DrawVertsTEX1[2].tv = 254.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+92, 1065222144 ; 3f7e0000H

; 932  : 
; 933  : 	DrawVertsTEX1[3].tu = 224.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+120, 1063256064 ; 3f600000H

; 934  : 	DrawVertsTEX1[3].tv = 254.0f / 256.0f;

	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+124, 1065222144 ; 3f7e0000H

; 935  : 
; 936  : 
; 937  : 	// draw skidmarks
; 938  : 	currentSkid = WHL_SkidHead;

	mov	eax, DWORD PTR ?WHL_SkidHead@@3HA	; WHL_SkidHead
	mov	DWORD PTR _currentSkid$[ebp], eax

; 939  : 	for (iSkid = 0; iSkid < WHL_NSkids; iSkid++) {

	mov	DWORD PTR _iSkid$[ebp], 0
	jmp	SHORT $L82774
$L82775:
	mov	eax, DWORD PTR _iSkid$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkid$[ebp], eax
$L82774:
	mov	eax, DWORD PTR _iSkid$[ebp]
	cmp	eax, DWORD PTR ?WHL_NSkids@@3HA		; WHL_NSkids
	jge	$L82759

; 940  : 
; 941  : 		// address of next skidmark to draw
; 942  : 		currentSkid--;

	mov	eax, DWORD PTR _currentSkid$[ebp]
	sub	eax, 1
	mov	DWORD PTR _currentSkid$[ebp], eax

; 943  : 		Wrap(currentSkid, 0, SKID_MAX_SKIDS);

	jns	SHORT $L82777
	mov	eax, DWORD PTR _currentSkid$[ebp]
	add	eax, 1000				; 000003e8H
	mov	DWORD PTR _currentSkid$[ebp], eax
$L82777:
	cmp	DWORD PTR _currentSkid$[ebp], 1000	; 000003e8H
	jl	SHORT $L82778
	mov	eax, DWORD PTR _currentSkid$[ebp]
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR _currentSkid$[ebp], eax
$L82778:

; 944  : 		skid = &WHL_SkidMark[currentSkid];

	mov	eax, DWORD PTR _currentSkid$[ebp]
	imul	eax, 72					; 00000048H
	add	eax, OFFSET FLAT:?WHL_SkidMark@@3PAUSKIDMARK@@A ; WHL_SkidMark
	mov	DWORD PTR _skid$[ebp], eax

; 945  : 
; 946  : 		// basic visibility test
; 947  : 		if (skid->VisiMask & CamVisiMask) continue;

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, DWORD PTR ?CamVisiMask@@3_KA
	mov	edx, DWORD PTR [eax+68]
	and	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	mov	DWORD PTR tv295[ebp], ecx
	mov	DWORD PTR tv295[ebp+4], edx
	mov	eax, DWORD PTR tv295[ebp]
	or	eax, DWORD PTR tv295[ebp+4]
	je	SHORT $L82779
	jmp	SHORT $L82775
$L82779:

; 948  : 		z = skid->Centre.v[X] * ViewMatrix.m[RZ] + skid->Centre.v[Y] * ViewMatrix.m[UZ] + skid->Centre.v[Z] * ViewMatrix.m[LZ] + ViewTrans.v[Z];

	mov	eax, DWORD PTR _skid$[ebp]
	fld	DWORD PTR ?ViewMatrix@@3TMatrixUnion@@A+8
	fmul	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _skid$[ebp]
	fld	DWORD PTR ?ViewMatrix@@3TMatrixUnion@@A+20
	fmul	DWORD PTR [ecx+52]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _skid$[ebp]
	fld	DWORD PTR ?ViewMatrix@@3TMatrixUnion@@A+32
	fmul	DWORD PTR [edx+56]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR ?ViewTrans@@3UVectorStruct@@A+8
	fstp	DWORD PTR _z$[ebp]

; 949  : 		if (z + SKID_HALF_LEN < RenderSettings.NearClip || z - SKID_HALF_LEN >= RenderSettings.FarClip) continue;

	fld	DWORD PTR _z$[ebp]
	fadd	DWORD PTR __real@42800000
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82783
	fld	DWORD PTR _z$[ebp]
	fsub	DWORD PTR __real@42800000
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82782
$L82783:
	jmp	$L82775
$L82782:

; 950  : 
; 951  : 		// draw skidmark
; 952  : 		for (j = 0 ; j < 4 ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L82784
$L82785:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L82784:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $L82786

; 953  : 		{
; 954  : 			RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &skid->Corner[j], (REAL*)&DrawVertsTEX1[j]);

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 5
	add	eax, OFFSET FLAT:?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A ; DrawVertsTEX1
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR _skid$[ebp]
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 955  : 			DrawVertsTEX1[j].color = skid->RGB;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _skid$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A[eax+16], edx

; 956  : 		}

	jmp	SHORT $L82785
$L82786:

; 957  : 		D3Ddevice->DrawPrimitive(D3DPT_TRIANGLEFAN, FVF_TEX1, DrawVertsTEX1, 4, D3DDP_DONOTUPDATEEXTENTS);

	push	8
	push	4
	push	OFFSET FLAT:?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A ; DrawVertsTEX1
	push	452					; 000001c4H
	push	6
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+112]

; 958  : 	}

	jmp	$L82775
$L82759:

; 959  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawSkidMarks@@YAXXZ ENDP				; DrawSkidMarks
_TEXT	ENDS
PUBLIC	?DrawObjects@@YAXXZ				; DrawObjects
EXTRN	?OBJ_ObjectHead@@3PAUobject_def@@A:DWORD	; OBJ_ObjectHead
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawObjects@@YAXXZ
_TEXT	SEGMENT
_obj$ = -4						; size = 4
?DrawObjects@@YAXXZ PROC NEAR				; DrawObjects, COMDAT

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 967  : 	OBJECT *obj;
; 968  : 
; 969  : 	for (obj = OBJ_ObjectHead; obj; obj = obj->next)

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj$[ebp], eax
	jmp	SHORT $L82792
$L82793:
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj$[ebp], ecx
$L82792:
	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $L82790

; 970  : 	{
; 971  : 		if (obj->renderhandler && obj->flag.Draw)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+700], 0
	je	SHORT $L82795
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	and	ecx, 1
	je	SHORT $L82795

; 972  : 
; 973  : 		{
; 974  : 			obj->renderhandler(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	call	DWORD PTR [ecx+700]
	add	esp, 4
$L82795:

; 975  : 		}
; 976  : 	}	

	jmp	SHORT $L82793
$L82790:

; 977  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawObjects@@YAXXZ ENDP				; DrawObjects
_TEXT	ENDS
PUBLIC	?RenderObject@@YAXPAUobject_def@@@Z		; RenderObject
PUBLIC	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
EXTRN	?LevelModel@@3PAULEVEL_MODEL@@A:BYTE		; LevelModel
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderObject@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv87 = -65						; size = 1
_obj$ = 8						; size = 4
?RenderObject@@YAXPAUobject_def@@@Z PROC NEAR		; RenderObject, COMDAT

; 984  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 985  : 	if (obj->DefaultModel != -1)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	je	SHORT $L82798

; 986  : 		obj->renderflag.visible |= RenderObjectModel(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &LevelModel[obj->DefaultModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR tv87[ebp], al
	movzx	edx, BYTE PTR tv87[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	or	ecx, edx
	and	ecx, 1
	shl	ecx, 6
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+584]
	and	eax, -65				; ffffffbfH
	or	eax, ecx
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+584], eax
$L82798:

; 987  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderObject@@YAXPAUobject_def@@@Z ENDP		; RenderObject
_TEXT	ENDS
EXTRN	?SetEnvStatic@@YAXPAUVectorStruct@@PATMatrixUnion@@JMMM@Z:NEAR ; SetEnvStatic
EXTRN	?CheckModelMeshFx@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@PAF@Z:NEAR ; CheckModelMeshFx
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z
_TEXT	SEGMENT
_flag$ = -36						; size = 2
_visflag$ = -32						; size = 4
_box$ = -28						; size = 24
_z$ = -4						; size = 4
_mat$ = 8						; size = 4
_pos$ = 12						; size = 4
_model$ = 16						; size = 4
_envrgb$ = 20						; size = 4
_renderflag$ = 24					; size = 4
?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z PROC NEAR ; RenderObjectModel, COMDAT

; 994  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 995  : 	REAL z;
; 996  : 	BOUNDING_BOX box;
; 997  : 	long visflag;
; 998  : 	short flag = MODEL_PLAIN;

	mov	WORD PTR _flag$[ebp], 0

; 999  : 
; 1000 : // get bounding box
; 1001 : 
; 1002 : 	box.Xmin = pos->v[X] - model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp]

; 1003 : 	box.Xmax = pos->v[X] + model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+4]

; 1004 : 	box.Ymin = pos->v[Y] - model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+8]

; 1005 : 	box.Ymax = pos->v[Y] + model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+12]

; 1006 : 	box.Zmin = pos->v[Z] - model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+16]

; 1007 : 	box.Zmax = pos->v[Z] + model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+20]

; 1008 : 
; 1009 : // test against visicubes
; 1010 : 
; 1011 : 	if (TestObjectVisiboxes(&box))

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	call	?TestObjectVisiboxes@@YADPAUBoundingBoxStruct@@@Z ; TestObjectVisiboxes
	add	esp, 4
	movsx	ecx, al
	test	ecx, ecx
	je	SHORT $L82811

; 1012 : 		return FALSE;

	xor	al, al
	jmp	$L82806
$L82811:

; 1013 : 
; 1014 : // skip if offscreen
; 1015 : 
; 1016 : 	visflag = TestSphereToFrustum(pos, model->Radius, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _visflag$[ebp], eax

; 1017 : 	if (visflag == SPHERE_OUT) return FALSE;

	cmp	DWORD PTR _visflag$[ebp], 0
	jne	SHORT $L82812
	xor	al, al
	jmp	$L82806
$L82812:

; 1018 : 	if (visflag == SPHERE_IN) flag |= MODEL_DONOTCLIP;

	cmp	DWORD PTR _visflag$[ebp], 2
	jne	SHORT $L82813
	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 8
	mov	WORD PTR _flag$[ebp], ax
$L82813:

; 1019 : 
; 1020 : // env?
; 1021 : 
; 1022 : 	if (renderflag.envmap)

	mov	eax, DWORD PTR _renderflag$[ebp]
	and	eax, 1
	je	SHORT $L82814

; 1023 : 	{
; 1024 : 		flag |= MODEL_ENV;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 4
	mov	WORD PTR _flag$[ebp], ax

; 1025 : 		SetEnvStatic(pos, mat, envrgb, 0.0f, 0.0f, 1.0f);

	push	1065353216				; 3f800000H
	push	0
	push	0
	mov	eax, DWORD PTR _envrgb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	?SetEnvStatic@@YAXPAUVectorStruct@@PATMatrixUnion@@JMMM@Z ; SetEnvStatic
	add	esp, 24					; 00000018H
$L82814:

; 1026 : 	}
; 1027 : 
; 1028 : // in light?
; 1029 : 
; 1030 : 	if (renderflag.light)

	mov	eax, DWORD PTR _renderflag$[ebp]
	shr	eax, 2
	and	eax, 1
	je	SHORT $L82815

; 1031 : 	{
; 1032 : 		if (CheckObjectLight(pos, &box, model->Radius))

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _box$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z ; CheckObjectLight
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L82815

; 1033 : 		{
; 1034 : 			flag |= MODEL_LIT;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 2
	mov	WORD PTR _flag$[ebp], ax

; 1035 : 			AddModelLight(model, pos, mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z ; AddModelLight
	add	esp, 12					; 0000000cH
$L82815:

; 1036 : 		}
; 1037 : 	}
; 1038 : 
; 1039 : // reflect?
; 1040 : 
; 1041 : 	if (renderflag.reflect && RenderSettings.Mirror)

	mov	eax, DWORD PTR _renderflag$[ebp]
	shr	eax, 4
	and	eax, 1
	je	SHORT $L82817
	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+80, 0
	je	SHORT $L82817

; 1042 : 	{
; 1043 : 		if (GetMirrorPlane(pos))

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?GetMirrorPlane@@YAJPAUVectorStruct@@@Z	; GetMirrorPlane
	add	esp, 4
	test	eax, eax
	je	SHORT $L82817

; 1044 : 		{
; 1045 : 			if (ViewCameraPos.v[Y] < MirrorHeight)

	fld	DWORD PTR ?ViewCameraPos@@3UVectorStruct@@A+4
	fcomp	DWORD PTR ?MirrorHeight@@3MA		; MirrorHeight
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82817

; 1046 : 				flag |= MODEL_MIRROR;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 16					; 00000010H
	mov	WORD PTR _flag$[ebp], ax
$L82817:

; 1047 : 		}
; 1048 : 	}
; 1049 : 
; 1050 : // in fog?
; 1051 : 
; 1052 : 	if (renderflag.fog && z + model->Radius > RenderSettings.FogStart && DxState.Fog)

	mov	eax, DWORD PTR _renderflag$[ebp]
	shr	eax, 5
	and	eax, 1
	je	$L82820
	mov	eax, DWORD PTR _model$[ebp]
	fld	DWORD PTR _z$[ebp]
	fadd	DWORD PTR [eax]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+48
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82820
	cmp	DWORD PTR ?DxState@@3UDX_STATE@@A+36, 0
	je	$L82820

; 1053 : 	{
; 1054 : 		ModelVertFog = (pos->v[Y] - RenderSettings.VertFogStart) * RenderSettings.VertFogMul;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+60
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+72
	fstp	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog

; 1055 : 		if (ModelVertFog < 0) ModelVertFog = 0;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82821
	mov	DWORD PTR ?ModelVertFog@@3MA, 0
$L82821:

; 1056 : 		if (ModelVertFog > 255) ModelVertFog = 255;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@437f0000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82822
	mov	DWORD PTR ?ModelVertFog@@3MA, 1132396544 ; 437f0000H
$L82822:

; 1057 : 
; 1058 : 		flag |= MODEL_FOG;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 1
	mov	WORD PTR _flag$[ebp], ax

; 1059 : 		FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L82820
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82820:

; 1060 : 	}
; 1061 : 
; 1062 : // glare?
; 1063 : 
; 1064 : 	if (renderflag.glare)

	mov	eax, DWORD PTR _renderflag$[ebp]
	shr	eax, 7
	and	eax, 1
	je	SHORT $L82824

; 1065 : 		flag |= MODEL_GLARE;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 64					; 00000040H
	mov	WORD PTR _flag$[ebp], ax
$L82824:

; 1066 : 
; 1067 : // mesh fx?
; 1068 : 
; 1069 : 	if (renderflag.meshfx)

	mov	eax, DWORD PTR _renderflag$[ebp]
	shr	eax, 8
	and	eax, 1
	je	SHORT $L82825

; 1070 : 	{
; 1071 : 		CheckModelMeshFx(model, mat, pos, &flag);

	lea	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?CheckModelMeshFx@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@PAF@Z ; CheckModelMeshFx
	add	esp, 16					; 00000010H
$L82825:

; 1072 : 	}
; 1073 : 
; 1074 : // draw model
; 1075 : 
; 1076 : 	DrawModel(model, mat, pos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H

; 1077 : 
; 1078 : // fog off?
; 1079 : 
; 1080 : 	if (flag & MODEL_FOG)

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 1
	je	SHORT $L82826

; 1081 : 		FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L82826
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82826:

; 1082 : 
; 1083 : // return rendered
; 1084 : 
; 1085 : 	return TRUE;

	mov	al, 1
$L82806:

; 1086 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ENDP ; RenderObjectModel
_TEXT	ENDS
PUBLIC	?RenderPlanet@@YAXPAUobject_def@@@Z		; RenderPlanet
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderPlanet@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv214 = -124						; size = 8
_flag$ = -52						; size = 2
_planet$ = -48						; size = 4
_model$ = -44						; size = 4
_mat$ = -40						; size = 4
_pos$ = -36						; size = 4
_visflag$ = -32						; size = 4
_box$ = -28						; size = 24
_z$ = -4						; size = 4
_obj$ = 8						; size = 4
?RenderPlanet@@YAXPAUobject_def@@@Z PROC NEAR		; RenderPlanet, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 1094 : 	REAL z;
; 1095 : 	BOUNDING_BOX box;
; 1096 : 	long visflag;
; 1097 : 	VEC *pos = &obj->body.Centre.Pos;

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _pos$[ebp], eax

; 1098 : 	MAT *mat = &obj->body.Centre.WMatrix;

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _mat$[ebp], eax

; 1099 : 	MODEL *model = &LevelModel[obj->DefaultModel].Model;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	add	ecx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	mov	DWORD PTR _model$[ebp], ecx

; 1100 : 	PLANET_OBJ *planet = (PLANET_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _planet$[ebp], ecx

; 1101 : 	short flag = MODEL_PLAIN;

	mov	WORD PTR _flag$[ebp], 0

; 1102 : 
; 1103 : // get bounding box
; 1104 : 
; 1105 : 	box.Xmin = pos->v[X] - model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp]

; 1106 : 	box.Xmax = pos->v[X] + model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+4]

; 1107 : 	box.Ymin = pos->v[Y] - model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+8]

; 1108 : 	box.Ymax = pos->v[Y] + model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+12]

; 1109 : 	box.Zmin = pos->v[Z] - model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+16]

; 1110 : 	box.Zmax = pos->v[Z] + model->Radius;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _box$[ebp+20]

; 1111 : 
; 1112 : // test against visicubes
; 1113 : 
; 1114 : 	if (planet->VisiMask & CamVisiMask)

	mov	eax, DWORD PTR _planet$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, DWORD PTR ?CamVisiMask@@3_KA
	mov	edx, DWORD PTR [eax+68]
	and	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	mov	DWORD PTR tv214[ebp], ecx
	mov	DWORD PTR tv214[ebp+4], edx
	mov	eax, DWORD PTR tv214[ebp]
	or	eax, DWORD PTR tv214[ebp+4]
	je	SHORT $L82840

; 1115 : 		return;

	jmp	$L82830
$L82840:

; 1116 : 
; 1117 : // skip if offscreen
; 1118 : 
; 1119 : 	visflag = TestSphereToFrustum(pos, model->Radius, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _visflag$[ebp], eax

; 1120 : 	if (visflag == SPHERE_OUT) return;

	cmp	DWORD PTR _visflag$[ebp], 0
	jne	SHORT $L82841
	jmp	$L82830
$L82841:

; 1121 : 	if (visflag == SPHERE_IN) flag |= MODEL_DONOTCLIP;

	cmp	DWORD PTR _visflag$[ebp], 2
	jne	SHORT $L82842
	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 8
	mov	WORD PTR _flag$[ebp], ax
$L82842:

; 1122 : 
; 1123 : // set visible flag
; 1124 : 
; 1125 : 	obj->renderflag.visible = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1126 : 
; 1127 : // in light?
; 1128 : 
; 1129 : 	if (CheckObjectLight(pos, &box, model->Radius))

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _box$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z ; CheckObjectLight
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L82843

; 1130 : 	{
; 1131 : 		flag |= MODEL_LIT;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 2
	mov	WORD PTR _flag$[ebp], ax

; 1132 : 		AddModelLight(model, pos, mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z ; AddModelLight
	add	esp, 12					; 0000000cH
$L82843:

; 1133 : 	}
; 1134 : 
; 1135 : // in fog?
; 1136 : 
; 1137 : 	if (z + model->Radius > RenderSettings.FogStart && DxState.Fog)

	mov	eax, DWORD PTR _model$[ebp]
	fld	DWORD PTR _z$[ebp]
	fadd	DWORD PTR [eax]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+48
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82844
	cmp	DWORD PTR ?DxState@@3UDX_STATE@@A+36, 0
	je	$L82844

; 1138 : 	{
; 1139 : 		ModelVertFog = (pos->v[Y] - RenderSettings.VertFogStart) * RenderSettings.VertFogMul;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+60
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+72
	fstp	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog

; 1140 : 		if (ModelVertFog < 0) ModelVertFog = 0;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82845
	mov	DWORD PTR ?ModelVertFog@@3MA, 0
$L82845:

; 1141 : 		if (ModelVertFog > 255) ModelVertFog = 255;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@437f0000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82846
	mov	DWORD PTR ?ModelVertFog@@3MA, 1132396544 ; 437f0000H
$L82846:

; 1142 : 
; 1143 : 		flag |= MODEL_FOG;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 1
	mov	WORD PTR _flag$[ebp], ax

; 1144 : 		FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L82844
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82844:

; 1145 : 	}
; 1146 : 
; 1147 : // mesh fx?
; 1148 : 
; 1149 : 	CheckModelMeshFx(model, mat, pos, &flag);

	lea	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?CheckModelMeshFx@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@PAF@Z ; CheckModelMeshFx
	add	esp, 16					; 00000010H

; 1150 : 
; 1151 : // draw model
; 1152 : 
; 1153 : 	DrawModel(model, mat, pos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H

; 1154 : 
; 1155 : // fog off?
; 1156 : 
; 1157 : 	if (flag & MODEL_FOG)

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 1
	je	SHORT $L82830

; 1158 : 		FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L82830
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82830:

; 1159 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderPlanet@@YAXPAUobject_def@@@Z ENDP		; RenderPlanet
_TEXT	ENDS
PUBLIC	__real@47c35000
PUBLIC	?RenderSun@@YAXPAUobject_def@@@Z		; RenderSun
EXTRN	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z:NEAR ; DrawFacingPolyRot
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?TimerFreq@@3KA:DWORD				; TimerFreq
EXTRN	?ZedBufferFormat@@3U_DDPIXELFORMAT@@A:BYTE	; ZedBufferFormat
EXTRN	?RotMatrixY@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixY
EXTRN	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixZ
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RenderSun@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv348 = -192						; size = 8
tv341 = -184						; size = 8
tv315 = -184						; size = 8
tv360 = -180						; size = 4
_sun$ = -112						; size = 4
_vec$ = -108						; size = 12
_mat2$ = -96						; size = 36
_mat$ = -60						; size = 36
_zbuf$ = -24						; size = 4
_zres$ = -20						; size = 4
_fog$ = -16						; size = 4
_z$ = -12						; size = 4
_starnum$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?RenderSun@@YAXPAUobject_def@@@Z PROC NEAR		; RenderSun, COMDAT

; 1166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 1167 : 	long i, starnum;
; 1168 : 	REAL z, fog, zres, zbuf;
; 1169 : 	MAT mat, mat2;
; 1170 : 	VEC vec;
; 1171 : 	SUN_OBJ *sun = (SUN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _sun$[ebp], ecx

; 1172 : 
; 1173 : // test against visicubes
; 1174 : 
; 1175 : 	if (sun->VisiMask & CamVisiMask)

	mov	eax, DWORD PTR _sun$[ebp]
	mov	ecx, DWORD PTR [eax+82088]
	and	ecx, DWORD PTR ?CamVisiMask@@3_KA
	mov	edx, DWORD PTR [eax+82092]
	and	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	mov	DWORD PTR tv315[ebp], ecx
	mov	DWORD PTR tv315[ebp+4], edx
	mov	eax, DWORD PTR tv315[ebp]
	or	eax, DWORD PTR tv315[ebp+4]
	je	SHORT $L82864

; 1176 : 		return;

	jmp	$L82852
$L82864:

; 1177 : 
; 1178 : // skip if offscreen
; 1179 : 
; 1180 : 	if (TestSphereToFrustum(&obj->body.Centre.Pos, 6144, &z) == SPHERE_OUT)

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	push	1170210816				; 45c00000H
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L82865

; 1181 : 		return;

	jmp	$L82852
$L82865:

; 1182 : 
; 1183 : // yep, draw
; 1184 : 
; 1185 : 	obj->renderflag.visible = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1186 : 
; 1187 : // draw sun
; 1188 : 
; 1189 : 	for (i = 0 ; i < SUN_OVERLAY_NUM ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82866
$L82867:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82866:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L82868

; 1190 : 	{
; 1191 : 		RotMatrixZ(&mat, sun->Overlay[i].Rot);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	edx, DWORD PTR [ecx+eax+88]
	push	edx
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1192 : 		SunFacingPoly.RGB = sun->Overlay[i].rgb;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	edx, DWORD PTR [ecx+eax+84]
	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+28, edx

; 1193 : 		DrawFacingPolyRot(&obj->body.Centre.Pos, &mat, &SunFacingPoly, 1, 0);

	push	0
	push	1
	push	OFFSET FLAT:?SunFacingPoly@@3UFACING_POLY@@A ; SunFacingPoly
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRot
	add	esp, 20					; 00000014H

; 1194 : 	}

	jmp	SHORT $L82867
$L82868:

; 1195 : 
; 1196 : // draw stars
; 1197 : 
; 1198 : 	RotMatrixY(&mat2, (float)TIME2MS(CurrentTimer()) / 100000.0f);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR tv341[ebp], eax
	mov	DWORD PTR tv341[ebp+4], 0
	fild	QWORD PTR tv341[ebp]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR tv348[ebp], eax
	mov	DWORD PTR tv348[ebp+4], 0
	fild	QWORD PTR tv348[ebp]
	fdivp	ST(1), ST(0)
	fdiv	DWORD PTR __real@47c35000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _mat2$[ebp]
	push	edx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 1199 : 	MulMatrix(&ViewMatrixScaled, &mat2, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 1200 : 	RotTransVector(&ViewMatrixScaled, &ViewTransScaled, &obj->body.Centre.Pos, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1201 : 
; 1202 : 	zres = (float)(1 << ZedBufferFormat.dwZBufferBitDepth);

	mov	eax, 1
	mov	ecx, DWORD PTR ?ZedBufferFormat@@3U_DDPIXELFORMAT@@A+12
	shl	eax, cl
	mov	DWORD PTR tv360[ebp], eax
	fild	DWORD PTR tv360[ebp]
	fstp	DWORD PTR _zres$[ebp]

; 1203 : 	zbuf = (zres - 1.0f) / zres;

	fld	DWORD PTR _zres$[ebp]
	fsub	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _zres$[ebp]
	fstp	DWORD PTR _zbuf$[ebp]

; 1204 : 
; 1205 : 	starnum = 0;

	mov	DWORD PTR _starnum$[ebp], 0

; 1206 : 
; 1207 : 	for (i = 0 ; i < SUN_STAR_NUM ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82871
$L82872:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82871:
	cmp	DWORD PTR _i$[ebp], 2048		; 00000800H
	jge	$L82873

; 1208 : 	{
; 1209 : 		z = sun->Star[i].Pos.v[X] * mat.m[RZ] + sun->Star[i].Pos.v[Y] * mat.m[UZ] + sun->Star[i].Pos.v[Z] * mat.m[LZ] + vec.v[Z];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR [ecx+eax+168]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+20]
	fmul	DWORD PTR [eax+edx+172]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+32]
	fmul	DWORD PTR [edx+ecx+176]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR _vec$[ebp+8]
	fstp	DWORD PTR _z$[ebp]

; 1210 : 		if (z < RenderSettings.NearClip || z >= RenderSettings.FarClip) continue;

	fld	DWORD PTR _z$[ebp]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82875
	fld	DWORD PTR _z$[ebp]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82874
$L82875:
	jmp	SHORT $L82872
$L82874:

; 1211 : 
; 1212 : 		sun->Verts[starnum].sx = (sun->Star[i].Pos.v[X] * mat.m[RX] + sun->Star[i].Pos.v[Y] * mat.m[UX] + sun->Star[i].Pos.v[Z] * mat.m[LX] + vec.v[X]) / z + RenderSettings.GeomCentreX;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR [ecx+eax+168]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+12]
	fmul	DWORD PTR [eax+edx+172]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+24]
	fmul	DWORD PTR [edx+ecx+176]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR _vec$[ebp]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+4
	mov	eax, DWORD PTR _starnum$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	fstp	DWORD PTR [ecx+eax+32936]

; 1213 : 		sun->Verts[starnum].sy = (sun->Star[i].Pos.v[X] * mat.m[RY] + sun->Star[i].Pos.v[Y] * mat.m[UY] + sun->Star[i].Pos.v[Z] * mat.m[LY] + vec.v[Y]) / z + RenderSettings.GeomCentreY;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR [ecx+eax+168]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+16]
	fmul	DWORD PTR [eax+edx+172]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _sun$[ebp]
	fld	DWORD PTR _mat$[ebp+28]
	fmul	DWORD PTR [edx+ecx+176]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR _vec$[ebp+4]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+8
	mov	eax, DWORD PTR _starnum$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	fstp	DWORD PTR [ecx+eax+32940]

; 1214 : 
; 1215 : 		sun->Verts[starnum].rhw = 1.0f;

	mov	eax, DWORD PTR _starnum$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+32948], 1065353216	; 3f800000H

; 1216 : 		sun->Verts[starnum].sz = zbuf;

	mov	eax, DWORD PTR _starnum$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	edx, DWORD PTR _zbuf$[ebp]
	mov	DWORD PTR [ecx+eax+32944], edx

; 1217 : 
; 1218 : 		sun->Verts[starnum].color = sun->Star[i].rgb;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _starnum$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _sun$[ebp]
	mov	esi, DWORD PTR _sun$[ebp]
	mov	eax, DWORD PTR [esi+eax+180]
	mov	DWORD PTR [edx+ecx+32952], eax

; 1219 : 
; 1220 : 		fog = (RenderSettings.FarClip - z) * RenderSettings.FogMul;

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	fsub	DWORD PTR _z$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+56
	fstp	DWORD PTR _fog$[ebp]

; 1221 : 		if (fog > 255) fog = 255;

	fld	DWORD PTR _fog$[ebp]
	fcomp	DWORD PTR __real@437f0000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82876
	mov	DWORD PTR _fog$[ebp], 1132396544	; 437f0000H

; 1222 : 		else if (fog < 0) fog = 0;

	jmp	SHORT $L82877
$L82876:
	fld	DWORD PTR _fog$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82877
	mov	DWORD PTR _fog$[ebp], 0
$L82877:

; 1223 : 		sun->Verts[starnum].specular = FTOL3(fog) << 24;

	fld	DWORD PTR _fog$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR _fog$[ebp]
	mov	eax, DWORD PTR _fog$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _starnum$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [edx+ecx+32956], eax

; 1224 : 
; 1225 : 		starnum++;

	mov	eax, DWORD PTR _starnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _starnum$[ebp], eax

; 1226 : 	}

	jmp	$L82872
$L82873:

; 1227 : 
; 1228 : 	FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L82881
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82881:

; 1229 : 	SET_TPAGE(-1);

	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	je	SHORT $L82882
	mov	WORD PTR ?RenderTP@@3FA, -1		; RenderTP
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	jne	SHORT $L82883
	push	0
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
	jmp	SHORT $L82882
$L82883:
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
$L82882:

; 1230 : 
; 1231 : 	D3Ddevice->DrawPrimitive(D3DPT_POINTLIST, FVF_TEX0, sun->Verts, starnum, D3DDP_DONOTUPDATEEXTENTS);

	push	8
	mov	eax, DWORD PTR _starnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sun$[ebp]
	add	ecx, 32936				; 000080a8H
	push	ecx
	push	196					; 000000c4H
	push	1
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	ecx
	call	DWORD PTR [eax+112]

; 1232 : 
; 1233 : 	FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L82852
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82852:

; 1234 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderSun@@YAXPAUobject_def@@@Z ENDP			; RenderSun
_TEXT	ENDS
PUBLIC	?RenderPlane@@YAXPAUobject_def@@@Z		; RenderPlane
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderPlane@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv133 = -76						; size = 4
_plane$ = -8						; size = 4
_vis2$ = -2						; size = 1
_vis1$ = -1						; size = 1
_obj$ = 8						; size = 4
?RenderPlane@@YAXPAUobject_def@@@Z PROC NEAR		; RenderPlane, COMDAT

; 1241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1242 : 	bool vis1, vis2;
; 1243 : 	PLANE_OBJ *plane = (PLANE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _plane$[ebp], ecx

; 1244 : 
; 1245 : // render plane
; 1246 : 
; 1247 : 	if (obj->DefaultModel != -1)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	je	SHORT $L82893

; 1248 : 		vis1 = RenderObjectModel(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &LevelModel[obj->DefaultModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR _vis1$[ebp], al

; 1249 : 	else

	jmp	SHORT $L82894
$L82893:

; 1250 : 		vis1 = FALSE;

	mov	BYTE PTR _vis1$[ebp], 0
$L82894:

; 1251 : 
; 1252 : // render propellor
; 1253 : 
; 1254 : 	if (plane->PropModel != -1)

	mov	eax, DWORD PTR _plane$[ebp]
	cmp	DWORD PTR [eax], -1
	je	SHORT $L82895

; 1255 : 		vis2 = RenderObjectModel(&plane->PropMatrix, &plane->PropPos, &LevelModel[plane->PropModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _plane$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _plane$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR _vis2$[ebp], al

; 1256 : 	else

	jmp	SHORT $L82896
$L82895:

; 1257 : 		vis2 = FALSE;

	mov	BYTE PTR _vis2$[ebp], 0
$L82896:

; 1258 : 
; 1259 : // set visible flag
; 1260 : 
; 1261 : 	obj->renderflag.visible |= (vis1 || vis2);

	movzx	eax, BYTE PTR _vis1$[ebp]
	test	eax, eax
	jne	SHORT $L83322
	movzx	ecx, BYTE PTR _vis2$[ebp]
	test	ecx, ecx
	jne	SHORT $L83322
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $L83323
$L83322:
	mov	DWORD PTR tv133[ebp], 1
$L83323:
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+584]
	shr	eax, 6
	and	eax, 1
	or	eax, DWORD PTR tv133[ebp]
	and	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+584]
	and	edx, -65				; ffffffbfH
	or	edx, eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+584], edx

; 1262 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderPlane@@YAXPAUobject_def@@@Z ENDP			; RenderPlane
_TEXT	ENDS
PUBLIC	?RenderCopter@@YAXPAUobject_def@@@Z		; RenderCopter
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderCopter@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv151 = -76						; size = 4
_copter$ = -8						; size = 4
_vis3$ = -3						; size = 1
_vis2$ = -2						; size = 1
_vis1$ = -1						; size = 1
_obj$ = 8						; size = 4
?RenderCopter@@YAXPAUobject_def@@@Z PROC NEAR		; RenderCopter, COMDAT

; 1269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1270 : 	bool vis1, vis2, vis3;
; 1271 : 	COPTER_OBJ *copter = (COPTER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _copter$[ebp], ecx

; 1272 : 
; 1273 : // render copter
; 1274 : 
; 1275 : 	if (obj->DefaultModel != -1)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	je	SHORT $L82905

; 1276 : 		vis1 = RenderObjectModel(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &LevelModel[obj->DefaultModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR _vis1$[ebp], al

; 1277 : 	else

	jmp	SHORT $L82906
$L82905:

; 1278 : 		vis1 = FALSE;

	mov	BYTE PTR _vis1$[ebp], 0
$L82906:

; 1279 : 
; 1280 : // render blade1
; 1281 : 
; 1282 : 	if (copter->BladeModel1 != -1)

	mov	eax, DWORD PTR _copter$[ebp]
	cmp	DWORD PTR [eax], -1
	je	SHORT $L82907

; 1283 : 		vis2 = RenderObjectModel(&copter->BladeMatrix1, &copter->BladePos1, &LevelModel[copter->BladeModel1].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _copter$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR _vis2$[ebp], al

; 1284 : 	else

	jmp	SHORT $L82908
$L82907:

; 1285 : 		vis2 = FALSE;

	mov	BYTE PTR _vis2$[ebp], 0
$L82908:

; 1286 : 
; 1287 : // render blade2
; 1288 : 
; 1289 : 	if (copter->BladeModel2 != -1)

	mov	eax, DWORD PTR _copter$[ebp]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $L82909

; 1290 : 		vis3 = RenderObjectModel(&copter->BladeMatrix2, &copter->BladePos2, &LevelModel[copter->BladeModel2].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _copter$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR _vis3$[ebp], al

; 1291 : 	else

	jmp	SHORT $L82910
$L82909:

; 1292 : 		vis3 = FALSE;

	mov	BYTE PTR _vis3$[ebp], 0
$L82910:

; 1293 : 
; 1294 : // set visible flag
; 1295 : 
; 1296 : 	obj->renderflag.visible |= (vis1 || vis2 || vis3);

	movzx	eax, BYTE PTR _vis1$[ebp]
	test	eax, eax
	jne	SHORT $L83326
	movzx	ecx, BYTE PTR _vis2$[ebp]
	test	ecx, ecx
	jne	SHORT $L83326
	movzx	edx, BYTE PTR _vis3$[ebp]
	test	edx, edx
	jne	SHORT $L83326
	mov	DWORD PTR tv151[ebp], 0
	jmp	SHORT $L83327
$L83326:
	mov	DWORD PTR tv151[ebp], 1
$L83327:
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	or	ecx, DWORD PTR tv151[ebp]
	and	ecx, 1
	shl	ecx, 6
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+584]
	and	eax, -65				; ffffffbfH
	or	eax, ecx
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+584], eax

; 1297 : 
; 1298 : // draw bounding box
; 1299 : 
; 1300 : 	//DrawBoundingBox(copter->FlyBox.XMin, copter->FlyBox.XMax, copter->FlyBox.YMin, copter->FlyBox.YMax, copter->FlyBox.ZMin, copter->FlyBox.ZMax, 0xff0000, 0x00ff00, 0x0000ff, 0x00ffff, 0xff00ff, 0xffff00);
; 1301 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderCopter@@YAXPAUobject_def@@@Z ENDP		; RenderCopter
_TEXT	ENDS
PUBLIC	?RenderDragon@@YAXPAUobject_def@@@Z		; RenderDragon
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderDragon@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv133 = -80						; size = 4
_dragon$ = -12						; size = 4
_i$ = -8						; size = 4
_vis2$ = -2						; size = 1
_vis1$ = -1						; size = 1
_obj$ = 8						; size = 4
?RenderDragon@@YAXPAUobject_def@@@Z PROC NEAR		; RenderDragon, COMDAT

; 1308 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1309 : 	bool vis1, vis2;
; 1310 : 	long i;
; 1311 : 	DRAGON_OBJ *dragon = (DRAGON_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _dragon$[ebp], ecx

; 1312 : 
; 1313 : // render body
; 1314 : 
; 1315 : 	if (dragon->BodyModel != -1)

	mov	eax, DWORD PTR _dragon$[ebp]
	cmp	DWORD PTR [eax], -1
	je	SHORT $L82919

; 1316 : 		vis1 = RenderObjectModel(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &LevelModel[dragon->BodyModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR _vis1$[ebp], al

; 1317 : 	else

	jmp	SHORT $L82920
$L82919:

; 1318 : 		vis1 = FALSE;

	mov	BYTE PTR _vis1$[ebp], 0
$L82920:

; 1319 : 
; 1320 : // render head
; 1321 : 
; 1322 : 	if (dragon->HeadModel != -1)

	mov	eax, DWORD PTR _dragon$[ebp]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $L82921

; 1323 : 		vis2 = RenderObjectModel(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &LevelModel[dragon->HeadModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR _vis2$[ebp], al

; 1324 : 	else

	jmp	SHORT $L82922
$L82921:

; 1325 : 		vis2 = FALSE;

	mov	BYTE PTR _vis2$[ebp], 0
$L82922:

; 1326 : 
; 1327 : // set visible flag
; 1328 : 
; 1329 : 	obj->renderflag.visible |= (vis1 || vis2);

	movzx	eax, BYTE PTR _vis1$[ebp]
	test	eax, eax
	jne	SHORT $L83330
	movzx	ecx, BYTE PTR _vis2$[ebp]
	test	ecx, ecx
	jne	SHORT $L83330
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $L83331
$L83330:
	mov	DWORD PTR tv133[ebp], 1
$L83331:
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+584]
	shr	eax, 6
	and	eax, 1
	or	eax, DWORD PTR tv133[ebp]
	and	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+584]
	and	edx, -65				; ffffffbfH
	or	edx, eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+584], edx

; 1330 : 
; 1331 : // draw fire
; 1332 : 
; 1333 : 	for (i = 0 ; i < DRAGON_FIRE_NUM ; i++) if (dragon->Fire[i].Time)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82923
$L82924:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82923:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	$L82913
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [ecx+eax+44]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L82926

; 1334 : 	{
; 1335 : 		DragonFireFacingPoly.Xsize = dragon->Fire[i].Size;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	edx, DWORD PTR [ecx+eax+52]
	mov	DWORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A, edx

; 1336 : 		DragonFireFacingPoly.Ysize = dragon->Fire[i].Size;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	edx, DWORD PTR [ecx+eax+52]
	mov	DWORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A+4, edx

; 1337 : 		DragonFireFacingPoly.RGB = dragon->Fire[i].rgb;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A+28, edx

; 1338 : 		DrawFacingPolyRot(&dragon->Fire[i].Pos, &dragon->Fire[i].Matrix, &DragonFireFacingPoly, 1, 0);

	push	0
	push	1
	push	OFFSET FLAT:?DragonFireFacingPoly@@3UFACING_POLY@@A ; DragonFireFacingPoly
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	lea	edx, DWORD PTR [ecx+eax+76]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	lea	edx, DWORD PTR [ecx+eax+64]
	push	edx
	call	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRot
	add	esp, 20					; 00000014H
$L82926:

; 1339 : 	}
; 1340 : }

	jmp	$L82924
$L82913:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderDragon@@YAXPAUobject_def@@@Z ENDP		; RenderDragon
_TEXT	ENDS
PUBLIC	?DrawGridCollPolys@@YAXPAUCOLLGRID@@@Z		; DrawGridCollPolys
EXTRN	?DrawCollPoly@@YAXPAUCollPolyStruct@@@Z:NEAR	; DrawCollPoly
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawGridCollPolys@@YAXPAUCOLLGRID@@@Z
_TEXT	SEGMENT
_iPoly$ = -4						; size = 4
_grid$ = 8						; size = 4
?DrawGridCollPolys@@YAXPAUCOLLGRID@@@Z PROC NEAR	; DrawGridCollPolys, COMDAT

; 1350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1351 : 	int iPoly;
; 1352 : 
; 1353 : 	SET_TPAGE(-1);

	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	je	SHORT $L82931
	mov	WORD PTR ?RenderTP@@3FA, -1		; RenderTP
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	jne	SHORT $L82932
	push	0
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
	jmp	SHORT $L82931
$L82932:
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
$L82931:

; 1354 : 
; 1355 : 	for (iPoly = 0; iPoly < grid->NCollPolys; iPoly++)

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82934
$L82935:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82934:
	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR _iPoly$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $L82929

; 1356 : 	{
; 1357 : 		DrawCollPoly(grid->CollPolyPtr[iPoly]);

	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iPoly$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	?DrawCollPoly@@YAXPAUCollPolyStruct@@@Z	; DrawCollPoly
	add	esp, 4

; 1358 : 	}

	jmp	SHORT $L82935
$L82929:

; 1359 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawGridCollPolys@@YAXPAUCOLLGRID@@@Z ENDP		; DrawGridCollPolys
_TEXT	ENDS
PUBLIC	?RenderTrolley@@YAXPAUobject_def@@@Z		; RenderTrolley
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderTrolley@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?RenderTrolley@@YAXPAUobject_def@@@Z PROC NEAR		; RenderTrolley, COMDAT

; 1369 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1370 : 	BuildCarMatricesNew(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?BuildCarMatricesNew@@YAXPAUCarStruct@@@Z ; BuildCarMatricesNew
	add	esp, 4

; 1371 : 	DrawCar(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?DrawCar@@YAXPAUCarStruct@@@Z		; DrawCar
	add	esp, 4

; 1372 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderTrolley@@YAXPAUobject_def@@@Z ENDP		; RenderTrolley
_TEXT	ENDS
PUBLIC	?RenderTrain@@YAXPAUobject_def@@@Z		; RenderTrain
EXTRN	?RotMatrixX@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixX
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderTrain@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv88 = -141						; size = 1
_mat2$ = -76						; size = 36
_mat1$ = -40						; size = 36
_train$ = -4						; size = 4
_obj$ = 8						; size = 4
?RenderTrain@@YAXPAUobject_def@@@Z PROC NEAR		; RenderTrain, COMDAT

; 1379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 1380 : 	TRAIN_OBJ *train = (TRAIN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _train$[ebp], ecx

; 1381 : 	MAT mat1, mat2;
; 1382 : 	
; 1383 : // render train
; 1384 : 
; 1385 : 	if (obj->DefaultModel != -1)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	je	SHORT $L82947

; 1386 : 		obj->renderflag.visible |= RenderObjectModel(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &LevelModel[obj->DefaultModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR tv88[ebp], al
	movzx	edx, BYTE PTR tv88[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	or	ecx, edx
	and	ecx, 1
	shl	ecx, 6
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+584]
	and	eax, -65				; ffffffbfH
	or	eax, ecx
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+584], eax
$L82947:

; 1387 : 
; 1388 : // render wheels
; 1389 : 
; 1390 : 	obj->renderflag.envmap = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1391 : 
; 1392 : 	if (train->FrontWheel)

	mov	eax, DWORD PTR _train$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$L82948

; 1393 : 	{
; 1394 : 		RotMatrixX(&mat1, train->TimeFront);

	mov	eax, DWORD PTR _train$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	lea	edx, DWORD PTR _mat1$[ebp]
	push	edx
	call	?RotMatrixX@@YAXPATMatrixUnion@@M@Z	; RotMatrixX
	add	esp, 8

; 1395 : 		MulMatrix(&obj->body.Centre.WMatrix, &mat1, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 1396 : 
; 1397 : 		RenderObjectModel(&mat2, &train->WheelPos[2], &LevelModel[train->FrontWheel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _train$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _train$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H

; 1398 : 		RenderObjectModel(&mat2, &train->WheelPos[3], &LevelModel[train->FrontWheel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _train$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _train$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
$L82948:

; 1399 : 	}
; 1400 : 
; 1401 : 	if (train->BackWheel)

	mov	eax, DWORD PTR _train$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$L82949

; 1402 : 	{
; 1403 : 		RotMatrixX(&mat1, train->TimeBack);

	mov	eax, DWORD PTR _train$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	lea	edx, DWORD PTR _mat1$[ebp]
	push	edx
	call	?RotMatrixX@@YAXPATMatrixUnion@@M@Z	; RotMatrixX
	add	esp, 8

; 1404 : 		MulMatrix(&obj->body.Centre.WMatrix, &mat1, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 1405 : 
; 1406 : 		RenderObjectModel(&mat2, &train->WheelPos[0], &LevelModel[train->BackWheel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _train$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _train$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H

; 1407 : 		RenderObjectModel(&mat2, &train->WheelPos[1], &LevelModel[train->BackWheel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _train$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _train$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
$L82949:

; 1408 : 	}
; 1409 : 
; 1410 : 	obj->renderflag.envmap = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 1
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1411 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderTrain@@YAXPAUobject_def@@@Z ENDP			; RenderTrain
_TEXT	ENDS
PUBLIC	__real@41800000
PUBLIC	__real@459c4000
PUBLIC	?RenderStrobe@@YAXPAUobject_def@@@Z		; RenderStrobe
EXTRN	?DrawFacingPoly@@YAXPAUVectorStruct@@PAUFACING_POLY@@JM@Z:NEAR ; DrawFacingPoly
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@459c4000
CONST	SEGMENT
__real@459c4000 DD 0459c4000r			; 5000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RenderStrobe@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv205 = -148						; size = 8
_ang$ = -76						; size = 4
_mat$ = -72						; size = 36
_strobe$ = -36						; size = 4
_poly$ = -32						; size = 32
_obj$ = 8						; size = 4
?RenderStrobe@@YAXPAUobject_def@@@Z PROC NEAR		; RenderStrobe, COMDAT

; 1418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 1419 : 	FACING_POLY poly;
; 1420 : 	STROBE_OBJ *strobe = (STROBE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _strobe$[ebp], ecx

; 1421 : 	MAT mat;
; 1422 : 	REAL ang;
; 1423 : 
; 1424 : // render model
; 1425 : 
; 1426 : 	RenderObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?RenderObject@@YAXPAUobject_def@@@Z	; RenderObject
	add	esp, 4

; 1427 : 
; 1428 : // draw glow?
; 1429 : 
; 1430 : 	if (strobe->Glow && obj->Light && obj->renderflag.visible)

	mov	eax, DWORD PTR _strobe$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [eax+32]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$L82952
	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	$L82952
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	je	$L82952

; 1431 : 	{
; 1432 : 		FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L82959
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82959:

; 1433 : 
; 1434 : 		poly.Xsize = poly.Ysize = strobe->Glow * 64.0f + 16.0f;

	mov	eax, DWORD PTR _strobe$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR __real@42800000
	fadd	DWORD PTR __real@41800000
	fstp	DWORD PTR _poly$[ebp+4]
	mov	ecx, DWORD PTR _poly$[ebp+4]
	mov	DWORD PTR _poly$[ebp], ecx

; 1435 : 		poly.U = 128.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+8], 1056964608	; 3f000000H

; 1436 : 		poly.V = 0.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+12], 0

; 1437 : 		poly.Usize = poly.Vsize = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+20], 1048576000	; 3e800000H
	mov	eax, DWORD PTR _poly$[ebp+20]
	mov	DWORD PTR _poly$[ebp+16], eax

; 1438 : 		poly.Tpage = TPAGE_FX1;

	mov	WORD PTR _poly$[ebp+24], 27		; 0000001bH

; 1439 : 		poly.RGB = obj->Light->r << 16 | obj->Light->g << 8 | obj->Light->b;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR [ecx+88]
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	eax, DWORD PTR [ecx+92]
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [ecx+672]
	or	edx, DWORD PTR [eax+96]
	mov	DWORD PTR _poly$[ebp+28], edx

; 1440 : 
; 1441 : 		DrawFacingPoly(&strobe->LightPos, &poly, 1, -256);

	push	-1015021568				; c3800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strobe$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	call	?DrawFacingPoly@@YAXPAUVectorStruct@@PAUFACING_POLY@@JM@Z ; DrawFacingPoly
	add	esp, 16					; 00000010H

; 1442 : 
; 1443 : 		poly.U = 192.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+8], 1061158912	; 3f400000H

; 1444 : 		poly.V = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+12], 1048576000	; 3e800000H

; 1445 : 
; 1446 : //		ang = -(float)atan(ViewMatrix.m[LZ] / ViewMatrix.m[LX]) / PI;
; 1447 : 		ang = TIME2MS(CurrentTimer()) / 5000.0f;

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	DWORD PTR tv205[ebp], eax
	mov	DWORD PTR tv205[ebp+4], 0
	fild	QWORD PTR tv205[ebp]
	fdiv	DWORD PTR __real@459c4000
	fstp	DWORD PTR _ang$[ebp]

; 1448 : 
; 1449 : 		RotMatrixZ(&mat, ang);

	mov	eax, DWORD PTR _ang$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1450 : 		DrawFacingPolyRot(&strobe->LightPos, &mat, &poly, 1, -256);

	push	-1015021568				; c3800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _strobe$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	call	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRot
	add	esp, 20					; 00000014H

; 1451 : 
; 1452 : 		RotMatrixZ(&mat, ang * 2.0f);

	fld	DWORD PTR _ang$[ebp]
	fadd	ST(0), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1453 : 		DrawFacingPolyRot(&strobe->LightPos, &mat, &poly, 1, -256);

	push	-1015021568				; c3800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _strobe$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	call	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRot
	add	esp, 20					; 00000014H

; 1454 : 
; 1455 : 		FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L82952
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82952:

; 1456 : 	}
; 1457 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderStrobe@@YAXPAUobject_def@@@Z ENDP		; RenderStrobe
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	__real@3f400000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@42000000
PUBLIC	?RenderPickup@@YAXPAUobject_def@@@Z		; RenderPickup
EXTRN	?DrawFacingPolyRotMirror@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z:NEAR ; DrawFacingPolyRotMirror
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RenderPickup@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv69 = -168						; size = 4
__temp$82991 = -100					; size = 4
__temp$82985 = -96					; size = 4
_size$ = -92						; size = 4
_mat$ = -88						; size = 36
_poly$ = -52						; size = 32
_pickup$ = -20						; size = 4
_model$ = -16						; size = 4
_alpha$ = -12						; size = 4
_i$ = -8						; size = 4
_col$ = -4						; size = 4
_obj$ = 8						; size = 4
?RenderPickup@@YAXPAUobject_def@@@Z PROC NEAR		; RenderPickup, COMDAT

; 1464 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi

; 1465 : 	long col, i, alpha;
; 1466 : 	MODEL *model = &LevelModel[obj->DefaultModel].Model;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	add	ecx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	mov	DWORD PTR _model$[ebp], ecx

; 1467 : 	PICKUP_OBJ *pickup = (PICKUP_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _pickup$[ebp], ecx

; 1468 : 	FACING_POLY poly;
; 1469 : 	MAT mat;
; 1470 : 	REAL size;
; 1471 : 
; 1472 : // act on mode
; 1473 : 
; 1474 : 	switch (pickup->Mode)

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $L82977
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $L82978
	cmp	DWORD PTR tv69[ebp], 2
	je	$L82990
	jmp	$L82963
$L82977:

; 1475 : 	{
; 1476 : 
; 1477 : // waiting to gen
; 1478 : 
; 1479 : 		case 0:
; 1480 : 			return;

	jmp	$L82963
$L82978:

; 1481 : 
; 1482 : // waiting to be picked up
; 1483 : 
; 1484 : 		case 1:
; 1485 : 
; 1486 : // draw model?
; 1487 : 
; 1488 : 			if (pickup->Timer > 0.5f)

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3f000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82979

; 1489 : 			{
; 1490 : 				if (model->PolyPtr->Type & POLY_SEMITRANS)

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	movsx	edx, WORD PTR [ecx]
	and	edx, 4
	je	SHORT $L82980

; 1491 : 				{
; 1492 : 					for (i = 0 ; i < model->PolyNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82981
$L82982:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82981:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+32]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $L82980

; 1493 : 					{
; 1494 : 						model->PolyPtr[i].Type &= ~POLY_SEMITRANS;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	movsx	eax, WORD PTR [edx+eax]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [edx+48]
	mov	WORD PTR [ecx+edx], ax

; 1495 : 					}

	jmp	SHORT $L82982
$L82980:

; 1496 : 				}
; 1497 : 
; 1498 : 				RenderObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?RenderObject@@YAXPAUobject_def@@@Z	; RenderObject
	add	esp, 4
$L82979:

; 1499 : 			}
; 1500 : 
; 1501 : // draw 'generation'
; 1502 : 
; 1503 : 			if (pickup->Timer < 0.75f)

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3f400000
	fnstsw	ax
	test	ah, 5
	jp	$L82984

; 1504 : 			{
; 1505 : 				FTOL((float)sin(pickup->Timer * 4.0f / 3.0f * PI) * 255.0f, col);

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR __real@40800000
	fdiv	DWORD PTR __real@40400000
	fmul	DWORD PTR __real@40490fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fmul	DWORD PTR __real@437f0000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82985[ebp]
	mov	eax, DWORD PTR __temp$82985[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _col$[ebp], eax

; 1506 : 
; 1507 : 				size = (float)sin(pickup->Timer * 4.0f / 3.0f * PI) * 64.0f + 32;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR __real@40800000
	fdiv	DWORD PTR __real@40400000
	fmul	DWORD PTR __real@40490fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fmul	DWORD PTR __real@42800000
	fadd	DWORD PTR __real@42000000
	fstp	DWORD PTR _size$[ebp]

; 1508 : 
; 1509 : 				poly.Xsize = poly.Ysize = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _poly$[ebp+4], eax
	mov	ecx, DWORD PTR _poly$[ebp+4]
	mov	DWORD PTR _poly$[ebp], ecx

; 1510 : 
; 1511 : 				poly.Usize = poly.Vsize = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+20], 1048576000	; 3e800000H
	mov	eax, DWORD PTR _poly$[ebp+20]
	mov	DWORD PTR _poly$[ebp+16], eax

; 1512 : 				poly.Tpage = TPAGE_FX1;

	mov	WORD PTR _poly$[ebp+24], 27		; 0000001bH

; 1513 : 
; 1514 : 				poly.U = 193.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+8], 1061224448	; 3f410000H

; 1515 : 				poly.V = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+12], 1048576000	; 3e800000H

; 1516 : 				poly.RGB = (col >> 1) | (col << 8) | (col << 16);

	mov	eax, DWORD PTR _col$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _col$[ebp]
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _col$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	DWORD PTR _poly$[ebp+28], eax

; 1517 : 
; 1518 : 				RotMatrixZ(&mat, pickup->Timer / 4.0f);

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fdiv	DWORD PTR __real@40800000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1519 : 				DrawFacingPolyRotMirror(&obj->body.Centre.Pos, &mat, &poly, 1, -256);

	push	-1015021568				; c3800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?DrawFacingPolyRotMirror@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRotMirror
	add	esp, 20					; 00000014H

; 1520 : 
; 1521 : 				RotMatrixZ(&mat, pickup->Timer / 2.0f + 0.5f);

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fdiv	DWORD PTR __real@40000000
	fadd	DWORD PTR __real@3f000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1522 : 				DrawFacingPolyRotMirror(&obj->body.Centre.Pos, &mat, &poly, 1, -256);

	push	-1015021568				; c3800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?DrawFacingPolyRotMirror@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRotMirror
	add	esp, 20					; 00000014H

; 1523 : 
; 1524 : 				poly.U = 128.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+8], 1056964608	; 3f000000H

; 1525 : 				poly.V = 0.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+12], 0

; 1526 : 				poly.RGB = (col) | (col << 8) | (col << 16);

	mov	eax, DWORD PTR _col$[ebp]
	shl	eax, 8
	or	eax, DWORD PTR _col$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	mov	DWORD PTR _poly$[ebp+28], eax

; 1527 : 
; 1528 : 				RotMatrixZ(&mat, 0.0f);

	push	0
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1529 : 				DrawFacingPolyRotMirror(&obj->body.Centre.Pos, &mat, &poly, 1, -256);

	push	-1015021568				; c3800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?DrawFacingPolyRotMirror@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRotMirror
	add	esp, 20					; 00000014H
$L82984:

; 1530 : 			}
; 1531 : 
; 1532 : 		break;

	jmp	$L82963
$L82990:

; 1533 : 
; 1534 : // disappearing
; 1535 : 
; 1536 : 		case 2:
; 1537 : 
; 1538 : // set alpha
; 1539 : 
; 1540 : 			FTOL(-pickup->Timer * 255.0f + 255.0f, alpha);

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	fmul	DWORD PTR __real@437f0000
	fadd	DWORD PTR __real@437f0000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82991[ebp]
	mov	eax, DWORD PTR __temp$82991[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _alpha$[ebp], eax

; 1541 : 
; 1542 : 			for (i = 0 ; i < model->PolyNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82994
$L82995:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82994:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+32]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $L82996

; 1543 : 			{
; 1544 : 				model->PolyPtr[i].Type |= POLY_SEMITRANS;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	movsx	eax, WORD PTR [edx+eax]
	or	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [edx+48]
	mov	WORD PTR [ecx+edx], ax

; 1545 : 				model->PolyRGB[i].rgb[0].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [edx+eax+3], cl

; 1546 : 				model->PolyRGB[i].rgb[1].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [edx+eax+7], cl

; 1547 : 				model->PolyRGB[i].rgb[2].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [edx+eax+11], cl

; 1548 : 				model->PolyRGB[i].rgb[3].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [edx+eax+15], cl

; 1549 : 			}

	jmp	$L82995
$L82996:

; 1550 : 
; 1551 : // draw model
; 1552 : 
; 1553 : 			RenderObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?RenderObject@@YAXPAUobject_def@@@Z	; RenderObject
	add	esp, 4
$L82963:

; 1554 : 
; 1555 : 		break;
; 1556 : 	}
; 1557 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderPickup@@YAXPAUobject_def@@@Z ENDP		; RenderPickup
_TEXT	ENDS
PUBLIC	?RenderDissolveModel@@YAXPAUobject_def@@@Z	; RenderDissolveModel
; Function compile flags: /Odt /ZI
;	COMDAT ?RenderDissolveModel@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv83 = -69						; size = 1
_dissolve$ = -4						; size = 4
_obj$ = 8						; size = 4
?RenderDissolveModel@@YAXPAUobject_def@@@Z PROC NEAR	; RenderDissolveModel, COMDAT

; 1564 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1565 : 	DISSOLVE_OBJ *dissolve = (DISSOLVE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _dissolve$[ebp], ecx

; 1566 : 
; 1567 : // render model
; 1568 : 
; 1569 : 	obj->renderflag.visible |= RenderObjectModel(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &dissolve->Model, dissolve->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _dissolve$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _dissolve$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H
	mov	BYTE PTR tv83[ebp], al
	movzx	ecx, BYTE PTR tv83[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+584]
	shr	eax, 6
	and	eax, 1
	or	eax, ecx
	and	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+584]
	and	edx, -65				; ffffffbfH
	or	edx, eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+584], edx

; 1570 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderDissolveModel@@YAXPAUobject_def@@@Z ENDP		; RenderDissolveModel
_TEXT	ENDS
PUBLIC	__real@3727c5ac
PUBLIC	__real@42c80000
PUBLIC	__real@461c4000
PUBLIC	?RenderLaser@@YAXPAUobject_def@@@Z		; RenderLaser
EXTRN	__ftol2:NEAR
EXTRN	?TimerCurrent@@3KA:DWORD			; TimerCurrent
EXTRN	?SemiPoly@@3PAUDRAW_SEMI_POLY@@A:BYTE		; SemiPoly
EXTRN	?SemiCount@@3JA:DWORD				; SemiCount
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RenderLaser@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv685 = -244						; size = 8
tv648 = -244						; size = 8
tv485 = -244						; size = 8
tv706 = -240						; size = 4
tv669 = -240						; size = 4
_laser$ = -172						; size = 4
_vert$ = -168						; size = 4
_poly$ = -164						; size = 32
_mat$ = -132						; size = 36
_dR$ = -96						; size = 12
_ePos$ = -84						; size = 12
_sPos$ = -72						; size = 12
_z$ = -60						; size = 4
_widMod$ = -56						; size = 4
_dLen$ = -52						; size = 4
_dt$ = -48						; size = 4
_dy$ = -44						; size = 4
_dx$ = -40						; size = 4
_ang$ = -36						; size = 4
_dRLen$ = -32						; size = 4
_bitLen$ = -28						; size = 4
_delta$ = -24						; size = 4
_visflag$ = -20						; size = 4
_size$ = -16						; size = 4
_col$ = -12						; size = 4
_nBits$ = -8						; size = 4
_ii$ = -4						; size = 4
_obj$ = 8						; size = 4
?RenderLaser@@YAXPAUobject_def@@@Z PROC NEAR		; RenderLaser, COMDAT

; 1577 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi

; 1578 : 	int ii, nBits;
; 1579 : 	long col, size, visflag;
; 1580 : 	REAL delta, bitLen, dRLen, ang, dx, dy, dt, dLen, widMod, z;
; 1581 : 	VEC sPos, ePos, dR;
; 1582 : 	MAT mat;
; 1583 : 	FACING_POLY poly;
; 1584 : 	VERTEX_TEX1 *vert;
; 1585 : 	LASER_OBJ *laser = (LASER_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _laser$[ebp], ecx

; 1586 : 
; 1587 : 	// Check against visi-boxes
; 1588 : 	if (CamVisiMask & laser->VisiMask) {

	mov	eax, DWORD PTR _laser$[ebp]
	mov	ecx, DWORD PTR ?CamVisiMask@@3_KA
	and	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	and	edx, DWORD PTR [eax+52]
	mov	DWORD PTR tv485[ebp], ecx
	mov	DWORD PTR tv485[ebp+4], edx
	mov	eax, DWORD PTR tv485[ebp]
	or	eax, DWORD PTR tv485[ebp+4]
	je	SHORT $L83032

; 1589 : 		return;

	jmp	$L83008
$L83032:

; 1590 : 	}
; 1591 : 
; 1592 : 	// Check against view frustum
; 1593 : 	visflag = TestSphereToFrustum(&obj->body.Centre.Pos, obj->body.CollSkin.Radius, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _visflag$[ebp], eax

; 1594 : 	if (visflag == SPHERE_OUT) {

	cmp	DWORD PTR _visflag$[ebp], 0
	jne	SHORT $L83033

; 1595 : 		return;

	jmp	$L83008
$L83033:

; 1596 : 	}
; 1597 : 
; 1598 : 	// Laser is visible
; 1599 : 	obj->renderflag.visible = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1600 : 
; 1601 : 	// Calculate the number of sections to split the laser into
; 1602 : 	VecEqScalarVec(&dR, laser->Dist, &laser->Delta);

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _laser$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _laser$[ebp]
	fmul	DWORD PTR [ecx+16]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _laser$[ebp]
	fmul	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR$[ebp+8]

; 1603 : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 1604 : 	if (dRLen > SMALL_REAL) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83035

; 1605 : 		VecDivScalar(&dR, dRLen);

	fld	DWORD PTR _dR$[ebp]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp+4]
	fld	DWORD PTR _dR$[ebp+8]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp+8]

; 1606 : 		nBits = 1 + (int)(dRLen / 100.0f);

	fld	DWORD PTR _dRLen$[ebp]
	fdiv	DWORD PTR __real@42c80000
	call	__ftol2
	add	eax, 1
	mov	DWORD PTR _nBits$[ebp], eax

; 1607 : 		bitLen = dRLen / (REAL)nBits;

	fild	DWORD PTR _nBits$[ebp]
	fdivr	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _bitLen$[ebp]

; 1608 : 	} else {

	jmp	SHORT $L83038
$L83035:

; 1609 : 		return;

	jmp	$L83008
$L83038:

; 1610 : 	}
; 1611 : 	
; 1612 : 	// Calculate the end shifts
; 1613 : 	RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &obj->body.Centre.Pos, (REAL*)&DrawVertsTEX1[0]);

	push	OFFSET FLAT:?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A ; DrawVertsTEX1
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1614 : 	RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &laser->Dest, (REAL*)&DrawVertsTEX1[1]);

	push	OFFSET FLAT:?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+32
	mov	eax, DWORD PTR _laser$[ebp]
	push	eax
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1615 : 	dx = DrawVertsTEX1[1].sx - DrawVertsTEX1[0].sx;

	fld	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+32
	fsub	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A
	fstp	DWORD PTR _dx$[ebp]

; 1616 : 	dy = DrawVertsTEX1[1].sy - DrawVertsTEX1[0].sy;

	fld	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+36
	fsub	DWORD PTR ?DrawVertsTEX1@@3PAUVERTEX_TEX1@@A+4
	fstp	DWORD PTR _dy$[ebp]

; 1617 : 	dLen = (REAL)sqrt(dx * dx + dy * dy);

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _dx$[ebp]
	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _dy$[ebp]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dLen$[ebp]

; 1618 : 	dt = dx;

	mov	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _dt$[ebp], eax

; 1619 : 	dx = dy / dLen;

	fld	DWORD PTR _dy$[ebp]
	fdiv	DWORD PTR _dLen$[ebp]
	fstp	DWORD PTR _dx$[ebp]

; 1620 : 	dy = -dt / dLen;

	fld	DWORD PTR _dt$[ebp]
	fchs
	fdiv	DWORD PTR _dLen$[ebp]
	fstp	DWORD PTR _dy$[ebp]

; 1621 : 
; 1622 : 
; 1623 : 	// Draw each bit
; 1624 : 	CopyVec(&obj->body.Centre.Pos, &sPos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _sPos$[ebp], ecx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _sPos$[ebp+4], ecx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _sPos$[ebp+8], ecx

; 1625 : 	size = ((TIME2MS(TimerCurrent) + laser->Phase) % 100l);

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	xor	edx, edx
	div	ecx
	mov	edx, DWORD PTR _laser$[ebp]
	add	eax, DWORD PTR [edx+40]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	DWORD PTR _size$[ebp], edx

; 1626 : 	widMod = (REAL)size * laser->RandWidth / 100.0f;

	fild	DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _laser$[ebp]
	fmul	DWORD PTR [eax+32]
	fdiv	DWORD PTR __real@42c80000
	fstp	DWORD PTR _widMod$[ebp]

; 1627 : 	for (ii = 0; ii < nBits; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L83043
$L83044:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L83043:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _nBits$[ebp]
	jge	$L83045

; 1628 : 
; 1629 : 		VecPlusScalarVec(&sPos, bitLen, &dR, &ePos);

	fld	DWORD PTR _bitLen$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fadd	DWORD PTR _sPos$[ebp]
	fstp	DWORD PTR _ePos$[ebp]
	fld	DWORD PTR _bitLen$[ebp]
	fmul	DWORD PTR _dR$[ebp+4]
	fadd	DWORD PTR _sPos$[ebp+4]
	fstp	DWORD PTR _ePos$[ebp+4]
	fld	DWORD PTR _bitLen$[ebp]
	fmul	DWORD PTR _dR$[ebp+8]
	fadd	DWORD PTR _sPos$[ebp+8]
	fstp	DWORD PTR _ePos$[ebp+8]

; 1630 : 
; 1631 : 		// Generate the polys
; 1632 : 		if (!SEMI_POLY_FREE()) return;

	cmp	DWORD PTR ?SemiCount@@3JA, 800		; SemiCount, 00000320H
	jl	SHORT $L83046
	jmp	$L83008
$L83046:

; 1633 : 		SEMI_POLY_SETUP(vert, FALSE, 4, TPAGE_FX1, TRUE, TRUE);

	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+12], 0
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+4], 4
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+8], 27 ; 0000001bH
	mov	eax, 1
	test	eax, eax
	je	SHORT $L83047
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax], 8
	jmp	SHORT $L83048
$L83047:
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax], 12 ; 0000000cH
$L83048:
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+16], 1
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+20], 0
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	add	eax, OFFSET FLAT:?SemiPoly@@3PAUDRAW_SEMI_POLY@@A+24
	mov	DWORD PTR _vert$[ebp], eax
	mov	ecx, DWORD PTR ?SemiCount@@3JA		; SemiCount
	add	ecx, 1
	mov	DWORD PTR ?SemiCount@@3JA, ecx		; SemiCount

; 1634 : 
; 1635 : 		vert[3].tu = 225.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+120], 1063321600		; 3f610000H

; 1636 : 		vert[3].tv = 33.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+124], 1040449536		; 3e040000H

; 1637 : 
; 1638 : 		vert[0].tu = 239.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+24], 1064239104		; 3f6f0000H

; 1639 : 		vert[0].tv = 33.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+28], 1040449536		; 3e040000H

; 1640 : 
; 1641 : 		vert[1].tu = 239.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+56], 1064239104		; 3f6f0000H

; 1642 : 		vert[1].tv = 47.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+60], 1044119552		; 3e3c0000H

; 1643 : 
; 1644 : 		vert[2].tu = 225.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+88], 1063321600		; 3f610000H

; 1645 : 		vert[2].tv = 47.0f / 256.0f;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+92], 1044119552		; 3e3c0000H

; 1646 : 
; 1647 : 		// Transform src and dest into view coords
; 1648 : 		RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &sPos, (REAL*)&vert[0]);

	mov	eax, DWORD PTR _vert$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sPos$[ebp]
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1649 : 		RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &ePos, (REAL*)&vert[2]);

	mov	eax, DWORD PTR _vert$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _ePos$[ebp]
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1650 : 
; 1651 : 		delta = vert[0].rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _delta$[ebp], ecx

; 1652 : 		vert[1].sx = vert[0].sx + dx * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx+32]

; 1653 : 		vert[1].sy = vert[0].sy + dy * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx+36]

; 1654 : 		vert[1].sz = vert[0].sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+40], edx

; 1655 : 		vert[1].rhw = vert[0].rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+44], edx

; 1656 : 		vert[0].sx -= dx * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fsubr	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx]

; 1657 : 		vert[0].sy -= dy * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fsubr	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx+4]

; 1658 : 
; 1659 : 		delta = vert[2].rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _delta$[ebp], ecx

; 1660 : 		vert[3].sx = vert[2].sx - dx * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fsubr	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx+96]

; 1661 : 		vert[3].sy = vert[2].sy - dy * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fsubr	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx+100]

; 1662 : 		vert[3].sz = vert[2].sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+104], edx

; 1663 : 		vert[3].rhw = vert[2].rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+108], edx

; 1664 : 		vert[2].sx += dx * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fadd	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx+64]

; 1665 : 		vert[2].sy += dy * (laser->Width + widMod) * delta * RenderSettings.GeomPers;

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR _widMod$[ebp]
	fadd	DWORD PTR [eax+28]
	fmul	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _delta$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	ecx, DWORD PTR _vert$[ebp]
	fadd	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [edx+68]

; 1666 : 
; 1667 : 		vert[0].color = 0x888888;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+16], 8947848		; 00888888H

; 1668 : 		vert[1].color = 0x888888;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+48], 8947848		; 00888888H

; 1669 : 		vert[2].color = 0x888888;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+80], 8947848		; 00888888H

; 1670 : 		vert[3].color = 0x888888;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [eax+112], 8947848		; 00888888H

; 1671 : 
; 1672 : 		VecPlusEqScalarVec(&sPos, bitLen, &dR);

	fld	DWORD PTR _bitLen$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fadd	DWORD PTR _sPos$[ebp]
	fstp	DWORD PTR _sPos$[ebp]
	fld	DWORD PTR _bitLen$[ebp]
	fmul	DWORD PTR _dR$[ebp+4]
	fadd	DWORD PTR _sPos$[ebp+4]
	fstp	DWORD PTR _sPos$[ebp+4]
	fld	DWORD PTR _bitLen$[ebp]
	fmul	DWORD PTR _dR$[ebp+8]
	fadd	DWORD PTR _sPos$[ebp+8]
	fstp	DWORD PTR _sPos$[ebp+8]

; 1673 : 	}

	jmp	$L83044
$L83045:

; 1674 : 
; 1675 : 	FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L83051
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L83051:

; 1676 : 	col = 0xff3333;

	mov	DWORD PTR _col$[ebp], 16724787		; 00ff3333H

; 1677 : 	poly.Usize = poly.Vsize = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+20], 1048576000	; 3e800000H
	mov	eax, DWORD PTR _poly$[ebp+20]
	mov	DWORD PTR _poly$[ebp+16], eax

; 1678 : 	poly.Tpage = TPAGE_FX1;

	mov	WORD PTR _poly$[ebp+24], 27		; 0000001bH

; 1679 : 	poly.RGB = (col >> 1) | (col << 8) | (col << 16);

	mov	eax, DWORD PTR _col$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _col$[ebp]
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _col$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	DWORD PTR _poly$[ebp+28], eax

; 1680 : 	poly.U = 192.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+8], 1061158912	; 3f400000H

; 1681 : 	poly.V = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+12], 1048576000	; 3e800000H

; 1682 : 
; 1683 : 
; 1684 : 	ang = TIME2MS(TimerCurrent) / 10000.0f;

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	xor	edx, edx
	div	ecx
	mov	DWORD PTR tv648[ebp], eax
	mov	DWORD PTR tv648[ebp+4], 0
	fild	QWORD PTR tv648[ebp]
	fdiv	DWORD PTR __real@461c4000
	fstp	DWORD PTR _ang$[ebp]

; 1685 : 	size = (long)((TIME2MS(TimerCurrent) % 100l) - 50l);

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	xor	edx, edx
	div	ecx
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	sub	edx, 50					; 00000032H
	mov	DWORD PTR _size$[ebp], edx

; 1686 : 	poly.Xsize = poly.Ysize = (2 * laser->Width) + (size / 5);

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _size$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	DWORD PTR tv669[ebp], eax
	fiadd	DWORD PTR tv669[ebp]
	fstp	DWORD PTR _poly$[ebp+4]
	mov	edx, DWORD PTR _poly$[ebp+4]
	mov	DWORD PTR _poly$[ebp], edx

; 1687 : 	RotMatrixZ(&mat, ang);

	mov	eax, DWORD PTR _ang$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1688 : 	DrawFacingPolyRotMirror(&sPos, &mat, &poly, 1, -16);

	push	-1048576000				; c1800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sPos$[ebp]
	push	edx
	call	?DrawFacingPolyRotMirror@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRotMirror
	add	esp, 20					; 00000014H

; 1689 : 
; 1690 : 	ang = TIME2MS(TimerCurrent) / 5000.0f;

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	xor	edx, edx
	div	ecx
	mov	DWORD PTR tv685[ebp], eax
	mov	DWORD PTR tv685[ebp+4], 0
	fild	QWORD PTR tv685[ebp]
	fdiv	DWORD PTR __real@459c4000
	fstp	DWORD PTR _ang$[ebp]

; 1691 : 	size = (long)((TIME2MS(TimerCurrent) % 200l) - 100l);

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	xor	edx, edx
	div	ecx
	xor	edx, edx
	mov	ecx, 200				; 000000c8H
	div	ecx
	sub	edx, 100				; 00000064H
	mov	DWORD PTR _size$[ebp], edx

; 1692 : 	poly.Xsize = poly.Ysize = (2 * laser->Width) + (size / 10);

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _size$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR tv706[ebp], eax
	fiadd	DWORD PTR tv706[ebp]
	fstp	DWORD PTR _poly$[ebp+4]
	mov	edx, DWORD PTR _poly$[ebp+4]
	mov	DWORD PTR _poly$[ebp], edx

; 1693 : 	RotMatrixZ(&mat, ang);

	mov	eax, DWORD PTR _ang$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1694 : 	DrawFacingPolyRotMirror(&sPos, &mat, &poly, 1, -16);

	push	-1048576000				; c1800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sPos$[ebp]
	push	edx
	call	?DrawFacingPolyRotMirror@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRotMirror
	add	esp, 20					; 00000014H

; 1695 : 
; 1696 : 	FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L83008
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L83008:

; 1697 : 
; 1698 : 	// draw the polys
; 1699 : 	//DrawModel(&PLR_LocalPlayer->car.Models->Wheel[0][0], &Identity, &sPos, MODEL_PLAIN);
; 1700 : 
; 1701 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderLaser@@YAXPAUobject_def@@@Z ENDP			; RenderLaser
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?DrawTarget@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_poly$ = -80						; size = 32
_mat$ = -48						; size = 36
_ang$ = -12						; size = 4
_col$ = -8						; size = 4
_mod$ = -4						; size = 4
_player$ = 8						; size = 4
?DrawTarget@@YAXPAUPlayerStruct@@@Z PROC NEAR		; DrawTarget, COMDAT

; 1710 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 1711 : 	long mod, col;
; 1712 : 	REAL ang;
; 1713 : 	MAT mat;
; 1714 : 	FACING_POLY poly;
; 1715 : 
; 1716 : 	FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L83063
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L83063:

; 1717 : 
; 1718 : 	col = 0xff;

	mov	DWORD PTR _col$[ebp], 255		; 000000ffH

; 1719 : 	poly.Usize = poly.Vsize = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+20], 1048576000	; 3e800000H
	mov	eax, DWORD PTR _poly$[ebp+20]
	mov	DWORD PTR _poly$[ebp+16], eax

; 1720 : 	poly.Tpage = TPAGE_FX1;

	mov	WORD PTR _poly$[ebp+24], 27		; 0000001bH

; 1721 : 	poly.RGB = (col >> 1) | (col << 8) | (col << 16);

	mov	eax, DWORD PTR _col$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _col$[ebp]
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _col$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	DWORD PTR _poly$[ebp+28], eax

; 1722 : 	poly.U = 192.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+8], 1061158912	; 3f400000H

; 1723 : 	poly.V = 64.0f / 256.0f;

	mov	DWORD PTR _poly$[ebp+12], 1048576000	; 3e800000H

; 1724 : 
; 1725 : 	mod = TIME2MS(TimerCurrent) % 10000;

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	xor	edx, edx
	div	ecx
	xor	edx, edx
	mov	ecx, 10000				; 00002710H
	div	ecx
	mov	DWORD PTR _mod$[ebp], edx

; 1726 : 	ang = mod / Real(10000);

	fild	DWORD PTR _mod$[ebp]
	fdiv	DWORD PTR __real@461c4000
	fstp	DWORD PTR _ang$[ebp]

; 1727 : 	poly.Xsize = poly.Ysize = Real(30);

	mov	DWORD PTR _poly$[ebp+4], 1106247680	; 41f00000H
	mov	eax, DWORD PTR _poly$[ebp+4]
	mov	DWORD PTR _poly$[ebp], eax

; 1728 : 
; 1729 : 	RotMatrixZ(&mat, ang);

	mov	eax, DWORD PTR _ang$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1730 : 	DrawFacingPolyRotMirror(&player->PickupTarget->player->car.Body->Centre.Pos, &mat, &poly, 1, -256);

	push	-1015021568				; c3800000H
	push	1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx+10236]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR [ecx+900]
	add	edx, 20					; 00000014H
	push	edx
	call	?DrawFacingPolyRotMirror@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRotMirror
	add	esp, 20					; 00000014H

; 1731 : 
; 1732 : 	FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L83057
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L83057:

; 1733 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawTarget@@YAXPAUPlayerStruct@@@Z ENDP		; DrawTarget
_TEXT	ENDS
PUBLIC	__real@41600000
PUBLIC	__real@41f00000
PUBLIC	__real@41000000
PUBLIC	?RenderSplash@@YAXPAUobject_def@@@Z		; RenderSplash
;	COMDAT __real@41600000
CONST	SEGMENT
__real@41600000 DD 041600000r			; 14
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RenderSplash@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
__temp$83089 = -40					; size = 4
__temp$83086 = -36					; size = 4
_vert$ = -32						; size = 4
_spoly$ = -28						; size = 4
_splash$ = -24						; size = 4
_tv$ = -20						; size = 4
_tu$ = -16						; size = 4
_rgb$ = -12						; size = 4
_frame$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?RenderSplash@@YAXPAUobject_def@@@Z PROC NEAR		; RenderSplash, COMDAT

; 1740 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 1741 : 	long i, frame, rgb;
; 1742 : 	REAL tu, tv;
; 1743 : 	SPLASH_OBJ *splash = (SPLASH_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _splash$[ebp], ecx

; 1744 : 	SPLASH_POLY *spoly;
; 1745 : 	VERTEX_TEX1 *vert;
; 1746 : 
; 1747 : // loop thru all polys
; 1748 : 
; 1749 : 	spoly = splash->Poly;

	mov	eax, DWORD PTR _splash$[ebp]
	add	eax, 4
	mov	DWORD PTR _spoly$[ebp], eax

; 1750 : 	for (i = 0 ; i < SPLASH_POLY_NUM ; i++, spoly++) if (spoly->Frame < 16.0f)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83079
$L83080:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _spoly$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _spoly$[ebp], ecx
$L83079:
	cmp	DWORD PTR _i$[ebp], 150			; 00000096H
	jge	$L83069
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR [eax+96]
	fcomp	DWORD PTR __real@41800000
	fnstsw	ax
	test	ah, 5
	jp	$L83082

; 1751 : 	{
; 1752 : 
; 1753 : // get semi poly
; 1754 : 
; 1755 : 		if (!SEMI_POLY_FREE()) return;

	cmp	DWORD PTR ?SemiCount@@3JA, 800		; SemiCount, 00000320H
	jl	SHORT $L83083
	jmp	$L83069
$L83083:

; 1756 : 		SEMI_POLY_SETUP(vert, FALSE, 4, TPAGE_FX3, TRUE, 1);

	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+12], 0
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+4], 4
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+8], 29 ; 0000001dH
	mov	eax, 1
	test	eax, eax
	je	SHORT $L83084
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax], 8
	jmp	SHORT $L83085
$L83084:
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax], 12 ; 0000000cH
$L83085:
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+16], 1
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+20], 0
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	add	eax, OFFSET FLAT:?SemiPoly@@3PAUDRAW_SEMI_POLY@@A+24
	mov	DWORD PTR _vert$[ebp], eax
	mov	ecx, DWORD PTR ?SemiCount@@3JA		; SemiCount
	add	ecx, 1
	mov	DWORD PTR ?SemiCount@@3JA, ecx		; SemiCount

; 1757 : 
; 1758 : // transform poly
; 1759 : 
; 1760 : 		RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &spoly->Pos[0], &vert[0].sx);

	mov	eax, DWORD PTR _vert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spoly$[ebp]
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1761 : 		RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &spoly->Pos[1], &vert[1].sx);

	mov	eax, DWORD PTR _vert$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _spoly$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1762 : 		RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &spoly->Pos[2], &vert[2].sx);

	mov	eax, DWORD PTR _vert$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _spoly$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1763 : 		RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &spoly->Pos[3], &vert[3].sx);

	mov	eax, DWORD PTR _vert$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _spoly$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1764 : 
; 1765 : // setup tex + rgb
; 1766 : 
; 1767 : 		FTOL(spoly->Frame, frame);

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR [eax+96]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$83086[ebp]
	mov	eax, DWORD PTR __temp$83086[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _frame$[ebp], eax

; 1768 : 
; 1769 : 		tu = frame * 16.0f + 1.0f;

	fild	DWORD PTR _frame$[ebp]
	fmul	DWORD PTR __real@41800000
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _tu$[ebp]

; 1770 : 		tv = 1.0f;

	mov	DWORD PTR _tv$[ebp], 1065353216		; 3f800000H

; 1771 : 
; 1772 : 		vert[0].tu = vert[3].tu = tu / 256.0f;

	fld	DWORD PTR _tu$[ebp]
	fdiv	DWORD PTR __real@43800000
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR [ecx+24], eax

; 1773 : 		vert[1].tu = vert[2].tu = (tu + 14.0f) / 256.0f;

	fld	DWORD PTR _tu$[ebp]
	fadd	DWORD PTR __real@41600000
	fdiv	DWORD PTR __real@43800000
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx+56], eax

; 1774 : 		vert[0].tv = vert[1].tv = tv / 256.0f;

	fld	DWORD PTR _tv$[ebp]
	fdiv	DWORD PTR __real@43800000
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+28], eax

; 1775 : 		vert[2].tv = vert[3].tv = (tv + 30.0f) / 256.0f;

	fld	DWORD PTR _tv$[ebp]
	fadd	DWORD PTR __real@41f00000
	fdiv	DWORD PTR __real@43800000
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR [ecx+92], eax

; 1776 : 
; 1777 : 		FTOL((16.0f - spoly->Frame) * 8.0f, rgb);

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR __real@41800000
	fsub	DWORD PTR [eax+96]
	fmul	DWORD PTR __real@41000000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$83089[ebp]
	mov	eax, DWORD PTR __temp$83089[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _rgb$[ebp], eax

; 1778 : 		rgb |= rgb << 8 | rgb << 16;

	mov	eax, DWORD PTR _rgb$[ebp]
	shl	eax, 8
	mov	ecx, DWORD PTR _rgb$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	or	eax, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR _rgb$[ebp], eax

; 1779 : 		vert[0].color = vert[1].color = vert[2].color = vert[3].color = rgb;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax+112], ecx
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [edx+80], eax
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax+16], ecx
$L83082:

; 1780 : 	}
; 1781 : }

	jmp	$L83080
$L83069:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderSplash@@YAXPAUobject_def@@@Z ENDP		; RenderSplash
_TEXT	ENDS
PUBLIC	__real@46fffe00
PUBLIC	__real@41b00000
PUBLIC	__real@42300000
PUBLIC	__real@c1b00000
PUBLIC	__real@41700000
PUBLIC	__real@c1700000
PUBLIC	__real@43960000
PUBLIC	?RenderSpeedup@@YAXPAUobject_def@@@Z		; RenderSpeedup
EXTRN	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z:NEAR ; CreateSpark
EXTRN	_rand:NEAR
EXTRN	?DrawJumpSpark2@@YAXPAUVectorStruct@@0@Z:NEAR	; DrawJumpSpark2
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
CONST	ENDS
;	COMDAT __real@42300000
CONST	SEGMENT
__real@42300000 DD 042300000r			; 44
CONST	ENDS
;	COMDAT __real@c1b00000
CONST	SEGMENT
__real@c1b00000 DD 0c1b00000r			; -22
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@c1700000
CONST	SEGMENT
__real@c1700000 DD 0c1700000r			; -15
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RenderSpeedup@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv581 = -140						; size = 4
tv573 = -140						; size = 4
tv565 = -140						; size = 4
tv557 = -140						; size = 4
tv548 = -140						; size = 4
tv544 = -140						; size = 4
tv540 = -140						; size = 4
tv536 = -140						; size = 4
_speedup$ = -72						; size = 4
_playerNear$ = -65					; size = 1
_player$ = -64						; size = 4
_dR$ = -60						; size = 12
_vel$ = -48						; size = 12
_pPos$ = -36						; size = 12
_ePos$ = -24						; size = 12
_sPos$ = -12						; size = 12
_obj$ = 8						; size = 4
?RenderSpeedup@@YAXPAUobject_def@@@Z PROC NEAR		; RenderSpeedup, COMDAT

; 1790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 1791 : 	VEC sPos, ePos, pPos, vel, dR;
; 1792 : 	PLAYER *player;
; 1793 : 	bool playerNear = FALSE;

	mov	BYTE PTR _playerNear$[ebp], 0

; 1794 : 
; 1795 : 	SPEEDUP_OBJ *speedup = (SPEEDUP_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _speedup$[ebp], ecx

; 1796 : 
; 1797 : 	RenderObjectModel(&obj->body.Centre.WMatrix, &speedup->PostPos[0], &LevelModel[obj->DefaultModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _speedup$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H

; 1798 : 	RenderObjectModel(&obj->body.Centre.WMatrix, &speedup->PostPos[1], &LevelModel[obj->DefaultModel].Model, obj->EnvRGB, obj->renderflag);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+652]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	imul	edx, 168				; 000000a8H
	add	edx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	edx
	mov	eax, DWORD PTR _speedup$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RenderObjectModel@@YA_NPATMatrixUnion@@PAUVectorStruct@@PAUMODEL@@JUrenderflags@@@Z ; RenderObjectModel
	add	esp, 20					; 00000014H

; 1799 : 
; 1800 : 	if ((TimerCurrent % 1000ul) < 500) {

	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	cmp	edx, 500				; 000001f4H
	jae	SHORT $L83104

; 1801 : 		speedup->HeightMod[0] += TimeStep * (frand(70) + 70.0f);

	call	_rand
	mov	DWORD PTR tv536[ebp], eax
	fild	DWORD PTR tv536[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@428c0000
	fadd	DWORD PTR __real@428c0000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	eax, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [eax+164]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+164]

; 1802 : 		speedup->HeightMod[1] += TimeStep * (frand(70) + 70.0f);

	call	_rand
	mov	DWORD PTR tv540[ebp], eax
	fild	DWORD PTR tv540[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@428c0000
	fadd	DWORD PTR __real@428c0000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	eax, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [eax+168]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+168]

; 1803 : 	} else {

	jmp	SHORT $L83107
$L83104:

; 1804 : 		speedup->HeightMod[0] -= TimeStep * (frand(70) + 70.0f);

	call	_rand
	mov	DWORD PTR tv544[ebp], eax
	fild	DWORD PTR tv544[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@428c0000
	fadd	DWORD PTR __real@428c0000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	eax, DWORD PTR _speedup$[ebp]
	fsubr	DWORD PTR [eax+164]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+164]

; 1805 : 		speedup->HeightMod[1] -= TimeStep * (frand(70) + 70.0f);

	call	_rand
	mov	DWORD PTR tv548[ebp], eax
	fild	DWORD PTR tv548[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@428c0000
	fadd	DWORD PTR __real@428c0000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	eax, DWORD PTR _speedup$[ebp]
	fsubr	DWORD PTR [eax+168]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+168]
$L83107:

; 1806 : 	}
; 1807 : 	if (speedup->HeightMod[0] > SPEEDUP_GEN_HEIGHT) speedup->HeightMod[0] = frand(2 * SPEEDUP_GEN_HEIGHT) - SPEEDUP_GEN_HEIGHT;

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+164]
	fcomp	DWORD PTR __real@41b00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83110
	call	_rand
	mov	DWORD PTR tv557[ebp], eax
	fild	DWORD PTR tv557[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42300000
	fsub	DWORD PTR __real@41b00000
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+164]
$L83110:

; 1808 : 	if (speedup->HeightMod[0] < -SPEEDUP_GEN_HEIGHT) speedup->HeightMod[0] = frand(2 * SPEEDUP_GEN_HEIGHT) - SPEEDUP_GEN_HEIGHT;

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+164]
	fcomp	DWORD PTR __real@c1b00000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83112
	call	_rand
	mov	DWORD PTR tv565[ebp], eax
	fild	DWORD PTR tv565[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42300000
	fsub	DWORD PTR __real@41b00000
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+164]
$L83112:

; 1809 : 	if (speedup->HeightMod[1] > SPEEDUP_GEN_HEIGHT) speedup->HeightMod[1] = frand(2 * SPEEDUP_GEN_HEIGHT) - SPEEDUP_GEN_HEIGHT;

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+168]
	fcomp	DWORD PTR __real@41b00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83114
	call	_rand
	mov	DWORD PTR tv573[ebp], eax
	fild	DWORD PTR tv573[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42300000
	fsub	DWORD PTR __real@41b00000
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+168]
$L83114:

; 1810 : 	if (speedup->HeightMod[1] < -SPEEDUP_GEN_HEIGHT) speedup->HeightMod[1] = frand(2 * SPEEDUP_GEN_HEIGHT) - SPEEDUP_GEN_HEIGHT;

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+168]
	fcomp	DWORD PTR __real@c1b00000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83116
	call	_rand
	mov	DWORD PTR tv581[ebp], eax
	fild	DWORD PTR tv581[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42300000
	fsub	DWORD PTR __real@41b00000
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+168]
$L83116:

; 1811 : 
; 1812 : 	ScalarVecPlusScalarVec(SPEEDUP_GEN_WIDTH, &obj->body.Centre.WMatrix.mv[R], -speedup->Height + speedup->HeightMod[0], &obj->body.Centre.WMatrix.mv[U], &sPos);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@41700000
	fmul	DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	mov	edx, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [edx+164]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+112]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _sPos$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@41700000
	fmul	DWORD PTR [eax+104]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	mov	edx, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [edx+164]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _sPos$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@41700000
	fmul	DWORD PTR [eax+108]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	mov	edx, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [edx+164]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+120]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _sPos$[ebp+8]

; 1813 : 	VecPlusEqVec(&sPos, &speedup->PostPos[0]);

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _sPos$[ebp]
	fadd	DWORD PTR [eax+140]
	fstp	DWORD PTR _sPos$[ebp]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _sPos$[ebp+4]
	fadd	DWORD PTR [eax+144]
	fstp	DWORD PTR _sPos$[ebp+4]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _sPos$[ebp+8]
	fadd	DWORD PTR [eax+148]
	fstp	DWORD PTR _sPos$[ebp+8]

; 1814 : 	ScalarVecPlusScalarVec(-SPEEDUP_GEN_WIDTH, &obj->body.Centre.WMatrix.mv[R], -speedup->Height + speedup->HeightMod[1], &obj->body.Centre.WMatrix.mv[U], &ePos);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@c1700000
	fmul	DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	mov	edx, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [edx+168]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+112]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ePos$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@c1700000
	fmul	DWORD PTR [eax+104]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	mov	edx, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [edx+168]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ePos$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@c1700000
	fmul	DWORD PTR [eax+108]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	mov	edx, DWORD PTR _speedup$[ebp]
	fadd	DWORD PTR [edx+168]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+120]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ePos$[ebp+8]

; 1815 : 	VecPlusEqVec(&ePos, &speedup->PostPos[1]);

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _ePos$[ebp]
	fadd	DWORD PTR [eax+152]
	fstp	DWORD PTR _ePos$[ebp]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _ePos$[ebp+4]
	fadd	DWORD PTR [eax+156]
	fstp	DWORD PTR _ePos$[ebp+4]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _ePos$[ebp+8]
	fadd	DWORD PTR [eax+160]
	fstp	DWORD PTR _ePos$[ebp+8]

; 1816 : 
; 1817 : 	// Find the players near to the speedup and electrocute them
; 1818 : 	for (player = PLR_PlayerHead; player != NULL; player = player->next) {

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L83118
$L83119:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L83118:
	cmp	DWORD PTR _player$[ebp], 0
	je	$L83120

; 1819 : 
; 1820 : 		CopyVec(&player->car.Aerial.Section[AERIAL_LASTSECTION].Pos, &pPos);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+1400]
	mov	DWORD PTR _pPos$[ebp], ecx
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+1404]
	mov	DWORD PTR _pPos$[ebp+4], ecx
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+1408]
	mov	DWORD PTR _pPos$[ebp+8], ecx

; 1821 : 		VecMinusVec(&sPos, &pPos, &dR);

	fld	DWORD PTR _sPos$[ebp]
	fsub	DWORD PTR _pPos$[ebp]
	fstp	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _sPos$[ebp+4]
	fsub	DWORD PTR _pPos$[ebp+4]
	fstp	DWORD PTR _dR$[ebp+4]
	fld	DWORD PTR _sPos$[ebp+8]
	fsub	DWORD PTR _pPos$[ebp+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 1822 : 		if (VecDotVec(&dR, &dR) > 4 * speedup->Width * speedup->Width) continue;

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR __real@40800000
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fmul	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83121
	jmp	$L83119
$L83121:

; 1823 : 		VecMinusVec(&ePos, &pPos, &dR);

	fld	DWORD PTR _ePos$[ebp]
	fsub	DWORD PTR _pPos$[ebp]
	fstp	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _ePos$[ebp+4]
	fsub	DWORD PTR _pPos$[ebp+4]
	fstp	DWORD PTR _dR$[ebp+4]
	fld	DWORD PTR _ePos$[ebp+8]
	fsub	DWORD PTR _pPos$[ebp+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 1824 : 		if (VecDotVec(&dR, &dR) > 4 * speedup->Width * speedup->Width) continue;

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR __real@40800000
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fmul	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83122
	jmp	$L83119
$L83122:

; 1825 : 		
; 1826 : 		playerNear = TRUE;

	mov	BYTE PTR _playerNear$[ebp], 1

; 1827 : 		DrawJumpSpark2(&sPos, &pPos);

	lea	eax, DWORD PTR _pPos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sPos$[ebp]
	push	ecx
	call	?DrawJumpSpark2@@YAXPAUVectorStruct@@0@Z ; DrawJumpSpark2
	add	esp, 8

; 1828 : 		DrawJumpSpark2(&ePos, &pPos);

	lea	eax, DWORD PTR _pPos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ePos$[ebp]
	push	ecx
	call	?DrawJumpSpark2@@YAXPAUVectorStruct@@0@Z ; DrawJumpSpark2
	add	esp, 8

; 1829 : 		DrawJumpSpark2(&player->car.Aerial.Section[2].Pos, &player->car.Aerial.Section[1].Pos);

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 1176				; 00000498H
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 1400				; 00000578H
	push	ecx
	call	?DrawJumpSpark2@@YAXPAUVectorStruct@@0@Z ; DrawJumpSpark2
	add	esp, 8

; 1830 : 		DrawJumpSpark2(&player->car.Aerial.Section[1].Pos, &player->car.Aerial.Section[0].Pos);

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 952				; 000003b8H
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 1176				; 00000498H
	push	ecx
	call	?DrawJumpSpark2@@YAXPAUVectorStruct@@0@Z ; DrawJumpSpark2
	add	esp, 8

; 1831 : 
; 1832 : 	}

	jmp	$L83119
$L83120:

; 1833 : 
; 1834 : 	if (!playerNear) {

	movzx	eax, BYTE PTR _playerNear$[ebp]
	test	eax, eax
	jne	SHORT $L83123

; 1835 : 		DrawJumpSpark2(&sPos, &ePos);

	lea	eax, DWORD PTR _ePos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sPos$[ebp]
	push	ecx
	call	?DrawJumpSpark2@@YAXPAUVectorStruct@@0@Z ; DrawJumpSpark2
	add	esp, 8
$L83123:

; 1836 : 	}
; 1837 : 
; 1838 : 
; 1839 : 	VecEqScalarVec(&vel, 300, &obj->body.Centre.WMatrix.mv[R]);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@43960000
	fmul	DWORD PTR [eax+100]
	fstp	DWORD PTR _vel$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@43960000
	fmul	DWORD PTR [eax+104]
	fstp	DWORD PTR _vel$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@43960000
	fmul	DWORD PTR [eax+108]
	fstp	DWORD PTR _vel$[ebp+8]

; 1840 : 	CreateSpark(SPARK_ELECTRIC, &sPos, &vel, 200, 0);

	push	0
	push	0
	push	1128792064				; 43480000H
	lea	eax, DWORD PTR _vel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sPos$[ebp]
	push	ecx
	push	7
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H

; 1841 : 	NegateVec(&vel);

	fld	DWORD PTR _vel$[ebp]
	fchs
	fstp	DWORD PTR _vel$[ebp]
	fld	DWORD PTR _vel$[ebp+4]
	fchs
	fstp	DWORD PTR _vel$[ebp+4]
	fld	DWORD PTR _vel$[ebp+8]
	fchs
	fstp	DWORD PTR _vel$[ebp+8]

; 1842 : 	CreateSpark(SPARK_ELECTRIC, &ePos, &vel, 200, 0);

	push	0
	push	0
	push	1128792064				; 43480000H
	lea	eax, DWORD PTR _vel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ePos$[ebp]
	push	ecx
	push	7
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H

; 1843 : 
; 1844 : 
; 1845 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderSpeedup@@YAXPAUobject_def@@@Z ENDP		; RenderSpeedup
_TEXT	ENDS
END
