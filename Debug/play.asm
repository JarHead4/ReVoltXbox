; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\play.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CF@EEJBNBPH@Can?8t?5create?5DirectPlay?5Lobby?5ob@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JBKJDKHK@Revolt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GDEODLEF@revolt?4exe?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@PCGKAEMC@Can?8t?5register?5for?5lobby?5support@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@MGFIBCBA@Can?8t?5create?5DirectPlay?5object?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@DHGGKJAF@Can?8t?5enumerate?5DirectPlay?5conne@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@MAAMMKNE@Can?8t?5create?5player?5event?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IJ@NAOIIGML@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@MFNLIMMH@Can?8t?5init?5DirectPlay?5connection@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMALIJDB@Can?8t?5create?5DirectPlay?5session?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@CBKFGPLC@Can?8t?5join?5DirectPlay?5session?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CKMGEKH@Can?8t?5create?5a?5player?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@FABKFLC@can?8t?5cancel?5priority?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@BEHPONHA@Can?8t?5find?5Level?5directory?5?8?$CFs?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DEKLHJLP@Session?5lost?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAPOONBC@Select?5Connection?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MIMJOPLF@Enter?5Game?5Name?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CKJOPMII@Choose?5a?5Game?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06IOLFCPIM@CLOSED?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DANIOFHI@OPEN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OPGJMNB@Players?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@IPEEFNCK@Hit?5Enter?5To?5Start?5Game?4?4?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@HCDHJLHD@Waiting?5For?5Host?4?4?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@CLAJAHAN@Timed?5out?5waiting?5for?5players?5to@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@DFOKBENB@Timed?5out?5waiting?5for?5server?5to?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LobbyRegister@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlay@@YA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KillPlay@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitConnection@@YA_ND@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSession@@YA_NPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?JoinSession@@YA_ND@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ListSessions@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSessionEnum@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumSessionsCallback@@YGHPBUDPSESSIONDESC2@@PAKKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreatePlayer@@YA_NPADJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisplayPlayers@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransmitMessage@@YAXPADFKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransmitMessageGuaranteed@@YAXPADFKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CancelPriority@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRemoteMessages@@YADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessPersonalMessage@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCarMessage@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestPings@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessPingRequest@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessPingReturn@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessPlayerReady@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessSyncTimers1@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessSyncTimers2@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessSyncTimers3@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessSystemMessage@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ListPlayers@@YAXPAU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumPlayersCallback@@YGHKKPBUDPNAME@@KPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConnectionMenu@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSessionName@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LookForSessions@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HostWait@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientWait@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHostDetails@@YADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckLegalIP@@YADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoteSync@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??KillPlay@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?LegalIP@@3PAULEGAL_IP@@A			; LegalIP
PUBLIC	?DP_GUID@@3U_GUID@@A				; DP_GUID
PUBLIC	?Lobby@@3PAUIDirectPlayLobby3@@A		; Lobby
PUBLIC	?DP@@3PAUIDirectPlay4@@A			; DP
PUBLIC	?FromID@@3KA					; FromID
PUBLIC	?ToID@@3KA					; ToID
PUBLIC	?LocalPlayerID@@3KA				; LocalPlayerID
PUBLIC	?ServerID@@3KA					; ServerID
PUBLIC	?PlayerList@@3PAUDP_PLAYER@@A			; PlayerList
PUBLIC	?PlayerCount@@3JA				; PlayerCount
PUBLIC	?ReceiveBuff@@3PADA				; ReceiveBuff
PUBLIC	?TransmitBuff@@3PADA				; TransmitBuff
PUBLIC	?StartData@@3USTART_DATA@@A			; StartData
_BSS	SEGMENT
?Lobby@@3PAUIDirectPlayLobby3@@A DD 01H DUP (?)		; Lobby
?DP@@3PAUIDirectPlay4@@A DD 01H DUP (?)			; DP
?FromID@@3KA DD	01H DUP (?)				; FromID
?ToID@@3KA DD	01H DUP (?)				; ToID
?LocalPlayerID@@3KA DD 01H DUP (?)			; LocalPlayerID
?ServerID@@3KA DD 01H DUP (?)				; ServerID
?PlayerList@@3PAUDP_PLAYER@@A DB 0570H DUP (?)		; PlayerList
?PlayerCount@@3JA DD 01H DUP (?)			; PlayerCount
?ReceiveBuff@@3PADA DB 0400H DUP (?)			; ReceiveBuff
?TransmitBuff@@3PADA DB 0400H DUP (?)			; TransmitBuff
?StartData@@3USTART_DATA@@A DB 03a4H DUP (?)		; StartData
_PlayerEvent DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?LegalIP@@3PAULEGAL_IP@@A DB 0ffH			; LegalIP
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	064H
	DB	067H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	064H
	DB	069H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	064H
	DB	06aH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	026H
	DB	0f0H
	DB	069H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	064H
	DB	00H
	DB	07H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	064H
	DB	00H
	DB	05H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0c2H
	DB	081H
	DB	012H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	064H
	DB	00H
	DB	05H
	DB	046H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+4
?DP_GUID@@3U_GUID@@A DD 06bb78285H			; DP_GUID
	DW	071dfH
	DW	011d2H
	DB	0b4H
	DB	06cH
	DB	0cH
	DB	078H
	DB	0cH
	DB	0c1H
	DB	08H
	DB	040H
_DATA	ENDS
PUBLIC	??_C@_0CF@EEJBNBPH@Can?8t?5create?5DirectPlay?5Lobby?5ob@ ; `string'
PUBLIC	??_C@_06JBKJDKHK@Revolt?$AA@			; `string'
PUBLIC	??_C@_0L@GDEODLEF@revolt?4exe?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0CB@PCGKAEMC@Can?8t?5register?5for?5lobby?5support@ ; `string'
PUBLIC	?LobbyRegister@@YAXXZ				; LobbyRegister
EXTRN	__imp__GetCurrentDirectoryA@8:NEAR
EXTRN	__imp__CoCreateInstance@20:NEAR
EXTRN	_IID_IDirectPlayLobby3A:BYTE
EXTRN	_CLSID_DirectPlayLobby:BYTE
EXTRN	?ErrorDX@@YAXJPAD@Z:NEAR			; ErrorDX
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
;	COMDAT ??_C@_0CF@EEJBNBPH@Can?8t?5create?5DirectPlay?5Lobby?5ob@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\play.cpp
CONST	SEGMENT
??_C@_0CF@EEJBNBPH@Can?8t?5create?5DirectPlay?5Lobby?5ob@ DB 'Can''t crea'
	DB	'te DirectPlay Lobby object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBKJDKHK@Revolt?$AA@
CONST	SEGMENT
??_C@_06JBKJDKHK@Revolt?$AA@ DB 'Revolt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GDEODLEF@revolt?4exe?$AA@
CONST	SEGMENT
??_C@_0L@GDEODLEF@revolt?4exe?$AA@ DB 'revolt.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PCGKAEMC@Can?8t?5register?5for?5lobby?5support@
CONST	SEGMENT
??_C@_0CB@PCGKAEMC@Can?8t?5register?5for?5lobby?5support@ DB 'Can''t regi'
	DB	'ster for lobby support', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LobbyRegister@@YAXXZ
_TEXT	SEGMENT
_dir$ = -312						; size = 256
_app$ = -56						; size = 52
_r$ = -4						; size = 4
?LobbyRegister@@YAXXZ PROC NEAR				; LobbyRegister, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	push	ebx
	push	esi
	push	edi

; 82   : 	HRESULT r;
; 83   : 	DPAPPLICATIONDESC app;
; 84   : 	char dir[256];
; 85   : 
; 86   : // create lobby object
; 87   : 
; 88   : 	r = CoCreateInstance(CLSID_DirectPlayLobby, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayLobby3A, (void**)&Lobby);

	push	OFFSET FLAT:?Lobby@@3PAUIDirectPlayLobby3@@A ; Lobby
	push	OFFSET FLAT:_IID_IDirectPlayLobby3A
	push	1
	push	0
	push	OFFSET FLAT:_CLSID_DirectPlayLobby
	call	DWORD PTR __imp__CoCreateInstance@20
	mov	DWORD PTR _r$[ebp], eax

; 89   : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96270

; 90   : 	{
; 91   : 		ErrorDX(r, "Can't create DirectPlay Lobby object");

	push	OFFSET FLAT:??_C@_0CF@EEJBNBPH@Can?8t?5create?5DirectPlay?5Lobby?5ob@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 92   : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 93   : 		return;

	jmp	$L96264
$L96270:

; 94   : 	}
; 95   : 
; 96   : // register
; 97   : 
; 98   : 	GetCurrentDirectory(256, dir);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	push	256					; 00000100H
	call	DWORD PTR __imp__GetCurrentDirectoryA@8

; 99   : 
; 100  : 	app.dwSize = sizeof(app);

	mov	DWORD PTR _app$[ebp], 52		; 00000034H

; 101  : 	app.dwFlags = 0;

	mov	DWORD PTR _app$[ebp+4], 0

; 102  : 	app.lpszApplicationNameA = "Revolt";

	mov	DWORD PTR _app$[ebp+8], OFFSET FLAT:??_C@_06JBKJDKHK@Revolt?$AA@

; 103  : 	app.guidApplication = DP_GUID;

	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A
	mov	DWORD PTR _app$[ebp+12], eax
	mov	ecx, DWORD PTR ?DP_GUID@@3U_GUID@@A+4
	mov	DWORD PTR _app$[ebp+16], ecx
	mov	edx, DWORD PTR ?DP_GUID@@3U_GUID@@A+8
	mov	DWORD PTR _app$[ebp+20], edx
	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A+12
	mov	DWORD PTR _app$[ebp+24], eax

; 104  : 	app.lpszFilenameA = "revolt.exe";

	mov	DWORD PTR _app$[ebp+28], OFFSET FLAT:??_C@_0L@GDEODLEF@revolt?4exe?$AA@

; 105  : 	app.lpszCommandLineA = "";

	mov	DWORD PTR _app$[ebp+32], OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 106  : 	app.lpszPathA = dir;

	lea	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR _app$[ebp+36], eax

; 107  : 	app.lpszCurrentDirectoryA = dir;

	lea	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR _app$[ebp+40], eax

; 108  : 	app.lpszDescriptionA = NULL;

	mov	DWORD PTR _app$[ebp+44], 0

; 109  : 	app.lpszDescriptionW = NULL;

	mov	DWORD PTR _app$[ebp+48], 0

; 110  : 
; 111  : 	r = Lobby->RegisterApplication(0, &app);

	lea	eax, DWORD PTR _app$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?Lobby@@3PAUIDirectPlayLobby3@@A ; Lobby
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?Lobby@@3PAUIDirectPlayLobby3@@A ; Lobby
	push	eax
	call	DWORD PTR [edx+64]
	mov	DWORD PTR _r$[ebp], eax

; 112  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96276

; 113  : 	{
; 114  : 		ErrorDX(r, "Can't register for lobby support");

	push	OFFSET FLAT:??_C@_0CB@PCGKAEMC@Can?8t?5register?5for?5lobby?5support@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 115  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 116  : 		return;

	jmp	SHORT $L96264
$L96276:

; 117  : 	}
; 118  : 
; 119  : // release
; 120  : 
; 121  : 	RELEASE(Lobby);

	cmp	DWORD PTR ?Lobby@@3PAUIDirectPlayLobby3@@A, 0 ; Lobby
	je	SHORT $L96264
	mov	eax, DWORD PTR ?Lobby@@3PAUIDirectPlayLobby3@@A ; Lobby
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?Lobby@@3PAUIDirectPlayLobby3@@A ; Lobby
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?Lobby@@3PAUIDirectPlayLobby3@@A, 0 ; Lobby
$L96264:

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LobbyRegister@@YAXXZ ENDP				; LobbyRegister
_TEXT	ENDS
PUBLIC	??_C@_0BP@MGFIBCBA@Can?8t?5create?5DirectPlay?5object?$AA@ ; `string'
PUBLIC	??_C@_0CH@DHGGKJAF@Can?8t?5enumerate?5DirectPlay?5conne@ ; `string'
PUBLIC	??_C@_0BL@MAAMMKNE@Can?8t?5create?5player?5event?$CB?$AA@ ; `string'
PUBLIC	?InitPlay@@YA_NXZ				; InitPlay
PUBLIC	?EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z ; EnumConnectionsCallback
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	_IID_IDirectPlay4A:BYTE
EXTRN	_CLSID_DirectPlay:BYTE
_BSS	SEGMENT
_ConnectionCount DB 01H DUP (?)
	ALIGN	4

_Connection DB	0840H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BP@MGFIBCBA@Can?8t?5create?5DirectPlay?5object?$AA@
CONST	SEGMENT
??_C@_0BP@MGFIBCBA@Can?8t?5create?5DirectPlay?5object?$AA@ DB 'Can''t cre'
	DB	'ate DirectPlay object', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DHGGKJAF@Can?8t?5enumerate?5DirectPlay?5conne@
CONST	SEGMENT
??_C@_0CH@DHGGKJAF@Can?8t?5enumerate?5DirectPlay?5conne@ DB 'Can''t enume'
	DB	'rate DirectPlay connections', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MAAMMKNE@Can?8t?5create?5player?5event?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@MAAMMKNE@Can?8t?5create?5player?5event?$CB?$AA@ DB 'Can''t crea'
	DB	'te player event!', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitPlay@@YA_NXZ
_TEXT	SEGMENT
_i$ = -5						; size = 1
_r$ = -4						; size = 4
?InitPlay@@YA_NXZ PROC NEAR				; InitPlay, COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 130  : 	HRESULT r;
; 131  : 	char i;
; 132  : 
; 133  : // Create an IDirectPlay4 interface
; 134  : 
; 135  : 	r = CoCreateInstance(CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay4A, (void**)&DP);

	push	OFFSET FLAT:?DP@@3PAUIDirectPlay4@@A	; DP
	push	OFFSET FLAT:_IID_IDirectPlay4A
	push	1
	push	0
	push	OFFSET FLAT:_CLSID_DirectPlay
	call	DWORD PTR __imp__CoCreateInstance@20
	mov	DWORD PTR _r$[ebp], eax

; 136  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96286

; 137  : 	{
; 138  : 		ErrorDX(r, "Can't create DirectPlay object");

	push	OFFSET FLAT:??_C@_0BP@MGFIBCBA@Can?8t?5create?5DirectPlay?5object?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 139  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 140  : 		return FALSE;

	xor	al, al
	jmp	$L96281
$L96286:

; 141  : 	}
; 142  : 
; 143  : // enum connection types
; 144  : 
; 145  : 	ConnectionCount = 0;

	mov	BYTE PTR _ConnectionCount, 0

; 146  : 	for (i = 0 ; i < CONNECTION_MAX ; i++) Connection[i].Ptr = NULL;

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L96288
$L96289:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L96288:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $L96290
	movsx	eax, BYTE PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	DWORD PTR _Connection[eax], 0
	jmp	SHORT $L96289
$L96290:

; 147  : 
; 148  : 	r = DP->EnumConnections(&DP_GUID, EnumConnectionsCallback, NULL, DPCONNECTION_DIRECTPLAY);

	push	1
	push	0
	push	OFFSET FLAT:?EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z ; EnumConnectionsCallback
	push	OFFSET FLAT:?DP_GUID@@3U_GUID@@A	; DP_GUID
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+140]
	mov	DWORD PTR _r$[ebp], eax

; 149  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96292

; 150  : 	{
; 151  : 		ErrorDX(r, "Can't enumerate DirectPlay connections");

	push	OFFSET FLAT:??_C@_0CH@DHGGKJAF@Can?8t?5enumerate?5DirectPlay?5conne@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 152  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 153  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96281
$L96292:

; 154  : 	}
; 155  : 
; 156  : // create player event handle
; 157  : 
; 158  : 	PlayerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	DWORD PTR _PlayerEvent, eax

; 159  : 	if (!PlayerEvent)

	cmp	DWORD PTR _PlayerEvent, 0
	jne	SHORT $L96294

; 160  : 	{
; 161  : 		ErrorDX(0, "Can't create player event!");

	push	OFFSET FLAT:??_C@_0BL@MAAMMKNE@Can?8t?5create?5player?5event?$CB?$AA@
	push	0
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 162  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 163  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96281
$L96294:

; 164  : 	}
; 165  : 
; 166  : // return OK
; 167  : 
; 168  : 	return TRUE;

	mov	al, 1
$L96281:

; 169  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlay@@YA_NXZ ENDP					; InitPlay
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??KillPlay@@YAXXZ@4JA		; `KillPlay'::`2'::__LINE__Var
PUBLIC	??_C@_0IJ@NAOIIGML@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	?KillPlay@@YAXXZ				; KillPlay
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
EXTRN	__imp__CloseHandle@4:NEAR
;	COMDAT ??_C@_0IJ@NAOIIGML@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IJ@NAOIIGML@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\play.'
	DB	'cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??KillPlay@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??KillPlay@@YAXXZ@4JA DD 0b0H		; `KillPlay'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?KillPlay@@YAXXZ
_TEXT	SEGMENT
_i$ = -1						; size = 1
?KillPlay@@YAXXZ PROC NEAR				; KillPlay, COMDAT

; 176  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 177  : 	char i;
; 178  : 
; 179  : // free player event handle
; 180  : 
; 181  : 	CloseHandle(PlayerEvent);

	mov	eax, DWORD PTR _PlayerEvent
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 182  : 
; 183  : // free connection ptr's
; 184  : 
; 185  : 	for (i = 0 ; i < CONNECTION_MAX ; i++) if (Connection[i].Ptr)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L96300
$L96301:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L96300:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $L96302
	movsx	eax, BYTE PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	cmp	DWORD PTR _Connection[eax], 0
	je	SHORT $L96303

; 186  : 	{
; 187  : 		free(Connection[i].Ptr);

	push	OFFSET FLAT:??_C@_0IJ@NAOIIGML@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??KillPlay@@YAXXZ@4JA
	add	eax, 11					; 0000000bH
	push	eax
	movsx	ecx, BYTE PTR _i$[ebp]
	imul	ecx, 132				; 00000084H
	mov	edx, DWORD PTR _Connection[ecx]
	push	edx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 188  : 		Connection[i].Ptr = NULL;

	movsx	eax, BYTE PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	DWORD PTR _Connection[eax], 0
$L96303:

; 189  : 	}
; 190  : 
; 191  : // release DP object
; 192  : 
; 193  : 	RELEASE(DP);

	jmp	SHORT $L96301
$L96302:
	cmp	DWORD PTR ?DP@@3PAUIDirectPlay4@@A, 0	; DP
	je	SHORT $L96298
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?DP@@3PAUIDirectPlay4@@A, 0	; DP
$L96298:

; 194  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?KillPlay@@YAXXZ ENDP					; KillPlay
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z@4JA ; `EnumConnectionsCallback'::`2'::__LINE__Var
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
EXTRN	_memcpy:NEAR
;	COMDAT ?__LINE__Var@?1??EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z@4JA DD 0c9H ; `EnumConnectionsCallback'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z
_TEXT	SEGMENT
_lpguidSP$ = 8						; size = 4
_lpConnection$ = 12					; size = 4
_dwConnectionSize$ = 16					; size = 4
_lpName$ = 20						; size = 4
_dwFlags$ = 24						; size = 4
_lpContext$ = 28					; size = 4
?EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z PROC NEAR ; EnumConnectionsCallback, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 202  : 
; 203  : // skip if reached max connections
; 204  : 
; 205  : 	if (ConnectionCount >= CONNECTION_MAX) return FALSE;

	movsx	eax, BYTE PTR _ConnectionCount
	cmp	eax, 16					; 00000010H
	jl	SHORT $L96315
	xor	eax, eax
	jmp	$L96314
$L96315:

; 206  : 
; 207  : // store connection name / info
; 208  : 
; 209  : 	memcpy(Connection[ConnectionCount].Name, lpName->lpszShortNameA, 128);

	push	128					; 00000080H
	mov	eax, DWORD PTR _lpName$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	movsx	edx, BYTE PTR _ConnectionCount
	imul	edx, 132				; 00000084H
	add	edx, OFFSET FLAT:_Connection+4
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 210  : 	Connection[ConnectionCount].Ptr = malloc(dwConnectionSize);

	push	OFFSET FLAT:??_C@_0IJ@NAOIIGML@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z@4JA
	add	eax, 9
	push	eax
	mov	ecx, DWORD PTR _dwConnectionSize$[ebp]
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	movsx	edx, BYTE PTR _ConnectionCount
	imul	edx, 132				; 00000084H
	mov	DWORD PTR _Connection[edx], eax

; 211  : 	memcpy(Connection[ConnectionCount].Ptr, lpConnection, dwConnectionSize);

	mov	eax, DWORD PTR _dwConnectionSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	movsx	edx, BYTE PTR _ConnectionCount
	imul	edx, 132				; 00000084H
	mov	eax, DWORD PTR _Connection[edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 212  : 
; 213  : // return OK
; 214  : 
; 215  : 	ConnectionCount++;

	mov	al, BYTE PTR _ConnectionCount
	add	al, 1
	mov	BYTE PTR _ConnectionCount, al

; 216  : 	return TRUE;

	mov	eax, 1
$L96314:

; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?EnumConnectionsCallback@@YGHPBU_GUID@@PAXKPBUDPNAME@@K1@Z ENDP ; EnumConnectionsCallback
_TEXT	ENDS
PUBLIC	??_C@_0CB@MFNLIMMH@Can?8t?5init?5DirectPlay?5connection@ ; `string'
PUBLIC	?InitConnection@@YA_ND@Z			; InitConnection
;	COMDAT ??_C@_0CB@MFNLIMMH@Can?8t?5init?5DirectPlay?5connection@
CONST	SEGMENT
??_C@_0CB@MFNLIMMH@Can?8t?5init?5DirectPlay?5connection@ DB 'Can''t init '
	DB	'DirectPlay connection', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitConnection@@YA_ND@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_num$ = 8						; size = 1
?InitConnection@@YA_ND@Z PROC NEAR			; InitConnection, COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 225  : 	HRESULT r;
; 226  : 
; 227  : // init connection
; 228  : 
; 229  : 	r = DP->InitializeConnection(Connection[num].Ptr, 0);

	push	0
	movsx	eax, BYTE PTR _num$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _Connection[eax]
	push	ecx
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	ecx
	call	DWORD PTR [eax+152]
	mov	DWORD PTR _r$[ebp], eax

; 230  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96322

; 231  : 	{
; 232  : 		ErrorDX(r, "Can't init DirectPlay connection");

	push	OFFSET FLAT:??_C@_0CB@MFNLIMMH@Can?8t?5init?5DirectPlay?5connection@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 233  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 234  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96319
$L96322:

; 235  : 	}
; 236  : 
; 237  : // return OK
; 238  : 
; 239  : 	return TRUE;

	mov	al, 1
$L96319:

; 240  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitConnection@@YA_ND@Z ENDP				; InitConnection
_TEXT	ENDS
PUBLIC	??_C@_0CA@LMALIJDB@Can?8t?5create?5DirectPlay?5session?$AA@ ; `string'
PUBLIC	?CreateSession@@YA_NPAD@Z			; CreateSession
EXTRN	_memset:NEAR
_BSS	SEGMENT
_Session DB	050H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CA@LMALIJDB@Can?8t?5create?5DirectPlay?5session?$AA@
CONST	SEGMENT
??_C@_0CA@LMALIJDB@Can?8t?5create?5DirectPlay?5session?$AA@ DB 'Can''t cr'
	DB	'eate DirectPlay session', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CreateSession@@YA_NPAD@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_name$ = 8						; size = 4
?CreateSession@@YA_NPAD@Z PROC NEAR			; CreateSession, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 248  : 	HRESULT r;
; 249  : 
; 250  : // setup a new session
; 251  : 
; 252  : 	ZeroMemory(&Session, sizeof(Session));

	push	80					; 00000050H
	push	0
	push	OFFSET FLAT:_Session
	call	_memset
	add	esp, 12					; 0000000cH

; 253  : 	Session.dwSize = sizeof(Session);

	mov	DWORD PTR _Session, 80			; 00000050H

; 254  : //	Session.dwFlags = DPSESSION_DIRECTPLAYPROTOCOL | DPSESSION_MIGRATEHOST | DPSESSION_KEEPALIVE;
; 255  : 	Session.dwFlags = DPSESSION_DIRECTPLAYPROTOCOL | DPSESSION_MULTICASTSERVER | DPSESSION_KEEPALIVE;

	mov	DWORD PTR _Session+4, 10304		; 00002840H

; 256  : 	Session.guidApplication = DP_GUID;

	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A
	mov	DWORD PTR _Session+24, eax
	mov	ecx, DWORD PTR ?DP_GUID@@3U_GUID@@A+4
	mov	DWORD PTR _Session+28, ecx
	mov	edx, DWORD PTR ?DP_GUID@@3U_GUID@@A+8
	mov	DWORD PTR _Session+32, edx
	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A+12
	mov	DWORD PTR _Session+36, eax

; 257  : 	Session.dwMaxPlayers = MAX_NUM_PLAYERS;

	mov	DWORD PTR _Session+40, 12		; 0000000cH

; 258  : 	Session.lpszSessionNameA = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _Session+48, eax

; 259  : 
; 260  : // open session
; 261  : 
; 262  : 	r = DP->Open(&Session, DPOPEN_CREATE);

	push	2
	push	OFFSET FLAT:_Session
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+96]
	mov	DWORD PTR _r$[ebp], eax

; 263  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96329

; 264  : 	{
; 265  : 		ErrorDX(r, "Can't create DirectPlay session");

	push	OFFSET FLAT:??_C@_0CA@LMALIJDB@Can?8t?5create?5DirectPlay?5session?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 266  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 267  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96326
$L96329:

; 268  : 	}
; 269  : 
; 270  : // return OK
; 271  : 
; 272  : 	return TRUE;

	mov	al, 1
$L96326:

; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateSession@@YA_NPAD@Z ENDP				; CreateSession
_TEXT	ENDS
PUBLIC	??_C@_0BO@CBKFGPLC@Can?8t?5join?5DirectPlay?5session?$AA@ ; `string'
PUBLIC	?JoinSession@@YA_ND@Z				; JoinSession
_BSS	SEGMENT
_SessionJoin DB	050H DUP (?)
_SessionList DB	01c0H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BO@CBKFGPLC@Can?8t?5join?5DirectPlay?5session?$AA@
CONST	SEGMENT
??_C@_0BO@CBKFGPLC@Can?8t?5join?5DirectPlay?5session?$AA@ DB 'Can''t join'
	DB	' DirectPlay session', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?JoinSession@@YA_ND@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_num$ = 8						; size = 1
?JoinSession@@YA_ND@Z PROC NEAR				; JoinSession, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 281  : 	HRESULT r;
; 282  : 
; 283  : // setup a session
; 284  : 
; 285  : 	ZeroMemory(&SessionJoin, sizeof(SessionJoin));

	push	80					; 00000050H
	push	0
	push	OFFSET FLAT:_SessionJoin
	call	_memset
	add	esp, 12					; 0000000cH

; 286  : 	SessionJoin.dwSize = sizeof(SessionJoin);

	mov	DWORD PTR _SessionJoin, 80		; 00000050H

; 287  : 	SessionJoin.guidInstance = SessionList[num].Guid;

	movsx	eax, BYTE PTR _num$[ebp]
	imul	eax, 56					; 00000038H
	add	eax, OFFSET FLAT:_SessionList
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _SessionJoin+8, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _SessionJoin+12, edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _SessionJoin+16, ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _SessionJoin+20, edx

; 288  : 
; 289  : // open session
; 290  : 
; 291  : 	r = DP->Open(&SessionJoin, DPOPEN_JOIN);

	push	1
	push	OFFSET FLAT:_SessionJoin
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+96]
	mov	DWORD PTR _r$[ebp], eax

; 292  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96336

; 293  : 	{
; 294  : 		ErrorDX(r, "Can't join DirectPlay session");

	push	OFFSET FLAT:??_C@_0BO@CBKFGPLC@Can?8t?5join?5DirectPlay?5session?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 295  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 296  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96333
$L96336:

; 297  : 	}
; 298  : 
; 299  : // return OK
; 300  : 
; 301  : 	return TRUE;

	mov	al, 1
$L96333:

; 302  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?JoinSession@@YA_ND@Z ENDP				; JoinSession
_TEXT	ENDS
PUBLIC	?ListSessions@@YAXXZ				; ListSessions
PUBLIC	?EnumSessionsCallback@@YGHPBUDPSESSIONDESC2@@PAKKPAX@Z ; EnumSessionsCallback
_BSS	SEGMENT
_SessionCount DB 01H DUP (?)
	ALIGN	4

_SessionEnum DB	050H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?ListSessions@@YAXXZ
_TEXT	SEGMENT
?ListSessions@@YAXXZ PROC NEAR				; ListSessions, COMDAT

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 310  : 	SessionCount = 0;

	mov	BYTE PTR _SessionCount, 0

; 311  : 
; 312  : 	ZeroMemory(&SessionEnum, sizeof(SessionEnum));

	push	80					; 00000050H
	push	0
	push	OFFSET FLAT:_SessionEnum
	call	_memset
	add	esp, 12					; 0000000cH

; 313  : 	SessionEnum.dwSize = sizeof(SessionEnum);

	mov	DWORD PTR _SessionEnum, 80		; 00000050H

; 314  : 	SessionEnum.guidApplication = DP_GUID;

	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A
	mov	DWORD PTR _SessionEnum+24, eax
	mov	ecx, DWORD PTR ?DP_GUID@@3U_GUID@@A+4
	mov	DWORD PTR _SessionEnum+28, ecx
	mov	edx, DWORD PTR ?DP_GUID@@3U_GUID@@A+8
	mov	DWORD PTR _SessionEnum+32, edx
	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A+12
	mov	DWORD PTR _SessionEnum+36, eax

; 315  : 
; 316  : 	DP->EnumSessions(&SessionEnum, 0, EnumSessionsCallback, NULL, DPENUMSESSIONS_ASYNC | DPENUMSESSIONS_ALL);

	push	18					; 00000012H
	push	0
	push	OFFSET FLAT:?EnumSessionsCallback@@YGHPBUDPSESSIONDESC2@@PAKKPAX@Z ; EnumSessionsCallback
	push	0
	push	OFFSET FLAT:_SessionEnum
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+52]

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ListSessions@@YAXXZ ENDP				; ListSessions
_TEXT	ENDS
PUBLIC	?StopSessionEnum@@YAXXZ				; StopSessionEnum
; Function compile flags: /Odt /ZI
;	COMDAT ?StopSessionEnum@@YAXXZ
_TEXT	SEGMENT
?StopSessionEnum@@YAXXZ PROC NEAR			; StopSessionEnum, COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 325  : 	ZeroMemory(&SessionEnum, sizeof(SessionEnum));

	push	80					; 00000050H
	push	0
	push	OFFSET FLAT:_SessionEnum
	call	_memset
	add	esp, 12					; 0000000cH

; 326  : 	SessionEnum.dwSize = sizeof(SessionEnum);

	mov	DWORD PTR _SessionEnum, 80		; 00000050H

; 327  : 	SessionEnum.guidApplication = DP_GUID;

	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A
	mov	DWORD PTR _SessionEnum+24, eax
	mov	ecx, DWORD PTR ?DP_GUID@@3U_GUID@@A+4
	mov	DWORD PTR _SessionEnum+28, ecx
	mov	edx, DWORD PTR ?DP_GUID@@3U_GUID@@A+8
	mov	DWORD PTR _SessionEnum+32, edx
	mov	eax, DWORD PTR ?DP_GUID@@3U_GUID@@A+12
	mov	DWORD PTR _SessionEnum+36, eax

; 328  : 
; 329  : 	DP->EnumSessions(&SessionEnum, 0, EnumSessionsCallback, NULL, DPENUMSESSIONS_STOPASYNC);

	push	32					; 00000020H
	push	0
	push	OFFSET FLAT:?EnumSessionsCallback@@YGHPBUDPSESSIONDESC2@@PAKKPAX@Z ; EnumSessionsCallback
	push	0
	push	OFFSET FLAT:_SessionEnum
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+52]

; 330  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSessionEnum@@YAXXZ ENDP				; StopSessionEnum
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?EnumSessionsCallback@@YGHPBUDPSESSIONDESC2@@PAKKPAX@Z
_TEXT	SEGMENT
_lpSessionDesc$ = 8					; size = 4
_lpdwTimeOut$ = 12					; size = 4
_dwFlags$ = 16						; size = 4
_lpContext$ = 20					; size = 4
?EnumSessionsCallback@@YGHPBUDPSESSIONDESC2@@PAKKPAX@Z PROC NEAR ; EnumSessionsCallback, COMDAT

; 337  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 338  : 
; 339  : // skip if reached max sessions
; 340  : 
; 341  : 	if (SessionCount >= SESSION_MAX) return FALSE;

	movsx	eax, BYTE PTR _SessionCount
	cmp	eax, 8
	jl	SHORT $L96350
	xor	eax, eax
	jmp	$L96349
$L96350:

; 342  : 
; 343  : // skip if timed out
; 344  : 
; 345  : 	if (dwFlags & DPESC_TIMEDOUT) return FALSE;

	mov	eax, DWORD PTR _dwFlags$[ebp]
	and	eax, 1
	je	SHORT $L96351
	xor	eax, eax
	jmp	SHORT $L96349
$L96351:

; 346  : 
; 347  : // store session name / info
; 348  : 
; 349  : 	memcpy(SessionList[SessionCount].Name, lpSessionDesc->lpszSessionNameA, MAX_SESSION_NAME);

	push	34					; 00000022H
	mov	eax, DWORD PTR _lpSessionDesc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	movsx	edx, BYTE PTR _SessionCount
	imul	edx, 56					; 00000038H
	add	edx, OFFSET FLAT:_SessionList+20
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 350  : 	SessionList[SessionCount].Guid = lpSessionDesc->guidInstance;

	mov	eax, DWORD PTR _lpSessionDesc$[ebp]
	add	eax, 8
	movsx	ecx, BYTE PTR _SessionCount
	imul	ecx, 56					; 00000038H
	add	ecx, OFFSET FLAT:_SessionList
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 351  : 	SessionList[SessionCount].Flags = lpSessionDesc->dwFlags;

	movsx	eax, BYTE PTR _SessionCount
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _lpSessionDesc$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _SessionList[eax+16], edx

; 352  : 
; 353  : // return OK
; 354  : 
; 355  : 	SessionCount++;

	mov	al, BYTE PTR _SessionCount
	add	al, 1
	mov	BYTE PTR _SessionCount, al

; 356  : 	return TRUE;

	mov	eax, 1
$L96349:

; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?EnumSessionsCallback@@YGHPBUDPSESSIONDESC2@@PAKKPAX@Z ENDP ; EnumSessionsCallback
_TEXT	ENDS
PUBLIC	??_C@_0BG@CKMGEKH@Can?8t?5create?5a?5player?$AA@ ; `string'
PUBLIC	?CreatePlayer@@YA_NPADJ@Z			; CreatePlayer
EXTRN	?GameSettings@@3UGAME_SETTINGS@@A:BYTE		; GameSettings
_BSS	SEGMENT
_LocalPlayerData DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BG@CKMGEKH@Can?8t?5create?5a?5player?$AA@
CONST	SEGMENT
??_C@_0BG@CKMGEKH@Can?8t?5create?5a?5player?$AA@ DB 'Can''t create a play'
	DB	'er', 00H					; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CreatePlayer@@YA_NPADJ@Z
_TEXT	SEGMENT
_r$ = -20						; size = 4
_dpname$ = -16						; size = 16
_name$ = 8						; size = 4
_server$ = 12						; size = 4
?CreatePlayer@@YA_NPADJ@Z PROC NEAR			; CreatePlayer, COMDAT

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 365  : 	DPNAME dpname;
; 366  : 	HRESULT r;
; 367  : 
; 368  : // setup a name
; 369  : 
; 370  : 	ZeroMemory(&dpname, sizeof(dpname));

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _dpname$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 371  : 	dpname.dwSize = sizeof(dpname);

	mov	DWORD PTR _dpname$[ebp], 16		; 00000010H

; 372  : 	dpname.lpszShortNameA = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _dpname$[ebp+8], eax

; 373  : 	dpname.lpszLongNameA = NULL;

	mov	DWORD PTR _dpname$[ebp+12], 0

; 374  : 
; 375  : // setup player data
; 376  : 
; 377  : 	LocalPlayerData.CarID = GameSettings.CarID;

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+24
	mov	DWORD PTR _LocalPlayerData, eax

; 378  : 
; 379  : // create a player
; 380  : 
; 381  : 	r = DP->CreatePlayer(&LocalPlayerID, &dpname, PlayerEvent, &LocalPlayerData, sizeof(LocalPlayerData), 0);

	push	0
	push	4
	push	OFFSET FLAT:_LocalPlayerData
	mov	eax, DWORD PTR _PlayerEvent
	push	eax
	lea	ecx, DWORD PTR _dpname$[ebp]
	push	ecx
	push	OFFSET FLAT:?LocalPlayerID@@3KA		; LocalPlayerID
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	ecx
	call	DWORD PTR [eax+24]
	mov	DWORD PTR _r$[ebp], eax

; 382  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96359

; 383  : 	{
; 384  : 		ErrorDX(r, "Can't create a player");

	push	OFFSET FLAT:??_C@_0BG@CKMGEKH@Can?8t?5create?5a?5player?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 385  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 386  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96355
$L96359:

; 387  : 	}
; 388  : 
; 389  : // return OK
; 390  : 
; 391  : 	return TRUE;

	mov	al, 1
$L96355:

; 392  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreatePlayer@@YA_NPADJ@Z ENDP				; CreatePlayer
_TEXT	ENDS
PUBLIC	?DisplayPlayers@@YAXXZ				; DisplayPlayers
EXTRN	?PLR_PlayerHead@@3PAUPlayerStruct@@A:DWORD	; PLR_PlayerHead
EXTRN	?DumpText@@YAXFFFFJPAD@Z:NEAR			; DumpText
; Function compile flags: /Odt /ZI
;	COMDAT ?DisplayPlayers@@YAXXZ
_TEXT	SEGMENT
_player$ = -8						; size = 4
_j$ = -4						; size = 2
?DisplayPlayers@@YAXXZ PROC NEAR			; DisplayPlayers, COMDAT

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 400  : 	short j;
; 401  : 	PLAYER *player;
; 402  : 
; 403  : 	j = 128;

	mov	WORD PTR _j$[ebp], 128			; 00000080H

; 404  : 	for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L96366
$L96367:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L96366:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L96363

; 405  : 	{
; 406  : 		DumpText(0, j, 8, 16, 0x000080, player->PlayerName);

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 10244				; 00002804H
	push	eax
	push	128					; 00000080H
	push	16					; 00000010H
	push	8
	mov	cx, WORD PTR _j$[ebp]
	push	ecx
	push	0
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 407  : 		j += 16;

	movsx	eax, WORD PTR _j$[ebp]
	add	eax, 16					; 00000010H
	mov	WORD PTR _j$[ebp], ax

; 408  : 	}

	jmp	SHORT $L96367
$L96363:

; 409  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayPlayers@@YAXXZ ENDP				; DisplayPlayers
_TEXT	ENDS
PUBLIC	?TransmitMessage@@YAXPADFKJ@Z			; TransmitMessage
; Function compile flags: /Odt /ZI
;	COMDAT ?TransmitMessage@@YAXPADFKJ@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_buff$ = 8						; size = 4
_size$ = 12						; size = 2
_to$ = 16						; size = 4
_pri$ = 20						; size = 4
?TransmitMessage@@YAXPADFKJ@Z PROC NEAR			; TransmitMessage, COMDAT

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 417  : 	HRESULT r;
; 418  : 
; 419  : 	r = DP->SendEx(LocalPlayerID, to, DPSEND_ASYNC | DPSEND_NOSENDCOMPLETEMSG, buff, size, pri, 0, NULL, NULL);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pri$[ebp]
	push	eax
	movsx	ecx, WORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buff$[ebp]
	push	edx
	push	1536					; 00000600H
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?LocalPlayerID@@3KA	; LocalPlayerID
	push	ecx
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	ecx
	call	DWORD PTR [eax+196]
	mov	DWORD PTR _r$[ebp], eax

; 420  : //	r = DP->SendEx(LocalPlayerID, to, 0, buff, size, pri, 0, NULL, NULL);
; 421  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransmitMessage@@YAXPADFKJ@Z ENDP			; TransmitMessage
_TEXT	ENDS
PUBLIC	?TransmitMessageGuaranteed@@YAXPADFKJ@Z		; TransmitMessageGuaranteed
; Function compile flags: /Odt /ZI
;	COMDAT ?TransmitMessageGuaranteed@@YAXPADFKJ@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_buff$ = 8						; size = 4
_size$ = 12						; size = 2
_to$ = 16						; size = 4
_pri$ = 20						; size = 4
?TransmitMessageGuaranteed@@YAXPADFKJ@Z PROC NEAR	; TransmitMessageGuaranteed, COMDAT

; 428  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 429  : 	HRESULT r;
; 430  : 
; 431  : 	r = DP->SendEx(LocalPlayerID, to, DPSEND_GUARANTEED, buff, size, pri, 0, NULL, NULL);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pri$[ebp]
	push	eax
	movsx	ecx, WORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buff$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?LocalPlayerID@@3KA	; LocalPlayerID
	push	ecx
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	ecx
	call	DWORD PTR [eax+196]
	mov	DWORD PTR _r$[ebp], eax

; 432  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransmitMessageGuaranteed@@YAXPADFKJ@Z ENDP		; TransmitMessageGuaranteed
_TEXT	ENDS
PUBLIC	??_C@_0BH@FABKFLC@can?8t?5cancel?5priority?$CB?$AA@ ; `string'
PUBLIC	?CancelPriority@@YAXJ@Z				; CancelPriority
;	COMDAT ??_C@_0BH@FABKFLC@can?8t?5cancel?5priority?$CB?$AA@
CONST	SEGMENT
??_C@_0BH@FABKFLC@can?8t?5cancel?5priority?$CB?$AA@ DB 'can''t cancel pri'
	DB	'ority!', 00H				; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CancelPriority@@YAXJ@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_pri$ = 8						; size = 4
?CancelPriority@@YAXJ@Z PROC NEAR			; CancelPriority, COMDAT

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 440  : 	HRESULT r;
; 441  : 
; 442  : 	r = DP->CancelPriority(pri, pri, 0);

	push	0
	mov	eax, DWORD PTR _pri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pri$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	ecx
	call	DWORD PTR [eax+208]
	mov	DWORD PTR _r$[ebp], eax

; 443  : 	if (r != DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L96385

; 444  : 		ErrorDX(r, "can't cancel priority!");

	push	OFFSET FLAT:??_C@_0BH@FABKFLC@can?8t?5cancel?5priority?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8
$L96385:

; 445  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CancelPriority@@YAXJ@Z ENDP				; CancelPriority
_TEXT	ENDS
PUBLIC	?GetRemoteMessages@@YADXZ			; GetRemoteMessages
PUBLIC	?ProcessPersonalMessage@@YAXXZ			; ProcessPersonalMessage
PUBLIC	?ProcessSystemMessage@@YAXXZ			; ProcessSystemMessage
; Function compile flags: /Odt /ZI
;	COMDAT ?GetRemoteMessages@@YADXZ
_TEXT	SEGMENT
_flag$ = -9						; size = 1
_size$ = -8						; size = 4
_r$ = -4						; size = 4
?GetRemoteMessages@@YADXZ PROC NEAR			; GetRemoteMessages, COMDAT

; 452  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 453  : 	HRESULT r;
; 454  : 	DWORD size;
; 455  : 	char flag = FALSE;

	mov	BYTE PTR _flag$[ebp], 0
$L96396:

; 456  : 
; 457  : // get all messages
; 458  : 
; 459  : 	do
; 460  : 	{
; 461  : 
; 462  : // get one
; 463  : 
; 464  : 		size = 1024;

	mov	DWORD PTR _size$[ebp], 1024		; 00000400H

; 465  : 		r = DP->Receive(&FromID, &ToID, DPRECEIVE_ALL, ReceiveBuff, &size);

	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	OFFSET FLAT:?ReceiveBuff@@3PADA		; ReceiveBuff
	push	1
	push	OFFSET FLAT:?ToID@@3KA			; ToID
	push	OFFSET FLAT:?FromID@@3KA		; FromID
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	eax
	call	DWORD PTR [edx+100]
	mov	DWORD PTR _r$[ebp], eax

; 466  : 
; 467  : // valid message?
; 468  : 
; 469  : 		if (r == DP_OK)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $L96397

; 470  : 		{
; 471  : 
; 472  : // set 'got message' flag
; 473  : 
; 474  : 			flag = TRUE;

	mov	BYTE PTR _flag$[ebp], 1

; 475  : 
; 476  : // system message?
; 477  : 
; 478  : 			if (FromID == DPID_SYSMSG)

	cmp	DWORD PTR ?FromID@@3KA, 0		; FromID
	jne	SHORT $L96401

; 479  : 			{
; 480  : 				ProcessSystemMessage();

	call	?ProcessSystemMessage@@YAXXZ		; ProcessSystemMessage

; 481  : 			}
; 482  : 
; 483  : // personal message?
; 484  : 
; 485  : 			else

	jmp	SHORT $L96397
$L96401:

; 486  : 			{
; 487  : 				ProcessPersonalMessage();

	call	?ProcessPersonalMessage@@YAXXZ		; ProcessPersonalMessage
$L96397:

; 488  : 			}
; 489  : 		}
; 490  : 
; 491  : // next message
; 492  : 
; 493  : 	} while (r != DPERR_NOMESSAGES);

	cmp	DWORD PTR _r$[ebp], -2005466946		; 887700beH
	jne	SHORT $L96396

; 494  : 
; 495  : // return
; 496  : 
; 497  : 	return flag;

	mov	al, BYTE PTR _flag$[ebp]

; 498  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRemoteMessages@@YADXZ ENDP				; GetRemoteMessages
_TEXT	ENDS
PUBLIC	?ProcessCarMessage@@YAXXZ			; ProcessCarMessage
PUBLIC	?ProcessPingRequest@@YAXXZ			; ProcessPingRequest
PUBLIC	?ProcessPingReturn@@YAXXZ			; ProcessPingReturn
PUBLIC	?ProcessPlayerReady@@YAXXZ			; ProcessPlayerReady
PUBLIC	??_C@_0CA@BEHPONHA@Can?8t?5find?5Level?5directory?5?8?$CFs?8?$AA@ ; `string'
PUBLIC	?ProcessSyncTimers1@@YAXXZ			; ProcessSyncTimers1
PUBLIC	?ProcessSyncTimers2@@YAXXZ			; ProcessSyncTimers2
PUBLIC	?ProcessSyncTimers3@@YAXXZ			; ProcessSyncTimers3
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	?LevelInf@@3PAULEVELINFO@@A:DWORD		; LevelInf
EXTRN	_strcmp:NEAR
EXTRN	__imp__wsprintfA:NEAR
_BSS	SEGMENT
_GameStarted DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CA@BEHPONHA@Can?8t?5find?5Level?5directory?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0CA@BEHPONHA@Can?8t?5find?5Level?5directory?5?8?$CFs?8?$AA@ DB 'Can'
	DB	'''t find Level directory ''%s''', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ProcessPersonalMessage@@YAXXZ
_TEXT	SEGMENT
tv65 = -208						; size = 4
_header$ = -140						; size = 4
_buf$ = -136						; size = 128
_flag$ = -8						; size = 4
_i$ = -4						; size = 4
?ProcessPersonalMessage@@YAXXZ PROC NEAR		; ProcessPersonalMessage, COMDAT

; 505  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 506  : 	long i, flag;
; 507  : 	char buf[128];
; 508  : 	MESSAGE_HEADER *header = (MESSAGE_HEADER*)ReceiveBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 509  : 
; 510  : // act on message
; 511  : 
; 512  : 	switch (header->Type)

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 7
	ja	$L96409
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $L96969[edx*4]
$L96419:

; 513  : 	{
; 514  : 
; 515  : // game started
; 516  : 
; 517  : 		case MESSAGE_GAME_STARTED:
; 518  : 
; 519  : 			GameStarted = TRUE;

	mov	DWORD PTR _GameStarted, 1

; 520  : 			ServerID = FromID;

	mov	eax, DWORD PTR ?FromID@@3KA		; FromID
	mov	DWORD PTR ?ServerID@@3KA, eax		; ServerID

; 521  : 
; 522  : 			StartData = *(START_DATA*)(header + 1);

	mov	esi, DWORD PTR _header$[ebp]
	add	esi, 4
	mov	ecx, 233				; 000000e9H
	mov	edi, OFFSET FLAT:?StartData@@3USTART_DATA@@A ; StartData
	rep movsd

; 523  : 
; 524  : 			flag = FALSE;

	mov	DWORD PTR _flag$[ebp], 0

; 525  : 			for (i = 0 ; i < GameSettings.LevelNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L96421
$L96422:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L96421:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+8
	jge	SHORT $L96423

; 526  : 			{
; 527  : 				if (!strcmp(StartData.LevelDir, LevelInf[i].Dir))

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	push	OFFSET FLAT:?StartData@@3USTART_DATA@@A+4
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L96424

; 528  : 				{
; 529  : 					GameSettings.Level = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4, eax

; 530  : 					flag = TRUE;

	mov	DWORD PTR _flag$[ebp], 1

; 531  : 					break;

	jmp	SHORT $L96423
$L96424:

; 532  : 				}
; 533  : 			}

	jmp	SHORT $L96422
$L96423:

; 534  : 
; 535  : 			if (!flag)

	cmp	DWORD PTR _flag$[ebp], 0
	jne	SHORT $L96425

; 536  : 			{
; 537  : 				wsprintf(buf, "Can't find Level directory '%s'", StartData.LevelDir);

	push	OFFSET FLAT:?StartData@@3USTART_DATA@@A+4
	push	OFFSET FLAT:??_C@_0CA@BEHPONHA@Can?8t?5find?5Level?5directory?5?8?$CFs?8?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 538  : 				Box(NULL, buf, MB_OK);

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 539  : 				QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame
$L96425:

; 540  : 			}
; 541  : 
; 542  : 		break;

	jmp	SHORT $L96409
$L96427:

; 543  : 
; 544  : // car data
; 545  : 
; 546  : 		case MESSAGE_CAR_DATA:
; 547  : 			ProcessCarMessage();

	call	?ProcessCarMessage@@YAXXZ		; ProcessCarMessage

; 548  : 		break;

	jmp	SHORT $L96409
$L96428:

; 549  : 
; 550  : // ping request
; 551  : 
; 552  : 		case MESSAGE_PING_REQUEST:
; 553  : 			ProcessPingRequest();

	call	?ProcessPingRequest@@YAXXZ		; ProcessPingRequest

; 554  : 		break;

	jmp	SHORT $L96409
$L96429:

; 555  : 
; 556  : // ping return
; 557  : 
; 558  : 		case MESSAGE_PING_RETURN:
; 559  : 			ProcessPingReturn();

	call	?ProcessPingReturn@@YAXXZ		; ProcessPingReturn

; 560  : 		break;

	jmp	SHORT $L96409
$L96430:

; 561  : 
; 562  : // client ready
; 563  : 
; 564  : 		case MESSAGE_PLAYER_READY:
; 565  : 			ProcessPlayerReady();

	call	?ProcessPlayerReady@@YAXXZ		; ProcessPlayerReady

; 566  : 		break;

	jmp	SHORT $L96409
$L96431:

; 567  : 
; 568  : // syncing timers 1
; 569  : 
; 570  : 		case MESSAGE_SYNC_TIMERS1:
; 571  : 			ProcessSyncTimers1();

	call	?ProcessSyncTimers1@@YAXXZ		; ProcessSyncTimers1

; 572  : 		break;

	jmp	SHORT $L96409
$L96432:

; 573  : 
; 574  : // syncing timers 2
; 575  : 
; 576  : 		case MESSAGE_SYNC_TIMERS2:
; 577  : 			ProcessSyncTimers2();

	call	?ProcessSyncTimers2@@YAXXZ		; ProcessSyncTimers2

; 578  : 		break;

	jmp	SHORT $L96409
$L96433:

; 579  : 
; 580  : // syncing timers 3
; 581  : 
; 582  : 		case MESSAGE_SYNC_TIMERS3:
; 583  : 			ProcessSyncTimers3();

	call	?ProcessSyncTimers3@@YAXXZ		; ProcessSyncTimers3
$L96409:

; 584  : 		break;
; 585  : 	}
; 586  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L96969:
	DD	$L96419
	DD	$L96427
	DD	$L96428
	DD	$L96429
	DD	$L96430
	DD	$L96431
	DD	$L96432
	DD	$L96433
?ProcessPersonalMessage@@YAXXZ ENDP			; ProcessPersonalMessage
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	__real@42c80000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3f800000
PUBLIC	__real@40400000
PUBLIC	__real@447a0000
EXTRN	?NextRemoteData@@YAPAURemoteDataStruct@@PAUCarStruct@@@Z:NEAR ; NextRemoteData
EXTRN	__fltused:NEAR
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ProcessCarMessage@@YAXXZ
_TEXT	SEGMENT
tv393 = -96						; size = 4
tv389 = -96						; size = 4
tv385 = -96						; size = 4
tv375 = -96						; size = 4
tv371 = -96						; size = 4
tv367 = -96						; size = 4
tv328 = -96						; size = 4
tv324 = -96						; size = 4
tv320 = -96						; size = 4
tv316 = -96						; size = 4
_qLen$96458 = -28					; size = 4
_ptr$ = -24						; size = 4
_sh$ = -20						; size = 4
_header$ = -16						; size = 4
_player$ = -12						; size = 4
_car$ = -8						; size = 4
_rem$ = -4						; size = 4
?ProcessCarMessage@@YAXXZ PROC NEAR			; ProcessCarMessage, COMDAT

; 593  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 594  : 	REMOTE_DATA *rem;
; 595  : 	CAR *car;
; 596  : 	PLAYER *player;
; 597  : 	MESSAGE_HEADER *header = (MESSAGE_HEADER*)ReceiveBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 598  : 	short *sh;
; 599  : 	char *ptr = (char*)(header + 1);

	mov	eax, DWORD PTR _header$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 600  : 
; 601  : // get relevant car
; 602  : 
; 603  : 	for (player = PLR_PlayerHead ; player ; player = player->next) if ((player->type == PLAYER_REMOTE) && (FromID == player->PlayerID))

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L96444
$L96445:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L96444:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L96446
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $L96447
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR ?FromID@@3KA		; FromID
	cmp	ecx, DWORD PTR [eax+10308]
	jne	SHORT $L96447

; 604  : 	{
; 605  : 		car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 606  : 		break;

	jmp	SHORT $L96446
$L96447:

; 607  : 	}
; 608  : 
; 609  : // get remote data struct to fill
; 610  : 
; 611  : 	rem = NextRemoteData(car);

	jmp	SHORT $L96445
$L96446:
	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?NextRemoteData@@YAPAURemoteDataStruct@@PAUCarStruct@@@Z ; NextRemoteData
	add	esp, 4
	mov	DWORD PTR _rem$[ebp], eax

; 612  : 
; 613  : 	rem->PacketInfo = 0;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [eax], 0

; 614  : 
; 615  : // set packet arrival time
; 616  : 
; 617  : 	rem->PacketInfo |= REMOTE_TIME;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [edx], ecx

; 618  : 
; 619  : // get pos?
; 620  : 
; 621  : 	if (header->Contents & MESSAGE_CONTENTS_CAR_POS)

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	and	ecx, 2
	je	SHORT $L96448

; 622  : 	{
; 623  : 		CopyVec((VEC*)ptr, &rem->Pos);

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+16], edx

; 624  : 		rem->PacketInfo |= REMOTE_POS;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [edx], ecx

; 625  : 		ptr += sizeof(VEC);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _ptr$[ebp], eax
$L96448:

; 626  : 	}
; 627  : 
; 628  : // get quat?
; 629  : 
; 630  : 	if (header->Contents & MESSAGE_CONTENTS_CAR_QUAT)

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	and	ecx, 4
	je	$L96453

; 631  : 	{
; 632  : 		rem->Quat.v[VX] = ((REAL)*ptr++ / CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv316[ebp], ecx
	fild	DWORD PTR tv316[ebp]
	fdiv	DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+44]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 633  : 		rem->Quat.v[VY] = ((REAL)*ptr++ / CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv320[ebp], ecx
	fild	DWORD PTR tv320[ebp]
	fdiv	DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 634  : 		rem->Quat.v[VZ] = ((REAL)*ptr++ / CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv324[ebp], ecx
	fild	DWORD PTR tv324[ebp]
	fdiv	DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 635  : 		rem->Quat.v[S] = ((REAL)*ptr++ / CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv328[ebp], ecx
	fild	DWORD PTR tv328[ebp]
	fdiv	DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+56]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 636  : 		NormalizeQuat(&rem->Quat);

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [edx+48]
	fmul	DWORD PTR [eax+48]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _rem$[ebp]
	mov	edx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [ecx+52]
	fmul	DWORD PTR [edx+52]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+56]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$96458[ebp]
	fld	DWORD PTR _qLen$96458[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L96460
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$96458[ebp]
	fstp	DWORD PTR _qLen$96458[ebp]
	mov	eax, DWORD PTR _rem$[ebp]
	fld	DWORD PTR _qLen$96458[ebp]
	fmul	DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _rem$[ebp]
	fld	DWORD PTR _qLen$96458[ebp]
	fmul	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _rem$[ebp]
	fld	DWORD PTR _qLen$96458[ebp]
	fmul	DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _rem$[ebp]
	fld	DWORD PTR _qLen$96458[ebp]
	fmul	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [ecx+56]
$L96460:

; 637  : 		rem->PacketInfo |= REMOTE_QUAT;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 8
	mov	edx, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [edx], ecx
$L96453:

; 638  : 	}
; 639  : 
; 640  : // get vel?
; 641  : 
; 642  : 	if (header->Contents & MESSAGE_CONTENTS_CAR_VEL)

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	and	ecx, 8
	je	SHORT $L96461

; 643  : 	{
; 644  : 		sh = (short*)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sh$[ebp], eax

; 645  : 		rem->Vel.v[X] = ((REAL)*sh++ / CAR_REMOTE_VEL_SCALE);

	mov	eax, DWORD PTR _sh$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv367[ebp], ecx
	fild	DWORD PTR tv367[ebp]
	fdiv	DWORD PTR __real@40400000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 646  : 		rem->Vel.v[Y] = ((REAL)*sh++ / CAR_REMOTE_VEL_SCALE);

	mov	eax, DWORD PTR _sh$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv371[ebp], ecx
	fild	DWORD PTR tv371[ebp]
	fdiv	DWORD PTR __real@40400000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 647  : 		rem->Vel.v[Z] = ((REAL)*sh++ / CAR_REMOTE_VEL_SCALE);

	mov	eax, DWORD PTR _sh$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv375[ebp], ecx
	fild	DWORD PTR tv375[ebp]
	fdiv	DWORD PTR __real@40400000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 648  : 		rem->PacketInfo |= REMOTE_VEL;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [edx], ecx

; 649  : 		ptr = (char*)sh;

	mov	eax, DWORD PTR _sh$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax
$L96461:

; 650  : 	}
; 651  : 
; 652  : // get ang vel?
; 653  : 
; 654  : 	if (header->Contents & MESSAGE_CONTENTS_CAR_ANGVEL)

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	and	ecx, 16					; 00000010H
	je	SHORT $L96467

; 655  : 	{
; 656  : 		sh = (short*)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sh$[ebp], eax

; 657  : 		rem->AngVel.v[X] = ((REAL)*sh++ / CAR_REMOTE_ANGVEL_SCALE);

	mov	eax, DWORD PTR _sh$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv385[ebp], ecx
	fild	DWORD PTR tv385[ebp]
	fdiv	DWORD PTR __real@447a0000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 658  : 		rem->AngVel.v[Y] = ((REAL)*sh++ / CAR_REMOTE_ANGVEL_SCALE);

	mov	eax, DWORD PTR _sh$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv389[ebp], ecx
	fild	DWORD PTR tv389[ebp]
	fdiv	DWORD PTR __real@447a0000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 659  : 		rem->AngVel.v[Z] = ((REAL)*sh++ / CAR_REMOTE_ANGVEL_SCALE);

	mov	eax, DWORD PTR _sh$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv393[ebp], ecx
	fild	DWORD PTR tv393[ebp]
	fdiv	DWORD PTR __real@447a0000
	mov	edx, DWORD PTR _rem$[ebp]
	fstp	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 660  : 		rem->PacketInfo |= REMOTE_ANGVEL;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 4
	mov	edx, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [edx], ecx

; 661  : 		ptr = (char*)sh;

	mov	eax, DWORD PTR _sh$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax
$L96467:

; 662  : 
; 663  : 	}
; 664  : 
; 665  : // get control input?
; 666  : 
; 667  : 	if (header->Contents & MESSAGE_CONTENTS_CAR_CONTROL)

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	and	ecx, 32					; 00000020H
	je	SHORT $L96473

; 668  : 	{
; 669  : 		rem->dx = *ptr++;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+60], dl
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 670  : 		rem->dy = *ptr++;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+61], dl
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 671  : 		rem->PacketInfo |= REMOTE_CONTROL;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [edx], ecx
$L96473:

; 672  : 	}
; 673  : 
; 674  : 	rem->NewData = TRUE;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	BYTE PTR [eax+4], 1

; 675  : 
; 676  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessCarMessage@@YAXXZ ENDP				; ProcessCarMessage
_TEXT	ENDS
PUBLIC	?RequestPings@@YAXXZ				; RequestPings
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
; Function compile flags: /Odt /ZI
;	COMDAT ?RequestPings@@YAXXZ
_TEXT	SEGMENT
_ptr$ = -12						; size = 4
_header$ = -8						; size = 4
_i$ = -4						; size = 4
?RequestPings@@YAXXZ PROC NEAR				; RequestPings, COMDAT

; 683  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 684  : 	long i;
; 685  : 	MESSAGE_HEADER *header = (MESSAGE_HEADER*)TransmitBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?TransmitBuff@@3PADA ; TransmitBuff

; 686  : 	unsigned long *ptr = (unsigned long*)(header + 1);

	mov	eax, DWORD PTR _header$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 687  : 
; 688  : // zero local player ping
; 689  : 
; 690  : 	for (i = 0 ; i < PlayerCount ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L96482
$L96483:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L96482:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	jge	SHORT $L96484

; 691  : 	{
; 692  : 		if (PlayerList[i].PlayerID == LocalPlayerID)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax]
	cmp	ecx, DWORD PTR ?LocalPlayerID@@3KA	; LocalPlayerID
	jne	SHORT $L96485

; 693  : 			PlayerList[i].Ping = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax+44], 0
$L96485:

; 694  : 	}

	jmp	SHORT $L96483
$L96484:

; 695  : 
; 696  : // setup ping packet
; 697  : 
; 698  : 	header->Type = MESSAGE_PING_REQUEST;

	mov	eax, DWORD PTR _header$[ebp]
	mov	WORD PTR [eax], 2

; 699  : 	ptr[0] = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], eax

; 700  : 
; 701  : // send
; 702  : 
; 703  : 	TransmitMessage(TransmitBuff, sizeof(MESSAGE_HEADER) + sizeof(long), DPID_ALLPLAYERS, MESSAGE_PRIORITY_NORMAL);

	push	0
	push	0
	push	8
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessage@@YAXPADFKJ@Z		; TransmitMessage
	add	esp, 16					; 00000010H

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestPings@@YAXXZ ENDP				; RequestPings
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ProcessPingRequest@@YAXXZ
_TEXT	SEGMENT
_tptr$ = -16						; size = 4
_rptr$ = -12						; size = 4
_theader$ = -8						; size = 4
_rheader$ = -4						; size = 4
?ProcessPingRequest@@YAXXZ PROC NEAR			; ProcessPingRequest, COMDAT

; 711  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 712  : 	MESSAGE_HEADER *rheader = (MESSAGE_HEADER*)ReceiveBuff;

	mov	DWORD PTR _rheader$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 713  : 	MESSAGE_HEADER *theader = (MESSAGE_HEADER*)TransmitBuff;

	mov	DWORD PTR _theader$[ebp], OFFSET FLAT:?TransmitBuff@@3PADA ; TransmitBuff

; 714  : 	long *rptr = (long*)(rheader + 1);

	mov	eax, DWORD PTR _rheader$[ebp]
	add	eax, 4
	mov	DWORD PTR _rptr$[ebp], eax

; 715  : 	long *tptr = (long*)(theader + 1);

	mov	eax, DWORD PTR _theader$[ebp]
	add	eax, 4
	mov	DWORD PTR _tptr$[ebp], eax

; 716  : 
; 717  : // setup return packet
; 718  : 
; 719  : 	theader->Type = MESSAGE_PING_RETURN;

	mov	eax, DWORD PTR _theader$[ebp]
	mov	WORD PTR [eax], 3

; 720  : 	tptr[0] = rptr[0];

	mov	eax, DWORD PTR _tptr$[ebp]
	mov	ecx, DWORD PTR _rptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 721  : 
; 722  : // send
; 723  : 
; 724  : 	TransmitMessage(TransmitBuff, sizeof(MESSAGE_HEADER) + sizeof(long) * 2, FromID, MESSAGE_PRIORITY_NORMAL);

	push	0
	mov	eax, DWORD PTR ?FromID@@3KA		; FromID
	push	eax
	push	12					; 0000000cH
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessage@@YAXPADFKJ@Z		; TransmitMessage
	add	esp, 16					; 00000010H

; 725  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessPingRequest@@YAXXZ ENDP				; ProcessPingRequest
_TEXT	ENDS
EXTRN	?TimerFreq@@3KA:DWORD				; TimerFreq
; Function compile flags: /Odt /ZI
;	COMDAT ?ProcessPingReturn@@YAXXZ
_TEXT	SEGMENT
_ptr$ = -16						; size = 4
_ping$ = -12						; size = 4
_i$ = -8						; size = 4
_header$ = -4						; size = 4
?ProcessPingReturn@@YAXXZ PROC NEAR			; ProcessPingReturn, COMDAT

; 732  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 733  : 	MESSAGE_HEADER *header = (MESSAGE_HEADER*)ReceiveBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 734  : 	long i;
; 735  : 	unsigned long ping, *ptr = (unsigned long*)(header + 1);

	mov	eax, DWORD PTR _header$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 736  : 
; 737  : // get ping time
; 738  : 
; 739  : 	ping = TIME2MS(CurrentTimer() - ptr[0]);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	edx, DWORD PTR _ptr$[ebp]
	sub	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	DWORD PTR _ping$[ebp], eax

; 740  : 
; 741  : // set player ping
; 742  : 
; 743  : 	for (i = 0 ; i < PlayerCount ; i++) if (PlayerList[i].PlayerID == FromID)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L96510
$L96511:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L96510:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	jge	SHORT $L96503
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax]
	cmp	ecx, DWORD PTR ?FromID@@3KA		; FromID
	jne	SHORT $L96513

; 744  : 	{
; 745  : 		PlayerList[i].Ping = ping;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR _ping$[ebp]
	mov	DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax+44], ecx
$L96513:

; 746  : 	}
; 747  : }

	jmp	SHORT $L96511
$L96503:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessPingReturn@@YAXXZ ENDP				; ProcessPingReturn
_TEXT	ENDS
_BSS	SEGMENT
_ReadyFlag DD	01H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?ProcessPlayerReady@@YAXXZ
_TEXT	SEGMENT
_player$ = -4						; size = 4
?ProcessPlayerReady@@YAXXZ PROC NEAR			; ProcessPlayerReady, COMDAT

; 754  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 755  : 	PLAYER *player;
; 756  : 
; 757  : // set player ready flag
; 758  : 
; 759  : 	if (!ReadyFlag)

	cmp	DWORD PTR _ReadyFlag, 0
	jne	SHORT $L96518

; 760  : 		return;

	jmp	SHORT $L96516
$L96518:

; 761  : 
; 762  : 	for (player = PLR_PlayerHead ; player ; player = player->next) if ((player->type == PLAYER_REMOTE) && (FromID == player->PlayerID))

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L96519
$L96520:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L96519:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L96516
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $L96522
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR ?FromID@@3KA		; FromID
	cmp	ecx, DWORD PTR [eax+10308]
	jne	SHORT $L96522

; 763  : 	{
; 764  : 		player->Ready = TRUE;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10240], 1
$L96522:

; 765  : 	}
; 766  : }

	jmp	SHORT $L96520
$L96516:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessPlayerReady@@YAXXZ ENDP				; ProcessPlayerReady
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ProcessSyncTimers1@@YAXXZ
_TEXT	SEGMENT
_tptr$ = -16						; size = 4
_rptr$ = -12						; size = 4
_th$ = -8						; size = 4
_rh$ = -4						; size = 4
?ProcessSyncTimers1@@YAXXZ PROC NEAR			; ProcessSyncTimers1, COMDAT

; 773  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 774  : 	MESSAGE_HEADER *rh = (MESSAGE_HEADER*)ReceiveBuff;

	mov	DWORD PTR _rh$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 775  : 	MESSAGE_HEADER *th = (MESSAGE_HEADER*)TransmitBuff;

	mov	DWORD PTR _th$[ebp], OFFSET FLAT:?TransmitBuff@@3PADA ; TransmitBuff

; 776  : 	unsigned long *rptr = (unsigned long*)(rh + 1);

	mov	eax, DWORD PTR _rh$[ebp]
	add	eax, 4
	mov	DWORD PTR _rptr$[ebp], eax

; 777  : 	unsigned long *tptr = (unsigned long*)(th + 1);

	mov	eax, DWORD PTR _th$[ebp]
	add	eax, 4
	mov	DWORD PTR _tptr$[ebp], eax

; 778  : 
; 779  : // set everyone ready flag
; 780  : 
; 781  : 	ReadyFlag = TRUE;

	mov	DWORD PTR _ReadyFlag, 1

; 782  : 
; 783  : // send back server timer with client timer
; 784  : 
; 785  : 	th->Type = MESSAGE_SYNC_TIMERS2;

	mov	eax, DWORD PTR _th$[ebp]
	mov	WORD PTR [eax], 6

; 786  : 	tptr[0] = rptr[0];

	mov	eax, DWORD PTR _tptr$[ebp]
	mov	ecx, DWORD PTR _rptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 787  : 	tptr[1] = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, DWORD PTR _tptr$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 788  : 
; 789  : 	TransmitMessage(TransmitBuff, sizeof(MESSAGE_HEADER) + sizeof(unsigned long) * 2, FromID, MESSAGE_PRIORITY_NORMAL);

	push	0
	mov	eax, DWORD PTR ?FromID@@3KA		; FromID
	push	eax
	push	12					; 0000000cH
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessage@@YAXPADFKJ@Z		; TransmitMessage
	add	esp, 16					; 00000010H

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessSyncTimers1@@YAXXZ ENDP				; ProcessSyncTimers1
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ProcessSyncTimers2@@YAXXZ
_TEXT	SEGMENT
_tptr$ = -16						; size = 4
_rptr$ = -12						; size = 4
_th$ = -8						; size = 4
_rh$ = -4						; size = 4
?ProcessSyncTimers2@@YAXXZ PROC NEAR			; ProcessSyncTimers2, COMDAT

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 798  : 	MESSAGE_HEADER *rh = (MESSAGE_HEADER*)ReceiveBuff;

	mov	DWORD PTR _rh$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 799  : 	MESSAGE_HEADER *th = (MESSAGE_HEADER*)TransmitBuff;

	mov	DWORD PTR _th$[ebp], OFFSET FLAT:?TransmitBuff@@3PADA ; TransmitBuff

; 800  : 	unsigned long *rptr = (unsigned long*)(rh + 1);

	mov	eax, DWORD PTR _rh$[ebp]
	add	eax, 4
	mov	DWORD PTR _rptr$[ebp], eax

; 801  : 	unsigned long *tptr = (unsigned long*)(th + 1);

	mov	eax, DWORD PTR _th$[ebp]
	add	eax, 4
	mov	DWORD PTR _tptr$[ebp], eax

; 802  : 
; 803  : // calc server to client ping in MS, send it back with client timer
; 804  : 
; 805  : 	th->Type = MESSAGE_SYNC_TIMERS3;

	mov	eax, DWORD PTR _th$[ebp]
	mov	WORD PTR [eax], 7

; 806  : 	tptr[0] = TIME2MS(CurrentTimer() - rptr[0]);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	edx, DWORD PTR _rptr$[ebp]
	sub	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	ecx, DWORD PTR _tptr$[ebp]
	mov	DWORD PTR [ecx], eax

; 807  : 	tptr[1] = rptr[1];

	mov	eax, DWORD PTR _tptr$[ebp]
	mov	ecx, DWORD PTR _rptr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 808  : 
; 809  : 	TransmitMessage(TransmitBuff, sizeof(MESSAGE_HEADER) + sizeof(unsigned long) * 2, FromID, MESSAGE_PRIORITY_NORMAL);

	push	0
	mov	eax, DWORD PTR ?FromID@@3KA		; FromID
	push	eax
	push	12					; 0000000cH
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessage@@YAXPADFKJ@Z		; TransmitMessage
	add	esp, 16					; 00000010H

; 810  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessSyncTimers2@@YAXXZ ENDP				; ProcessSyncTimers2
_TEXT	ENDS
EXTRN	?CountdownTime@@3KA:DWORD			; CountdownTime
EXTRN	?CountdownEndTime@@3KA:DWORD			; CountdownEndTime
; Function compile flags: /Odt /ZI
;	COMDAT ?ProcessSyncTimers3@@YAXXZ
_TEXT	SEGMENT
_ping$ = -12						; size = 4
_ptr$ = -8						; size = 4
_header$ = -4						; size = 4
?ProcessSyncTimers3@@YAXXZ PROC NEAR			; ProcessSyncTimers3, COMDAT

; 817  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 818  : 	MESSAGE_HEADER *header = (MESSAGE_HEADER*)ReceiveBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 819  : 	unsigned long *ptr = (unsigned long*)(header + 1), ping;

	mov	eax, DWORD PTR _header$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 820  : 
; 821  : // guess total 3-way ping
; 822  : 
; 823  : 	ping = TIME2MS(CurrentTimer() - ptr[1]) + (ptr[0] / 2);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	edx, DWORD PTR _ptr$[ebp]
	sub	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 1
	add	eax, edx
	mov	DWORD PTR _ping$[ebp], eax

; 824  : 
; 825  : // set countdown timer
; 826  : 
; 827  : 	CountdownEndTime = CurrentTimer() + MS2TIME(COUNTDOWN_START - ping);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	esi, 1
	sub	esi, DWORD PTR _ping$[ebp]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	edi, 1000				; 000003e8H
	div	edi
	imul	esi, eax
	add	ecx, esi
	mov	DWORD PTR ?CountdownEndTime@@3KA, ecx	; CountdownEndTime

; 828  : 	CountdownTime = TRUE;

	mov	DWORD PTR ?CountdownTime@@3KA, 1	; CountdownTime

; 829  : 
; 830  : // set ready
; 831  : 
; 832  : 	ReadyFlag = TRUE;

	mov	DWORD PTR _ReadyFlag, 1

; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessSyncTimers3@@YAXXZ ENDP				; ProcessSyncTimers3
_TEXT	ENDS
PUBLIC	??_C@_0O@DEKLHJLP@Session?5lost?$CB?$AA@	; `string'
EXTRN	?PLR_KillPlayer@@YAXPAUPlayerStruct@@@Z:NEAR	; PLR_KillPlayer
;	COMDAT ??_C@_0O@DEKLHJLP@Session?5lost?$CB?$AA@
CONST	SEGMENT
??_C@_0O@DEKLHJLP@Session?5lost?$CB?$AA@ DB 'Session lost!', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ProcessSystemMessage@@YAXXZ
_TEXT	SEGMENT
tv64 = -84						; size = 4
_next$ = -16						; size = 4
_player$ = -12						; size = 4
_Player$ = -8						; size = 4
_Message$ = -4						; size = 4
?ProcessSystemMessage@@YAXXZ PROC NEAR			; ProcessSystemMessage, COMDAT

; 840  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 841  : 	DPMSG_GENERIC *Message = (DPMSG_GENERIC*)ReceiveBuff;

	mov	DWORD PTR _Message$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 842  : 	DPMSG_CREATEPLAYERORGROUP *Player;
; 843  : 	PLAYER *player, *next;
; 844  : 
; 845  : 	switch (Message->dwType)

	mov	eax, DWORD PTR _Message$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 5
	je	SHORT $L96570
	cmp	DWORD PTR tv64[ebp], 49			; 00000031H
	je	SHORT $L96577
	cmp	DWORD PTR tv64[ebp], 257		; 00000101H
	je	SHORT $L96579
	jmp	$L96559
$L96570:

; 846  : 	{
; 847  : 
; 848  : // new player joining
; 849  : 
; 850  : 		case DPSYS_CREATEPLAYERORGROUP:
; 851  : 		break;
; 852  : 
; 853  : // existing player leaving
; 854  : 
; 855  : 		case DPSYS_DESTROYPLAYERORGROUP:
; 856  : 			Player = (DPMSG_CREATEPLAYERORGROUP*)ReceiveBuff;

	mov	DWORD PTR _Player$[ebp], OFFSET FLAT:?ReceiveBuff@@3PADA ; ReceiveBuff

; 857  : 			if (Player->dwPlayerType == DPPLAYERTYPE_PLAYER)

	mov	eax, DWORD PTR _Player$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $L96572

; 858  : 			{
; 859  : 				for (player = PLR_PlayerHead ; player ; )

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
$L96574:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L96572

; 860  : 				{
; 861  : 					next = player->next;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _next$[ebp], ecx

; 862  : 					if ((player->type == PLAYER_REMOTE) && player->PlayerID == Player->dpId)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $L96576
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR _Player$[ebp]
	mov	edx, DWORD PTR [eax+10308]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $L96576

; 863  : 					{
; 864  : 						PLR_KillPlayer(player);

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	?PLR_KillPlayer@@YAXPAUPlayerStruct@@@Z	; PLR_KillPlayer
	add	esp, 4
$L96576:

; 865  : 					}
; 866  : 					player = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _player$[ebp], eax

; 867  : 				}

	jmp	SHORT $L96574
$L96572:

; 868  : 			}
; 869  :  		break;

	jmp	SHORT $L96559
$L96577:

; 870  : 
; 871  : // session lost
; 872  : 
; 873  : 		case DPSYS_SESSIONLOST:
; 874  : 			Box(NULL, "Session lost!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0O@DEKLHJLP@Session?5lost?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 875  : 			GameSettings.GameType = GAMETYPE_SESSIONLOST;

	mov	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 4

; 876  :  		break;

	jmp	SHORT $L96559
$L96579:

; 877  : 
; 878  : // become the host
; 879  : 
; 880  : 		case DPSYS_HOST:
; 881  : 			GameSettings.GameType = GAMETYPE_SERVER;

	mov	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 2

; 882  : 			ServerID = LocalPlayerID;

	mov	eax, DWORD PTR ?LocalPlayerID@@3KA	; LocalPlayerID
	mov	DWORD PTR ?ServerID@@3KA, eax		; ServerID
$L96559:

; 883  :  		break;
; 884  : 	}
; 885  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessSystemMessage@@YAXXZ ENDP			; ProcessSystemMessage
_TEXT	ENDS
PUBLIC	?ListPlayers@@YAXPAU_GUID@@@Z			; ListPlayers
PUBLIC	?EnumPlayersCallback@@YGHKKPBUDPNAME@@KPAX@Z	; EnumPlayersCallback
; Function compile flags: /Odt /ZI
;	COMDAT ?ListPlayers@@YAXPAU_GUID@@@Z
_TEXT	SEGMENT
_guid$ = 8						; size = 4
?ListPlayers@@YAXPAU_GUID@@@Z PROC NEAR			; ListPlayers, COMDAT

; 892  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 893  : 	PlayerCount = 0;

	mov	DWORD PTR ?PlayerCount@@3JA, 0		; PlayerCount

; 894  : 	if (!guid) DP->EnumPlayers(NULL, EnumPlayersCallback, NULL, DPENUMPLAYERS_ALL);

	cmp	DWORD PTR _guid$[ebp], 0
	jne	SHORT $L96583
	push	0
	push	0
	push	OFFSET FLAT:?EnumPlayersCallback@@YGHKKPBUDPNAME@@KPAX@Z ; EnumPlayersCallback
	push	0
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+48]

; 895  : 	else DP->EnumPlayers(guid, EnumPlayersCallback, NULL, DPENUMPLAYERS_SESSION);

	jmp	SHORT $L96582
$L96583:
	push	128					; 00000080H
	push	0
	push	OFFSET FLAT:?EnumPlayersCallback@@YGHKKPBUDPNAME@@KPAX@Z ; EnumPlayersCallback
	mov	eax, DWORD PTR _guid$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	eax
	call	DWORD PTR [edx+48]
$L96582:

; 896  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ListPlayers@@YAXPAU_GUID@@@Z ENDP			; ListPlayers
_TEXT	ENDS
EXTRN	_strncpy:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?EnumPlayersCallback@@YGHKKPBUDPNAME@@KPAX@Z
_TEXT	SEGMENT
_size$ = -4						; size = 4
_dpId$ = 8						; size = 4
_dwPlayerType$ = 12					; size = 4
_lpName$ = 16						; size = 4
_dwFlags$ = 20						; size = 4
_lpContext$ = 24					; size = 4
?EnumPlayersCallback@@YGHKKPBUDPNAME@@KPAX@Z PROC NEAR	; EnumPlayersCallback, COMDAT

; 903  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 904  : 	DWORD size;
; 905  : 
; 906  : // skip if max players
; 907  : 
; 908  : 	if (PlayerCount >= MAX_NUM_PLAYERS) return FALSE;

	cmp	DWORD PTR ?PlayerCount@@3JA, 12		; PlayerCount, 0000000cH
	jl	SHORT $L96593
	xor	eax, eax
	jmp	$L96591
$L96593:

; 909  : 
; 910  : // store ID / name
; 911  : 
; 912  : 	PlayerList[PlayerCount].PlayerID = dpId;

	mov	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR _dpId$[ebp]
	mov	DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax], ecx

; 913  : 	strncpy(PlayerList[PlayerCount].Name, lpName->lpszShortNameA, MAX_PLAYER_NAME);

	push	64					; 00000040H
	mov	eax, DWORD PTR _lpName$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	imul	edx, 116				; 00000074H
	add	edx, OFFSET FLAT:?PlayerList@@3PAUDP_PLAYER@@A+48
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 914  : 	DP->GetPlayerCaps(PlayerList[PlayerCount].PlayerID, &PlayerList[PlayerCount].Caps, NULL);

	push	0
	mov	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	imul	eax, 116				; 00000074H
	add	eax, OFFSET FLAT:?PlayerList@@3PAUDP_PLAYER@@A+4
	push	eax
	mov	ecx, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	imul	ecx, 116				; 00000074H
	mov	edx, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[ecx]
	push	edx
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+76]

; 915  : 
; 916  : // get player data
; 917  : 
; 918  : 	size = sizeof(DP_PLAYER_DATA);

	mov	DWORD PTR _size$[ebp], 4

; 919  : 	DP->GetPlayerData(PlayerList[PlayerCount].PlayerID, &PlayerList[PlayerCount].Data, &size, DPGET_REMOTE);

	push	0
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	imul	ecx, 116				; 00000074H
	add	ecx, OFFSET FLAT:?PlayerList@@3PAUDP_PLAYER@@A+112
	push	ecx
	mov	edx, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	imul	edx, 116				; 00000074H
	mov	eax, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[edx]
	push	eax
	mov	ecx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	eax
	call	DWORD PTR [edx+80]

; 920  : 
; 921  : // return OK
; 922  : 
; 923  : 	PlayerCount++;

	mov	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	add	eax, 1
	mov	DWORD PTR ?PlayerCount@@3JA, eax	; PlayerCount

; 924  : 	return TRUE;

	mov	eax, 1
$L96591:

; 925  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?EnumPlayersCallback@@YGHKKPBUDPNAME@@KPAX@Z ENDP	; EnumPlayersCallback
_TEXT	ENDS
PUBLIC	?ConnectionMenu@@YAXXZ				; ConnectionMenu
PUBLIC	?GetSessionName@@YAXXZ				; GetSessionName
PUBLIC	?LookForSessions@@YAXXZ				; LookForSessions
PUBLIC	??_C@_0BD@JAPOONBC@Select?5Connection?3?$AA@	; `string'
EXTRN	?MenuCount@@3FA:WORD				; MenuCount
EXTRN	?CheckSurfaces@@YAXXZ:NEAR			; CheckSurfaces
EXTRN	?FlipBuffers@@YAXXZ:NEAR			; FlipBuffers
EXTRN	?ClearBuffers@@YAXXZ:NEAR			; ClearBuffers
EXTRN	?BackBuffer@@3PAUIDirectDrawSurface4@@A:DWORD	; BackBuffer
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
EXTRN	?ReadKeyboard@@YAXXZ:NEAR			; ReadKeyboard
EXTRN	?ReadMouse@@YAXXZ:NEAR				; ReadMouse
EXTRN	?Keys@@3PADA:BYTE				; Keys
EXTRN	?LastKeys@@3PADA:BYTE				; LastKeys
EXTRN	?TitleHbm@@3PAUHBITMAP__@@A:DWORD		; TitleHbm
EXTRN	?Event@@3P6AXXZA:DWORD				; Event
EXTRN	?BlitBitmap@@YAHPAUHBITMAP__@@PAPAUIDirectDrawSurface4@@@Z:NEAR ; BlitBitmap
EXTRN	?BeginTextState@@YAXXZ:NEAR			; BeginTextState
EXTRN	?MainMenu@@YAXXZ:NEAR				; MainMenu
_BSS	SEGMENT
_SessionRequestTime DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@JAPOONBC@Select?5Connection?3?$AA@
CONST	SEGMENT
??_C@_0BD@JAPOONBC@Select?5Connection?3?$AA@ DB 'Select Connection:', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ConnectionMenu@@YAXXZ
_TEXT	SEGMENT
_col$ = -8						; size = 4
_i$ = -4						; size = 2
?ConnectionMenu@@YAXXZ PROC NEAR			; ConnectionMenu, COMDAT

; 932  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 933  : 	short i;
; 934  : 	long col;
; 935  : 
; 936  : // buffer flip / clear
; 937  : 
; 938  : 	CheckSurfaces();

	call	?CheckSurfaces@@YAXXZ			; CheckSurfaces

; 939  : 	FlipBuffers();

	call	?FlipBuffers@@YAXXZ			; FlipBuffers

; 940  : 	ClearBuffers();

	call	?ClearBuffers@@YAXXZ			; ClearBuffers

; 941  : 
; 942  : // update pos
; 943  : 
; 944  : 	ReadMouse();

	call	?ReadMouse@@YAXXZ			; ReadMouse

; 945  : 	ReadKeyboard();

	call	?ReadKeyboard@@YAXXZ			; ReadKeyboard

; 946  : 
; 947  : 	if (Keys[DIK_UP] && !LastKeys[DIK_UP] && MenuCount) MenuCount--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+200
	test	eax, eax
	je	SHORT $L96600
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+200
	test	eax, eax
	jne	SHORT $L96600
	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	test	eax, eax
	je	SHORT $L96600
	mov	ax, WORD PTR ?MenuCount@@3FA		; MenuCount
	sub	ax, 1
	mov	WORD PTR ?MenuCount@@3FA, ax		; MenuCount
$L96600:

; 948  : 	if (Keys[DIK_DOWN] && !LastKeys[DIK_DOWN] && MenuCount < ConnectionCount - 1) MenuCount++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+208
	test	eax, eax
	je	SHORT $L96601
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+208
	test	eax, eax
	jne	SHORT $L96601
	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	movsx	ecx, BYTE PTR _ConnectionCount
	sub	ecx, 1
	cmp	eax, ecx
	jge	SHORT $L96601
	mov	ax, WORD PTR ?MenuCount@@3FA		; MenuCount
	add	ax, 1
	mov	WORD PTR ?MenuCount@@3FA, ax		; MenuCount
$L96601:

; 949  : 
; 950  : // show menu
; 951  : 
; 952  : 	D3Ddevice->BeginScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+36]

; 953  : 
; 954  : 	BlitBitmap(TitleHbm, &BackBuffer);

	push	OFFSET FLAT:?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	mov	eax, DWORD PTR ?TitleHbm@@3PAUHBITMAP__@@A ; TitleHbm
	push	eax
	call	?BlitBitmap@@YAHPAUHBITMAP__@@PAPAUIDirectDrawSurface4@@@Z ; BlitBitmap
	add	esp, 8

; 955  : 
; 956  : 	BeginTextState();

	call	?BeginTextState@@YAXXZ			; BeginTextState

; 957  : 
; 958  : 	DumpText(128, 112, 12, 24, 0x808000, "Select Connection:");

	push	OFFSET FLAT:??_C@_0BD@JAPOONBC@Select?5Connection?3?$AA@
	push	8421376					; 00808000H
	push	24					; 00000018H
	push	12					; 0000000cH
	push	112					; 00000070H
	push	128					; 00000080H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 959  : 
; 960  : 	for (i = 0 ; i < ConnectionCount ; i++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L96603
$L96604:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L96603:
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _ConnectionCount
	cmp	eax, ecx
	jge	SHORT $L96605

; 961  : 	{
; 962  : 		if (MenuCount == i) col = 0xff0000;

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	eax, ecx
	jne	SHORT $L96606
	mov	DWORD PTR _col$[ebp], 16711680		; 00ff0000H

; 963  : 		else col = 0x808080;

	jmp	SHORT $L96607
$L96606:
	mov	DWORD PTR _col$[ebp], 8421504		; 00808080H
$L96607:

; 964  : 		DumpText(128, i * 48 + 176, 12, 24, col, Connection[i].Name);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	add	eax, OFFSET FLAT:_Connection+4
	push	eax
	mov	ecx, DWORD PTR _col$[ebp]
	push	ecx
	push	24					; 00000018H
	push	12					; 0000000cH
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	add	edx, 176				; 000000b0H
	push	edx
	push	128					; 00000080H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 965  : 	}

	jmp	SHORT $L96604
$L96605:

; 966  : 
; 967  : 	D3Ddevice->EndScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+40]

; 968  : 
; 969  : // selected?
; 970  : 
; 971  : 	if (Keys[DIK_ESCAPE] && !LastKeys[DIK_ESCAPE])

	movsx	eax, BYTE PTR ?Keys@@3PADA+1
	test	eax, eax
	je	SHORT $L96608
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+1
	test	eax, eax
	jne	SHORT $L96608

; 972  : 	{
; 973  : 		KillPlay();

	call	?KillPlay@@YAXXZ			; KillPlay

; 974  : 		MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 975  : 		Event = MainMenu;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?MainMenu@@YAXXZ ; Event, MainMenu
$L96608:

; 976  : 	}		
; 977  : 
; 978  : 	if (Keys[DIK_RETURN] && !LastKeys[DIK_RETURN])

	movsx	eax, BYTE PTR ?Keys@@3PADA+28
	test	eax, eax
	je	SHORT $L96597
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+28
	test	eax, eax
	jne	SHORT $L96597

; 979  : 	{
; 980  : 		InitConnection((char)MenuCount);

	mov	al, BYTE PTR ?MenuCount@@3FA
	push	eax
	call	?InitConnection@@YA_ND@Z		; InitConnection
	add	esp, 4

; 981  : 
; 982  : 		if (GameSettings.GameType == GAMETYPE_SERVER)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 2
	jne	SHORT $L96611

; 983  : 		{
; 984  : 			MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 985  : 			Event = GetSessionName;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?GetSessionName@@YAXXZ ; Event, GetSessionName

; 986  : 		}
; 987  : 
; 988  : 		else

	jmp	SHORT $L96597
$L96611:

; 989  : 		{
; 990  : 			MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 991  : 			SessionCount = 0;

	mov	BYTE PTR _SessionCount, 0

; 992  : 			SessionRequestTime = 0.0f;

	mov	DWORD PTR _SessionRequestTime, 0

; 993  : 			Event = LookForSessions;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?LookForSessions@@YAXXZ ; Event, LookForSessions
$L96597:

; 994  : 		}
; 995  : 	}
; 996  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConnectionMenu@@YAXXZ ENDP				; ConnectionMenu
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?HostWait@@YAXXZ				; HostWait
PUBLIC	??_C@_0BB@MIMJOPLF@Enter?5Game?5Name?3?$AA@	; `string'
EXTRN	?GetKeyPress@@YAEXZ:NEAR			; GetKeyPress
EXTRN	?RegistrySettings@@3UREGISTRY_SETTINGS@@A:BYTE	; RegistrySettings
_BSS	SEGMENT
_PingRequestTime DD 01H DUP (?)
_SessionName DB	022H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@MIMJOPLF@Enter?5Game?5Name?3?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\play.cpp
CONST	SEGMENT
??_C@_0BB@MIMJOPLF@Enter?5Game?5Name?3?$AA@ DB 'Enter Game Name:', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?GetSessionName@@YAXXZ
_TEXT	SEGMENT
_c$ = -1						; size = 1
?GetSessionName@@YAXXZ PROC NEAR			; GetSessionName, COMDAT

; 1003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1004 : 	unsigned char c;
; 1005 : 
; 1006 : // buffer flip / clear
; 1007 : 
; 1008 : 	CheckSurfaces();

	call	?CheckSurfaces@@YAXXZ			; CheckSurfaces

; 1009 : 	FlipBuffers();

	call	?FlipBuffers@@YAXXZ			; FlipBuffers

; 1010 : 	ClearBuffers();

	call	?ClearBuffers@@YAXXZ			; ClearBuffers

; 1011 : 
; 1012 : // get a key
; 1013 : 
; 1014 : 	ReadMouse();

	call	?ReadMouse@@YAXXZ			; ReadMouse

; 1015 : 	ReadKeyboard();

	call	?ReadKeyboard@@YAXXZ			; ReadKeyboard

; 1016 : 
; 1017 : 	if ((c = GetKeyPress()))

	call	?GetKeyPress@@YAEXZ			; GetKeyPress
	mov	BYTE PTR _c$[ebp], al
	movzx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	$L96617

; 1018 : 	{
; 1019 : 
; 1020 : // backspace
; 1021 : 
; 1022 : 		if (c == 8)

	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 8
	jne	SHORT $L96618

; 1023 : 		{
; 1024 : 			if (MenuCount) MenuCount--;

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	test	eax, eax
	je	SHORT $L96619
	mov	ax, WORD PTR ?MenuCount@@3FA		; MenuCount
	sub	ax, 1
	mov	WORD PTR ?MenuCount@@3FA, ax		; MenuCount
$L96619:

; 1025 : 		}
; 1026 : 
; 1027 : // tab
; 1028 : 
; 1029 : 		else if (c == 9)

	jmp	$L96617
$L96618:
	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 9
	jne	SHORT $L96621

; 1030 : 		{
; 1031 : 			MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 1032 : 		}
; 1033 : 
; 1034 : // enter
; 1035 : 
; 1036 : 		else if (c == 13)

	jmp	$L96617
$L96621:
	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $L96623

; 1037 : 		{
; 1038 : 			SessionName[MenuCount] = 0;

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	mov	BYTE PTR _SessionName[eax], 0

; 1039 : 			CreateSession(SessionName);

	push	OFFSET FLAT:_SessionName
	call	?CreateSession@@YA_NPAD@Z		; CreateSession
	add	esp, 4

; 1040 : 			CreatePlayer(RegistrySettings.PlayerName, TRUE);

	push	1
	push	OFFSET FLAT:?RegistrySettings@@3UREGISTRY_SETTINGS@@A+60
	call	?CreatePlayer@@YA_NPADJ@Z		; CreatePlayer
	add	esp, 8

; 1041 : 			PingRequestTime = 0.0f;

	mov	DWORD PTR _PingRequestTime, 0

; 1042 : 			Event = HostWait;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?HostWait@@YAXXZ ; Event, HostWait

; 1043 : 		}
; 1044 : 
; 1045 : // escape
; 1046 : 
; 1047 : 		else if (c == 27)

	jmp	SHORT $L96617
$L96623:
	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 27					; 0000001bH
	jne	SHORT $L96625

; 1048 : 		{
; 1049 : 			MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 1050 : 			KillPlay();

	call	?KillPlay@@YAXXZ			; KillPlay

; 1051 : 			InitPlay();

	call	?InitPlay@@YA_NXZ			; InitPlay

; 1052 : 			Event = ConnectionMenu;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?ConnectionMenu@@YAXXZ ; Event, ConnectionMenu

; 1053 : 		}
; 1054 : 
; 1055 : // normal key
; 1056 : 
; 1057 : 		else if (MenuCount < MAX_SESSION_NAME - 2)

	jmp	SHORT $L96617
$L96625:
	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	cmp	eax, 32					; 00000020H
	jge	SHORT $L96617

; 1058 : 		{
; 1059 : 			SessionName[MenuCount++] = c;

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR _SessionName[eax], cl
	mov	dx, WORD PTR ?MenuCount@@3FA		; MenuCount
	add	dx, 1
	mov	WORD PTR ?MenuCount@@3FA, dx		; MenuCount
$L96617:

; 1060 : 		}
; 1061 : 	}
; 1062 : 
; 1063 : // print name
; 1064 : 
; 1065 : 	D3Ddevice->BeginScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+36]

; 1066 : 
; 1067 : 	BlitBitmap(TitleHbm, &BackBuffer);

	push	OFFSET FLAT:?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	mov	eax, DWORD PTR ?TitleHbm@@3PAUHBITMAP__@@A ; TitleHbm
	push	eax
	call	?BlitBitmap@@YAHPAUHBITMAP__@@PAPAUIDirectDrawSurface4@@@Z ; BlitBitmap
	add	esp, 8

; 1068 : 
; 1069 : 	BeginTextState();

	call	?BeginTextState@@YAXXZ			; BeginTextState

; 1070 : 
; 1071 : 	DumpText(208, 224, 12, 24, 0x808000, "Enter Game Name:");

	push	OFFSET FLAT:??_C@_0BB@MIMJOPLF@Enter?5Game?5Name?3?$AA@
	push	8421376					; 00808000H
	push	24					; 00000018H
	push	12					; 0000000cH
	push	224					; 000000e0H
	push	208					; 000000d0H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1072 : 	SessionName[MenuCount] = '_';

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	mov	BYTE PTR _SessionName[eax], 95		; 0000005fH

; 1073 : 	SessionName[MenuCount + 1] = 0;

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	mov	BYTE PTR _SessionName[eax+1], 0

; 1074 : 	DumpText(128, 276, 12, 24, 0x808080, SessionName);

	push	OFFSET FLAT:_SessionName
	push	8421504					; 00808080H
	push	24					; 00000018H
	push	12					; 0000000cH
	push	276					; 00000114H
	push	128					; 00000080H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1075 : 
; 1076 : 	D3Ddevice->EndScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+40]

; 1077 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSessionName@@YAXXZ ENDP				; GetSessionName
_TEXT	ENDS
PUBLIC	?ClientWait@@YAXXZ				; ClientWait
PUBLIC	??_C@_0P@CKJOPMII@Choose?5a?5Game?3?$AA@	; `string'
PUBLIC	??_C@_06IOLFCPIM@CLOSED?$AA@			; `string'
PUBLIC	??_C@_04DANIOFHI@OPEN?$AA@			; `string'
PUBLIC	??_C@_08OPGJMNB@Players?3?$AA@			; `string'
PUBLIC	__real@00000000
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?UpdateTimeFactor@@YAXXZ:NEAR			; UpdateTimeFactor
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0P@CKJOPMII@Choose?5a?5Game?3?$AA@
CONST	SEGMENT
??_C@_0P@CKJOPMII@Choose?5a?5Game?3?$AA@ DB 'Choose a Game:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IOLFCPIM@CLOSED?$AA@
CONST	SEGMENT
??_C@_06IOLFCPIM@CLOSED?$AA@ DB 'CLOSED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DANIOFHI@OPEN?$AA@
CONST	SEGMENT
??_C@_04DANIOFHI@OPEN?$AA@ DB 'OPEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OPGJMNB@Players?3?$AA@
CONST	SEGMENT
??_C@_08OPGJMNB@Players?3?$AA@ DB 'Players:', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LookForSessions@@YAXXZ
_TEXT	SEGMENT
_state$ = -16						; size = 7
_col$ = -8						; size = 4
_i$ = -4						; size = 2
?LookForSessions@@YAXXZ PROC NEAR			; LookForSessions, COMDAT

; 1084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1085 : 	short i;
; 1086 : 	long col;
; 1087 : 	char state[7];
; 1088 : 
; 1089 : // buffer flip / clear
; 1090 : 
; 1091 : 	CheckSurfaces();

	call	?CheckSurfaces@@YAXXZ			; CheckSurfaces

; 1092 : 	FlipBuffers();

	call	?FlipBuffers@@YAXXZ			; FlipBuffers

; 1093 : 	ClearBuffers();

	call	?ClearBuffers@@YAXXZ			; ClearBuffers

; 1094 : 
; 1095 : // read keyboard / mouse / timers
; 1096 : 
; 1097 : 	UpdateTimeFactor();

	call	?UpdateTimeFactor@@YAXXZ		; UpdateTimeFactor

; 1098 : 	ReadMouse();

	call	?ReadMouse@@YAXXZ			; ReadMouse

; 1099 : 	ReadKeyboard();

	call	?ReadKeyboard@@YAXXZ			; ReadKeyboard

; 1100 : 
; 1101 : // dump back piccy
; 1102 : 
; 1103 : 	BlitBitmap(TitleHbm, &BackBuffer);

	push	OFFSET FLAT:?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	mov	eax, DWORD PTR ?TitleHbm@@3PAUHBITMAP__@@A ; TitleHbm
	push	eax
	call	?BlitBitmap@@YAHPAUHBITMAP__@@PAPAUIDirectDrawSurface4@@@Z ; BlitBitmap
	add	esp, 8

; 1104 : 
; 1105 : // begin scene
; 1106 : 
; 1107 : 	D3Ddevice->BeginScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+36]

; 1108 : 
; 1109 : // request sessions?
; 1110 : 
; 1111 : 	SessionRequestTime -= TimeStep;

	fld	DWORD PTR _SessionRequestTime
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _SessionRequestTime

; 1112 : 	if (SessionRequestTime < 0.0f)

	fld	DWORD PTR _SessionRequestTime
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L96635

; 1113 : 	{
; 1114 : 		ListSessions();

	call	?ListSessions@@YAXXZ			; ListSessions

; 1115 : 		SessionRequestTime = 2.0f;

	mov	DWORD PTR _SessionRequestTime, 1073741824 ; 40000000H

; 1116 : 
; 1117 : 		if (SessionCount)

	movsx	eax, BYTE PTR _SessionCount
	test	eax, eax
	je	SHORT $L96635

; 1118 : 		{
; 1119 : 			if (MenuCount > SessionCount - 1) MenuCount = SessionCount - 1;

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	movsx	ecx, BYTE PTR _SessionCount
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $L96637
	movsx	eax, BYTE PTR _SessionCount
	sub	eax, 1
	mov	WORD PTR ?MenuCount@@3FA, ax		; MenuCount
$L96637:

; 1120 : 			ListPlayers(&SessionList[MenuCount].Guid);

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	imul	eax, 56					; 00000038H
	add	eax, OFFSET FLAT:_SessionList
	push	eax
	call	?ListPlayers@@YAXPAU_GUID@@@Z		; ListPlayers
	add	esp, 4
$L96635:

; 1121 : 		}
; 1122 : 	}
; 1123 : 
; 1124 : // display sessions
; 1125 : 
; 1126 : 	BeginTextState();

	call	?BeginTextState@@YAXXZ			; BeginTextState

; 1127 : 
; 1128 : 	DumpText(264, 16, 8, 16, 0x808000, "Choose a Game:");

	push	OFFSET FLAT:??_C@_0P@CKJOPMII@Choose?5a?5Game?3?$AA@
	push	8421376					; 00808000H
	push	16					; 00000010H
	push	8
	push	16					; 00000010H
	push	264					; 00000108H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1129 : 
; 1130 : 	for (i = 0 ; i < SessionCount ; i++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L96639
$L96640:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L96639:
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _SessionCount
	cmp	eax, ecx
	jge	$L96641

; 1131 : 	{
; 1132 : 		if (MenuCount == i) col = 0xff0000;

	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	eax, ecx
	jne	SHORT $L96642
	mov	DWORD PTR _col$[ebp], 16711680		; 00ff0000H

; 1133 : 		else col = 0x808080;

	jmp	SHORT $L96643
$L96642:
	mov	DWORD PTR _col$[ebp], 8421504		; 00808080H
$L96643:

; 1134 : 		DumpText(168, i * 16 + 48, 8, 16, col, SessionList[i].Name);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 56					; 00000038H
	add	eax, OFFSET FLAT:_SessionList+20
	push	eax
	mov	ecx, DWORD PTR _col$[ebp]
	push	ecx
	push	16					; 00000010H
	push	8
	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, 48					; 00000030H
	push	edx
	push	168					; 000000a8H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1135 : 		if (SessionList[i].Flags & DPSESSION_JOINDISABLED) memcpy(state, "CLOSED", sizeof(state));

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _SessionList[eax+16]
	and	ecx, 32					; 00000020H
	je	SHORT $L96644
	push	7
	push	OFFSET FLAT:??_C@_06IOLFCPIM@CLOSED?$AA@
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1136 : 		else memcpy(state, "OPEN", sizeof(state));

	jmp	SHORT $L96646
$L96644:
	push	7
	push	OFFSET FLAT:??_C@_04DANIOFHI@OPEN?$AA@
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$L96646:

; 1137 : 		DumpText(432, i * 16 + 48, 8, 16, 0x808000, state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	push	8421376					; 00808000H
	push	16					; 00000010H
	push	8
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, 48					; 00000030H
	push	ecx
	push	432					; 000001b0H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1138 : 	}

	jmp	$L96640
$L96641:

; 1139 : 
; 1140 : // list players in selected session
; 1141 : 
; 1142 : 	if (!SessionCount) PlayerCount = 0;

	movsx	eax, BYTE PTR _SessionCount
	test	eax, eax
	jne	SHORT $L96648
	mov	DWORD PTR ?PlayerCount@@3JA, 0		; PlayerCount
$L96648:

; 1143 : 
; 1144 : 	if (PlayerCount)

	cmp	DWORD PTR ?PlayerCount@@3JA, 0		; PlayerCount
	je	SHORT $L96649

; 1145 : 	{
; 1146 : 		DumpText(288, 192, 8, 16, 0x808000, "Players:");

	push	OFFSET FLAT:??_C@_08OPGJMNB@Players?3?$AA@
	push	8421376					; 00808000H
	push	16					; 00000010H
	push	8
	push	192					; 000000c0H
	push	288					; 00000120H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1147 : 		for (i = 0 ; i < PlayerCount ; i++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L96651
$L96652:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L96651:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	jge	SHORT $L96649

; 1148 : 		{
; 1149 : 			DumpText(168, i * 16 + 224, 8, 16, 0xff0000, PlayerList[i].Name);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	add	eax, OFFSET FLAT:?PlayerList@@3PAUDP_PLAYER@@A+48
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, 224				; 000000e0H
	push	ecx
	push	168					; 000000a8H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1150 : 		}

	jmp	SHORT $L96652
$L96649:

; 1151 : 	}
; 1152 : 
; 1153 : // end scene
; 1154 : 
; 1155 : 	D3Ddevice->EndScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+40]

; 1156 : 
; 1157 : // up / down
; 1158 : 
; 1159 : 	if (Keys[DIK_UP] && !LastKeys[DIK_UP] && MenuCount) MenuCount--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+200
	test	eax, eax
	je	SHORT $L96654
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+200
	test	eax, eax
	jne	SHORT $L96654
	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	test	eax, eax
	je	SHORT $L96654
	mov	ax, WORD PTR ?MenuCount@@3FA		; MenuCount
	sub	ax, 1
	mov	WORD PTR ?MenuCount@@3FA, ax		; MenuCount
$L96654:

; 1160 : 	if (Keys[DIK_DOWN] && !LastKeys[DIK_DOWN]) MenuCount++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+208
	test	eax, eax
	je	SHORT $L96655
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+208
	test	eax, eax
	jne	SHORT $L96655
	mov	ax, WORD PTR ?MenuCount@@3FA		; MenuCount
	add	ax, 1
	mov	WORD PTR ?MenuCount@@3FA, ax		; MenuCount
$L96655:

; 1161 : 	if (SessionCount && MenuCount >= SessionCount) MenuCount = SessionCount - 1;

	movsx	eax, BYTE PTR _SessionCount
	test	eax, eax
	je	SHORT $L96656
	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	movsx	ecx, BYTE PTR _SessionCount
	cmp	eax, ecx
	jl	SHORT $L96656
	movsx	eax, BYTE PTR _SessionCount
	sub	eax, 1
	mov	WORD PTR ?MenuCount@@3FA, ax		; MenuCount
$L96656:

; 1162 : 
; 1163 : // quit
; 1164 : 
; 1165 : 	if (Keys[DIK_ESCAPE] && !LastKeys[DIK_ESCAPE])

	movsx	eax, BYTE PTR ?Keys@@3PADA+1
	test	eax, eax
	je	SHORT $L96657
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+1
	test	eax, eax
	jne	SHORT $L96657

; 1166 : 	{
; 1167 : 		StopSessionEnum();

	call	?StopSessionEnum@@YAXXZ			; StopSessionEnum

; 1168 : 		KillPlay();

	call	?KillPlay@@YAXXZ			; KillPlay

; 1169 : 		InitPlay();

	call	?InitPlay@@YA_NXZ			; InitPlay

; 1170 : 		MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 1171 : 		Event = ConnectionMenu;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?ConnectionMenu@@YAXXZ ; Event, ConnectionMenu
$L96657:

; 1172 : 	}
; 1173 : 
; 1174 : // join
; 1175 : 
; 1176 : 	if (Keys[DIK_RETURN] && !LastKeys[DIK_RETURN] && SessionCount && !(SessionList[MenuCount].Flags & DPSESSION_JOINDISABLED))

	movsx	eax, BYTE PTR ?Keys@@3PADA+28
	test	eax, eax
	je	SHORT $L96631
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+28
	test	eax, eax
	jne	SHORT $L96631
	movsx	eax, BYTE PTR _SessionCount
	test	eax, eax
	je	SHORT $L96631
	movsx	eax, WORD PTR ?MenuCount@@3FA		; MenuCount
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _SessionList[eax+16]
	and	ecx, 32					; 00000020H
	jne	SHORT $L96631

; 1177 : 	{
; 1178 : 		JoinSession((char)MenuCount);

	mov	al, BYTE PTR ?MenuCount@@3FA
	push	eax
	call	?JoinSession@@YA_ND@Z			; JoinSession
	add	esp, 4

; 1179 : 		CreatePlayer(RegistrySettings.PlayerName, FALSE);

	push	0
	push	OFFSET FLAT:?RegistrySettings@@3UREGISTRY_SETTINGS@@A+60
	call	?CreatePlayer@@YA_NPADJ@Z		; CreatePlayer
	add	esp, 8

; 1180 : 		GameStarted = FALSE;

	mov	DWORD PTR _GameStarted, 0

; 1181 : 		PingRequestTime = 0.0f;

	mov	DWORD PTR _PingRequestTime, 0

; 1182 : 		Event = ClientWait;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?ClientWait@@YAXXZ ; Event, ClientWait
$L96631:

; 1183 : 	}
; 1184 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LookForSessions@@YAXXZ ENDP				; LookForSessions
_TEXT	ENDS
PUBLIC	??_C@_0BL@IPEEFNCK@Hit?5Enter?5To?5Start?5Game?4?4?4?$AA@ ; `string'
PUBLIC	??_C@_03JALODAI@?$CFld?$AA@			; `string'
EXTRN	_rand:NEAR
EXTRN	?SetupGame@@YAXXZ:NEAR				; SetupGame
;	COMDAT ??_C@_0BL@IPEEFNCK@Hit?5Enter?5To?5Start?5Game?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BL@IPEEFNCK@Hit?5Enter?5To?5Start?5Game?4?4?4?$AA@ DB 'Hit Enter T'
	DB	'o Start Game...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld?$AA@ DB '%ld', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?HostWait@@YAXXZ
_TEXT	SEGMENT
_buf$ = -192						; size = 128
_header$ = -64						; size = 4
_gridused$ = -60					; size = 48
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
?HostWait@@YAXXZ PROC NEAR				; HostWait, COMDAT

; 1191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi

; 1192 : 	long i, j, k, gridused[MAX_NUM_PLAYERS];
; 1193 : 	MESSAGE_HEADER *header;
; 1194 : 	char buf[128];
; 1195 : 
; 1196 : // buffer flip / clear
; 1197 : 
; 1198 : 	CheckSurfaces();

	call	?CheckSurfaces@@YAXXZ			; CheckSurfaces

; 1199 : 	FlipBuffers();

	call	?FlipBuffers@@YAXXZ			; FlipBuffers

; 1200 : 	ClearBuffers();

	call	?ClearBuffers@@YAXXZ			; ClearBuffers

; 1201 : 
; 1202 : // read keyboard / mouse / timers
; 1203 : 
; 1204 : 	UpdateTimeFactor();

	call	?UpdateTimeFactor@@YAXXZ		; UpdateTimeFactor

; 1205 : 	ReadMouse();

	call	?ReadMouse@@YAXXZ			; ReadMouse

; 1206 : 	ReadKeyboard();

	call	?ReadKeyboard@@YAXXZ			; ReadKeyboard

; 1207 : 
; 1208 : // display current players
; 1209 : 
; 1210 : 	D3Ddevice->BeginScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+36]

; 1211 : 
; 1212 : 	BlitBitmap(TitleHbm, &BackBuffer);

	push	OFFSET FLAT:?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	mov	eax, DWORD PTR ?TitleHbm@@3PAUHBITMAP__@@A ; TitleHbm
	push	eax
	call	?BlitBitmap@@YAHPAUHBITMAP__@@PAPAUIDirectDrawSurface4@@@Z ; BlitBitmap
	add	esp, 8

; 1213 : 
; 1214 : 	BeginTextState();

	call	?BeginTextState@@YAXXZ			; BeginTextState

; 1215 : 
; 1216 : 	DumpText(288, 64, 8, 16, 0x808000, "Players:");

	push	OFFSET FLAT:??_C@_08OPGJMNB@Players?3?$AA@
	push	8421376					; 00808000H
	push	16					; 00000010H
	push	8
	push	64					; 00000040H
	push	288					; 00000120H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1217 : 	DumpText(216, 400, 8, 16, 0x808000, "Hit Enter To Start Game...");

	push	OFFSET FLAT:??_C@_0BL@IPEEFNCK@Hit?5Enter?5To?5Start?5Game?4?4?4?$AA@
	push	8421376					; 00808000H
	push	16					; 00000010H
	push	8
	push	400					; 00000190H
	push	216					; 000000d8H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1218 : 
; 1219 : 	ListPlayers(NULL);

	push	0
	call	?ListPlayers@@YAXPAU_GUID@@@Z		; ListPlayers
	add	esp, 4

; 1220 : 
; 1221 : 	PingRequestTime -= TimeStep;

	fld	DWORD PTR _PingRequestTime
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _PingRequestTime

; 1222 : 	if (PingRequestTime < 0.0f)

	fld	DWORD PTR _PingRequestTime
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L96670

; 1223 : 	{
; 1224 : 		RequestPings();

	call	?RequestPings@@YAXXZ			; RequestPings

; 1225 : 		PingRequestTime = 2.0f;

	mov	DWORD PTR _PingRequestTime, 1073741824	; 40000000H
$L96670:

; 1226 : 	}
; 1227 : 
; 1228 : 	GetRemoteMessages();

	call	?GetRemoteMessages@@YADXZ		; GetRemoteMessages

; 1229 : 
; 1230 : 	for (i = 0 ; i < PlayerCount ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L96671
$L96672:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L96671:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	jge	SHORT $L96673

; 1231 : 	{
; 1232 : 		DumpText(192, i * 16 + 96, 8, 16, 0xff0000, PlayerList[i].Name);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	add	eax, OFFSET FLAT:?PlayerList@@3PAUDP_PLAYER@@A+48
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, 96					; 00000060H
	push	ecx
	push	192					; 000000c0H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1233 : 		wsprintf(buf, "%ld", PlayerList[i].Ping);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax+44]
	push	ecx
	push	OFFSET FLAT:??_C@_03JALODAI@?$CFld?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 1234 : 		DumpText(448, i * 16 + 96, 8, 16, 0xff0000, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, 96					; 00000060H
	push	ecx
	push	448					; 000001c0H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1235 : 	}

	jmp	$L96672
$L96673:

; 1236 : 
; 1237 : 	D3Ddevice->EndScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+40]

; 1238 : 
; 1239 : // quit?
; 1240 : 
; 1241 : 	if (Keys[DIK_ESCAPE] && !LastKeys[DIK_ESCAPE])

	movsx	eax, BYTE PTR ?Keys@@3PADA+1
	test	eax, eax
	je	SHORT $L96675
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+1
	test	eax, eax
	jne	SHORT $L96675

; 1242 : 	{
; 1243 : 		DP->Close();

	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+16]

; 1244 : 		Event = GetSessionName;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?GetSessionName@@YAXXZ ; Event, GetSessionName
$L96675:

; 1245 : 	}
; 1246 : 
; 1247 : // start game?
; 1248 : 
; 1249 : 	if (Keys[DIK_RETURN] && !LastKeys[DIK_RETURN])

	movsx	eax, BYTE PTR ?Keys@@3PADA+28
	test	eax, eax
	je	$L96662
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+28
	test	eax, eax
	jne	$L96662

; 1250 : 	{
; 1251 : 
; 1252 : // yep, disable game for new players
; 1253 : 
; 1254 : 		Session.dwFlags |= DPSESSION_JOINDISABLED;

	mov	eax, DWORD PTR _Session+4
	or	eax, 32					; 00000020H
	mov	DWORD PTR _Session+4, eax

; 1255 : 		DP->SetSessionDesc(&Session, NULL);

	push	0
	push	OFFSET FLAT:_Session
	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+124]

; 1256 : 
; 1257 : // setup start data
; 1258 : 
; 1259 : 		StartData.PlayerNum = PlayerCount;

	mov	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	mov	DWORD PTR ?StartData@@3USTART_DATA@@A, eax

; 1260 : 		strncpy(StartData.LevelDir, LevelInf[GameSettings.Level].Dir, MAX_LEVEL_DIR_NAME);

	push	16					; 00000010H
	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	push	OFFSET FLAT:?StartData@@3USTART_DATA@@A+4
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1261 : 
; 1262 : 		for (i = 0 ; i < StartData.PlayerNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L96677
$L96678:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L96677:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?StartData@@3USTART_DATA@@A
	jge	SHORT $L96679

; 1263 : 			gridused[i] = FALSE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _gridused$[ebp+eax*4], 0
	jmp	SHORT $L96678
$L96679:

; 1264 : 
; 1265 : 		for (i = 0 ; i < StartData.PlayerNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L96680
$L96681:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L96680:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?StartData@@3USTART_DATA@@A
	jge	$L96682

; 1266 : 		{
; 1267 : 			StartData.PlayerData[i].PlayerID = PlayerList[i].PlayerID;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax]
	mov	DWORD PTR ?StartData@@3USTART_DATA@@A[ecx+28], edx

; 1268 : 			StartData.PlayerData[i].CarID = PlayerList[i].Data.CarID;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax+112]
	mov	DWORD PTR ?StartData@@3USTART_DATA@@A[ecx+24], edx

; 1269 : 			strncpy(StartData.PlayerData[i].Name, PlayerList[i].Name, MAX_PLAYER_NAME);

	push	64					; 00000040H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	add	eax, OFFSET FLAT:?PlayerList@@3PAUDP_PLAYER@@A+48
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 76					; 0000004cH
	add	ecx, OFFSET FLAT:?StartData@@3USTART_DATA@@A+32
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1270 : 
; 1271 : 			k = (rand() % (StartData.PlayerNum - i)) + 1;

	call	_rand
	mov	ecx, DWORD PTR ?StartData@@3USTART_DATA@@A
	sub	ecx, DWORD PTR _i$[ebp]
	cdq
	idiv	ecx
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 1272 : 			for (j = 0 ; j < StartData.PlayerNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L96683
$L96684:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L96683:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?StartData@@3USTART_DATA@@A
	jge	SHORT $L96685

; 1273 : 			{
; 1274 : 				if (!gridused[j])

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _gridused$[ebp+eax*4], 0
	jne	SHORT $L96686

; 1275 : 					k--;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L96686:

; 1276 : 
; 1277 : 				if (!k)

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $L96687

; 1278 : 				{
; 1279 : 					StartData.PlayerData[i].GridNum = j;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR ?StartData@@3USTART_DATA@@A[eax+20], ecx

; 1280 : 					gridused[j] = TRUE;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _gridused$[ebp+eax*4], 1

; 1281 : 					break;

	jmp	SHORT $L96685
$L96687:

; 1282 : 				}
; 1283 : 			}

	jmp	SHORT $L96684
$L96685:

; 1284 : 		}

	jmp	$L96681
$L96682:

; 1285 : 
; 1286 : // go!
; 1287 : 
; 1288 : 		header = (MESSAGE_HEADER*)TransmitBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?TransmitBuff@@3PADA ; TransmitBuff

; 1289 : 		header->Type = MESSAGE_GAME_STARTED;

	mov	eax, DWORD PTR _header$[ebp]
	mov	WORD PTR [eax], 0

; 1290 : 
; 1291 : 		memcpy(header + 1, &StartData, sizeof(START_DATA));

	push	932					; 000003a4H
	push	OFFSET FLAT:?StartData@@3USTART_DATA@@A
	mov	eax, DWORD PTR _header$[ebp]
	add	eax, 4
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1292 : 
; 1293 : 		TransmitMessageGuaranteed(TransmitBuff, sizeof(MESSAGE_HEADER) + sizeof(START_DATA), DPID_ALLPLAYERS, MESSAGE_PRIORITY_NORMAL);

	push	0
	push	0
	push	936					; 000003a8H
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessageGuaranteed@@YAXPADFKJ@Z	; TransmitMessageGuaranteed
	add	esp, 16					; 00000010H

; 1294 : 		ReadyFlag = FALSE;

	mov	DWORD PTR _ReadyFlag, 0

; 1295 : 
; 1296 : 		Event = SetupGame;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?SetupGame@@YAXXZ ; Event, SetupGame
$L96662:

; 1297 : 	}
; 1298 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HostWait@@YAXXZ ENDP					; HostWait
_TEXT	ENDS
PUBLIC	??_C@_0BE@HCDHJLHD@Waiting?5For?5Host?4?4?4?$AA@ ; `string'
;	COMDAT ??_C@_0BE@HCDHJLHD@Waiting?5For?5Host?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BE@HCDHJLHD@Waiting?5For?5Host?4?4?4?$AA@ DB 'Waiting For Host...', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ClientWait@@YAXXZ
_TEXT	SEGMENT
_buf$ = -132						; size = 128
_i$ = -4						; size = 2
?ClientWait@@YAXXZ PROC NEAR				; ClientWait, COMDAT

; 1305 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 1306 : 	short i;
; 1307 : 	char buf[128];
; 1308 : 
; 1309 : // buffer flip / clear
; 1310 : 
; 1311 : 	CheckSurfaces();

	call	?CheckSurfaces@@YAXXZ			; CheckSurfaces

; 1312 : 	FlipBuffers();

	call	?FlipBuffers@@YAXXZ			; FlipBuffers

; 1313 : 	ClearBuffers();

	call	?ClearBuffers@@YAXXZ			; ClearBuffers

; 1314 : 
; 1315 : // read keyboard / mouse / timers
; 1316 : 
; 1317 : 	UpdateTimeFactor();

	call	?UpdateTimeFactor@@YAXXZ		; UpdateTimeFactor

; 1318 : 	ReadMouse();

	call	?ReadMouse@@YAXXZ			; ReadMouse

; 1319 : 	ReadKeyboard();

	call	?ReadKeyboard@@YAXXZ			; ReadKeyboard

; 1320 : 
; 1321 : // display current players
; 1322 : 
; 1323 : 	D3Ddevice->BeginScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+36]

; 1324 : 
; 1325 : 	BlitBitmap(TitleHbm, &BackBuffer);

	push	OFFSET FLAT:?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	mov	eax, DWORD PTR ?TitleHbm@@3PAUHBITMAP__@@A ; TitleHbm
	push	eax
	call	?BlitBitmap@@YAHPAUHBITMAP__@@PAPAUIDirectDrawSurface4@@@Z ; BlitBitmap
	add	esp, 8

; 1326 : 
; 1327 : 	BeginTextState();

	call	?BeginTextState@@YAXXZ			; BeginTextState

; 1328 : 
; 1329 : 	DumpText(288, 64, 8, 16, 0x808000, "Players:");

	push	OFFSET FLAT:??_C@_08OPGJMNB@Players?3?$AA@
	push	8421376					; 00808000H
	push	16					; 00000010H
	push	8
	push	64					; 00000040H
	push	288					; 00000120H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1330 : 	DumpText(240, 400, 8, 16, 0x808000, "Waiting For Host...");

	push	OFFSET FLAT:??_C@_0BE@HCDHJLHD@Waiting?5For?5Host?4?4?4?$AA@
	push	8421376					; 00808000H
	push	16					; 00000010H
	push	8
	push	400					; 00000190H
	push	240					; 000000f0H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1331 : 
; 1332 : 	ListPlayers(NULL);

	push	0
	call	?ListPlayers@@YAXPAU_GUID@@@Z		; ListPlayers
	add	esp, 4

; 1333 : 
; 1334 : 	PingRequestTime -= TimeStep;

	fld	DWORD PTR _PingRequestTime
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _PingRequestTime

; 1335 : 	if (PingRequestTime < 0.0f)

	fld	DWORD PTR _PingRequestTime
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L96698

; 1336 : 	{
; 1337 : 		RequestPings();

	call	?RequestPings@@YAXXZ			; RequestPings

; 1338 : 		PingRequestTime = 2.0f;

	mov	DWORD PTR _PingRequestTime, 1073741824	; 40000000H
$L96698:

; 1339 : 	}
; 1340 : 
; 1341 : 	GetRemoteMessages();

	call	?GetRemoteMessages@@YADXZ		; GetRemoteMessages

; 1342 : 
; 1343 : 	for (i = 0 ; i < PlayerCount ; i++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L96699
$L96700:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L96699:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?PlayerCount@@3JA	; PlayerCount
	jge	SHORT $L96701

; 1344 : 	{
; 1345 : 		DumpText(192, i * 16 + 96, 8, 16, 0xff0000, PlayerList[i].Name);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	add	eax, OFFSET FLAT:?PlayerList@@3PAUDP_PLAYER@@A+48
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, 96					; 00000060H
	push	ecx
	push	192					; 000000c0H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1346 : 		wsprintf(buf, "%ld", PlayerList[i].Ping);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 116				; 00000074H
	mov	ecx, DWORD PTR ?PlayerList@@3PAUDP_PLAYER@@A[eax+44]
	push	ecx
	push	OFFSET FLAT:??_C@_03JALODAI@?$CFld?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 1347 : 		DumpText(448, i * 16 + 96, 8, 16, 0xff0000, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, 96					; 00000060H
	push	ecx
	push	448					; 000001c0H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 1348 : 	}

	jmp	$L96700
$L96701:

; 1349 : 
; 1350 : 	D3Ddevice->EndScene();

	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+40]

; 1351 : 
; 1352 : // quit?
; 1353 : 
; 1354 : 	if ((Keys[DIK_ESCAPE] && !LastKeys[DIK_ESCAPE]) || GameSettings.GameType != GAMETYPE_CLIENT)

	movsx	eax, BYTE PTR ?Keys@@3PADA+1
	test	eax, eax
	je	SHORT $L96704
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+1
	test	eax, eax
	je	SHORT $L96703
$L96704:
	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 3
	je	SHORT $L96702
$L96703:

; 1355 : 	{
; 1356 : 		DP->Close();

	mov	eax, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DP@@3PAUIDirectPlay4@@A	; DP
	push	edx
	call	DWORD PTR [ecx+16]

; 1357 : 		MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 1358 : 		GameSettings.GameType = GAMETYPE_CLIENT;

	mov	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 3

; 1359 : 		Event = LookForSessions;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?LookForSessions@@YAXXZ ; Event, LookForSessions
$L96702:

; 1360 : 	}
; 1361 : 
; 1362 : // host started?
; 1363 : 
; 1364 : 	if (GameStarted)

	cmp	DWORD PTR _GameStarted, 0
	je	SHORT $L96694

; 1365 : 	{
; 1366 : 		Event = SetupGame;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?SetupGame@@YAXXZ ; Event, SetupGame
$L96694:

; 1367 : 	}
; 1368 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClientWait@@YAXXZ ENDP					; ClientWait
_TEXT	ENDS
PUBLIC	?GetHostDetails@@YADXZ				; GetHostDetails
EXTRN	_gethostbyname@4:NEAR
EXTRN	_gethostname@8:NEAR
_BSS	SEGMENT
	ALIGN	4

?hostname@?1??GetHostDetails@@YADXZ@4PADA DB 0400H DUP (?) ; `GetHostDetails'::`2'::hostname
_IP	DB	04H DUP (?)
_HostName DB	0400H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?GetHostDetails@@YADXZ
_TEXT	SEGMENT
_he$ = -8						; size = 4
_r$ = -4						; size = 4
?GetHostDetails@@YADXZ PROC NEAR			; GetHostDetails, COMDAT

; 1375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1376 : 	int r;
; 1377 : 	static char hostname[1024];
; 1378 : 	HOSTENT *he;
; 1379 : 
; 1380 : // get host name
; 1381 : 
; 1382 : 	r = gethostname(hostname, sizeof(hostname));

	push	1024					; 00000400H
	push	OFFSET FLAT:?hostname@?1??GetHostDetails@@YADXZ@4PADA
	call	_gethostname@8
	mov	DWORD PTR _r$[ebp], eax

; 1383 : 	if (r == SOCKET_ERROR)

	cmp	DWORD PTR _r$[ebp], -1
	jne	SHORT $L96713

; 1384 : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96708
$L96713:

; 1385 : 
; 1386 : // get host details
; 1387 : 
; 1388 : 	he = gethostbyname(hostname);

	push	OFFSET FLAT:?hostname@?1??GetHostDetails@@YADXZ@4PADA
	call	_gethostbyname@4
	mov	DWORD PTR _he$[ebp], eax

; 1389 : 	if (!he)

	cmp	DWORD PTR _he$[ebp], 0
	jne	SHORT $L96714

; 1390 : 		return FALSE;

	xor	al, al
	jmp	SHORT $L96708
$L96714:

; 1391 : 
; 1392 : // store host details
; 1393 : 
; 1394 : 	memcpy(HostName, he->h_name, MAX_HOST_NAME);

	push	1024					; 00000400H
	mov	eax, DWORD PTR _he$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET FLAT:_HostName
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1395 : 
; 1396 : 	IP[0] = (*he->h_addr_list)[0];

	mov	eax, DWORD PTR _he$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _IP, al

; 1397 : 	IP[1] = (*he->h_addr_list)[1];

	mov	eax, DWORD PTR _he$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _IP+1, al

; 1398 : 	IP[2] = (*he->h_addr_list)[2];

	mov	eax, DWORD PTR _he$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _IP+2, al

; 1399 : 	IP[3] = (*he->h_addr_list)[3];

	mov	eax, DWORD PTR _he$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _IP+3, al

; 1400 : 
; 1401 : // return OK
; 1402 : 
; 1403 : 	return TRUE;

	mov	al, 1
$L96708:

; 1404 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHostDetails@@YADXZ ENDP				; GetHostDetails
_TEXT	ENDS
PUBLIC	?CheckLegalIP@@YADXZ				; CheckLegalIP
; Function compile flags: /Odt /ZI
;	COMDAT ?CheckLegalIP@@YADXZ
_TEXT	SEGMENT
_lip$ = -4						; size = 4
?CheckLegalIP@@YADXZ PROC NEAR				; CheckLegalIP, COMDAT

; 1411 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1412 : 	LEGAL_IP *lip;
; 1413 : 
; 1414 : // init play
; 1415 : 
; 1416 : 	if (!InitPlay())

	call	?InitPlay@@YA_NXZ			; InitPlay
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L96719

; 1417 : 		return FALSE;

	xor	al, al
	jmp	$L96717
$L96719:

; 1418 : 
; 1419 : 	if (!InitConnection(0))

	push	0
	call	?InitConnection@@YA_ND@Z		; InitConnection
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L96720

; 1420 : 	{
; 1421 : 		KillPlay();

	call	?KillPlay@@YAXXZ			; KillPlay

; 1422 : 		return FALSE;

	xor	al, al
	jmp	$L96717
$L96720:

; 1423 : 	}
; 1424 : 
; 1425 : // get host details
; 1426 : 
; 1427 : 	if (!GetHostDetails())

	call	?GetHostDetails@@YADXZ			; GetHostDetails
	movsx	eax, al
	test	eax, eax
	jne	SHORT $L96721

; 1428 : 	{
; 1429 : 		KillPlay();

	call	?KillPlay@@YAXXZ			; KillPlay

; 1430 : 		return FALSE;

	xor	al, al
	jmp	$L96717
$L96721:

; 1431 : 	}
; 1432 : 
; 1433 : // kill play
; 1434 : 
; 1435 : 	KillPlay();

	call	?KillPlay@@YAXXZ			; KillPlay

; 1436 : 
; 1437 : // check for a legal IP
; 1438 : 
; 1439 : 	for (lip = LegalIP ; *(long*)lip->Mask ; lip++)

	mov	DWORD PTR _lip$[ebp], OFFSET FLAT:?LegalIP@@3PAULEGAL_IP@@A ; LegalIP
	jmp	SHORT $L96723
$L96724:
	mov	eax, DWORD PTR _lip$[ebp]
	add	eax, 8
	mov	DWORD PTR _lip$[ebp], eax
$L96723:
	mov	eax, DWORD PTR _lip$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L96725

; 1440 : 	{
; 1441 : 		if ((IP[0] & lip->Mask[0]) == lip->IP[0] &&
; 1442 : 			(IP[1] & lip->Mask[1]) == lip->IP[1] &&
; 1443 : 			(IP[2] & lip->Mask[2]) == lip->IP[2] &&
; 1444 : 			(IP[3] & lip->Mask[3]) == lip->IP[3])

	movzx	eax, BYTE PTR _IP
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	eax, edx
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	cmp	eax, edx
	jne	SHORT $L96726
	movzx	eax, BYTE PTR _IP+1
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	eax, edx
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx+5]
	cmp	eax, edx
	jne	SHORT $L96726
	movzx	eax, BYTE PTR _IP+2
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	and	eax, edx
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx+6]
	cmp	eax, edx
	jne	SHORT $L96726
	movzx	eax, BYTE PTR _IP+3
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	and	eax, edx
	mov	ecx, DWORD PTR _lip$[ebp]
	movzx	edx, BYTE PTR [ecx+7]
	cmp	eax, edx
	jne	SHORT $L96726

; 1445 : 				return TRUE;

	mov	al, 1
	jmp	SHORT $L96717
$L96726:

; 1446 : 	}

	jmp	$L96724
$L96725:

; 1447 : 
; 1448 : // illegal IP
; 1449 : 
; 1450 : 	return FALSE;

	xor	al, al
$L96717:

; 1451 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckLegalIP@@YADXZ ENDP				; CheckLegalIP
_TEXT	ENDS
PUBLIC	?RemoteSync@@YAXXZ				; RemoteSync
PUBLIC	??_C@_0CH@CLAJAHAN@Timed?5out?5waiting?5for?5players?5to@ ; `string'
PUBLIC	??_C@_0CH@DFOKBENB@Timed?5out?5waiting?5for?5server?5to?5@ ; `string'
;	COMDAT ??_C@_0CH@CLAJAHAN@Timed?5out?5waiting?5for?5players?5to@
CONST	SEGMENT
??_C@_0CH@CLAJAHAN@Timed?5out?5waiting?5for?5players?5to@ DB 'Timed out w'
	DB	'aiting for players to load!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DFOKBENB@Timed?5out?5waiting?5for?5server?5to?5@
CONST	SEGMENT
??_C@_0CH@DFOKBENB@Timed?5out?5waiting?5for?5server?5to?5@ DB 'Timed out '
	DB	'waiting for server to start!', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RemoteSync@@YAXXZ
_TEXT	SEGMENT
_header$ = -28						; size = 4
_player$ = -24						; size = 4
_sendtime$ = -20					; size = 4
_starttime$ = -16					; size = 4
_time$ = -12						; size = 4
_quit$ = -8						; size = 4
_flag$ = -4						; size = 4
?RemoteSync@@YAXXZ PROC NEAR				; RemoteSync, COMDAT

; 1458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1459 : 	unsigned long flag, quit, time, starttime, sendtime;
; 1460 : 	PLAYER *player;
; 1461 : 	MESSAGE_HEADER *header = (MESSAGE_HEADER*)TransmitBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?TransmitBuff@@3PADA ; TransmitBuff

; 1462 : 
; 1463 : // server
; 1464 : 
; 1465 : 	if (GameSettings.GameType == GAMETYPE_SERVER)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 2
	jne	$L96738

; 1466 : 	{
; 1467 : 
; 1468 : // zero ready flags
; 1469 : 
; 1470 : 		for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L96739
$L96740:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L96739:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L96741

; 1471 : 			player->Ready = FALSE;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10240], 0
	jmp	SHORT $L96740
$L96741:

; 1472 : 
; 1473 : 		ReadyFlag = TRUE;

	mov	DWORD PTR _ReadyFlag, 1

; 1474 : 
; 1475 : // wait for all loaded
; 1476 : 
; 1477 : 		quit = FALSE;

	mov	DWORD PTR _quit$[ebp], 0

; 1478 : 		starttime = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR _starttime$[ebp], eax
$L96743:

; 1479 : 
; 1480 : 		while (!quit)

	cmp	DWORD PTR _quit$[ebp], 0
	jne	$L96744

; 1481 : 		{
; 1482 : 			GetRemoteMessages();

	call	?GetRemoteMessages@@YADXZ		; GetRemoteMessages

; 1483 : 
; 1484 : 			time = TIME2MS(CurrentTimer() - starttime);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	sub	ecx, DWORD PTR _starttime$[ebp]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	DWORD PTR _time$[ebp], eax

; 1485 : 			if (time > (1000 * 60))

	cmp	DWORD PTR _time$[ebp], 60000		; 0000ea60H
	jbe	SHORT $L96745

; 1486 : 			{
; 1487 : 				Box(NULL, "Timed out waiting for players to load!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CH@CLAJAHAN@Timed?5out?5waiting?5for?5players?5to@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 1488 : 				quit = TRUE;

	mov	DWORD PTR _quit$[ebp], 1
$L96745:

; 1489 : 			}
; 1490 : 
; 1491 : 			flag = 0;

	mov	DWORD PTR _flag$[ebp], 0

; 1492 : 			for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L96747
$L96748:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L96747:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L96749

; 1493 : 				if (player->type == PLAYER_REMOTE && !player->Ready)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $L96750
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+10240], 0
	jne	SHORT $L96750

; 1494 : 					flag++;

	mov	eax, DWORD PTR _flag$[ebp]
	add	eax, 1
	mov	DWORD PTR _flag$[ebp], eax
$L96750:

; 1495 : 
; 1496 : 			if (!flag)

	jmp	SHORT $L96748
$L96749:
	cmp	DWORD PTR _flag$[ebp], 0
	jne	SHORT $L96751

; 1497 : 				quit = TRUE;

	mov	DWORD PTR _quit$[ebp], 1
$L96751:

; 1498 : 
; 1499 : 			if (GameSettings.GameType == GAMETYPE_SESSIONLOST)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 4
	jne	SHORT $L96752

; 1500 : 			{
; 1501 : 				QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 1502 : 				return;

	jmp	$L96729
$L96752:

; 1503 : 			}
; 1504 : 		}

	jmp	$L96743
$L96744:

; 1505 : 
; 1506 : // all loaded, start game
; 1507 : 
; 1508 : 		CountdownEndTime = CurrentTimer() + MS2TIME(COUNTDOWN_START);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	add	ecx, eax
	mov	DWORD PTR ?CountdownEndTime@@3KA, ecx	; CountdownEndTime

; 1509 : 		CountdownTime = TRUE;

	mov	DWORD PTR ?CountdownTime@@3KA, 1	; CountdownTime

; 1510 : 
; 1511 : 		header->Type = MESSAGE_SYNC_TIMERS1;

	mov	eax, DWORD PTR _header$[ebp]
	mov	WORD PTR [eax], 5

; 1512 : 		*(unsigned long*)(header + 1) = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, DWORD PTR _header$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1513 : 		TransmitMessage(TransmitBuff, sizeof(MESSAGE_HEADER) + sizeof(unsigned long), DPID_ALLPLAYERS, MESSAGE_PRIORITY_NORMAL);

	push	0
	push	0
	push	8
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessage@@YAXPADFKJ@Z		; TransmitMessage
	add	esp, 16					; 00000010H

; 1514 : 	}
; 1515 : 
; 1516 : // client
; 1517 : 
; 1518 : 	else

	jmp	$L96729
$L96738:

; 1519 : 	{
; 1520 : 
; 1521 : // send ready messages until everyone loaded
; 1522 : 
; 1523 : 		ReadyFlag = FALSE;

	mov	DWORD PTR _ReadyFlag, 0

; 1524 : 		starttime = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR _starttime$[ebp], eax

; 1525 : 		sendtime = 0;

	mov	DWORD PTR _sendtime$[ebp], 0
$L96758:

; 1526 : 
; 1527 : 		while (!ReadyFlag)

	cmp	DWORD PTR _ReadyFlag, 0
	jne	$L96759

; 1528 : 		{
; 1529 : 			GetRemoteMessages();

	call	?GetRemoteMessages@@YADXZ		; GetRemoteMessages

; 1530 : 
; 1531 : 			time = TIME2MS(CurrentTimer() - starttime);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	sub	ecx, DWORD PTR _starttime$[ebp]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	DWORD PTR _time$[ebp], eax

; 1532 : 			if (time > sendtime)

	mov	eax, DWORD PTR _time$[ebp]
	cmp	eax, DWORD PTR _sendtime$[ebp]
	jbe	SHORT $L96760

; 1533 : 			{
; 1534 : 				header->Type = MESSAGE_PLAYER_READY;

	mov	eax, DWORD PTR _header$[ebp]
	mov	WORD PTR [eax], 4

; 1535 : 				TransmitMessage(TransmitBuff, sizeof(MESSAGE_HEADER), ServerID, MESSAGE_PRIORITY_NORMAL);

	push	0
	mov	eax, DWORD PTR ?ServerID@@3KA		; ServerID
	push	eax
	push	4
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessage@@YAXPADFKJ@Z		; TransmitMessage
	add	esp, 16					; 00000010H

; 1536 : 				sendtime += 1000;

	mov	eax, DWORD PTR _sendtime$[ebp]
	add	eax, 1000				; 000003e8H
	mov	DWORD PTR _sendtime$[ebp], eax
$L96760:

; 1537 : 			}
; 1538 : 
; 1539 : 			if (time > (1000 * 60))

	cmp	DWORD PTR _time$[ebp], 60000		; 0000ea60H
	jbe	SHORT $L96762

; 1540 : 			{
; 1541 : 				Box(NULL, "Timed out waiting for server to start!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CH@DFOKBENB@Timed?5out?5waiting?5for?5server?5to?5@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 1542 : 				ReadyFlag = TRUE;

	mov	DWORD PTR _ReadyFlag, 1
$L96762:

; 1543 : 			}
; 1544 : 
; 1545 : 			if (GameSettings.GameType == GAMETYPE_SESSIONLOST)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 4
	jne	SHORT $L96764

; 1546 : 			{
; 1547 : 				QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 1548 : 				return;

	jmp	SHORT $L96729
$L96764:

; 1549 : 			}
; 1550 : 		}

	jmp	$L96758
$L96759:

; 1551 : 
; 1552 : // wait until countdown timer set
; 1553 : 
; 1554 : 		ReadyFlag = FALSE;

	mov	DWORD PTR _ReadyFlag, 0
$L96766:

; 1555 : 
; 1556 : 		while (!ReadyFlag)

	cmp	DWORD PTR _ReadyFlag, 0
	jne	SHORT $L96729

; 1557 : 		{
; 1558 : 			GetRemoteMessages();

	call	?GetRemoteMessages@@YADXZ		; GetRemoteMessages

; 1559 : 		}

	jmp	SHORT $L96766
$L96729:

; 1560 : 	}
; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoteSync@@YAXXZ ENDP					; RemoteSync
_TEXT	ENDS
END
