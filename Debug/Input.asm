; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Input.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BL@NCLPPIDD@Can?8t?5create?5input?5object?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@MHFBCFE@Can?8t?5create?5keyboard?5device?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@ONFNEDED@Can?8t?5set?5keyboard?5data?5format?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@MECKJNOJ@Can?8t?5set?5keyboard?5coop?5level?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@MBOHPANP@Can?8t?5create?5mouse?5device?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@GOBELDDO@Can?8t?5set?5mouse?5data?5format?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@FOFPCHPO@Can?8t?5set?5mouse?5coop?5level?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DAJODNCI@Can?8t?5enumerate?5joysticks?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitInput@@YAJPAUHINSTANCE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMouseExclusive@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumJoystickCallback@@YGHPAUDIDEVICEINSTANCEA@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumObjectsCallback@@YGHPAUDIDEVICEOBJECTINSTANCEA@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KillInput@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadKeyboard@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadMouse@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadJoystick@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetKeyPress@@YAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?ShiftKey@@3PAEA				; ShiftKey
PUBLIC	?Keys@@3PADA					; Keys
PUBLIC	?LastKeys@@3PADA				; LastKeys
PUBLIC	?Mouse@@3U_DIMOUSESTATE@@A			; Mouse
PUBLIC	?JoystickNum@@3JA				; JoystickNum
PUBLIC	?CurrentJoystick@@3JA				; CurrentJoystick
PUBLIC	?Joystick@@3PAUJOYSTICK@@A			; Joystick
PUBLIC	?JoystickState@@3UDIJOYSTATE@@A			; JoystickState
_BSS	SEGMENT
?Keys@@3PADA DB	0100H DUP (?)				; Keys
?LastKeys@@3PADA DB 0100H DUP (?)			; LastKeys
?Mouse@@3U_DIMOUSESTATE@@A DB 010H DUP (?)		; Mouse
?JoystickNum@@3JA DD 01H DUP (?)			; JoystickNum
?CurrentJoystick@@3JA DD 01H DUP (?)			; CurrentJoystick
?Joystick@@3PAUJOYSTICK@@A DB 0530H DUP (?)		; Joystick
?JoystickState@@3UDIJOYSTATE@@A DB 050H DUP (?)		; JoystickState
_BSS	ENDS
_DATA	SEGMENT
?ShiftKey@@3PAEA DB 030H				; ShiftKey
	DB	029H
	DB	031H
	DB	021H
	DB	032H
	DB	022H
	DB	033H
	DB	0a3H
	DB	034H
	DB	024H
	DB	035H
	DB	025H
	DB	036H
	DB	05eH
	DB	037H
	DB	026H
	DB	038H
	DB	02aH
	DB	039H
	DB	028H
	DB	02dH
	DB	05fH
	DB	03dH
	DB	02bH
	DB	05cH
	DB	07cH
	DB	05bH
	DB	07bH
	DB	05dH
	DB	07dH
	DB	03bH
	DB	03aH
	DB	027H
	DB	040H
	DB	023H
	DB	07eH
	DB	02cH
	DB	03cH
	DB	02eH
	DB	03eH
	DB	02fH
	DB	03fH
	DB	060H
	DB	0acH
	DB	0ffH
_DATA	ENDS
PUBLIC	??_C@_0BL@NCLPPIDD@Can?8t?5create?5input?5object?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BN@MHFBCFE@Can?8t?5create?5keyboard?5device?$AA@ ; `string'
PUBLIC	??_C@_0BP@ONFNEDED@Can?8t?5set?5keyboard?5data?5format?$AA@ ; `string'
PUBLIC	??_C@_0BO@MECKJNOJ@Can?8t?5set?5keyboard?5coop?5level?$AA@ ; `string'
PUBLIC	??_C@_0BK@MBOHPANP@Can?8t?5create?5mouse?5device?$AA@ ; `string'
PUBLIC	??_C@_0BM@GOBELDDO@Can?8t?5set?5mouse?5data?5format?$AA@ ; `string'
PUBLIC	??_C@_0BL@FOFPCHPO@Can?8t?5set?5mouse?5coop?5level?$AA@ ; `string'
PUBLIC	??_C@_0BL@DAJODNCI@Can?8t?5enumerate?5joysticks?$CB?$AA@ ; `string'
PUBLIC	?InitInput@@YAJPAUHINSTANCE__@@@Z		; InitInput
PUBLIC	?EnumJoystickCallback@@YGHPAUDIDEVICEINSTANCEA@@PAX@Z ; EnumJoystickCallback
EXTRN	?hwnd@@3PAUHWND__@@A:DWORD			; hwnd
EXTRN	_DirectInput8Create@20:NEAR
EXTRN	_IID_IDirectInput8A:BYTE
EXTRN	_GUID_SysMouse:BYTE
EXTRN	_GUID_SysKeyboard:BYTE
EXTRN	?ErrorDX@@YAXJPAD@Z:NEAR			; ErrorDX
EXTRN	_c_dfDIMouse:BYTE
EXTRN	_c_dfDIKeyboard:BYTE
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
_BSS	SEGMENT
_DI	DD	01H DUP (?)
_KeyboardDevice DD 01H DUP (?)
_MouseDevice DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BL@NCLPPIDD@Can?8t?5create?5input?5object?$CB?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\input.cpp
CONST	SEGMENT
??_C@_0BL@NCLPPIDD@Can?8t?5create?5input?5object?$CB?$AA@ DB 'Can''t crea'
	DB	'te input object!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MHFBCFE@Can?8t?5create?5keyboard?5device?$AA@
CONST	SEGMENT
??_C@_0BN@MHFBCFE@Can?8t?5create?5keyboard?5device?$AA@ DB 'Can''t create'
	DB	' keyboard device', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ONFNEDED@Can?8t?5set?5keyboard?5data?5format?$AA@
CONST	SEGMENT
??_C@_0BP@ONFNEDED@Can?8t?5set?5keyboard?5data?5format?$AA@ DB 'Can''t se'
	DB	't keyboard data format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MECKJNOJ@Can?8t?5set?5keyboard?5coop?5level?$AA@
CONST	SEGMENT
??_C@_0BO@MECKJNOJ@Can?8t?5set?5keyboard?5coop?5level?$AA@ DB 'Can''t set'
	DB	' keyboard coop level', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MBOHPANP@Can?8t?5create?5mouse?5device?$AA@
CONST	SEGMENT
??_C@_0BK@MBOHPANP@Can?8t?5create?5mouse?5device?$AA@ DB 'Can''t create m'
	DB	'ouse device', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GOBELDDO@Can?8t?5set?5mouse?5data?5format?$AA@
CONST	SEGMENT
??_C@_0BM@GOBELDDO@Can?8t?5set?5mouse?5data?5format?$AA@ DB 'Can''t set m'
	DB	'ouse data format', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FOFPCHPO@Can?8t?5set?5mouse?5coop?5level?$AA@
CONST	SEGMENT
??_C@_0BL@FOFPCHPO@Can?8t?5set?5mouse?5coop?5level?$AA@ DB 'Can''t set mo'
	DB	'use coop level', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DAJODNCI@Can?8t?5enumerate?5joysticks?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@DAJODNCI@Can?8t?5enumerate?5joysticks?$CB?$AA@ DB 'Can''t enume'
	DB	'rate joysticks!', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitInput@@YAJPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_inst$ = 8						; size = 4
?InitInput@@YAJPAUHINSTANCE__@@@Z PROC NEAR		; InitInput, COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 61   : 	HRESULT r;
; 62   : 
; 63   : // create input object
; 64   : 
; 65   : 	r = DirectInput8Create(inst, DIRECTINPUT_VERSION, IID_IDirectInput8A, (LPVOID *) &DI, NULL);

	push	0
	push	OFFSET FLAT:_DI
	push	OFFSET FLAT:_IID_IDirectInput8A
	push	2048					; 00000800H
	mov	eax, DWORD PTR _inst$[ebp]
	push	eax
	call	_DirectInput8Create@20
	mov	DWORD PTR _r$[ebp], eax

; 66   : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76184

; 67   : 	{
; 68   : 		ErrorDX(r, "Can't create input object!");

	push	OFFSET FLAT:??_C@_0BL@NCLPPIDD@Can?8t?5create?5input?5object?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 69   : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 70   : 		return FALSE;

	xor	eax, eax
	jmp	$L76180
$L76184:

; 71   : 	}
; 72   : 
; 73   : // create keyboard device
; 74   : 
; 75   : 	r = DI->CreateDevice(GUID_SysKeyboard, &KeyboardDevice, NULL);

	push	0
	push	OFFSET FLAT:_KeyboardDevice
	push	OFFSET FLAT:_GUID_SysKeyboard
	mov	eax, DWORD PTR _DI
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _DI
	push	edx
	call	DWORD PTR [ecx+12]
	mov	DWORD PTR _r$[ebp], eax

; 76   : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76187

; 77   : 	{
; 78   : 		ErrorDX(r, "Can't create keyboard device");

	push	OFFSET FLAT:??_C@_0BN@MHFBCFE@Can?8t?5create?5keyboard?5device?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 79   : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 80   : 		return FALSE;

	xor	eax, eax
	jmp	$L76180
$L76187:

; 81   : 	}
; 82   : 
; 83   : 	r = KeyboardDevice->SetDataFormat(&c_dfDIKeyboard);

	push	OFFSET FLAT:_c_dfDIKeyboard
	mov	eax, DWORD PTR _KeyboardDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _KeyboardDevice
	push	edx
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR _r$[ebp], eax

; 84   : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76190

; 85   : 	{
; 86   : 		ErrorDX(r, "Can't set keyboard data format");

	push	OFFSET FLAT:??_C@_0BP@ONFNEDED@Can?8t?5set?5keyboard?5data?5format?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 87   : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 88   : 		return FALSE;

	xor	eax, eax
	jmp	$L76180
$L76190:

; 89   : 	}
; 90   : 
; 91   : 	r = KeyboardDevice->SetCooperativeLevel(hwnd, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);

	push	6
	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	mov	ecx, DWORD PTR _KeyboardDevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _KeyboardDevice
	push	eax
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _r$[ebp], eax

; 92   : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76193

; 93   : 	{
; 94   : 		ErrorDX(r, "Can't set keyboard coop level");

	push	OFFSET FLAT:??_C@_0BO@MECKJNOJ@Can?8t?5set?5keyboard?5coop?5level?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 95   : 		return FALSE;

	xor	eax, eax
	jmp	$L76180
$L76193:

; 96   : 	}
; 97   : 
; 98   : // create mouse device
; 99   : 
; 100  : 	r = DI->CreateDevice(GUID_SysMouse, &MouseDevice, NULL);

	push	0
	push	OFFSET FLAT:_MouseDevice
	push	OFFSET FLAT:_GUID_SysMouse
	mov	eax, DWORD PTR _DI
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _DI
	push	edx
	call	DWORD PTR [ecx+12]
	mov	DWORD PTR _r$[ebp], eax

; 101  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76196

; 102  : 	{
; 103  : 		ErrorDX(r, "Can't create mouse device");

	push	OFFSET FLAT:??_C@_0BK@MBOHPANP@Can?8t?5create?5mouse?5device?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 104  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 105  : 		return FALSE;

	xor	eax, eax
	jmp	$L76180
$L76196:

; 106  : 	}
; 107  : 
; 108  : 	r = MouseDevice->SetDataFormat(&c_dfDIMouse);

	push	OFFSET FLAT:_c_dfDIMouse
	mov	eax, DWORD PTR _MouseDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _MouseDevice
	push	edx
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR _r$[ebp], eax

; 109  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76199

; 110  : 	{
; 111  : 		ErrorDX(r, "Can't set mouse data format");

	push	OFFSET FLAT:??_C@_0BM@GOBELDDO@Can?8t?5set?5mouse?5data?5format?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 112  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 113  : 		return FALSE;

	xor	eax, eax
	jmp	$L76180
$L76199:

; 114  : 	}
; 115  : 
; 116  : 
; 117  : 	r = MouseDevice->SetCooperativeLevel(hwnd, DISCL_EXCLUSIVE | DISCL_FOREGROUND);

	push	5
	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	mov	ecx, DWORD PTR _MouseDevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _MouseDevice
	push	eax
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _r$[ebp], eax

; 118  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76202

; 119  : 	{
; 120  : 		ErrorDX(r, "Can't set mouse coop level");

	push	OFFSET FLAT:??_C@_0BL@FOFPCHPO@Can?8t?5set?5mouse?5coop?5level?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 121  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L76180
$L76202:

; 122  : 	}
; 123  : 
; 124  : // enumerate joysticks
; 125  : 
; 126  : 	CurrentJoystick = -1;

	mov	DWORD PTR ?CurrentJoystick@@3JA, -1	; CurrentJoystick

; 127  : 	JoystickNum = 0;

	mov	DWORD PTR ?JoystickNum@@3JA, 0		; JoystickNum

; 128  : 
; 129  : 	r = DI->EnumDevices(DI8DEVCLASS_GAMECTRL, (LPDIENUMDEVICESCALLBACK)EnumJoystickCallback, NULL, DIEDFL_ATTACHEDONLY);

	push	1
	push	0
	push	OFFSET FLAT:?EnumJoystickCallback@@YGHPAUDIDEVICEINSTANCEA@@PAX@Z ; EnumJoystickCallback
	push	4
	mov	eax, DWORD PTR _DI
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _DI
	push	edx
	call	DWORD PTR [ecx+16]
	mov	DWORD PTR _r$[ebp], eax

; 130  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76206

; 131  : 	{
; 132  : 		ErrorDX(r, "Can't enumerate joysticks!");

	push	OFFSET FLAT:??_C@_0BL@DAJODNCI@Can?8t?5enumerate?5joysticks?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 133  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 134  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L76180
$L76206:

; 135  : 	}
; 136  : 
; 137  : // return OK
; 138  : 
; 139  : 	return TRUE;

	mov	eax, 1
$L76180:

; 140  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitInput@@YAJPAUHINSTANCE__@@@Z ENDP			; InitInput
_TEXT	ENDS
PUBLIC	?SetMouseExclusive@@YAXJ@Z			; SetMouseExclusive
; Function compile flags: /Odt /ZI
;	COMDAT ?SetMouseExclusive@@YAXJ@Z
_TEXT	SEGMENT
_flag$ = 8						; size = 4
?SetMouseExclusive@@YAXJ@Z PROC NEAR			; SetMouseExclusive, COMDAT

; 146  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 147  : 	MouseDevice->Unacquire();

	mov	eax, DWORD PTR _MouseDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _MouseDevice
	push	edx
	call	DWORD PTR [ecx+32]

; 148  : 	MouseDevice->SetCooperativeLevel(hwnd, flag ? DISCL_EXCLUSIVE | DISCL_FOREGROUND : DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);

	mov	eax, DWORD PTR _flag$[ebp]
	neg	eax
	sbb	eax, eax
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	ecx
	mov	edx, DWORD PTR _MouseDevice
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _MouseDevice
	push	ecx
	call	DWORD PTR [eax+52]

; 149  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMouseExclusive@@YAXJ@Z ENDP				; SetMouseExclusive
_TEXT	ENDS
PUBLIC	?EnumObjectsCallback@@YGHPAUDIDEVICEOBJECTINSTANCEA@@PAX@Z ; EnumObjectsCallback
EXTRN	_IID_IDirectInputDevice2A:BYTE
EXTRN	_memcpy:NEAR
EXTRN	_c_dfDIJoystick:BYTE
; Function compile flags: /Odt /ZI
;	COMDAT ?EnumJoystickCallback@@YGHPAUDIDEVICEINSTANCEA@@PAX@Z
_TEXT	SEGMENT
_dev$ = -80						; size = 4
_saturation$ = -76					; size = 20
_deadzone$ = -56					; size = 20
_range$ = -36						; size = 24
_joy$ = -12						; size = 4
_r$ = -8						; size = 4
_i$ = -4						; size = 4
_inst$ = 8						; size = 4
_user$ = 12						; size = 4
?EnumJoystickCallback@@YGHPAUDIDEVICEINSTANCEA@@PAX@Z PROC NEAR ; EnumJoystickCallback, COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 157  : 	long i;
; 158  : 	HRESULT r;
; 159  : 	JOYSTICK *joy = &Joystick[JoystickNum];

	mov	eax, DWORD PTR ?JoystickNum@@3JA	; JoystickNum
	imul	eax, 332				; 0000014cH
	add	eax, OFFSET FLAT:?Joystick@@3PAUJOYSTICK@@A ; Joystick
	mov	DWORD PTR _joy$[ebp], eax

; 160  : 	DIPROPRANGE range;
; 161  : 	DIPROPDWORD deadzone, saturation;
; 162  : 	IDirectInputDevice8 *dev;
; 163  : 
; 164  : // create this device
; 165  : 
; 166  : 	r = DI->CreateDevice(inst->guidInstance, &dev, NULL);

	push	0
	lea	eax, DWORD PTR _dev$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _DI
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _DI
	push	ecx
	call	DWORD PTR [eax+12]
	mov	DWORD PTR _r$[ebp], eax

; 167  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76223

; 168  : 	{
; 169  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76223:

; 170  : 	}
; 171  : 
; 172  : 	r = dev->QueryInterface(IID_IDirectInputDevice2, (void**)&joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IDirectInputDevice2A
	mov	ecx, DWORD PTR _dev$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _dev$[ebp]
	push	eax
	call	DWORD PTR [edx]
	mov	DWORD PTR _r$[ebp], eax

; 173  : 	RELEASE(dev);

	cmp	DWORD PTR _dev$[ebp], 0
	je	SHORT $L76225
	mov	eax, DWORD PTR _dev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dev$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _dev$[ebp], 0
$L76225:

; 174  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76227

; 175  : 	{
; 176  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76227:

; 177  : 	}
; 178  : 
; 179  : 	r = joy->Device->SetDataFormat(&c_dfDIJoystick);

	push	OFFSET FLAT:_c_dfDIJoystick
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR _r$[ebp], eax

; 180  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76229

; 181  : 	{
; 182  : 		RELEASE(joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L76230
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax], 0
$L76230:

; 183  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76229:

; 184  : 	}
; 185  : 
; 186  : 	r = joy->Device->SetCooperativeLevel(hwnd, DISCL_EXCLUSIVE | DISCL_FOREGROUND);

	push	5
	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	mov	ecx, DWORD PTR _joy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+52]
	mov	DWORD PTR _r$[ebp], eax

; 187  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76232

; 188  : 	{
; 189  : 		RELEASE(joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L76233
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax], 0
$L76233:

; 190  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76232:

; 191  : 	}
; 192  : 
; 193  : 	joy->Caps.dwSize = sizeof(joy->Caps);

	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax+28], 44			; 0000002cH

; 194  : 	r = joy->Device->GetCapabilities(&joy->Caps);

	mov	eax, DWORD PTR _joy$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _joy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+12]
	mov	DWORD PTR _r$[ebp], eax

; 195  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76235

; 196  : 	{
; 197  : 		RELEASE(joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L76236
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax], 0
$L76236:

; 198  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76235:

; 199  : 	}
; 200  : 
; 201  : // set axis range
; 202  : 
; 203  : 	range.diph.dwSize = sizeof(range);

	mov	DWORD PTR _range$[ebp], 24		; 00000018H

; 204  : 	range.diph.dwHeaderSize = sizeof(range.diph);

	mov	DWORD PTR _range$[ebp+4], 16		; 00000010H

; 205  : 	range.diph.dwObj = 0;

	mov	DWORD PTR _range$[ebp+8], 0

; 206  : 	range.diph.dwHow = DIPH_DEVICE;

	mov	DWORD PTR _range$[ebp+12], 0

; 207  :     range.lMin = -CTRL_RANGE_MAX; 

	mov	DWORD PTR _range$[ebp+16], -127		; ffffff81H

; 208  :     range.lMax = CTRL_RANGE_MAX; 

	mov	DWORD PTR _range$[ebp+20], 127		; 0000007fH

; 209  : 
; 210  : 	r = joy->Device->SetProperty(DIPROP_RANGE, &range.diph);

	lea	eax, DWORD PTR _range$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _joy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 211  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76239

; 212  : 	{
; 213  : 		RELEASE(joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L76240
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax], 0
$L76240:

; 214  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76239:

; 215  : 	}
; 216  : 
; 217  : // set dead zone
; 218  : 
; 219  : 	deadzone.diph.dwSize = sizeof(deadzone);

	mov	DWORD PTR _deadzone$[ebp], 20		; 00000014H

; 220  : 	deadzone.diph.dwHeaderSize = sizeof(deadzone.diph);

	mov	DWORD PTR _deadzone$[ebp+4], 16		; 00000010H

; 221  : 	deadzone.diph.dwObj = 0;

	mov	DWORD PTR _deadzone$[ebp+8], 0

; 222  : 	deadzone.diph.dwHow = DIPH_DEVICE;

	mov	DWORD PTR _deadzone$[ebp+12], 0

; 223  : 	deadzone.dwData = 1000;

	mov	DWORD PTR _deadzone$[ebp+16], 1000	; 000003e8H

; 224  : 
; 225  : 	r = joy->Device->SetProperty(DIPROP_DEADZONE, &deadzone.diph);

	lea	eax, DWORD PTR _deadzone$[ebp]
	push	eax
	push	5
	mov	ecx, DWORD PTR _joy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 226  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76243

; 227  : 	{
; 228  : 		RELEASE(joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L76244
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax], 0
$L76244:

; 229  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76243:

; 230  : 	}
; 231  : 
; 232  : // set saturation
; 233  : 
; 234  : 	saturation.diph.dwSize = sizeof(saturation);

	mov	DWORD PTR _saturation$[ebp], 20		; 00000014H

; 235  : 	saturation.diph.dwHeaderSize = sizeof(saturation.diph);

	mov	DWORD PTR _saturation$[ebp+4], 16	; 00000010H

; 236  : 	saturation.diph.dwObj = 0;

	mov	DWORD PTR _saturation$[ebp+8], 0

; 237  : 	saturation.diph.dwHow = DIPH_DEVICE;

	mov	DWORD PTR _saturation$[ebp+12], 0

; 238  : 	saturation.dwData = 9000;

	mov	DWORD PTR _saturation$[ebp+16], 9000	; 00002328H

; 239  : 
; 240  : 	r = joy->Device->SetProperty(DIPROP_SATURATION, &saturation.diph);

	lea	eax, DWORD PTR _saturation$[ebp]
	push	eax
	push	6
	mov	ecx, DWORD PTR _joy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 241  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76247

; 242  : 	{
; 243  : 		RELEASE(joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L76248
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax], 0
$L76248:

; 244  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	$L76214
$L76247:

; 245  : 	}
; 246  : 
; 247  : // enumerate objects
; 248  : 
; 249  : 	for (i = 0 ; i < MAX_AXIS ; i++) joy->Axis[i] = FALSE;

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76249
$L76250:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76249:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L76251
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], 0
	jmp	SHORT $L76250
$L76251:

; 250  : 
; 251  : 	r = joy->Device->EnumObjects((LPDIENUMDEVICEOBJECTSCALLBACK)EnumObjectsCallback, (void*)joy, DIDFT_ALL);

	push	0
	mov	eax, DWORD PTR _joy$[ebp]
	push	eax
	push	OFFSET FLAT:?EnumObjectsCallback@@YGHPAUDIDEVICEOBJECTINSTANCEA@@PAX@Z ; EnumObjectsCallback
	mov	ecx, DWORD PTR _joy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _r$[ebp], eax

; 252  : 	if (r != DI_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76255

; 253  : 	{
; 254  : 		RELEASE(joy->Device);

	mov	eax, DWORD PTR _joy$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L76256
	mov	eax, DWORD PTR _joy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _joy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax], 0
$L76256:

; 255  : 		return DIENUM_CONTINUE;

	mov	eax, 1
	jmp	SHORT $L76214
$L76255:

; 256  : 	}
; 257  : 
; 258  : // copy name
; 259  : 
; 260  : 	memcpy(joy->Name, inst->tszProductName, MAX_PATH);

	push	260					; 00000104H
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	mov	ecx, DWORD PTR _joy$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 261  : 
; 262  : // next please
; 263  : 
; 264  : 	JoystickNum++;

	mov	eax, DWORD PTR ?JoystickNum@@3JA	; JoystickNum
	add	eax, 1
	mov	DWORD PTR ?JoystickNum@@3JA, eax	; JoystickNum

; 265  : 	if (JoystickNum == MAX_JOYSTICKS) return DIENUM_STOP;

	cmp	DWORD PTR ?JoystickNum@@3JA, 4		; JoystickNum
	jne	SHORT $L76257
	xor	eax, eax
	jmp	SHORT $L76214
$L76257:

; 266  : 	else return DIENUM_CONTINUE;

	mov	eax, 1
$L76214:

; 267  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?EnumJoystickCallback@@YGHPAUDIDEVICEINSTANCEA@@PAX@Z ENDP ; EnumJoystickCallback
_TEXT	ENDS
PUBLIC	_==
EXTRN	_GUID_XAxis:BYTE
EXTRN	_GUID_YAxis:BYTE
EXTRN	_GUID_ZAxis:BYTE
EXTRN	_GUID_RxAxis:BYTE
EXTRN	_GUID_RyAxis:BYTE
EXTRN	_GUID_RzAxis:BYTE
; Function compile flags: /Odt /ZI
;	COMDAT ?EnumObjectsCallback@@YGHPAUDIDEVICEOBJECTINSTANCEA@@PAX@Z
_TEXT	SEGMENT
_joy$ = -4						; size = 4
_inst$ = 8						; size = 4
_user$ = 12						; size = 4
?EnumObjectsCallback@@YGHPAUDIDEVICEOBJECTINSTANCEA@@PAX@Z PROC NEAR ; EnumObjectsCallback, COMDAT

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 275  : 	JOYSTICK *joy = (JOYSTICK*)user;

	mov	eax, DWORD PTR _user$[ebp]
	mov	DWORD PTR _joy$[ebp], eax

; 276  : 
; 277  : // axis?
; 278  : 
; 279  : 	if (inst->dwType & DIDFT_ABSAXIS)

	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 2
	je	$L76265

; 280  : 	{
; 281  : 		if (inst->guidType == GUID_XAxis) joy->Axis[X_AXIS] = TRUE;

	push	OFFSET FLAT:_GUID_XAxis
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 4
	push	eax
	call	_==
	add	esp, 8
	test	eax, eax
	je	SHORT $L76266
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax+4], 1
$L76266:

; 282  : 		if (inst->guidType == GUID_YAxis) joy->Axis[Y_AXIS] = TRUE;

	push	OFFSET FLAT:_GUID_YAxis
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 4
	push	eax
	call	_==
	add	esp, 8
	test	eax, eax
	je	SHORT $L76267
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax+8], 1
$L76267:

; 283  : 		if (inst->guidType == GUID_ZAxis) joy->Axis[Z_AXIS] = TRUE;

	push	OFFSET FLAT:_GUID_ZAxis
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 4
	push	eax
	call	_==
	add	esp, 8
	test	eax, eax
	je	SHORT $L76268
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax+12], 1
$L76268:

; 284  : 		if (inst->guidType == GUID_RxAxis) joy->Axis[ROTX_AXIS] = TRUE;

	push	OFFSET FLAT:_GUID_RxAxis
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 4
	push	eax
	call	_==
	add	esp, 8
	test	eax, eax
	je	SHORT $L76269
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax+16], 1
$L76269:

; 285  : 		if (inst->guidType == GUID_RyAxis) joy->Axis[ROTY_AXIS] = TRUE;

	push	OFFSET FLAT:_GUID_RyAxis
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 4
	push	eax
	call	_==
	add	esp, 8
	test	eax, eax
	je	SHORT $L76270
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax+20], 1
$L76270:

; 286  : 		if (inst->guidType == GUID_RzAxis) joy->Axis[ROTZ_AXIS] = TRUE;

	push	OFFSET FLAT:_GUID_RzAxis
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 4
	push	eax
	call	_==
	add	esp, 8
	test	eax, eax
	je	SHORT $L76265
	mov	eax, DWORD PTR _joy$[ebp]
	mov	DWORD PTR [eax+24], 1
$L76265:

; 287  : 	}
; 288  : 
; 289  : // return OK
; 290  : 
; 291  : 	return DIENUM_CONTINUE;

	mov	eax, 1

; 292  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?EnumObjectsCallback@@YGHPAUDIDEVICEOBJECTINSTANCEA@@PAX@Z ENDP ; EnumObjectsCallback
_TEXT	ENDS
PUBLIC	_IsEqualGUID
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\platformsdk\include\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC NEAR					; COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 194  :     return IsEqualGUID(guidOne,guidOther);

	mov	eax, DWORD PTR _guidOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _guidOne$[ebp]
	push	ecx
	call	_IsEqualGUID
	add	esp, 8

; 195  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_==	ENDP
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC NEAR					; COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	push	16					; 00000010H
	mov	eax, DWORD PTR _rguid2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rguid1$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax

; 162  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsEqualGUID ENDP
_TEXT	ENDS
PUBLIC	?KillInput@@YAXXZ				; KillInput
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\input.cpp
;	COMDAT ?KillInput@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?KillInput@@YAXXZ PROC NEAR				; KillInput, COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 300  : 	long i;
; 301  : 
; 302  : // kill keyboard
; 303  : 
; 304  : 	KeyboardDevice->Unacquire();

	mov	eax, DWORD PTR _KeyboardDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _KeyboardDevice
	push	edx
	call	DWORD PTR [ecx+32]

; 305  : 	RELEASE(KeyboardDevice);

	cmp	DWORD PTR _KeyboardDevice, 0
	je	SHORT $L76276
	mov	eax, DWORD PTR _KeyboardDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _KeyboardDevice
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _KeyboardDevice, 0
$L76276:

; 306  : 
; 307  : // kill mouse
; 308  : 
; 309  : 	MouseDevice->Unacquire();

	mov	eax, DWORD PTR _MouseDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _MouseDevice
	push	edx
	call	DWORD PTR [ecx+32]

; 310  : 	RELEASE(MouseDevice);

	cmp	DWORD PTR _MouseDevice, 0
	je	SHORT $L76277
	mov	eax, DWORD PTR _MouseDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _MouseDevice
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _MouseDevice, 0
$L76277:

; 311  : 
; 312  : // kill joysticks
; 313  : 
; 314  : 	for (i = 0 ; i < JoystickNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76278
$L76279:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76278:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?JoystickNum@@3JA	; JoystickNum
	jge	SHORT $L76280

; 315  : 	{
; 316  : 		Joystick[i].Device->Unacquire();

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 332				; 0000014cH
	mov	ecx, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[eax]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 332				; 0000014cH
	mov	eax, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+32]

; 317  : 		RELEASE(Joystick[i].Device);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 332				; 0000014cH
	cmp	DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[eax], 0
	je	SHORT $L76281
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 332				; 0000014cH
	mov	ecx, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[eax]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 332				; 0000014cH
	mov	eax, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 332				; 0000014cH
	mov	DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[eax], 0
$L76281:

; 318  : 	}

	jmp	$L76279
$L76280:

; 319  : 
; 320  : // kill input object
; 321  : 
; 322  : 	RELEASE(DI);

	cmp	DWORD PTR _DI, 0
	je	SHORT $L76274
	mov	eax, DWORD PTR _DI
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _DI
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _DI, 0
$L76274:

; 323  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?KillInput@@YAXXZ ENDP					; KillInput
_TEXT	ENDS
PUBLIC	?ReadKeyboard@@YAXXZ				; ReadKeyboard
; Function compile flags: /Odt /ZI
;	COMDAT ?ReadKeyboard@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?ReadKeyboard@@YAXXZ PROC NEAR				; ReadKeyboard, COMDAT

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 331  : 	long i;
; 332  : 
; 333  : // copy current to last
; 334  : 
; 335  : 	for (i = 0 ; i < 256 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76287
$L76288:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76287:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $L76289

; 336  : 		LastKeys[i] = Keys[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR ?Keys@@3PADA[ecx]
	mov	BYTE PTR ?LastKeys@@3PADA[eax], dl
	jmp	SHORT $L76288
$L76289:

; 337  : 
; 338  : // read current
; 339  : 
; 340  : 	KeyboardDevice->Acquire();

	mov	eax, DWORD PTR _KeyboardDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _KeyboardDevice
	push	edx
	call	DWORD PTR [ecx+28]

; 341  : 	KeyboardDevice->GetDeviceState(sizeof(Keys), &Keys);

	push	OFFSET FLAT:?Keys@@3PADA		; Keys
	push	256					; 00000100H
	mov	eax, DWORD PTR _KeyboardDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _KeyboardDevice
	push	edx
	call	DWORD PTR [ecx+36]

; 342  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadKeyboard@@YAXXZ ENDP				; ReadKeyboard
_TEXT	ENDS
PUBLIC	?ReadMouse@@YAXXZ				; ReadMouse
; Function compile flags: /Odt /ZI
;	COMDAT ?ReadMouse@@YAXXZ
_TEXT	SEGMENT
?ReadMouse@@YAXXZ PROC NEAR				; ReadMouse, COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 350  : 
; 351  : // read current
; 352  : 
; 353  : 	MouseDevice->Acquire();

	mov	eax, DWORD PTR _MouseDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _MouseDevice
	push	edx
	call	DWORD PTR [ecx+28]

; 354  : 	MouseDevice->GetDeviceState(sizeof(Mouse), &Mouse);

	push	OFFSET FLAT:?Mouse@@3U_DIMOUSESTATE@@A	; Mouse
	push	16					; 00000010H
	mov	eax, DWORD PTR _MouseDevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _MouseDevice
	push	edx
	call	DWORD PTR [ecx+36]

; 355  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadMouse@@YAXXZ ENDP					; ReadMouse
_TEXT	ENDS
PUBLIC	?ReadJoystick@@YAXXZ				; ReadJoystick
; Function compile flags: /Odt /ZI
;	COMDAT ?ReadJoystick@@YAXXZ
_TEXT	SEGMENT
?ReadJoystick@@YAXXZ PROC NEAR				; ReadJoystick, COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 363  : 
; 364  : // current joystick?
; 365  : 
; 366  : 	if (CurrentJoystick == -1)

	cmp	DWORD PTR ?CurrentJoystick@@3JA, -1	; CurrentJoystick
	jne	SHORT $L76296

; 367  : 		return;

	jmp	$L76295
$L76296:

; 368  : 
; 369  : // yep, read current
; 370  : 
; 371  : 	Joystick[CurrentJoystick].Device->Acquire();

	mov	eax, DWORD PTR ?CurrentJoystick@@3JA	; CurrentJoystick
	imul	eax, 332				; 0000014cH
	mov	ecx, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[eax]
	mov	edx, DWORD PTR ?CurrentJoystick@@3JA	; CurrentJoystick
	imul	edx, 332				; 0000014cH
	mov	eax, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+28]

; 372  : 	Joystick[CurrentJoystick].Device->Poll();

	mov	eax, DWORD PTR ?CurrentJoystick@@3JA	; CurrentJoystick
	imul	eax, 332				; 0000014cH
	mov	ecx, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[eax]
	mov	edx, DWORD PTR ?CurrentJoystick@@3JA	; CurrentJoystick
	imul	edx, 332				; 0000014cH
	mov	eax, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+100]

; 373  : 	Joystick[CurrentJoystick].Device->GetDeviceState(sizeof(JoystickState), &JoystickState);

	push	OFFSET FLAT:?JoystickState@@3UDIJOYSTATE@@A ; JoystickState
	push	80					; 00000050H
	mov	eax, DWORD PTR ?CurrentJoystick@@3JA	; CurrentJoystick
	imul	eax, 332				; 0000014cH
	mov	ecx, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[eax]
	mov	edx, DWORD PTR ?CurrentJoystick@@3JA	; CurrentJoystick
	imul	edx, 332				; 0000014cH
	mov	eax, DWORD PTR ?Joystick@@3PAUJOYSTICK@@A[edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+36]
$L76295:

; 374  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadJoystick@@YAXXZ ENDP				; ReadJoystick
_TEXT	ENDS
PUBLIC	?GetKeyPress@@YAEXZ				; GetKeyPress
EXTRN	__imp__GetKeyState@4:NEAR
EXTRN	__imp__MapVirtualKeyA@8:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?GetKeyPress@@YAEXZ
_TEXT	SEGMENT
_ch$ = -16						; size = 4
_vk$ = -12						; size = 4
_p$ = -8						; size = 4
_i$ = -4						; size = 2
?GetKeyPress@@YAEXZ PROC NEAR				; GetKeyPress, COMDAT

; 381  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 382  : 	short i;
; 383  : 	unsigned char *p;
; 384  : 	unsigned long vk, ch;
; 385  : 
; 386  : // loop thru all keys, any new presses?
; 387  : 
; 388  : 	for (i = 0 ; i < 255 ; i++) if (Keys[i] && !LastKeys[i])

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L76304
$L76305:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L76304:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 255				; 000000ffH
	jge	$L76306
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR ?Keys@@3PADA[eax]
	test	ecx, ecx
	je	$L76307
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR ?LastKeys@@3PADA[eax]
	test	ecx, ecx
	jne	$L76307

; 389  : 	{
; 390  : 
; 391  : // yep, get ascii value
; 392  : 
; 393  : 		vk = MapVirtualKey(i, 1);

	push	1
	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	call	DWORD PTR __imp__MapVirtualKeyA@8
	mov	DWORD PTR _vk$[ebp], eax

; 394  : 		if (!vk) continue;

	cmp	DWORD PTR _vk$[ebp], 0
	jne	SHORT $L76308
	jmp	SHORT $L76305
$L76308:

; 395  : 
; 396  : 		ch = MapVirtualKey(vk, 2);

	push	2
	mov	eax, DWORD PTR _vk$[ebp]
	push	eax
	call	DWORD PTR __imp__MapVirtualKeyA@8
	mov	DWORD PTR _ch$[ebp], eax

; 397  : 		if (!ch) continue;

	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $L76309
	jmp	SHORT $L76305
$L76309:

; 398  : 
; 399  : // shift?
; 400  : 
; 401  : 		if (Keys[DIK_LSHIFT] || Keys[DIK_RSHIFT])

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	jne	SHORT $L76311
	movsx	eax, BYTE PTR ?Keys@@3PADA+54
	test	eax, eax
	je	SHORT $L76310
$L76311:

; 402  : 		{
; 403  : 			p = ShiftKey;

	mov	DWORD PTR _p$[ebp], OFFSET FLAT:?ShiftKey@@3PAEA ; ShiftKey
$L76313:

; 404  : 			while (*p != 255 && *p != ch) p += 2;

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $L76314
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _ch$[ebp]
	je	SHORT $L76314
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $L76313
$L76314:

; 405  : 			if (*p == ch) ch = *(p + 1);

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _ch$[ebp]
	jne	SHORT $L76315
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	DWORD PTR _ch$[ebp], ecx
$L76315:

; 406  : 		}
; 407  : 
; 408  : // no shift
; 409  : 
; 410  : 		else

	jmp	SHORT $L76316
$L76310:

; 411  : 		{
; 412  : 			if (ch >= 'A' && ch <= 'Z' && !(GetKeyState(VK_CAPITAL) & 1)) ch += ('a' - 'A');

	cmp	DWORD PTR _ch$[ebp], 65			; 00000041H
	jb	SHORT $L76316
	cmp	DWORD PTR _ch$[ebp], 90			; 0000005aH
	ja	SHORT $L76316
	push	20					; 00000014H
	call	DWORD PTR __imp__GetKeyState@4
	movsx	eax, ax
	and	eax, 1
	jne	SHORT $L76316
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _ch$[ebp], eax
$L76316:

; 413  : 		}
; 414  : 
; 415  : 		return (unsigned char)ch;

	mov	al, BYTE PTR _ch$[ebp]
	jmp	SHORT $L76299
$L76307:

; 416  : 	}
; 417  : 
; 418  : // return none
; 419  : 
; 420  : 	return FALSE;

	jmp	$L76305
$L76306:
	xor	al, al
$L76299:

; 421  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKeyPress@@YAEXZ ENDP				; GetKeyPress
_TEXT	ENDS
END
