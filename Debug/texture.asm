; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\texture.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IM@EDMNLHFK@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FEFGCBOG@Can?8t?5load?5texture?3?5?8?$CFs?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@JNPNPPAH@Can?8t?5create?5texture?5source?5surf@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@OLGMOGGB@Can?8t?5create?5texture?5dest?5surfac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@MGCJOGAA@Can?8t?5create?5texture?5palette?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@HNLHOIPF@Can?8t?5attach?5palette?5to?5texture?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@FELOGPAN@Can?8t?5attach?5palette?5to?5texture?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@CLDNNONA@Can?8t?5get?5texture?5surface?5DC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@CJGGGNKI@Can?8t?5blit?5to?5texture?5surface?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@IJCJKAAI@Can?8t?5query?5interface?5for?5textur@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@LBLBOAG@Can?8t?5query?5interface?5for?5textur@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@NPJMNOBK@Can?8t?5load?5dest?5texture?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@GPJIFGFK@Can?8t?5create?5mipmap?5source?5surfa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@OGBCNLBK@Can?8t?5create?5mipmap?5dest?5surface@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@KLINOPDH@Can?8t?5load?5mipmap?5texture?3?5?8?$CFs?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@OEAPAIEJ@Can?8t?5get?5attached?5surface?5for?5s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@ILJNDPDH@Can?8t?5get?5attached?5surface?5for?5d@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateTPages@@YA_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyTPages@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTextureFormat@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PickTextureSets@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MipSize@@YAJJJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindTextureCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountTexturePixels@@YAJJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountMipTexturePixels@@YAJJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTextureClever@@YA_NPADDJJJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTexture@@YA_NPADDJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadMipTexture@@YA_NPADDJJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTextures@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeTextures@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeOneTexture@@YAXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyTPages@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateTPages@@YA_NH@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?TexFormat@@3U_DDPIXELFORMAT@@A			; TexFormat
PUBLIC	?TexturesEnabled@@3DA				; TexturesEnabled
PUBLIC	?TexturesSquareOnly@@3DA			; TexturesSquareOnly
PUBLIC	?TexturesAGP@@3DA				; TexturesAGP
PUBLIC	?TexInfo@@3PAUTEXINFO@@A			; TexInfo
PUBLIC	?TEX_NTPages@@3HA				; TEX_NTPages
PUBLIC	?TexturePixels@@3JA				; TexturePixels
PUBLIC	?WorldTextureSet@@3JA				; WorldTextureSet
PUBLIC	?CarTextureSet@@3JA				; CarTextureSet
PUBLIC	?FxTextureSet@@3JA				; FxTextureSet
PUBLIC	?TextureMinWidth@@3KA				; TextureMinWidth
PUBLIC	?TextureMaxWidth@@3KA				; TextureMaxWidth
PUBLIC	?TextureMinHeight@@3KA				; TextureMinHeight
PUBLIC	?TextureMaxHeight@@3KA				; TextureMaxHeight
_BSS	SEGMENT
?TexFormat@@3U_DDPIXELFORMAT@@A DB 020H DUP (?)		; TexFormat
?TexturesEnabled@@3DA DB 01H DUP (?)			; TexturesEnabled
	ALIGN	4

?TexturesSquareOnly@@3DA DB 01H DUP (?)			; TexturesSquareOnly
	ALIGN	4

?TexturesAGP@@3DA DB 01H DUP (?)			; TexturesAGP
	ALIGN	4

?TexInfo@@3PAUTEXINFO@@A DD 01H DUP (?)			; TexInfo
?TEX_NTPages@@3HA DD 01H DUP (?)			; TEX_NTPages
?TexturePixels@@3JA DD 01H DUP (?)			; TexturePixels
?WorldTextureSet@@3JA DD 01H DUP (?)			; WorldTextureSet
?CarTextureSet@@3JA DD 01H DUP (?)			; CarTextureSet
?FxTextureSet@@3JA DD 01H DUP (?)			; FxTextureSet
?TextureMinWidth@@3KA DD 01H DUP (?)			; TextureMinWidth
?TextureMaxWidth@@3KA DD 01H DUP (?)			; TextureMaxWidth
?TextureMinHeight@@3KA DD 01H DUP (?)			; TextureMinHeight
?TextureMaxHeight@@3KA DD 01H DUP (?)			; TextureMaxHeight
_BSS	ENDS
PUBLIC	?__LINE__Var@?1??CreateTPages@@YA_NH@Z@4JA	; `CreateTPages'::`2'::__LINE__Var
PUBLIC	??_C@_0IM@EDMNLHFK@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	?CreateTPages@@YA_NH@Z				; CreateTPages
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
;	COMDAT ??_C@_0IM@EDMNLHFK@c?3?2documents?5and?5settings?2jarhea@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\texture.cpp
CONST	SEGMENT
??_C@_0IM@EDMNLHFK@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\textu'
	DB	're.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CreateTPages@@YA_NH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateTPages@@YA_NH@Z@4JA DD 016H	; `CreateTPages'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateTPages@@YA_NH@Z
_TEXT	SEGMENT
_nPages$ = 8						; size = 4
?CreateTPages@@YA_NH@Z PROC NEAR			; CreateTPages, COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 23   : 	if ((TexInfo = (TEXINFO *)malloc(sizeof(TEXINFO) * nPages)) == NULL) {

	push	OFFSET FLAT:??_C@_0IM@EDMNLHFK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateTPages@@YA_NH@Z@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _nPages$[ebp]
	shl	ecx, 6
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?TexInfo@@3PAUTEXINFO@@A, eax	; TexInfo
	cmp	DWORD PTR ?TexInfo@@3PAUTEXINFO@@A, 0	; TexInfo
	jne	SHORT $L76081

; 24   : 		return FALSE;

	xor	al, al
	jmp	SHORT $L76077
$L76081:

; 25   : 	}
; 26   : 	
; 27   : 	TEX_NTPages = nPages;

	mov	eax, DWORD PTR _nPages$[ebp]
	mov	DWORD PTR ?TEX_NTPages@@3HA, eax	; TEX_NTPages

; 28   : 
; 29   : 	return TRUE;

	mov	al, 1
$L76077:

; 30   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateTPages@@YA_NH@Z ENDP				; CreateTPages
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyTPages@@YAXXZ@4JA	; `DestroyTPages'::`2'::__LINE__Var
PUBLIC	?DestroyTPages@@YAXXZ				; DestroyTPages
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??DestroyTPages@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DestroyTPages@@YAXXZ@4JA DD 025H	; `DestroyTPages'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DestroyTPages@@YAXXZ
_TEXT	SEGMENT
?DestroyTPages@@YAXXZ PROC NEAR				; DestroyTPages, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 38   : 	free(TexInfo);

	push	OFFSET FLAT:??_C@_0IM@EDMNLHFK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyTPages@@YAXXZ@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 39   : 	TEX_NTPages = 0;

	mov	DWORD PTR ?TEX_NTPages@@3HA, 0		; TEX_NTPages

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyTPages@@YAXXZ ENDP				; DestroyTPages
_TEXT	ENDS
PUBLIC	?GetTextureFormat@@YAXJ@Z			; GetTextureFormat
PUBLIC	?FindTextureCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z ; FindTextureCallback
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
EXTRN	?D3Dcaps@@3U_D3DDeviceDesc@@A:BYTE		; D3Dcaps
_BSS	SEGMENT
_TexBppRequest DD 01H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?GetTextureFormat@@YAXJ@Z
_TEXT	SEGMENT
_bpp$ = 8						; size = 4
?GetTextureFormat@@YAXJ@Z PROC NEAR			; GetTextureFormat, COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 48   : 
; 49   : // set texture state to off
; 50   : 
; 51   : 	TexturesEnabled = FALSE;

	mov	BYTE PTR ?TexturesEnabled@@3DA, 0	; TexturesEnabled

; 52   : 	TexFormat.dwRGBBitCount = 0;

	mov	DWORD PTR ?TexFormat@@3U_DDPIXELFORMAT@@A+12, 0

; 53   : 
; 54   : // enumerate / find good texture format
; 55   : 
; 56   : 	TexBppRequest = bpp;

	mov	eax, DWORD PTR _bpp$[ebp]
	mov	DWORD PTR _TexBppRequest, eax

; 57   : 	D3Ddevice->EnumTextureFormats(FindTextureCallback, NULL);

	push	0
	push	OFFSET FLAT:?FindTextureCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z ; FindTextureCallback
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+32]

; 58   : 
; 59   : 	if (TexFormat.dwRGBBitCount)

	cmp	DWORD PTR ?TexFormat@@3U_DDPIXELFORMAT@@A+12, 0
	je	SHORT $L76089

; 60   : 		TexturesEnabled = TRUE;

	mov	BYTE PTR ?TexturesEnabled@@3DA, 1	; TexturesEnabled

; 61   : 	else

	jmp	SHORT $L76090
$L76089:

; 62   : 		TexturesEnabled = FALSE;

	mov	BYTE PTR ?TexturesEnabled@@3DA, 0	; TexturesEnabled
$L76090:

; 63   : 
; 64   : // set TextureSquare flag
; 65   : 
; 66   : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_SQUAREONLY)

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L76091
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+132
	and	eax, 32					; 00000020H
	je	SHORT $L76091

; 67   : 		TexturesSquareOnly = TRUE;

	mov	BYTE PTR ?TexturesSquareOnly@@3DA, 1	; TexturesSquareOnly

; 68   : 	else

	jmp	SHORT $L76092
$L76091:

; 69   : 		TexturesSquareOnly = FALSE;

	mov	BYTE PTR ?TexturesSquareOnly@@3DA, 0	; TexturesSquareOnly
$L76092:

; 70   : 
; 71   : // set TextureAGP flag
; 72   : 
; 73   : 	if (D3Dcaps.dwDevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM)

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+12
	and	eax, 4096				; 00001000H
	je	SHORT $L76093

; 74   : 		TexturesAGP = TRUE;

	mov	BYTE PTR ?TexturesAGP@@3DA, 1		; TexturesAGP

; 75   : 	else

	jmp	SHORT $L76094
$L76093:

; 76   : 		TexturesAGP = FALSE;

	mov	BYTE PTR ?TexturesAGP@@3DA, 0		; TexturesAGP
$L76094:

; 77   : 
; 78   : // get tex min / max size
; 79   : 
; 80   : 	TextureMinWidth = D3Dcaps.dwMinTextureWidth;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+172
	mov	DWORD PTR ?TextureMinWidth@@3KA, eax	; TextureMinWidth

; 81   : 	TextureMaxWidth = D3Dcaps.dwMaxTextureWidth;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+180
	mov	DWORD PTR ?TextureMaxWidth@@3KA, eax	; TextureMaxWidth

; 82   : 	TextureMinHeight = D3Dcaps.dwMinTextureWidth;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+172
	mov	DWORD PTR ?TextureMinHeight@@3KA, eax	; TextureMinHeight

; 83   : 	TextureMaxHeight = D3Dcaps.dwMaxTextureWidth;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+180
	mov	DWORD PTR ?TextureMaxHeight@@3KA, eax	; TextureMaxHeight

; 84   : 
; 85   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextureFormat@@YAXJ@Z ENDP				; GetTextureFormat
_TEXT	ENDS
PUBLIC	?PickTextureSets@@YAXJ@Z			; PickTextureSets
PUBLIC	?MipSize@@YAJJJJJ@Z				; MipSize
PUBLIC	?CountTexturePixels@@YAJJJJ@Z			; CountTexturePixels
; Function compile flags: /Odt /ZI
;	COMDAT ?PickTextureSets@@YAXJ@Z
_TEXT	SEGMENT
_max$ = -4						; size = 4
_playernum$ = 8						; size = 4
?PickTextureSets@@YAXJ@Z PROC NEAR			; PickTextureSets, COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 93   : 	long max;
; 94   : 
; 95   : // get max texture pixels
; 96   : 
; 97   : 	max = TPAGE_WORLD_NUM + playernum + TPAGE_SCALE_NUM + TPAGE_FIXED_NUM;

	mov	eax, DWORD PTR _playernum$[ebp]
	add	eax, 19					; 00000013H
	mov	DWORD PTR _max$[ebp], eax

; 98   : 	max += max / 3;

	mov	eax, DWORD PTR _max$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	add	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR _max$[ebp], eax

; 99   : 
; 100  : 	TexturePixels = CountTexturePixels(max, 256, 256);

	push	256					; 00000100H
	push	256					; 00000100H
	mov	eax, DWORD PTR _max$[ebp]
	push	eax
	call	?CountTexturePixels@@YAJJJJ@Z		; CountTexturePixels
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?TexturePixels@@3JA, eax	; TexturePixels

; 101  : 
; 102  : // pick texture sets
; 103  : 
; 104  : 	WorldTextureSet = 0;

	mov	DWORD PTR ?WorldTextureSet@@3JA, 0	; WorldTextureSet

; 105  : 	CarTextureSet = 0;

	mov	DWORD PTR ?CarTextureSet@@3JA, 0	; CarTextureSet

; 106  : 	FxTextureSet = 0;

	mov	DWORD PTR ?FxTextureSet@@3JA, 0		; FxTextureSet

; 107  : 
; 108  : 	if (MipSize(256, WorldTextureSet, TPAGE_WORLD_NUM, TRUE) + MipSize(256, CarTextureSet, playernum, TRUE) + MipSize(256, FxTextureSet, TPAGE_SCALE_NUM, TRUE) + MipSize(256, 0, TPAGE_FIXED_NUM, FALSE) > TexturePixels)

	push	1
	push	10					; 0000000aH
	mov	eax, DWORD PTR ?WorldTextureSet@@3JA	; WorldTextureSet
	push	eax
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _playernum$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CarTextureSet@@3JA	; CarTextureSet
	push	edx
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	push	1
	push	4
	mov	eax, DWORD PTR ?FxTextureSet@@3JA	; FxTextureSet
	push	eax
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	push	0
	push	5
	push	0
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	cmp	esi, DWORD PTR ?TexturePixels@@3JA	; TexturePixels
	jle	SHORT $L76099

; 109  : 		FxTextureSet++;

	mov	eax, DWORD PTR ?FxTextureSet@@3JA	; FxTextureSet
	add	eax, 1
	mov	DWORD PTR ?FxTextureSet@@3JA, eax	; FxTextureSet
$L76099:

; 110  : 
; 111  : 	if (MipSize(256, WorldTextureSet, TPAGE_WORLD_NUM, TRUE) + MipSize(256, CarTextureSet, playernum, TRUE) + MipSize(256, FxTextureSet, TPAGE_SCALE_NUM, TRUE) + MipSize(256, 0, TPAGE_FIXED_NUM, FALSE) > TexturePixels)

	push	1
	push	10					; 0000000aH
	mov	eax, DWORD PTR ?WorldTextureSet@@3JA	; WorldTextureSet
	push	eax
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _playernum$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CarTextureSet@@3JA	; CarTextureSet
	push	edx
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	push	1
	push	4
	mov	eax, DWORD PTR ?FxTextureSet@@3JA	; FxTextureSet
	push	eax
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	push	0
	push	5
	push	0
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	cmp	esi, DWORD PTR ?TexturePixels@@3JA	; TexturePixels
	jle	SHORT $L76100

; 112  : 		CarTextureSet++;

	mov	eax, DWORD PTR ?CarTextureSet@@3JA	; CarTextureSet
	add	eax, 1
	mov	DWORD PTR ?CarTextureSet@@3JA, eax	; CarTextureSet
$L76100:

; 113  : 
; 114  : 	if (MipSize(256, WorldTextureSet, TPAGE_WORLD_NUM, TRUE) + MipSize(256, CarTextureSet, playernum, TRUE) + MipSize(256, FxTextureSet, TPAGE_SCALE_NUM, TRUE) + MipSize(256, 0, TPAGE_FIXED_NUM, FALSE) > TexturePixels)

	push	1
	push	10					; 0000000aH
	mov	eax, DWORD PTR ?WorldTextureSet@@3JA	; WorldTextureSet
	push	eax
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _playernum$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CarTextureSet@@3JA	; CarTextureSet
	push	edx
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	push	1
	push	4
	mov	eax, DWORD PTR ?FxTextureSet@@3JA	; FxTextureSet
	push	eax
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	push	0
	push	5
	push	0
	push	256					; 00000100H
	call	?MipSize@@YAJJJJJ@Z			; MipSize
	add	esp, 16					; 00000010H
	add	esi, eax
	cmp	esi, DWORD PTR ?TexturePixels@@3JA	; TexturePixels
	jle	SHORT $L76097

; 115  : 		WorldTextureSet++;

	mov	eax, DWORD PTR ?WorldTextureSet@@3JA	; WorldTextureSet
	add	eax, 1
	mov	DWORD PTR ?WorldTextureSet@@3JA, eax	; WorldTextureSet
$L76097:

; 116  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PickTextureSets@@YAXJ@Z ENDP				; PickTextureSets
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?MipSize@@YAJJJJJ@Z
_TEXT	SEGMENT
_pixels$ = -4						; size = 4
_size$ = 8						; size = 4
_set$ = 12						; size = 4
_count$ = 16						; size = 4
_mip$ = 20						; size = 4
?MipSize@@YAJJJJJ@Z PROC NEAR				; MipSize, COMDAT

; 123  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 124  : 	long pixels = 0;

	mov	DWORD PTR _pixels$[ebp], 0

; 125  : 
; 126  : 	for ( ; set ; set--)

	jmp	SHORT $L76109
$L76110:
	mov	eax, DWORD PTR _set$[ebp]
	sub	eax, 1
	mov	DWORD PTR _set$[ebp], eax
$L76109:
	cmp	DWORD PTR _set$[ebp], 0
	je	SHORT $L76112

; 127  : 		size /= 2;

	mov	eax, DWORD PTR _size$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _size$[ebp], eax
	jmp	SHORT $L76110
$L76112:

; 128  : 
; 129  : 	do {
; 130  : 		pixels += size * size;

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR _pixels$[ebp], eax

; 131  : 		size /= 2;

	mov	eax, DWORD PTR _size$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 132  : 	} while ((size >= 128) && mip);

	cmp	DWORD PTR _size$[ebp], 128		; 00000080H
	jl	SHORT $L76114
	cmp	DWORD PTR _mip$[ebp], 0
	jne	SHORT $L76112
$L76114:

; 133  : 
; 134  : 	return pixels * count;

	mov	eax, DWORD PTR _pixels$[ebp]
	imul	eax, DWORD PTR _count$[ebp]

; 135  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MipSize@@YAJJJJJ@Z ENDP				; MipSize
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?FindTextureCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z
_TEXT	SEGMENT
_ddpf$ = 8						; size = 4
_lParam$ = 12						; size = 4
?FindTextureCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z PROC NEAR ; FindTextureCallback, COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 143  : 
; 144  : // skip if z buffer only
; 145  : 
; 146  : 	if (ddpf->dwFlags & DDPF_ZBUFFER) return DDENUMRET_OK;

	mov	eax, DWORD PTR _ddpf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1024				; 00000400H
	je	SHORT $L76120
	mov	eax, 1
	jmp	$L76119
$L76120:

; 147  : 
; 148  : // skip if alpha only
; 149  : 
; 150  : 	if (ddpf->dwFlags & DDPF_ALPHA) return DDENUMRET_OK;

	mov	eax, DWORD PTR _ddpf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2
	je	SHORT $L76121
	mov	eax, 1
	jmp	$L76119
$L76121:

; 151  : 
; 152  : // skip if has alpha channel
; 153  : 
; 154  : 	if (ddpf->dwFlags & DDPF_ALPHAPIXELS) return DDENUMRET_OK;

	mov	eax, DWORD PTR _ddpf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	je	SHORT $L76122
	mov	eax, 1
	jmp	$L76119
$L76122:

; 155  : 
; 156  : // skip if less than 16 bpp
; 157  : 
; 158  :     if (ddpf->dwRGBBitCount < 16) return DDENUMRET_OK;

	mov	eax, DWORD PTR _ddpf$[ebp]
	cmp	DWORD PTR [eax+12], 16			; 00000010H
	jae	SHORT $L76123
	mov	eax, 1
	jmp	SHORT $L76119
$L76123:

; 159  : 
; 160  : // skip if not RGB
; 161  : 
; 162  :     if (ddpf->dwRGBBitCount > 8 && !(ddpf->dwFlags & DDPF_RGB)) return DDENUMRET_OK;

	mov	eax, DWORD PTR _ddpf$[ebp]
	cmp	DWORD PTR [eax+12], 8
	jbe	SHORT $L76124
	mov	eax, DWORD PTR _ddpf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 64					; 00000040H
	jne	SHORT $L76124
	mov	eax, 1
	jmp	SHORT $L76119
$L76124:

; 163  : 
; 164  : // take this format if we have nothing so far
; 165  : 
; 166  : 	if (TexFormat.dwRGBBitCount == 0) TexFormat = *ddpf;

	cmp	DWORD PTR ?TexFormat@@3U_DDPIXELFORMAT@@A+12, 0
	jne	SHORT $L76125
	mov	esi, DWORD PTR _ddpf$[ebp]
	mov	ecx, 8
	mov	edi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	rep movsd
$L76125:

; 167  : 
; 168  : // take this format if equals request bpp
; 169  : 
; 170  : 	if (ddpf->dwRGBBitCount == 16 && TexBppRequest == 16) TexFormat = *ddpf;

	mov	eax, DWORD PTR _ddpf$[ebp]
	cmp	DWORD PTR [eax+12], 16			; 00000010H
	jne	SHORT $L76126
	cmp	DWORD PTR _TexBppRequest, 16		; 00000010H
	jne	SHORT $L76126
	mov	esi, DWORD PTR _ddpf$[ebp]
	mov	ecx, 8
	mov	edi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	rep movsd
$L76126:

; 171  : 	if (ddpf->dwRGBBitCount >= 24 && TexBppRequest == 24) TexFormat = *ddpf;

	mov	eax, DWORD PTR _ddpf$[ebp]
	cmp	DWORD PTR [eax+12], 24			; 00000018H
	jb	SHORT $L76127
	cmp	DWORD PTR _TexBppRequest, 24		; 00000018H
	jne	SHORT $L76127
	mov	esi, DWORD PTR _ddpf$[ebp]
	mov	ecx, 8
	mov	edi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	rep movsd
$L76127:

; 172  : 
; 173  : // return OK
; 174  : 
; 175  : 	return DDENUMRET_OK;

	mov	eax, 1
$L76119:

; 176  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FindTextureCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z ENDP	; FindTextureCallback
_TEXT	ENDS
EXTRN	__chkstk:NEAR
EXTRN	_memset:NEAR
EXTRN	?DD@@3PAUIDirectDraw4@@A:DWORD			; DD
EXTRN	_IID_IDirect3DTexture2:BYTE
; Function compile flags: /Odt /ZI
;	COMDAT ?CountTexturePixels@@YAJJJJ@Z
_TEXT	SEGMENT
_texture$ = -8336					; size = 4096
_surface$ = -4240					; size = 4096
_sourcetexture$ = -144					; size = 4
_sourcesurface$ = -140					; size = 4
_r$ = -136						; size = 4
_ddsd2$ = -132						; size = 124
_max$ = -8						; size = 4
_i$ = -4						; size = 4
_needed$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?CountTexturePixels@@YAJJJJ@Z PROC NEAR			; CountTexturePixels, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8400				; 000020d0H
	call	__chkstk
	push	ebx
	push	esi
	push	edi

; 184  : 	long i, max;
; 185  : 	DDSURFACEDESC2 ddsd2;
; 186  : 	HRESULT	r;
; 187  : 	IDirectDrawSurface4 *sourcesurface;
; 188  : 	IDirect3DTexture2 *sourcetexture;
; 189  : 	IDirectDrawSurface4 *surface[MAX_TEXTURE_TEST];
; 190  : 	IDirect3DTexture2 *texture[MAX_TEXTURE_TEST];
; 191  : 
; 192  : // zero count
; 193  : 
; 194  : 	max = 0;

	mov	DWORD PTR _max$[ebp], 0

; 195  : 
; 196  : // create source surface
; 197  : 
; 198  : 	ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 199  : 	ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 200  : 	ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_TEXTURESTAGE;

	mov	DWORD PTR _ddsd2$[ebp+4], 1052679	; 00101007H

; 201  : 	ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;

	mov	DWORD PTR _ddsd2$[ebp+104], 6144	; 00001800H

; 202  : 	ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 203  : 	ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 204  : 	ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 205  : 	ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 206  : 	ddsd2.dwTextureStage = 0;

	mov	DWORD PTR _ddsd2$[ebp+120], 0

; 207  : 
; 208  : 	r = DD->CreateSurface(&ddsd2, &sourcesurface, NULL);

	push	0
	lea	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ddsd2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	ecx
	call	DWORD PTR [eax+24]
	mov	DWORD PTR _r$[ebp], eax

; 209  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76141

; 210  : 	{
; 211  : 		return 0;

	xor	eax, eax
	jmp	$L76132
$L76141:

; 212  : 	}
; 213  : 
; 214  : 	r = sourcesurface->QueryInterface(IID_IDirect3DTexture2, (void**)&sourcetexture);

	lea	eax, DWORD PTR _sourcetexture$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	mov	ecx, DWORD PTR _sourcesurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	call	DWORD PTR [edx]
	mov	DWORD PTR _r$[ebp], eax

; 215  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76143

; 216  : 	{
; 217  : 		RELEASE(sourcesurface);

	cmp	DWORD PTR _sourcesurface$[ebp], 0
	je	SHORT $L76144
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcesurface$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcesurface$[ebp], 0
$L76144:

; 218  : 		return 0;

	xor	eax, eax
	jmp	$L76132
$L76143:

; 219  : 	}
; 220  : 
; 221  : // count textures
; 222  : 
; 223  : 	if (needed > MAX_TEXTURE_TEST) needed = MAX_TEXTURE_TEST;

	cmp	DWORD PTR _needed$[ebp], 1024		; 00000400H
	jle	SHORT $L76145
	mov	DWORD PTR _needed$[ebp], 1024		; 00000400H
$L76145:

; 224  : 
; 225  : 	for (i = 0 ; i < needed ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76146
$L76147:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76146:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _needed$[ebp]
	jge	$L76148

; 226  : 	{
; 227  : 		ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 228  : 		ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 229  : 		ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_TEXTURESTAGE;

	mov	DWORD PTR _ddsd2$[ebp+4], 1052679	; 00101007H

; 230  : 		ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM | DDSCAPS_ALLOCONLOAD;

	mov	DWORD PTR _ddsd2$[ebp+104], 335564800	; 14005000H

; 231  : 		ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 232  : 		ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 233  : 		ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 234  : 		ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 235  : 		ddsd2.dwTextureStage = 0;

	mov	DWORD PTR _ddsd2$[ebp+120], 0

; 236  : 
; 237  : 		r = DD->CreateSurface(&ddsd2, &surface[i], NULL);

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _surface$[ebp+eax*4]
	push	ecx
	lea	edx, DWORD PTR _ddsd2$[ebp]
	push	edx
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+24]
	mov	DWORD PTR _r$[ebp], eax

; 238  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76149

; 239  : 		{
; 240  : 			break;

	jmp	$L76148
$L76149:

; 241  : 		}
; 242  : 
; 243  : 		r = surface[i]->QueryInterface(IID_IDirect3DTexture2, (void**)&texture[i]);

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _texture$[ebp+eax*4]
	push	ecx
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _surface$[ebp+ecx*4]
	mov	eax, DWORD PTR [eax]
	push	edx
	call	DWORD PTR [eax]
	mov	DWORD PTR _r$[ebp], eax

; 244  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76151

; 245  : 		{
; 246  : 			RELEASE(surface[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _surface$[ebp+eax*4], 0
	je	SHORT $L76152
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surface$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _surface$[ebp+eax*4], 0
$L76152:

; 247  : 			break;

	jmp	$L76148
$L76151:

; 248  : 		}
; 249  : 
; 250  : 		r = texture[i]->Load(sourcetexture);

	mov	eax, DWORD PTR _sourcetexture$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _texture$[ebp+ecx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp+eax*4]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+20]
	mov	DWORD PTR _r$[ebp], eax

; 251  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76153

; 252  : 		{
; 253  : 			RELEASE(texture[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _texture$[ebp+eax*4], 0
	je	SHORT $L76154
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _texture$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _texture$[ebp+eax*4], 0
$L76154:

; 254  : 			RELEASE(surface[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _surface$[ebp+eax*4], 0
	je	SHORT $L76155
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surface$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _surface$[ebp+eax*4], 0
$L76155:

; 255  : 			break;

	jmp	SHORT $L76148
$L76153:

; 256  : 		}
; 257  : 
; 258  : 		max++;

	mov	eax, DWORD PTR _max$[ebp]
	add	eax, 1
	mov	DWORD PTR _max$[ebp], eax

; 259  : 	}

	jmp	$L76147
$L76148:

; 260  : 
; 261  : // kill textures
; 262  : 
; 263  : 	RELEASE(sourcesurface);

	cmp	DWORD PTR _sourcesurface$[ebp], 0
	je	SHORT $L76156
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcesurface$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcesurface$[ebp], 0
$L76156:

; 264  : 	RELEASE(sourcetexture);

	cmp	DWORD PTR _sourcetexture$[ebp], 0
	je	SHORT $L76157
	mov	eax, DWORD PTR _sourcetexture$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcetexture$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcetexture$[ebp], 0
$L76157:

; 265  : 
; 266  : 	for (i = 0 ; i < max ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76158
$L76159:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76158:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jge	SHORT $L76160

; 267  : 	{
; 268  : 		RELEASE(texture[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _texture$[ebp+eax*4], 0
	je	SHORT $L76161
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _texture$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _texture$[ebp+eax*4], 0
$L76161:

; 269  : 		RELEASE(surface[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _surface$[ebp+eax*4], 0
	je	SHORT $L76162
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surface$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _surface$[ebp+eax*4], 0
$L76162:

; 270  : 	}

	jmp	SHORT $L76159
$L76160:

; 271  : 
; 272  : // return count
; 273  : 
; 274  : 	return max * width * height;

	mov	eax, DWORD PTR _max$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
$L76132:

; 275  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CountTexturePixels@@YAJJJJ@Z ENDP			; CountTexturePixels
_TEXT	ENDS
PUBLIC	?CountMipTexturePixels@@YAJJJJ@Z		; CountMipTexturePixels
; Function compile flags: /Odt /ZI
;	COMDAT ?CountMipTexturePixels@@YAJJJJ@Z
_TEXT	SEGMENT
_texture$ = -8336					; size = 4096
_surface$ = -4240					; size = 4096
_sourcetexture$ = -144					; size = 4
_sourcesurface$ = -140					; size = 4
_r$ = -136						; size = 4
_ddsd2$ = -132						; size = 124
_max$ = -8						; size = 4
_i$ = -4						; size = 4
_needed$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?CountMipTexturePixels@@YAJJJJ@Z PROC NEAR		; CountMipTexturePixels, COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8400				; 000020d0H
	call	__chkstk
	push	ebx
	push	esi
	push	edi

; 283  : 	long i, max;
; 284  : 	DDSURFACEDESC2 ddsd2;
; 285  : 	HRESULT	r;
; 286  : 	IDirectDrawSurface4 *sourcesurface;
; 287  : 	IDirect3DTexture2 *sourcetexture;
; 288  : 	IDirectDrawSurface4 *surface[MAX_TEXTURE_TEST];
; 289  : 	IDirect3DTexture2 *texture[MAX_TEXTURE_TEST];
; 290  : 
; 291  : // zero count
; 292  : 
; 293  : 	max = 0;

	mov	DWORD PTR _max$[ebp], 0

; 294  : 
; 295  : // create source surface
; 296  : 
; 297  : 	ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 298  : 	ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 299  : 	ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_TEXTURESTAGE | DDSD_MIPMAPCOUNT;

	mov	DWORD PTR _ddsd2$[ebp+4], 1183751	; 00121007H

; 300  : 	ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY | DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;

	mov	DWORD PTR _ddsd2$[ebp+104], 4200456	; 00401808H

; 301  : 	ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 302  : 	ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 303  : 	ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 304  : 	ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 305  : 	ddsd2.dwTextureStage = 0;

	mov	DWORD PTR _ddsd2$[ebp+120], 0

; 306  : 	ddsd2.dwMipMapCount = MAX_MIPMAPS;

	mov	DWORD PTR _ddsd2$[ebp+24], 2

; 307  : 
; 308  : 	r = DD->CreateSurface(&ddsd2, &sourcesurface, NULL);

	push	0
	lea	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ddsd2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	ecx
	call	DWORD PTR [eax+24]
	mov	DWORD PTR _r$[ebp], eax

; 309  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76176

; 310  : 	{
; 311  : 		return 0;

	xor	eax, eax
	jmp	$L76167
$L76176:

; 312  : 	}
; 313  : 
; 314  : 	r = sourcesurface->QueryInterface(IID_IDirect3DTexture2, (void**)&sourcetexture);

	lea	eax, DWORD PTR _sourcetexture$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	mov	ecx, DWORD PTR _sourcesurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	call	DWORD PTR [edx]
	mov	DWORD PTR _r$[ebp], eax

; 315  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76178

; 316  : 	{
; 317  : 		RELEASE(sourcesurface);

	cmp	DWORD PTR _sourcesurface$[ebp], 0
	je	SHORT $L76179
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcesurface$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcesurface$[ebp], 0
$L76179:

; 318  : 		return 0;

	xor	eax, eax
	jmp	$L76167
$L76178:

; 319  : 	}
; 320  : 
; 321  : // count textures
; 322  : 
; 323  : 	if (needed > MAX_TEXTURE_TEST) needed = MAX_TEXTURE_TEST;

	cmp	DWORD PTR _needed$[ebp], 1024		; 00000400H
	jle	SHORT $L76180
	mov	DWORD PTR _needed$[ebp], 1024		; 00000400H
$L76180:

; 324  : 
; 325  : 	for (i = 0 ; i < needed ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76181
$L76182:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76181:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _needed$[ebp]
	jge	$L76183

; 326  : 	{
; 327  : 		ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 328  : 		ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 329  : 		ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_TEXTURESTAGE | DDSD_MIPMAPCOUNT;

	mov	DWORD PTR _ddsd2$[ebp+4], 1183751	; 00121007H

; 330  : 		ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM | DDSCAPS_ALLOCONLOAD | DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;

	mov	DWORD PTR _ddsd2$[ebp+104], 339759112	; 14405008H

; 331  : 		ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 332  : 		ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 333  : 		ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 334  : 		ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 335  : 		ddsd2.dwTextureStage = 0;

	mov	DWORD PTR _ddsd2$[ebp+120], 0

; 336  : 		ddsd2.dwMipMapCount = MAX_MIPMAPS;

	mov	DWORD PTR _ddsd2$[ebp+24], 2

; 337  : 
; 338  : 		r = DD->CreateSurface(&ddsd2, &surface[i], NULL);

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _surface$[ebp+eax*4]
	push	ecx
	lea	edx, DWORD PTR _ddsd2$[ebp]
	push	edx
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+24]
	mov	DWORD PTR _r$[ebp], eax

; 339  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76184

; 340  : 		{
; 341  : 			break;

	jmp	$L76183
$L76184:

; 342  : 		}
; 343  : 
; 344  : 		r = surface[i]->QueryInterface(IID_IDirect3DTexture2, (void**)&texture[i]);

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _texture$[ebp+eax*4]
	push	ecx
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _surface$[ebp+ecx*4]
	mov	eax, DWORD PTR [eax]
	push	edx
	call	DWORD PTR [eax]
	mov	DWORD PTR _r$[ebp], eax

; 345  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76186

; 346  : 		{
; 347  : 			RELEASE(surface[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _surface$[ebp+eax*4], 0
	je	SHORT $L76187
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surface$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _surface$[ebp+eax*4], 0
$L76187:

; 348  : 			break;

	jmp	$L76183
$L76186:

; 349  : 		}
; 350  : 
; 351  : 		r = texture[i]->Load(sourcetexture);

	mov	eax, DWORD PTR _sourcetexture$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _texture$[ebp+ecx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp+eax*4]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx+20]
	mov	DWORD PTR _r$[ebp], eax

; 352  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76188

; 353  : 		{
; 354  : 			RELEASE(texture[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _texture$[ebp+eax*4], 0
	je	SHORT $L76189
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _texture$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _texture$[ebp+eax*4], 0
$L76189:

; 355  : 			RELEASE(surface[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _surface$[ebp+eax*4], 0
	je	SHORT $L76190
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surface$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _surface$[ebp+eax*4], 0
$L76190:

; 356  : 			break;

	jmp	SHORT $L76183
$L76188:

; 357  : 		}
; 358  : 
; 359  : 		max++;

	mov	eax, DWORD PTR _max$[ebp]
	add	eax, 1
	mov	DWORD PTR _max$[ebp], eax

; 360  : 	}

	jmp	$L76182
$L76183:

; 361  : 
; 362  : // kill textures
; 363  : 
; 364  : 	RELEASE(sourcesurface);

	cmp	DWORD PTR _sourcesurface$[ebp], 0
	je	SHORT $L76191
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcesurface$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcesurface$[ebp], 0
$L76191:

; 365  : 	RELEASE(sourcetexture);

	cmp	DWORD PTR _sourcetexture$[ebp], 0
	je	SHORT $L76192
	mov	eax, DWORD PTR _sourcetexture$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcetexture$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcetexture$[ebp], 0
$L76192:

; 366  : 
; 367  : 	for (i = 0 ; i < max ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76193
$L76194:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76193:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jge	SHORT $L76195

; 368  : 	{
; 369  : 		RELEASE(texture[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _texture$[ebp+eax*4], 0
	je	SHORT $L76196
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _texture$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _texture$[ebp+eax*4], 0
$L76196:

; 370  : 		RELEASE(surface[i]);

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _surface$[ebp+eax*4], 0
	je	SHORT $L76197
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surface$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surface$[ebp+edx*4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _surface$[ebp+eax*4], 0
$L76197:

; 371  : 	}

	jmp	SHORT $L76194
$L76195:

; 372  : 
; 373  : // return count
; 374  : 
; 375  : 	return max * width * height;

	mov	eax, DWORD PTR _max$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
$L76167:

; 376  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CountMipTexturePixels@@YAJJJJ@Z ENDP			; CountMipTexturePixels
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?LoadTextureClever@@YA_NPADDJJJJJ@Z		; LoadTextureClever
PUBLIC	?LoadMipTexture@@YA_NPADDJJJJ@Z			; LoadMipTexture
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strlen:NEAR
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadTextureClever@@YA_NPADDJJJJJ@Z
_TEXT	SEGMENT
_buf$ = -272						; size = 256
_fp$ = -16						; size = 4
_mipcount$ = -12					; size = 4
_len$ = -8						; size = 4
_i$ = -4						; size = 4
_tex$ = 8						; size = 4
_tpage$ = 12						; size = 1
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_stage$ = 24						; size = 4
_set$ = 28						; size = 4
_mip$ = 32						; size = 4
?LoadTextureClever@@YA_NPADDJJJJJ@Z PROC NEAR		; LoadTextureClever, COMDAT

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi

; 384  : 	long i, len, mipcount;
; 385  : 	FILE *fp;
; 386  : 	char buf[256];
; 387  : 
; 388  : // skip if zero length filename
; 389  : 
; 390  : 	len = strlen(tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 391  : 	if (!len) return FALSE;

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $L76212
	xor	al, al
	jmp	$L76206
$L76212:

; 392  : 
; 393  : // count mip levels
; 394  : 
; 395  : 	mipcount = 0;

	mov	DWORD PTR _mipcount$[ebp], 0

; 396  : 	strcpy(buf, tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 397  : 
; 398  : 	for (i = 0 ; i < MAX_MIPMAPS ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76213
$L76214:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76213:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $L76215

; 399  : 	{
; 400  : 		buf[len - 1] = i + 'p';

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx-1], al

; 401  : 		fp = fopen(buf, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 402  : 		if (!fp) break;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L76217
	jmp	SHORT $L76215
$L76217:

; 403  : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 404  : 		mipcount++;

	mov	eax, DWORD PTR _mipcount$[ebp]
	add	eax, 1
	mov	DWORD PTR _mipcount$[ebp], eax

; 405  : 	}

	jmp	SHORT $L76214
$L76215:

; 406  : 
; 407  : 	if (!mipcount)

	cmp	DWORD PTR _mipcount$[ebp], 0
	jne	SHORT $L76218

; 408  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L76206
$L76218:

; 409  : 
; 410  : // get size
; 411  : 
; 412  : 	width >>= set;

	mov	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _set$[ebp]
	sar	eax, cl
	mov	DWORD PTR _width$[ebp], eax

; 413  : 	height >>= set;

	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _set$[ebp]
	sar	eax, cl
	mov	DWORD PTR _height$[ebp], eax

; 414  : 
; 415  : // get filename
; 416  : 
; 417  : 	if (set > mipcount - 1) set = mipcount - 1;

	mov	eax, DWORD PTR _mipcount$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _set$[ebp], eax
	jle	SHORT $L76219
	mov	eax, DWORD PTR _mipcount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _set$[ebp], eax
$L76219:

; 418  : 	buf[len - 1] = set + 'p';

	mov	eax, DWORD PTR _set$[ebp]
	add	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx-1], al

; 419  : 
; 420  : // get mip count
; 421  : 
; 422  : 	if (!mip)

	cmp	DWORD PTR _mip$[ebp], 0
	jne	SHORT $L76220

; 423  : 		mipcount = 1;

	mov	DWORD PTR _mipcount$[ebp], 1

; 424  : 	else

	jmp	SHORT $L76221
$L76220:

; 425  : 		mipcount -= set;

	mov	eax, DWORD PTR _mipcount$[ebp]
	sub	eax, DWORD PTR _set$[ebp]
	mov	DWORD PTR _mipcount$[ebp], eax
$L76221:

; 426  : 
; 427  : // load
; 428  : 
; 429  : 	return LoadMipTexture(buf, tpage, width, height, stage, mipcount);

	mov	eax, DWORD PTR _mipcount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	cl, BYTE PTR _tpage$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	?LoadMipTexture@@YA_NPADDJJJJ@Z		; LoadMipTexture
	add	esp, 24					; 00000018H
$L76206:

; 430  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadTextureClever@@YA_NPADDJJJJJ@Z ENDP		; LoadTextureClever
_TEXT	ENDS
PUBLIC	??_C@_0BJ@FEFGCBOG@Can?8t?5load?5texture?3?5?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR?$AA@			; `string'
PUBLIC	??_C@_0CO@JNPNPPAH@Can?8t?5create?5texture?5source?5surf@ ; `string'
PUBLIC	??_C@_0CM@OLGMOGGB@Can?8t?5create?5texture?5dest?5surfac@ ; `string'
PUBLIC	??_C@_0BN@MGCJOGAA@Can?8t?5create?5texture?5palette?$AA@ ; `string'
PUBLIC	??_C@_0CP@HNLHOIPF@Can?8t?5attach?5palette?5to?5texture?5@ ; `string'
PUBLIC	??_C@_0CN@FELOGPAN@Can?8t?5attach?5palette?5to?5texture?5@ ; `string'
PUBLIC	??_C@_0BN@CLDNNONA@Can?8t?5get?5texture?5surface?5DC?$AA@ ; `string'
PUBLIC	??_C@_0BO@CJGGGNKI@Can?8t?5blit?5to?5texture?5surface?$AA@ ; `string'
PUBLIC	??_C@_0CP@IJCJKAAI@Can?8t?5query?5interface?5for?5textur@ ; `string'
PUBLIC	??_C@_0DB@LBLBOAG@Can?8t?5query?5interface?5for?5textur@ ; `string'
PUBLIC	??_C@_0BI@NPJMNOBK@Can?8t?5load?5dest?5texture?$AA@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	?LoadTexture@@YA_NPADDJJJ@Z			; LoadTexture
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	__imp__GetObjectA@12:NEAR
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__StretchBlt@44:NEAR
EXTRN	?ErrorDX@@YAXJPAD@Z:NEAR			; ErrorDX
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	?DxState@@3UDX_STATE@@A:BYTE			; DxState
EXTRN	__imp__LoadImageA@24:NEAR
EXTRN	__imp__wsprintfA:NEAR
EXTRN	__imp__GetDIBColorTable@16:NEAR
;	COMDAT ??_C@_0BJ@FEFGCBOG@Can?8t?5load?5texture?3?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BJ@FEFGCBOG@Can?8t?5load?5texture?3?5?8?$CFs?8?$AA@ DB 'Can''t loa'
	DB	'd texture: ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR?$AA@ DB 'ERROR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JNPNPPAH@Can?8t?5create?5texture?5source?5surf@
CONST	SEGMENT
??_C@_0CO@JNPNPPAH@Can?8t?5create?5texture?5source?5surf@ DB 'Can''t crea'
	DB	'te texture source surface for ''%s''!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OLGMOGGB@Can?8t?5create?5texture?5dest?5surfac@
CONST	SEGMENT
??_C@_0CM@OLGMOGGB@Can?8t?5create?5texture?5dest?5surfac@ DB 'Can''t crea'
	DB	'te texture dest surface for ''%s''!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MGCJOGAA@Can?8t?5create?5texture?5palette?$AA@
CONST	SEGMENT
??_C@_0BN@MGCJOGAA@Can?8t?5create?5texture?5palette?$AA@ DB 'Can''t creat'
	DB	'e texture palette', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HNLHOIPF@Can?8t?5attach?5palette?5to?5texture?5@
CONST	SEGMENT
??_C@_0CP@HNLHOIPF@Can?8t?5attach?5palette?5to?5texture?5@ DB 'Can''t att'
	DB	'ach palette to texture source surface', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FELOGPAN@Can?8t?5attach?5palette?5to?5texture?5@
CONST	SEGMENT
??_C@_0CN@FELOGPAN@Can?8t?5attach?5palette?5to?5texture?5@ DB 'Can''t att'
	DB	'ach palette to texture dest surface', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CLDNNONA@Can?8t?5get?5texture?5surface?5DC?$AA@
CONST	SEGMENT
??_C@_0BN@CLDNNONA@Can?8t?5get?5texture?5surface?5DC?$AA@ DB 'Can''t get '
	DB	'texture surface DC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CJGGGNKI@Can?8t?5blit?5to?5texture?5surface?$AA@
CONST	SEGMENT
??_C@_0BO@CJGGGNKI@Can?8t?5blit?5to?5texture?5surface?$AA@ DB 'Can''t bli'
	DB	't to texture surface', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IJCJKAAI@Can?8t?5query?5interface?5for?5textur@
CONST	SEGMENT
??_C@_0CP@IJCJKAAI@Can?8t?5query?5interface?5for?5textur@ DB 'Can''t quer'
	DB	'y interface for texture dest surface', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LBLBOAG@Can?8t?5query?5interface?5for?5textur@
CONST	SEGMENT
??_C@_0DB@LBLBOAG@Can?8t?5query?5interface?5for?5textur@ DB 'Can''t query'
	DB	' interface for texture source surface', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NPJMNOBK@Can?8t?5load?5dest?5texture?$AA@
CONST	SEGMENT
??_C@_0BI@NPJMNOBK@Can?8t?5load?5dest?5texture?$AA@ DB 'Can''t load dest '
	DB	'texture', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadTexture@@YA_NPADDJJJ@Z
_TEXT	SEGMENT
_sourcesurface$ = -1480					; size = 4
_texsource$ = -1476					; size = 4
_blue$ = -1472						; size = 2
_green$ = -1468						; size = 2
_red$ = -1464						; size = 2
_ck$ = -1460						; size = 8
_adw$ = -1452						; size = 1024
_buff$ = -428						; size = 256
_i$ = -172						; size = 2
_cols$ = -168						; size = 2
_dc$ = -164						; size = 4
_dcimage$ = -160					; size = 4
_r$ = -156						; size = 4
_ddsd2$ = -152						; size = 124
_bm$ = -28						; size = 24
_hbm$ = -4						; size = 4
_tex$ = 8						; size = 4
_tpage$ = 12						; size = 1
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_stage$ = 24						; size = 4
?LoadTexture@@YA_NPADDJJJ@Z PROC NEAR			; LoadTexture, COMDAT

; 437  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1544				; 00000608H
	push	ebx
	push	esi
	push	edi

; 438  : 	HBITMAP hbm;
; 439  : 	BITMAP bm;
; 440  : 	DDSURFACEDESC2 ddsd2;
; 441  : 	HRESULT r;
; 442  : 	HDC dcimage, dc;
; 443  : 	unsigned short cols, i;
; 444  : 	char buff[256];
; 445  :     DWORD adw[256];
; 446  : 	DDCOLORKEY ck;
; 447  : 	short red, green, blue;
; 448  : 	IDirect3DTexture2 *texsource;
; 449  : 	IDirectDrawSurface4 *sourcesurface;
; 450  : 
; 451  : // null file?
; 452  : 
; 453  : 	if (!tex || tex[0] == '\0')

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $L76246
	mov	eax, DWORD PTR _tex$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L76245
$L76246:

; 454  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76245:

; 455  : 
; 456  : // check valid tpage
; 457  : 
; 458  : 	if (tpage > TEX_NTPages)

	movsx	eax, BYTE PTR _tpage$[ebp]
	cmp	eax, DWORD PTR ?TEX_NTPages@@3HA	; TEX_NTPages
	jle	SHORT $L76247

; 459  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76247:

; 460  : 
; 461  : // return if textures not enabled
; 462  : 
; 463  : 	if (!TexturesEnabled)

	movsx	eax, BYTE PTR ?TexturesEnabled@@3DA	; TexturesEnabled
	test	eax, eax
	jne	SHORT $L76248

; 464  : 	{
; 465  : 		TexInfo[tpage].Active = FALSE;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax], 0

; 466  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76248:

; 467  : 	}
; 468  : 
; 469  : // load bitmap
; 470  : 
; 471  : 	hbm = (HBITMAP)LoadImage(NULL, tex, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);

	push	8208					; 00002010H
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__LoadImageA@24
	mov	DWORD PTR _hbm$[ebp], eax

; 472  : 	if (!hbm)

	cmp	DWORD PTR _hbm$[ebp], 0
	jne	SHORT $L76250

; 473  : 	{
; 474  : 		wsprintf(buff, "Can't load texture: '%s'", tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BJ@FEFGCBOG@Can?8t?5load?5texture?3?5?8?$CFs?8?$AA@
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 475  : 		Box("ERROR", buff, MB_OK);

	push	0
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05MBDEGLCK@ERROR?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 476  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76250:

; 477  : 	}
; 478  : 	GetObject(hbm, sizeof(bm), &bm);

	lea	eax, DWORD PTR _bm$[ebp]
	push	eax
	push	24					; 00000018H
	mov	ecx, DWORD PTR _hbm$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetObjectA@12

; 479  : 
; 480  : // create texture source surface
; 481  : 
; 482  : 	ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 483  : 	ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 484  : 	ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_TEXTURESTAGE;

	mov	DWORD PTR _ddsd2$[ebp+4], 1052679	; 00101007H

; 485  : 	ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;

	mov	DWORD PTR _ddsd2$[ebp+104], 6144	; 00001800H

; 486  : 	ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 487  : 	ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 488  : 	ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 489  : 	ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 490  : 	ddsd2.dwTextureStage = stage;

	mov	eax, DWORD PTR _stage$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+120], eax

; 491  : 
; 492  : 	r = DD->CreateSurface(&ddsd2, &sourcesurface, NULL);

	push	0
	lea	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ddsd2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	ecx
	call	DWORD PTR [eax+24]
	mov	DWORD PTR _r$[ebp], eax

; 493  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76253

; 494  : 	{
; 495  : 		wsprintf(buff, "Can't create texture source surface for '%s'!", tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CO@JNPNPPAH@Can?8t?5create?5texture?5source?5surf@
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 496  : 		ErrorDX(r, buff);

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 497  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76253:

; 498  : 	}
; 499  : 
; 500  : // create texture dest surface
; 501  : 
; 502  : 	ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 503  : 	ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 504  : 	ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_TEXTURESTAGE;

	mov	DWORD PTR _ddsd2$[ebp+4], 1052679	; 00101007H

; 505  : 	ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM | DDSCAPS_ALLOCONLOAD;

	mov	DWORD PTR _ddsd2$[ebp+104], 335564800	; 14005000H

; 506  : 	ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 507  : 	ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 508  : 	ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 509  : 	ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 510  : 	ddsd2.dwTextureStage = stage;

	mov	eax, DWORD PTR _stage$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+120], eax

; 511  : 
; 512  : 	r = DD->CreateSurface(&ddsd2, &TexInfo[tpage].Surface, NULL);

	push	0
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	edx, DWORD PTR [ecx+eax+56]
	push	edx
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 513  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76255

; 514  : 	{
; 515  : 		wsprintf(buff, "Can't create texture dest surface for '%s'!", tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CM@OLGMOGGB@Can?8t?5create?5texture?5dest?5surfac@
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 516  : 		ErrorDX(r, buff);

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 517  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76255:

; 518  : 	}
; 519  : 
; 520  : // create a palette if 8 bit textures
; 521  : 
; 522  : 	if (TexFormat.dwRGBBitCount == 8)

	cmp	DWORD PTR ?TexFormat@@3U_DDPIXELFORMAT@@A+12, 8
	jne	$L76257

; 523  : 	{
; 524  : 		dcimage = CreateCompatibleDC(NULL);

	push	0
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	DWORD PTR _dcimage$[ebp], eax

; 525  : 		SelectObject(dcimage, hbm);

	mov	eax, DWORD PTR _hbm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dcimage$[ebp]
	push	ecx
	call	DWORD PTR __imp__SelectObject@8

; 526  : 		cols = GetDIBColorTable(dcimage, 0, 256, (RGBQUAD*)adw);

	lea	eax, DWORD PTR _adw$[ebp]
	push	eax
	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _dcimage$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDIBColorTable@16
	mov	WORD PTR _cols$[ebp], ax

; 527  : 		DeleteDC(dcimage);

	mov	eax, DWORD PTR _dcimage$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteDC@4

; 528  : 
; 529  : 		for (i = 0 ; i < cols ; i++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L76259
$L76260:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L76259:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _cols$[ebp]
	cmp	eax, ecx
	jge	$L76261

; 530  : 		{
; 531  : 			red = GetRValue(adw[i]);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	cx, BYTE PTR _adw$[ebp+eax*4]
	mov	WORD PTR _red$[ebp], cx

; 532  : 			green = GetGValue(adw[i]);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _adw$[ebp+eax*4]
	sar	ecx, 8
	movzx	dx, cl
	mov	WORD PTR _green$[ebp], dx

; 533  : 			blue = GetBValue(adw[i]);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _adw$[ebp+eax*4]
	shr	ecx, 16					; 00000010H
	movzx	dx, cl
	mov	WORD PTR _blue$[ebp], dx

; 534  : 
; 535  : 			adw[i] = RGB_MAKE(red, green, blue);

	movsx	eax, WORD PTR _red$[ebp]
	shl	eax, 16					; 00000010H
	movsx	ecx, WORD PTR _green$[ebp]
	shl	ecx, 8
	or	eax, ecx
	movsx	edx, WORD PTR _blue$[ebp]
	or	eax, edx
	movzx	ecx, WORD PTR _i$[ebp]
	mov	DWORD PTR _adw$[ebp+ecx*4], eax

; 536  : 		}

	jmp	$L76260
$L76261:

; 537  : 
; 538  : 		r = DD->CreatePalette(DDPCAPS_8BIT, (PALETTEENTRY*)adw, &TexInfo[tpage].Palette, NULL);

	push	0
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	edx, DWORD PTR [ecx+eax+60]
	push	edx
	lea	eax, DWORD PTR _adw$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+20]
	mov	DWORD PTR _r$[ebp], eax

; 539  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76268

; 540  : 		{
; 541  : 			ErrorDX(r, "Can't create texture palette");

	push	OFFSET FLAT:??_C@_0BN@MGCJOGAA@Can?8t?5create?5texture?5palette?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 542  : 			return FALSE;

	xor	al, al
	jmp	$L76228
$L76268:

; 543  : 		}
; 544  : 
; 545  : 		r = sourcesurface->SetPalette(TexInfo[tpage].Palette);

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+60]
	push	edx
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcesurface$[ebp]
	push	edx
	call	DWORD PTR [ecx+124]
	mov	DWORD PTR _r$[ebp], eax

; 546  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76270

; 547  : 		{
; 548  : 			ErrorDX(r, "Can't attach palette to texture source surface");

	push	OFFSET FLAT:??_C@_0CP@HNLHOIPF@Can?8t?5attach?5palette?5to?5texture?5@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 549  : 			return FALSE;

	xor	al, al
	jmp	$L76228
$L76270:

; 550  : 		}
; 551  : 
; 552  : 		r = TexInfo[tpage].Surface->SetPalette(TexInfo[tpage].Palette);

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+60]
	push	edx
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+56]
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [ecx+eax+56]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+124]
	mov	DWORD PTR _r$[ebp], eax

; 553  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76257

; 554  : 		{
; 555  : 			ErrorDX(r, "Can't attach palette to texture dest surface");

	push	OFFSET FLAT:??_C@_0CN@FELOGPAN@Can?8t?5attach?5palette?5to?5texture?5@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 556  : 			return FALSE;

	xor	al, al
	jmp	$L76228
$L76257:

; 557  : 		}
; 558  : 	}
; 559  : 
; 560  : // copy bitmap to source surface
; 561  : 
; 562  : 	dcimage = CreateCompatibleDC(NULL);

	push	0
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	DWORD PTR _dcimage$[ebp], eax

; 563  : 	SelectObject(dcimage, hbm);

	mov	eax, DWORD PTR _hbm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dcimage$[ebp]
	push	ecx
	call	DWORD PTR __imp__SelectObject@8

; 564  : 
; 565  : 	r = sourcesurface->GetDC(&dc);

	lea	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sourcesurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _r$[ebp], eax

; 566  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76274

; 567  : 	{
; 568  : 		ErrorDX(r, "Can't get texture surface DC");

	push	OFFSET FLAT:??_C@_0BN@CLDNNONA@Can?8t?5get?5texture?5surface?5DC?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 569  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76274:

; 570  : 	}
; 571  : 
; 572  : 	r = StretchBlt(dc, 0, 0, width, height, dcimage, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

	push	13369376				; 00cc0020H
	mov	eax, DWORD PTR _bm$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _bm$[ebp+4]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _dcimage$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _dc$[ebp]
	push	edx
	call	DWORD PTR __imp__StretchBlt@44
	mov	DWORD PTR _r$[ebp], eax

; 573  : 	if (!r)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $L76277

; 574  : 	{
; 575  : 		ErrorDX(r, "Can't blit to texture surface");

	push	OFFSET FLAT:??_C@_0BO@CJGGGNKI@Can?8t?5blit?5to?5texture?5surface?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 576  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76277:

; 577  : 	}
; 578  : 
; 579  : 	sourcesurface->ReleaseDC(dc);

	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sourcesurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	call	DWORD PTR [edx+104]

; 580  : 	DeleteDC(dcimage);

	mov	eax, DWORD PTR _dcimage$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteDC@4

; 581  : 
; 582  : // query interface for surfaces
; 583  : 
; 584  : 	r = TexInfo[tpage].Surface->QueryInterface(IID_IDirect3DTexture2, (void**)&TexInfo[tpage].Texture);

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+56]
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [ecx+eax+56]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx]
	mov	DWORD PTR _r$[ebp], eax

; 585  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76280

; 586  : 	{
; 587  : 		ErrorDX(r, "Can't query interface for texture dest surface");

	push	OFFSET FLAT:??_C@_0CP@IJCJKAAI@Can?8t?5query?5interface?5for?5textur@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 588  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76280:

; 589  : 	}
; 590  : 
; 591  : 	r = sourcesurface->QueryInterface(IID_IDirect3DTexture2, (void**)&texsource);

	lea	eax, DWORD PTR _texsource$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	mov	ecx, DWORD PTR _sourcesurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	call	DWORD PTR [edx]
	mov	DWORD PTR _r$[ebp], eax

; 592  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76283

; 593  : 	{
; 594  : 		ErrorDX(r, "Can't query interface for texture source surface");

	push	OFFSET FLAT:??_C@_0DB@LBLBOAG@Can?8t?5query?5interface?5for?5textur@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 595  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76283:

; 596  : 	}
; 597  : 
; 598  : // load dest with source
; 599  : 
; 600  : 	r = TexInfo[tpage].Texture->Load(texsource);

	mov	eax, DWORD PTR _texsource$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [edx+ecx+52]
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	ecx, DWORD PTR [edx+ecx+52]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+20]
	mov	DWORD PTR _r$[ebp], eax

; 601  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76285

; 602  : 	{
; 603  : 		ErrorDX(r, "Can't load dest texture");

	push	OFFSET FLAT:??_C@_0BI@NPJMNOBK@Can?8t?5load?5dest?5texture?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 604  : 		return FALSE;

	xor	al, al
	jmp	$L76228
$L76285:

; 605  : 	}
; 606  : 
; 607  : // set color key for dest surface
; 608  : 
; 609  : 	if (DxState.ColorKey)

	cmp	DWORD PTR ?DxState@@3UDX_STATE@@A+52, 0
	je	SHORT $L76287

; 610  : 	{
; 611  : 		ck.dwColorSpaceLowValue = 0;

	mov	DWORD PTR _ck$[ebp], 0

; 612  : 		ck.dwColorSpaceHighValue = 0;

	mov	DWORD PTR _ck$[ebp+4], 0

; 613  : 		TexInfo[tpage].Surface->SetColorKey(DDCKEY_SRCBLT, &ck);

	lea	eax, DWORD PTR _ck$[ebp]
	push	eax
	push	8
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [edx+ecx+56]
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	ecx, DWORD PTR [edx+ecx+56]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+116]
$L76287:

; 614  : 	}
; 615  : 
; 616  : // release source tex + surface
; 617  : 
; 618  : 	RELEASE(texsource);

	cmp	DWORD PTR _texsource$[ebp], 0
	je	SHORT $L76288
	mov	eax, DWORD PTR _texsource$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _texsource$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _texsource$[ebp], 0
$L76288:

; 619  : 	RELEASE(sourcesurface);

	cmp	DWORD PTR _sourcesurface$[ebp], 0
	je	SHORT $L76289
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcesurface$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcesurface$[ebp], 0
$L76289:

; 620  : 
; 621  : // kill bitmap object
; 622  : 
; 623  : 	DeleteObject(hbm);

	mov	eax, DWORD PTR _hbm$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteObject@4

; 624  : 
; 625  : // set info flags
; 626  : 
; 627  : 	TexInfo[tpage].Active = TRUE;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax], 1

; 628  : 	TexInfo[tpage].Width = width;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 629  : 	TexInfo[tpage].Height = height;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx

; 630  : 	TexInfo[tpage].Stage = stage;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR _stage$[ebp]
	mov	DWORD PTR [ecx+eax+12], edx

; 631  : 	TexInfo[tpage].MipCount = 0;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax+16], 0

; 632  : 	wsprintf(TexInfo[tpage].File, "%s", tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	eax, DWORD PTR [edx+ecx+20]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 633  : 
; 634  : // return OK
; 635  : 
; 636  : 	return TRUE;

	mov	al, 1
$L76228:

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadTexture@@YA_NPADDJJJ@Z ENDP			; LoadTexture
_TEXT	ENDS
PUBLIC	??_C@_0CO@GPJIFGFK@Can?8t?5create?5mipmap?5source?5surfa@ ; `string'
PUBLIC	??_C@_0CM@OGBCNLBK@Can?8t?5create?5mipmap?5dest?5surface@ ; `string'
PUBLIC	??_C@_0CA@KLINOPDH@Can?8t?5load?5mipmap?5texture?3?5?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0CN@OEAPAIEJ@Can?8t?5get?5attached?5surface?5for?5s@ ; `string'
PUBLIC	??_C@_0CL@ILJNDPDH@Can?8t?5get?5attached?5surface?5for?5d@ ; `string'
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0CO@GPJIFGFK@Can?8t?5create?5mipmap?5source?5surfa@
CONST	SEGMENT
??_C@_0CO@GPJIFGFK@Can?8t?5create?5mipmap?5source?5surfa@ DB 'Can''t crea'
	DB	'te mipmap source surfaces for ''%s''!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OGBCNLBK@Can?8t?5create?5mipmap?5dest?5surface@
CONST	SEGMENT
??_C@_0CM@OGBCNLBK@Can?8t?5create?5mipmap?5dest?5surface@ DB 'Can''t crea'
	DB	'te mipmap dest surfaces for ''%s''!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KLINOPDH@Can?8t?5load?5mipmap?5texture?3?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0CA@KLINOPDH@Can?8t?5load?5mipmap?5texture?3?5?8?$CFs?8?$AA@ DB 'Ca'
	DB	'n''t load mipmap texture: ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OEAPAIEJ@Can?8t?5get?5attached?5surface?5for?5s@
CONST	SEGMENT
??_C@_0CN@OEAPAIEJ@Can?8t?5get?5attached?5surface?5for?5s@ DB 'Can''t get'
	DB	' attached surface for source mipmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ILJNDPDH@Can?8t?5get?5attached?5surface?5for?5d@
CONST	SEGMENT
??_C@_0CL@ILJNDPDH@Can?8t?5get?5attached?5surface?5for?5d@ DB 'Can''t get'
	DB	' attached surface for dest mipmap', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadMipTexture@@YA_NPADDJJJJ@Z
_TEXT	SEGMENT
tv165 = -1584						; size = 4
_mipdestnext$ = -1516					; size = 4
_mipsourcenext$ = -1512					; size = 4
_mipdest$ = -1508					; size = 4
_mipsource$ = -1504					; size = 4
_sourcesurface$ = -1500					; size = 4
_texsource$ = -1496					; size = 4
_blue$ = -1492						; size = 2
_green$ = -1488						; size = 2
_red$ = -1484						; size = 2
_ck$ = -1480						; size = 8
_adw$ = -1472						; size = 1024
_buff$ = -448						; size = 256
_miploop$ = -192					; size = 2
_i$ = -188						; size = 2
_cols$ = -184						; size = 2
_dc$ = -180						; size = 4
_dcimage$ = -176					; size = 4
_r$ = -172						; size = 4
_ddscaps2$ = -168					; size = 16
_ddsd2$ = -152						; size = 124
_bm$ = -28						; size = 24
_hbm$ = -4						; size = 4
_tex$ = 8						; size = 4
_tpage$ = 12						; size = 1
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_stage$ = 24						; size = 4
_mipcount$ = 28						; size = 4
?LoadMipTexture@@YA_NPADDJJJJ@Z PROC NEAR		; LoadMipTexture, COMDAT

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1584				; 00000630H
	push	ebx
	push	esi
	push	edi

; 645  : 	HBITMAP hbm;
; 646  : 	BITMAP bm;
; 647  : 	DDSURFACEDESC2 ddsd2;
; 648  : 	DDSCAPS2 ddscaps2;
; 649  : 	HRESULT r;
; 650  : 	HDC dcimage, dc;
; 651  : 	unsigned short cols, i, miploop;
; 652  : 	char buff[256];
; 653  :     DWORD adw[256];
; 654  : 	DDCOLORKEY ck;
; 655  : 	short red, green, blue;
; 656  : 	IDirect3DTexture2 *texsource;
; 657  : 	IDirectDrawSurface4 *sourcesurface;
; 658  : 	IDirectDrawSurface4 *mipsource, *mipdest, *mipsourcenext, *mipdestnext;
; 659  : 
; 660  : // null file?
; 661  : 
; 662  : 	if (!tex || tex[0] == '\0')

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $L76322
	mov	eax, DWORD PTR _tex$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L76321
$L76322:

; 663  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76321:

; 664  : 
; 665  : // check valid tpage
; 666  : 
; 667  : 	if (tpage > TEX_NTPages)

	movsx	eax, BYTE PTR _tpage$[ebp]
	cmp	eax, DWORD PTR ?TEX_NTPages@@3HA	; TEX_NTPages
	jle	SHORT $L76323

; 668  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76323:

; 669  : 
; 670  : // return if textures not enabled
; 671  : 
; 672  : 	if (!TexturesEnabled)

	movsx	eax, BYTE PTR ?TexturesEnabled@@3DA	; TexturesEnabled
	test	eax, eax
	jne	SHORT $L76324

; 673  : 	{
; 674  : 		TexInfo[tpage].Active = FALSE;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax], 0

; 675  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76324:

; 676  : 	}
; 677  : 
; 678  : // check mipcount
; 679  : 
; 680  : 	if (mipcount < 0 || mipcount > MAX_MIPMAPS)

	cmp	DWORD PTR _mipcount$[ebp], 0
	jl	SHORT $L76326
	cmp	DWORD PTR _mipcount$[ebp], 2
	jle	SHORT $L76325
$L76326:

; 681  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76325:

; 682  : 
; 683  : // create texture source surfaces
; 684  : 
; 685  : 	ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 686  : 	ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 687  : 	ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_MIPMAPCOUNT | DDSD_TEXTURESTAGE;

	mov	DWORD PTR _ddsd2$[ebp+4], 1183751	; 00121007H

; 688  : 	ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY | DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;

	mov	DWORD PTR _ddsd2$[ebp+104], 4200456	; 00401808H

; 689  : 	ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 690  : 	ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 691  : 	ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 692  : 	ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 693  : 	ddsd2.dwMipMapCount = mipcount;

	mov	eax, DWORD PTR _mipcount$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+24], eax

; 694  : 	ddsd2.dwTextureStage = stage;

	mov	eax, DWORD PTR _stage$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+120], eax

; 695  : 
; 696  : 	r = DD->CreateSurface(&ddsd2, &sourcesurface, NULL);

	push	0
	lea	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ddsd2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	ecx
	call	DWORD PTR [eax+24]
	mov	DWORD PTR _r$[ebp], eax

; 697  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76327

; 698  : 	{
; 699  : 		wsprintf(buff, "Can't create mipmap source surfaces for '%s'!", tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CO@GPJIFGFK@Can?8t?5create?5mipmap?5source?5surfa@
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 700  : 		ErrorDX(r, buff);

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 701  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76327:

; 702  : 	}
; 703  : 
; 704  : // create texture dest surfaces
; 705  : 
; 706  : 	ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 707  : 	ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 708  : 	ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_MIPMAPCOUNT | DDSD_TEXTURESTAGE;

	mov	DWORD PTR _ddsd2$[ebp+4], 1183751	; 00121007H

; 709  : 	ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM | DDSCAPS_ALLOCONLOAD | DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;

	mov	DWORD PTR _ddsd2$[ebp+104], 339759112	; 14405008H

; 710  : 	ddsd2.ddsCaps.dwCaps2 = DDSCAPS2_OPAQUE;

	mov	DWORD PTR _ddsd2$[ebp+108], 128		; 00000080H

; 711  : 	ddsd2.dwWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 712  : 	ddsd2.dwHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 713  : 	ddsd2.ddpfPixelFormat = TexFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?TexFormat@@3U_DDPIXELFORMAT@@A ; TexFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 714  : 	ddsd2.dwMipMapCount = mipcount;

	mov	eax, DWORD PTR _mipcount$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+24], eax

; 715  : 	ddsd2.dwTextureStage = stage;

	mov	eax, DWORD PTR _stage$[ebp]
	mov	DWORD PTR _ddsd2$[ebp+120], eax

; 716  : 
; 717  : 	r = DD->CreateSurface(&ddsd2, &TexInfo[tpage].Surface, NULL);

	push	0
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	edx, DWORD PTR [ecx+eax+56]
	push	edx
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 718  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76329

; 719  : 	{
; 720  : 		wsprintf(buff, "Can't create mipmap dest surfaces for '%s'!", tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CM@OGBCNLBK@Can?8t?5create?5mipmap?5dest?5surface@
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 721  : 		ErrorDX(r, buff);

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 722  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76329:

; 723  : 	}
; 724  : 
; 725  : // load each mipmap into source, set palette for source and dest
; 726  : 
; 727  : 	mipsource = sourcesurface;

	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	DWORD PTR _mipsource$[ebp], eax

; 728  : 	mipsource->AddRef();

	mov	eax, DWORD PTR _mipsource$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mipsource$[ebp]
	push	edx
	call	DWORD PTR [ecx+4]

; 729  : 
; 730  : 	mipdest = TexInfo[tpage].Surface;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+56]
	mov	DWORD PTR _mipdest$[ebp], edx

; 731  : 	mipdest->AddRef();

	mov	eax, DWORD PTR _mipdest$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mipdest$[ebp]
	push	edx
	call	DWORD PTR [ecx+4]

; 732  : 
; 733  : 	for (miploop = 0 ; miploop < mipcount ; miploop++)

	mov	WORD PTR _miploop$[ebp], 0
	jmp	SHORT $L76331
$L76332:
	mov	ax, WORD PTR _miploop$[ebp]
	add	ax, 1
	mov	WORD PTR _miploop$[ebp], ax
$L76331:
	movzx	eax, WORD PTR _miploop$[ebp]
	cmp	eax, DWORD PTR _mipcount$[ebp]
	jge	$L76333

; 734  : 	{
; 735  : 
; 736  : // load bitmap
; 737  : 
; 738  : 		memcpy(buff, tex, MAX_TPAGE_FILENAME);

	push	32					; 00000020H
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 739  : 		buff[strlen(buff) - 1] += miploop;

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _buff$[ebp+eax-1]
	mov	DWORD PTR tv165[ebp], ecx
	movzx	edx, WORD PTR _miploop$[ebp]
	mov	eax, DWORD PTR tv165[ebp]
	movsx	ecx, BYTE PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR tv165[ebp]
	mov	BYTE PTR [edx], cl

; 740  : 		hbm = (HBITMAP)LoadImage(NULL, buff, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);

	push	8208					; 00002010H
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__LoadImageA@24
	mov	DWORD PTR _hbm$[ebp], eax

; 741  : 		if (!hbm)

	cmp	DWORD PTR _hbm$[ebp], 0
	jne	SHORT $L76335

; 742  : 		{
; 743  : 			wsprintf(buff, "Can't load mipmap texture: '%s'", buff);

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CA@KLINOPDH@Can?8t?5load?5mipmap?5texture?3?5?8?$CFs?8?$AA@
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 744  : 			Box("ERROR", buff, MB_OK);

	push	0
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05MBDEGLCK@ERROR?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 745  : 			return FALSE;

	xor	al, al
	jmp	$L76298
$L76335:

; 746  : 		}
; 747  : 		GetObject(hbm, sizeof(bm), &bm);

	lea	eax, DWORD PTR _bm$[ebp]
	push	eax
	push	24					; 00000018H
	mov	ecx, DWORD PTR _hbm$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetObjectA@12

; 748  : 
; 749  : // create a palette if 8 bit textures
; 750  : 
; 751  : 		if (TexFormat.dwRGBBitCount == 8)

	cmp	DWORD PTR ?TexFormat@@3U_DDPIXELFORMAT@@A+12, 8
	jne	$L76337

; 752  : 		{
; 753  : 			if (!miploop)

	movzx	eax, WORD PTR _miploop$[ebp]
	test	eax, eax
	jne	$L76338

; 754  : 			{
; 755  : 				dcimage = CreateCompatibleDC(NULL);

	push	0
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	DWORD PTR _dcimage$[ebp], eax

; 756  : 				SelectObject(dcimage, hbm);

	mov	eax, DWORD PTR _hbm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dcimage$[ebp]
	push	ecx
	call	DWORD PTR __imp__SelectObject@8

; 757  : 				cols = GetDIBColorTable(dcimage, 0, 256, (RGBQUAD*)adw);

	lea	eax, DWORD PTR _adw$[ebp]
	push	eax
	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _dcimage$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDIBColorTable@16
	mov	WORD PTR _cols$[ebp], ax

; 758  : 				DeleteDC(dcimage);

	mov	eax, DWORD PTR _dcimage$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteDC@4

; 759  : 
; 760  : 				for (i = 0 ; i < cols ; i++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L76340
$L76341:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L76340:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _cols$[ebp]
	cmp	eax, ecx
	jge	$L76342

; 761  : 				{
; 762  : 					red = GetRValue(adw[i]);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	cx, BYTE PTR _adw$[ebp+eax*4]
	mov	WORD PTR _red$[ebp], cx

; 763  : 					green = GetGValue(adw[i]);

	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _adw$[ebp+eax*4]
	sar	ecx, 8
	movzx	dx, cl
	mov	WORD PTR _green$[ebp], dx

; 764  : 					blue = GetBValue(adw[i]);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _adw$[ebp+eax*4]
	shr	ecx, 16					; 00000010H
	movzx	dx, cl
	mov	WORD PTR _blue$[ebp], dx

; 765  : 
; 766  : 					adw[i] = RGB_MAKE(red, green, blue);

	movsx	eax, WORD PTR _red$[ebp]
	shl	eax, 16					; 00000010H
	movsx	ecx, WORD PTR _green$[ebp]
	shl	ecx, 8
	or	eax, ecx
	movsx	edx, WORD PTR _blue$[ebp]
	or	eax, edx
	movzx	ecx, WORD PTR _i$[ebp]
	mov	DWORD PTR _adw$[ebp+ecx*4], eax

; 767  : 				}

	jmp	$L76341
$L76342:

; 768  : 
; 769  : 				r = DD->CreatePalette(DDPCAPS_8BIT, (PALETTEENTRY*)adw, &TexInfo[tpage].Palette, NULL);

	push	0
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	edx, DWORD PTR [ecx+eax+60]
	push	edx
	lea	eax, DWORD PTR _adw$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+20]
	mov	DWORD PTR _r$[ebp], eax

; 770  : 				if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76338

; 771  : 				{
; 772  : 					ErrorDX(r, "Can't create texture palette");

	push	OFFSET FLAT:??_C@_0BN@MGCJOGAA@Can?8t?5create?5texture?5palette?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 773  : 					return FALSE;

	xor	al, al
	jmp	$L76298
$L76338:

; 774  : 				}
; 775  : 			}
; 776  : 
; 777  : 			r = mipsource->SetPalette(TexInfo[tpage].Palette);

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+60]
	push	edx
	mov	eax, DWORD PTR _mipsource$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mipsource$[ebp]
	push	edx
	call	DWORD PTR [ecx+124]
	mov	DWORD PTR _r$[ebp], eax

; 778  : 			if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76350

; 779  : 			{
; 780  : 				ErrorDX(r, "Can't attach palette to texture source surface");

	push	OFFSET FLAT:??_C@_0CP@HNLHOIPF@Can?8t?5attach?5palette?5to?5texture?5@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 781  : 				return FALSE;

	xor	al, al
	jmp	$L76298
$L76350:

; 782  : 			}
; 783  : 
; 784  : 			r = mipdest->SetPalette(TexInfo[tpage].Palette);

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+60]
	push	edx
	mov	eax, DWORD PTR _mipdest$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mipdest$[ebp]
	push	edx
	call	DWORD PTR [ecx+124]
	mov	DWORD PTR _r$[ebp], eax

; 785  : 			if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76337

; 786  : 			{
; 787  : 				ErrorDX(r, "Can't attach palette to texture dest surface");

	push	OFFSET FLAT:??_C@_0CN@FELOGPAN@Can?8t?5attach?5palette?5to?5texture?5@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 788  : 				return FALSE;

	xor	al, al
	jmp	$L76298
$L76337:

; 789  : 			}
; 790  : 		}
; 791  : 
; 792  : // copy bitmap to source surface
; 793  : 
; 794  : 		dcimage = CreateCompatibleDC(NULL);

	push	0
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	DWORD PTR _dcimage$[ebp], eax

; 795  : 		SelectObject(dcimage, hbm);

	mov	eax, DWORD PTR _hbm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dcimage$[ebp]
	push	ecx
	call	DWORD PTR __imp__SelectObject@8

; 796  : 
; 797  : 		r = mipsource->GetDC(&dc);

	lea	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mipsource$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _mipsource$[ebp]
	push	eax
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _r$[ebp], eax

; 798  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76352

; 799  : 		{
; 800  : 			ErrorDX(r, "Can't get texture surface DC");

	push	OFFSET FLAT:??_C@_0BN@CLDNNONA@Can?8t?5get?5texture?5surface?5DC?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 801  : 			return FALSE;

	xor	al, al
	jmp	$L76298
$L76352:

; 802  : 		}
; 803  : 
; 804  : 		r = StretchBlt(dc, 0, 0, width >> miploop, height >> miploop, dcimage, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

	push	13369376				; 00cc0020H
	mov	eax, DWORD PTR _bm$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _bm$[ebp+4]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _dcimage$[ebp]
	push	edx
	movzx	ecx, WORD PTR _miploop$[ebp]
	mov	eax, DWORD PTR _height$[ebp]
	sar	eax, cl
	push	eax
	movzx	ecx, WORD PTR _miploop$[ebp]
	mov	edx, DWORD PTR _width$[ebp]
	sar	edx, cl
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	call	DWORD PTR __imp__StretchBlt@44
	mov	DWORD PTR _r$[ebp], eax

; 805  : 		if (!r)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $L76354

; 806  : 		{
; 807  : 			ErrorDX(r, "Can't blit to texture surface");

	push	OFFSET FLAT:??_C@_0BO@CJGGGNKI@Can?8t?5blit?5to?5texture?5surface?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 808  : 			return FALSE;

	xor	al, al
	jmp	$L76298
$L76354:

; 809  : 		}
; 810  : 
; 811  : 		mipsource->ReleaseDC(dc);

	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mipsource$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _mipsource$[ebp]
	push	eax
	call	DWORD PTR [edx+104]

; 812  : 		DeleteDC(dcimage);

	mov	eax, DWORD PTR _dcimage$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteDC@4

; 813  : 
; 814  : // set color key for dest surface
; 815  : 
; 816  : 		if (DxState.ColorKey)

	cmp	DWORD PTR ?DxState@@3UDX_STATE@@A+52, 0
	je	SHORT $L76355

; 817  : 		{
; 818  : 			ck.dwColorSpaceLowValue = 0;

	mov	DWORD PTR _ck$[ebp], 0

; 819  : 			ck.dwColorSpaceHighValue = 0;

	mov	DWORD PTR _ck$[ebp+4], 0

; 820  : 			mipdest->SetColorKey(DDCKEY_SRCBLT, &ck);

	lea	eax, DWORD PTR _ck$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _mipdest$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _mipdest$[ebp]
	push	eax
	call	DWORD PTR [edx+116]
$L76355:

; 821  : 		}
; 822  : 
; 823  : // kill bitmap object
; 824  : 
; 825  : 		DeleteObject(hbm);

	mov	eax, DWORD PTR _hbm$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteObject@4

; 826  : 
; 827  : // get child surfaces if not last mipmap
; 828  : 
; 829  : 		if (miploop != mipcount - 1)

	movzx	eax, WORD PTR _miploop$[ebp]
	mov	ecx, DWORD PTR _mipcount$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	je	$L76356

; 830  : 		{
; 831  : 			ddscaps2.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP | DDSCAPS_SYSTEMMEMORY;

	mov	DWORD PTR _ddscaps2$[ebp], 4200448	; 00401800H

; 832  : 			r = mipsource->GetAttachedSurface(&ddscaps2, &mipsourcenext);

	lea	eax, DWORD PTR _mipsourcenext$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ddscaps2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mipsource$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _mipsource$[ebp]
	push	ecx
	call	DWORD PTR [eax+48]
	mov	DWORD PTR _r$[ebp], eax

; 833  : 			if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76357

; 834  : 			{
; 835  : 				ErrorDX(r, "Can't get attached surface for source mipmap");

	push	OFFSET FLAT:??_C@_0CN@OEAPAIEJ@Can?8t?5get?5attached?5surface?5for?5s@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 836  : 				return FALSE;

	xor	al, al
	jmp	$L76298
$L76357:

; 837  : 			}
; 838  : 
; 839  : 			ddscaps2.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP | DDSCAPS_ALLOCONLOAD;

	mov	DWORD PTR _ddscaps2$[ebp], 71307264	; 04401000H

; 840  : 			r = mipdest->GetAttachedSurface(&ddscaps2, &mipdestnext);

	lea	eax, DWORD PTR _mipdestnext$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ddscaps2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mipdest$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _mipdest$[ebp]
	push	ecx
	call	DWORD PTR [eax+48]
	mov	DWORD PTR _r$[ebp], eax

; 841  : 			if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76356

; 842  : 			{
; 843  : 				ErrorDX(r, "Can't get attached surface for dest mipmap");

	push	OFFSET FLAT:??_C@_0CL@ILJNDPDH@Can?8t?5get?5attached?5surface?5for?5d@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 844  : 				return FALSE;

	xor	al, al
	jmp	$L76298
$L76356:

; 845  : 			}
; 846  : 		}
; 847  : 
; 848  : 		RELEASE(mipsource);

	cmp	DWORD PTR _mipsource$[ebp], 0
	je	SHORT $L76361
	mov	eax, DWORD PTR _mipsource$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mipsource$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _mipsource$[ebp], 0
$L76361:

; 849  : 		mipsource = mipsourcenext;

	mov	eax, DWORD PTR _mipsourcenext$[ebp]
	mov	DWORD PTR _mipsource$[ebp], eax

; 850  : 
; 851  : 		RELEASE(mipdest);

	cmp	DWORD PTR _mipdest$[ebp], 0
	je	SHORT $L76362
	mov	eax, DWORD PTR _mipdest$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mipdest$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _mipdest$[ebp], 0
$L76362:

; 852  : 		mipdest = mipdestnext;

	mov	eax, DWORD PTR _mipdestnext$[ebp]
	mov	DWORD PTR _mipdest$[ebp], eax

; 853  : 	}

	jmp	$L76332
$L76333:

; 854  : 
; 855  : // query interface for surfaces
; 856  : 
; 857  : 	r = TexInfo[tpage].Surface->QueryInterface(IID_IDirect3DTexture2, (void**)&TexInfo[tpage].Texture);

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+56]
	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [ecx+eax+56]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx]
	mov	DWORD PTR _r$[ebp], eax

; 858  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76364

; 859  : 	{
; 860  : 		ErrorDX(r, "Can't query interface for texture dest surface");

	push	OFFSET FLAT:??_C@_0CP@IJCJKAAI@Can?8t?5query?5interface?5for?5textur@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 861  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76364:

; 862  : 	}
; 863  : 
; 864  : 	r = sourcesurface->QueryInterface(IID_IDirect3DTexture2, (void**)&texsource);

	lea	eax, DWORD PTR _texsource$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IDirect3DTexture2
	mov	ecx, DWORD PTR _sourcesurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	push	eax
	call	DWORD PTR [edx]
	mov	DWORD PTR _r$[ebp], eax

; 865  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76366

; 866  : 	{
; 867  : 		ErrorDX(r, "Can't query interface for texture source surface");

	push	OFFSET FLAT:??_C@_0DB@LBLBOAG@Can?8t?5query?5interface?5for?5textur@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 868  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76366:

; 869  : 	}
; 870  : 
; 871  : // load dest with source
; 872  : 
; 873  : 	r = TexInfo[tpage].Texture->Load(texsource);

	mov	eax, DWORD PTR _texsource$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [edx+ecx+52]
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	ecx, DWORD PTR [edx+ecx+52]
	mov	edx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR [edx+20]
	mov	DWORD PTR _r$[ebp], eax

; 874  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L76367

; 875  : 	{
; 876  : 		ErrorDX(r, "Can't load dest texture");

	push	OFFSET FLAT:??_C@_0BI@NPJMNOBK@Can?8t?5load?5dest?5texture?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 877  : 		return FALSE;

	xor	al, al
	jmp	$L76298
$L76367:

; 878  : 	}
; 879  : 
; 880  : // set info flags
; 881  : 
; 882  : 	TexInfo[tpage].Active = TRUE;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax], 1

; 883  : 	TexInfo[tpage].Width = width;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 884  : 	TexInfo[tpage].Height = height;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx

; 885  : 	TexInfo[tpage].Stage = stage;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR _stage$[ebp]
	mov	DWORD PTR [ecx+eax+12], edx

; 886  : 	TexInfo[tpage].MipCount = mipcount;

	movsx	eax, BYTE PTR _tpage$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR _mipcount$[ebp]
	mov	DWORD PTR [ecx+eax+16], edx

; 887  : 	wsprintf(TexInfo[tpage].File, "%s", tex);

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
	movsx	ecx, BYTE PTR _tpage$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	lea	eax, DWORD PTR [edx+ecx+20]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 888  : 
; 889  : // release source tex + surface
; 890  : 
; 891  : 	RELEASE(texsource);

	cmp	DWORD PTR _texsource$[ebp], 0
	je	SHORT $L76368
	mov	eax, DWORD PTR _texsource$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _texsource$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _texsource$[ebp], 0
$L76368:

; 892  : 	RELEASE(sourcesurface);

	cmp	DWORD PTR _sourcesurface$[ebp], 0
	je	SHORT $L76369
	mov	eax, DWORD PTR _sourcesurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sourcesurface$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _sourcesurface$[ebp], 0
$L76369:

; 893  : 
; 894  : // return OK
; 895  : 
; 896  : 	return TRUE;

	mov	al, 1
$L76298:

; 897  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadMipTexture@@YA_NPADDJJJJ@Z ENDP			; LoadMipTexture
_TEXT	ENDS
PUBLIC	?InitTextures@@YAXXZ				; InitTextures
EXTRN	?RenderTP@@3FA:WORD				; RenderTP
EXTRN	?RenderTP2@@3FA:WORD				; RenderTP2
; Function compile flags: /Odt /ZI
;	COMDAT ?InitTextures@@YAXXZ
_TEXT	SEGMENT
_i$ = -1						; size = 1
?InitTextures@@YAXXZ PROC NEAR				; InitTextures, COMDAT

; 904  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 905  : 	char i;
; 906  : 
; 907  : 	RenderTP = -2;

	mov	WORD PTR ?RenderTP@@3FA, -2		; RenderTP, fffffffeH

; 908  : 	RenderTP2 = -2;

	mov	WORD PTR ?RenderTP2@@3FA, -2		; RenderTP2, fffffffeH

; 909  : 
; 910  : 	for (i = 0 ; i < TEX_NTPages ; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L76374
$L76375:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L76374:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, DWORD PTR ?TEX_NTPages@@3HA	; TEX_NTPages
	jge	SHORT $L76372

; 911  : 	{
; 912  : 		TexInfo[i].Active = FALSE;

	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax], 0

; 913  : 		TexInfo[i].Palette = NULL;

	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax+60], 0

; 914  : 		TexInfo[i].Texture = NULL;

	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax+52], 0

; 915  : 		TexInfo[i].Surface = NULL;

	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax+56], 0

; 916  : 	}

	jmp	SHORT $L76375
$L76372:

; 917  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitTextures@@YAXXZ ENDP				; InitTextures
_TEXT	ENDS
PUBLIC	?FreeTextures@@YAXXZ				; FreeTextures
PUBLIC	?FreeOneTexture@@YAXD@Z				; FreeOneTexture
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeTextures@@YAXXZ
_TEXT	SEGMENT
_i$ = -1						; size = 1
?FreeTextures@@YAXXZ PROC NEAR				; FreeTextures, COMDAT

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 925  : 	char i;
; 926  : 
; 927  : 	for (i = 0 ; i < TEX_NTPages ; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L76381
$L76382:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L76381:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, DWORD PTR ?TEX_NTPages@@3HA	; TEX_NTPages
	jge	SHORT $L76379

; 928  : 	{
; 929  : 		if (TexInfo[i].Active)

	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	cmp	DWORD PTR [ecx+eax], 0
	je	SHORT $L76384

; 930  : 			FreeOneTexture(i);

	mov	al, BYTE PTR _i$[ebp]
	push	eax
	call	?FreeOneTexture@@YAXD@Z			; FreeOneTexture
	add	esp, 4
$L76384:

; 931  : 	}

	jmp	SHORT $L76382
$L76379:

; 932  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeTextures@@YAXXZ ENDP				; FreeTextures
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?FreeOneTexture@@YAXD@Z
_TEXT	SEGMENT
_tp$ = 8						; size = 1
?FreeOneTexture@@YAXD@Z PROC NEAR			; FreeOneTexture, COMDAT

; 939  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 940  : 
; 941  : // used texture?
; 942  : 
; 943  : 	if (!TexInfo[tp].Active)

	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $L76388

; 944  : 		return;

	jmp	$L76387
$L76388:

; 945  : 
; 946  : // free
; 947  : 
; 948  : 	TexInfo[tp].Active = NULL;

	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax], 0

; 949  : 	RELEASE(TexInfo[tp].Palette);

	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	cmp	DWORD PTR [ecx+eax+60], 0
	je	SHORT $L76389
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+60]
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [ecx+eax+60]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax+60], 0
$L76389:

; 950  : 	RELEASE(TexInfo[tp].Texture);

	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	cmp	DWORD PTR [ecx+eax+52], 0
	je	SHORT $L76390
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+52]
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [ecx+eax+52]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax+52], 0
$L76390:

; 951  : 	RELEASE(TexInfo[tp].Surface);

	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	cmp	DWORD PTR [ecx+eax+56], 0
	je	SHORT $L76387
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+56]
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [ecx+eax+56]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR _tp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	DWORD PTR [ecx+eax+56], 0
$L76387:

; 952  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeOneTexture@@YAXD@Z ENDP				; FreeOneTexture
_TEXT	ENDS
END
