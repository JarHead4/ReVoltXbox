; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Spark.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IK@DNMHCLIC@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeTrail@@YAXPAUSparkTrailStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ModifyFirstTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitSparks@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFreeSpark@@YAPAUSparkStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeSpark@@YAXPAUSparkStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessSparks@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SparkCameraCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SparkWorldCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SparkObjectCollide@@YAXPAUSparkStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SparkConvexCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SparkSphereCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SparkProbability@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawSparkTrail@@YAXPAUSparkTrailStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawSparks@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawTrails@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?Sparks@@3PAUSparkStruct@@A			; Sparks
PUBLIC	?NActiveSparks@@3HA				; NActiveSparks
PUBLIC	?SparkTrail@@3PAUSparkTrailStruct@@A		; SparkTrail
PUBLIC	?NActiveTrails@@3HA				; NActiveTrails
PUBLIC	?TrailData@@3PAUTrailDataStruct@@A		; TrailData
_BSS	SEGMENT
?Sparks@@3PAUSparkStruct@@A DB 012000H DUP (?)		; Sparks
?NActiveSparks@@3HA DD 01H DUP (?)			; NActiveSparks
?SparkTrail@@3PAUSparkTrailStruct@@A DB 05200H DUP (?)	; SparkTrail
?NActiveTrails@@3HA DD 01H DUP (?)			; NActiveTrails
_BSS	ENDS
_DATA	SEGMENT
_SparkData DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f700000r			; 0.9375
	DD	000000000r			; 0
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	0cbH
	DD	03dcccccdr			; 0.1
	DD	03ca3d70ar			; 0.02
	DD	03dcccccdr			; 0.1
	DD	03f000000r			; 0.5
	DD	01f4H
	DD	032H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	01H
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f700000r			; 0.9375
	DD	000000000r			; 0
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	080H
	DD	03dcccccdr			; 0.1
	DD	03ca3d70ar			; 0.02
	DD	03dcccccdr			; 0.1
	DD	03f000000r			; 0.5
	DD	012cH
	DD	014H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	040a00000r			; 5
	DD	040a00000r			; 5
	DD	03f600000r			; 0.875
	DD	000000000r			; 0
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffH
	DD	0cbH
	DD	03cf5c28fr			; 0.03
	DD	03dcccccdr			; 0.1
	DD	03f19999ar			; 0.6
	DD	03e4ccccdr			; 0.2
	DD	02710H
	DD	01388H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	041200000r			; 10
	DD	041200000r			; 10
	DD	03f500000r			; 0.8125
	DD	000000000r			; 0
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ff33ffH
	DD	0cfH
	DD	03e99999ar			; 0.3
	DD	03c23d70ar			; 0.01
	DD	03f333333r			; 0.7
	DD	03f4ccccdr			; 0.8
	DD	02710H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	040600000r			; 3.5
	DD	040600000r			; 3.5
	DD	03f400000r			; 0.75
	DD	000000000r			; 0
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ff808080H
	DD	04fH
	DD	03dcccccdr			; 0.1
	DD	03ca3d70ar			; 0.02
	DD	03f333333r			; 0.7
	DD	03f000000r			; 0.5
	DD	01f4H
	DD	064H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	040000000r			; 2
	DD	040000000r			; 2
	DD	03f700000r			; 0.9375
	DD	000000000r			; 0
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	0cfH
	DD	03dcccccdr			; 0.1
	DD	03ca3d70ar			; 0.02
	DD	03f333333r			; 0.7
	DD	03f000000r			; 0.5
	DD	07a120H
	DD	0186a0H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	040000000r			; 2
	DD	040000000r			; 2
	DD	03f700000r			; 0.9375
	DD	000000000r			; 0
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	0cfH
	DD	03dcccccdr			; 0.1
	DD	03ca3d70ar			; 0.02
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	01f4H
	DD	064H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	03f4ccccdr			; 0.8
	DD	03f4ccccdr			; 0.8
	DD	03f600000r			; 0.875
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffc0c0ffH
	DD	08aH
	DD	03dcccccdr			; 0.1
	DD	03ca3d70ar			; 0.02
	DD	03dcccccdr			; 0.1
	DD	03f000000r			; 0.5
	DD	096H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	041200000r			; 10
	DD	041200000r			; 10
	DD	03f400000r			; 0.75
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ff4433ddH
	DD	0cfH
	DD	03cf5c28fr			; 0.03
	DD	03a83126fr			; 0.001
	DD	03f4ccccdr			; 0.8
	DD	03e4ccccdr			; 0.2
	DD	07d0H
	DD	03e8H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	040a00000r			; 5
	DD	040a00000r			; 5
	DD	03f500000r			; 0.8125
	DD	041800000r			; 16
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	0cfH
	DD	03cf5c28fr			; 0.03
	DD	03a83126fr			; 0.001
	DD	03dcccccdr			; 0.1
	DD	03e4ccccdr			; 0.2
	DD	03e8H
	DD	01f4H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	040c00000r			; 6
	DD	040c00000r			; 6
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DW	01bH
	DW	00H
	DD	0404040H
	DD	0b3H
	DD	03cf5c28fr			; 0.03
	DD	03b03126fr			; 0.002
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	01f4H
	DD	064H
	DD	000000000r			; 0
	DD	040c00000r			; 6
	DD	040000000r			; 2
	DD	000000000r			; 0
	DD	042100000r			; 36
	DD	0ffffffffH
	DD	042800000r			; 64
	DD	042800000r			; 64
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DW	01bH
	DW	00H
	DD	0606060H
	DD	0b3H
	DD	03cf5c28fr			; 0.03
	DD	03ca3d70ar			; 0.02
	DD	03a83126fr			; 0.001
	DD	000000000r			; 0
	DD	0a28H
	DD	00H
	DD	000000000r			; 0
	DD	040c00000r			; 6
	DD	000000000r			; 0
	DD	042200000r			; 40
	DD	041a00000r			; 20
	DD	0ffffffffH
	DD	040800000r			; 4
	DD	040800000r			; 4
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DW	01bH
	DW	00H
	DD	0404040H
	DD	0b2H
	DD	03cf5c28fr			; 0.03
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	05dcH
	DD	064H
	DD	000000000r			; 0
	DD	040c00000r			; 6
	DD	040000000r			; 2
	DD	000000000r			; 0
	DD	042100000r			; 36
	DD	0ffffffffH
	DD	040800000r			; 4
	DD	040800000r			; 4
	DD	03f600000r			; 0.875
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0808080H
	DD	080H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	01f4H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	040800000r			; 4
	DD	040800000r			; 4
	DD	03f600000r			; 0.875
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0808080H
	DD	088H
	DD	03dcccccdr			; 0.1
	DD	03ca3d70ar			; 0.02
	DD	03dcccccdr			; 0.1
	DD	03f000000r			; 0.5
	DD	01f4H
	DD	01f4H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	041000000r			; 8
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	041900000r			; 18
	DD	041900000r			; 18
	DD	03f400000r			; 0.75
	DD	03e000000r			; 0.125
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	089H
	DD	03cf5c28fr			; 0.03
	DD	03c83126fr			; 0.016
	DD	03f19999ar			; 0.6
	DD	000000000r			; 0
	DD	04b0H
	DD	01f4H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	0c0000000r			; -2
	DD	000000000r			; 0
	DD	00H
	DD	041a00000r			; 20
	DD	041a00000r			; 20
	DD	03f700000r			; 0.9375
	DD	03e000000r			; 0.125
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	08dH
	DD	03cf5c28fr			; 0.03
	DD	03c449ba6r			; 0.012
	DD	03f19999ar			; 0.6
	DD	000000000r			; 0
	DD	05dcH
	DD	01f4H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040a00000r			; 5
	DD	0c0a00000r			; -5
	DD	000000000r			; 0
	DD	00H
	DD	041400000r			; 12
	DD	041400000r			; 12
	DD	03e800000r			; 0.25
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	0b0H
	DD	03cf5c28fr			; 0.03
	DD	03c75c28fr			; 0.015
	DD	03f19999ar			; 0.6
	DD	000000000r			; 0
	DD	01f4H
	DD	00H
	DD	000000000r			; 0
	DD	040c00000r			; 6
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	000000000r			; 0
	DD	0ffffffffH
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	03e800000r			; 0.25
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DW	01bH
	DW	00H
	DD	0ffffffffH
	DD	0b0H
	DD	03cf5c28fr			; 0.03
	DD	03c75c28fr			; 0.015
	DD	03f19999ar			; 0.6
	DD	000000000r			; 0
	DD	01f4H
	DD	012cH
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	000000000r			; 0
	DD	041400000r			; 12
	DD	040a00000r			; 5
	DD	0ffffffffH
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	03f710000r			; 0.941406
	DD	03e000000r			; 0.125
	DD	03d700000r			; 0.0585938
	DD	03d800000r			; 0.0625
	DW	01bH
	DW	00H
	DD	0ffffffH
	DD	0a0H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	01f4H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	041f00000r			; 30
	DD	000000000r			; 0
	DD	0ffffffffH
?TrailData@@3PAUTrailDataStruct@@A DD 03f610000r ; 0.878906 ; TrailData
	DD	03e040000r			; 0.128906
	DD	03d600000r			; 0.0546875
	DD	03d600000r			; 0.0546875
	DD	03f610000r			; 0.878906
	DD	03e040000r			; 0.128906
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	03H
	DD	03e99999ar			; 0.3
	DD	040a00000r			; 5
	DD	0cH
	DD	03f760000r			; 0.960938
	DD	000000000r			; 0
	DD	03c000000r			; 0.0078125
	DD	03d800000r			; 0.0625
	DD	03f760000r			; 0.960938
	DD	000000000r			; 0
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	0ffH
	DD	03H
	DD	03cf5c28fr			; 0.03
	DD	03f800000r			; 1
	DD	02H
	DD	03f600000r			; 0.875
	DD	03e400000r			; 0.1875
	DD	03d800000r			; 0.0625
	DD	03d800000r			; 0.0625
	DD	03f700000r			; 0.9375
	DD	03e400000r			; 0.1875
	DD	0ffH
	DD	088H
	DD	088H
	DD	0aaH
	DD	05H
	DD	03ecccccdr			; 0.4
	DD	041200000r			; 10
	DD	0cH
_DATA	ENDS
PUBLIC	?GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z	; GetFreeTrail
PUBLIC	?__LINE__Var@?1??GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z@4JA ; `GetFreeTrail'::`2'::__LINE__Var
PUBLIC	??_C@_0IK@DNMHCLIC@c?3?2documents?5and?5settings?2jarhea@ ; `string'
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
;	COMDAT ??_C@_0IK@DNMHCLIC@c?3?2documents?5and?5settings?2jarhea@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\spark.cpp
CONST	SEGMENT
??_C@_0IK@DNMHCLIC@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\spark'
	DB	'.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z@4JA DD 0298H ; `GetFreeTrail'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z
_TEXT	SEGMENT
_iTrail$ = -4						; size = 4
_trailType$ = 8						; size = 4
?GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z PROC NEAR	; GetFreeTrail, COMDAT

; 664  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 665  : 	int iTrail;
; 666  : 
; 667  : 	Assert(trailType < TRAIL_NTYPES);

	push	OFFSET FLAT:??_C@_0IK@DNMHCLIC@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z@4JA
	add	eax, 3
	push	eax
	cmp	DWORD PTR _trailType$[ebp], 3
	setl	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 668  : 
; 669  : 	for (iTrail = 0; iTrail < MAX_TRAILS; iTrail++) {

	mov	DWORD PTR _iTrail$[ebp], 0
	jmp	SHORT $L81817
$L81818:
	mov	eax, DWORD PTR _iTrail$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTrail$[ebp], eax
$L81817:
	cmp	DWORD PTR _iTrail$[ebp], 128		; 00000080H
	jge	$L81819

; 670  : 		if (SparkTrail[iTrail].Free) {

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	movzx	ecx, BYTE PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[eax]
	test	ecx, ecx
	je	$L81820

; 671  : 			NActiveTrails++;

	mov	eax, DWORD PTR ?NActiveTrails@@3HA	; NActiveTrails
	add	eax, 1
	mov	DWORD PTR ?NActiveTrails@@3HA, eax	; NActiveTrails

; 672  : 			SparkTrail[iTrail].Free = FALSE;

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	mov	BYTE PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[eax], 0

; 673  : 			SparkTrail[iTrail].Data = &TrailData[trailType];

	mov	eax, DWORD PTR _trailType$[ebp]
	imul	eax, 56					; 00000038H
	add	eax, OFFSET FLAT:?TrailData@@3PAUTrailDataStruct@@A ; TrailData
	mov	ecx, DWORD PTR _iTrail$[ebp]
	imul	ecx, 164				; 000000a4H
	mov	DWORD PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[ecx+148], eax

; 674  : 			SparkTrail[iTrail].NTrails = 0;

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	mov	DWORD PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[eax+160], 0

; 675  : 			SparkTrail[iTrail].MaxTrails = TrailData[trailType].MaxTrails;

	mov	eax, DWORD PTR _trailType$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _iTrail$[ebp]
	imul	ecx, 164				; 000000a4H
	mov	edx, DWORD PTR ?TrailData@@3PAUTrailDataStruct@@A[eax+52]
	mov	DWORD PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[ecx+156], edx

; 676  : 			SparkTrail[iTrail].FirstTrail = 0;

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	mov	DWORD PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[eax+152], 0

; 677  : 			return &SparkTrail[iTrail];

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	add	eax, OFFSET FLAT:?SparkTrail@@3PAUSparkTrailStruct@@A ; SparkTrail
	jmp	SHORT $L81813
$L81820:

; 678  : 		}
; 679  : 	}

	jmp	$L81818
$L81819:

; 680  : 
; 681  : 	return NULL;

	xor	eax, eax
$L81813:

; 682  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z ENDP		; GetFreeTrail
_TEXT	ENDS
PUBLIC	?FreeTrail@@YAXPAUSparkTrailStruct@@@Z		; FreeTrail
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeTrail@@YAXPAUSparkTrailStruct@@@Z
_TEXT	SEGMENT
_trail$ = 8						; size = 4
?FreeTrail@@YAXPAUSparkTrailStruct@@@Z PROC NEAR	; FreeTrail, COMDAT

; 691  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 692  : 	trail->Free = TRUE;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	BYTE PTR [eax], 1

; 693  : 	NActiveTrails--;

	mov	eax, DWORD PTR ?NActiveTrails@@3HA	; NActiveTrails
	sub	eax, 1
	mov	DWORD PTR ?NActiveTrails@@3HA, eax	; NActiveTrails

; 694  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeTrail@@YAXPAUSparkTrailStruct@@@Z ENDP		; FreeTrail
_TEXT	ENDS
PUBLIC	?UpdateTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z ; UpdateTrail
EXTRN	__fltused:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?UpdateTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_trail$ = 8						; size = 4
_newPos$ = 12						; size = 4
?UpdateTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z PROC NEAR ; UpdateTrail, COMDAT

; 704  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 705  : 	if (trail->FirstTrail == trail->MaxTrails - 1) {

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	sub	ecx, 1
	mov	edx, DWORD PTR _trail$[ebp]
	cmp	DWORD PTR [edx+152], ecx
	jne	SHORT $L81828

; 706  : 		trail->FirstTrail = 0;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	DWORD PTR [eax+152], 0

; 707  : 	} else {

	jmp	SHORT $L81829
$L81828:

; 708  : 		trail->FirstTrail++;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	add	ecx, 1
	mov	edx, DWORD PTR _trail$[ebp]
	mov	DWORD PTR [edx+152], ecx
$L81829:

; 709  : 	}
; 710  : 
; 711  : 	if (trail->NTrails < trail->MaxTrails) {

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR _trail$[ebp]
	mov	edx, DWORD PTR [eax+160]
	cmp	edx, DWORD PTR [ecx+156]
	jge	SHORT $L81830

; 712  : 		trail->NTrails++;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	add	ecx, 1
	mov	edx, DWORD PTR _trail$[ebp]
	mov	DWORD PTR [edx+160], ecx
$L81830:

; 713  : 	}
; 714  : 
; 715  : 	CopyVec(newPos, &trail->Pos[trail->FirstTrail]);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR _newPos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx+4], eax
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR _newPos$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx+8], eax
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR _newPos$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+ecx+12], eax

; 716  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z ENDP ; UpdateTrail
_TEXT	ENDS
PUBLIC	?ModifyFirstTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z ; ModifyFirstTrail
; Function compile flags: /Odt /ZI
;	COMDAT ?ModifyFirstTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_trail$ = 8						; size = 4
_newPos$ = 12						; size = 4
?ModifyFirstTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z PROC NEAR ; ModifyFirstTrail, COMDAT

; 719  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 720  : 	CopyVec(newPos, &trail->Pos[trail->FirstTrail]);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR _newPos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx+4], eax
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR _newPos$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx+8], eax
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR _newPos$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+ecx+12], eax

; 721  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ModifyFirstTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z ENDP ; ModifyFirstTrail
_TEXT	ENDS
PUBLIC	?InitSparks@@YAXXZ				; InitSparks
; Function compile flags: /Odt /ZI
;	COMDAT ?InitSparks@@YAXXZ
_TEXT	SEGMENT
_iTrail$ = -8						; size = 4
_iSpark$ = -4						; size = 4
?InitSparks@@YAXXZ PROC NEAR				; InitSparks, COMDAT

; 730  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 731  : 	int iSpark, iTrail;
; 732  : 
; 733  : 	for (iSpark = 0; iSpark < MAX_SPARKS; iSpark++) {

	mov	DWORD PTR _iSpark$[ebp], 0
	jmp	SHORT $L81839
$L81840:
	mov	eax, DWORD PTR _iSpark$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpark$[ebp], eax
$L81839:
	cmp	DWORD PTR _iSpark$[ebp], 1024		; 00000400H
	jge	SHORT $L81841

; 734  : 		Sparks[iSpark].Free = TRUE;

	mov	eax, DWORD PTR _iSpark$[ebp]
	imul	eax, 72					; 00000048H
	mov	BYTE PTR ?Sparks@@3PAUSparkStruct@@A[eax], 1

; 735  : 	}

	jmp	SHORT $L81840
$L81841:

; 736  : 	NActiveSparks = 0;

	mov	DWORD PTR ?NActiveSparks@@3HA, 0	; NActiveSparks

; 737  : 
; 738  : 	for (iTrail = 0; iTrail < MAX_TRAILS; iTrail++) {

	mov	DWORD PTR _iTrail$[ebp], 0
	jmp	SHORT $L81842
$L81843:
	mov	eax, DWORD PTR _iTrail$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTrail$[ebp], eax
$L81842:
	cmp	DWORD PTR _iTrail$[ebp], 128		; 00000080H
	jge	SHORT $L81844

; 739  : 		SparkTrail[iTrail].Free = TRUE;

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	mov	BYTE PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[eax], 1

; 740  : 	}

	jmp	SHORT $L81843
$L81844:

; 741  : 	NActiveTrails = 0;

	mov	DWORD PTR ?NActiveTrails@@3HA, 0	; NActiveTrails

; 742  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSparks@@YAXXZ ENDP					; InitSparks
_TEXT	ENDS
PUBLIC	?GetFreeSpark@@YAPAUSparkStruct@@XZ		; GetFreeSpark
; Function compile flags: /Odt /ZI
;	COMDAT ?GetFreeSpark@@YAPAUSparkStruct@@XZ
_TEXT	SEGMENT
_iSpark$ = -4						; size = 4
?GetFreeSpark@@YAPAUSparkStruct@@XZ PROC NEAR		; GetFreeSpark, COMDAT

; 751  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 752  : 	int iSpark;
; 753  : 
; 754  : 	// Find first free spark
; 755  : 	for (iSpark = 0; iSpark < MAX_SPARKS; iSpark++) {

	mov	DWORD PTR _iSpark$[ebp], 0
	jmp	SHORT $L81848
$L81849:
	mov	eax, DWORD PTR _iSpark$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpark$[ebp], eax
$L81848:
	cmp	DWORD PTR _iSpark$[ebp], 1024		; 00000400H
	jge	SHORT $L81850

; 756  : 		if (Sparks[iSpark].Free) {

	mov	eax, DWORD PTR _iSpark$[ebp]
	imul	eax, 72					; 00000048H
	movzx	ecx, BYTE PTR ?Sparks@@3PAUSparkStruct@@A[eax]
	test	ecx, ecx
	je	SHORT $L81851

; 757  : 			Sparks[iSpark].Free = FALSE;

	mov	eax, DWORD PTR _iSpark$[ebp]
	imul	eax, 72					; 00000048H
	mov	BYTE PTR ?Sparks@@3PAUSparkStruct@@A[eax], 0

; 758  : 			NActiveSparks++;

	mov	eax, DWORD PTR ?NActiveSparks@@3HA	; NActiveSparks
	add	eax, 1
	mov	DWORD PTR ?NActiveSparks@@3HA, eax	; NActiveSparks

; 759  : 			return &Sparks[iSpark];

	mov	eax, DWORD PTR _iSpark$[ebp]
	imul	eax, 72					; 00000048H
	add	eax, OFFSET FLAT:?Sparks@@3PAUSparkStruct@@A ; Sparks
	jmp	SHORT $L81846
$L81851:

; 760  : 		}
; 761  : 	}

	jmp	SHORT $L81849
$L81850:

; 762  : 
; 763  : 	// No free sparks
; 764  : 	return NULL;

	xor	eax, eax
$L81846:

; 765  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeSpark@@YAPAUSparkStruct@@XZ ENDP		; GetFreeSpark
_TEXT	ENDS
PUBLIC	?FreeSpark@@YAXPAUSparkStruct@@@Z		; FreeSpark
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeSpark@@YAXPAUSparkStruct@@@Z
_TEXT	SEGMENT
_spark$ = 8						; size = 4
?FreeSpark@@YAXPAUSparkStruct@@@Z PROC NEAR		; FreeSpark, COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 775  : 	if (spark->Trail != NULL) {

	mov	eax, DWORD PTR _spark$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $L81855

; 776  : 		FreeTrail(spark->Trail);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?FreeTrail@@YAXPAUSparkTrailStruct@@@Z	; FreeTrail
	add	esp, 4
$L81855:

; 777  : 	}
; 778  : 
; 779  : 	spark->Free = TRUE;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	BYTE PTR [eax], 1

; 780  : 	NActiveSparks--;

	mov	eax, DWORD PTR ?NActiveSparks@@3HA	; NActiveSparks
	sub	eax, 1
	mov	DWORD PTR ?NActiveSparks@@3HA, eax	; NActiveSparks

; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeSpark@@YAXPAUSparkStruct@@@Z ENDP			; FreeSpark
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@42f00000
PUBLIC	?ProcessSparks@@YAXXZ				; ProcessSparks
PUBLIC	?SparkCameraCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z ; SparkCameraCollide
PUBLIC	?SparkWorldCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z ; SparkWorldCollide
PUBLIC	?SparkObjectCollide@@YAXPAUSparkStruct@@@Z	; SparkObjectCollide
EXTRN	?TimerDiff@@3KA:DWORD				; TimerDiff
EXTRN	?TimerFreq@@3KA:DWORD				; TimerFreq
EXTRN	?AllFieldImpulses@@YAXPAUFieldDataStruct@@PAUVectorStruct@@1@Z:NEAR ; AllFieldImpulses
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?Identity@@3TMatrixUnion@@A:BYTE		; Identity
EXTRN	?ZeroVector@@3UVectorStruct@@A:BYTE		; ZeroVector
EXTRN	?IdentityQuat@@3UQuaternionStruct@@A:BYTE	; IdentityQuat
EXTRN	?CamVisiMask@@3_KA:QWORD			; CamVisiMask
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ProcessSparks@@YAXXZ
_TEXT	SEGMENT
tv329 = -148						; size = 8
_spark$ = -76						; size = 4
_fieldData$ = -72					; size = 32
_oldPos$ = -40						; size = 12
_angImp$ = -28						; size = 12
_imp$ = -16						; size = 12
_iSpark$ = -4						; size = 4
?ProcessSparks@@YAXXZ PROC NEAR				; ProcessSparks, COMDAT

; 790  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 791  : 
; 792  : #ifndef _PSX	
; 793  : 
; 794  : 	int iSpark;
; 795  : 	VEC imp, angImp, oldPos;
; 796  : 	FIELD_DATA fieldData;
; 797  : 	SPARK *spark;
; 798  : 
; 799  : 	for (iSpark = 0; iSpark < MAX_SPARKS; iSpark++) {

	mov	DWORD PTR _iSpark$[ebp], 0
	jmp	SHORT $L81864
$L81865:
	mov	eax, DWORD PTR _iSpark$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpark$[ebp], eax
$L81864:
	cmp	DWORD PTR _iSpark$[ebp], 1024		; 00000400H
	jge	$L81857

; 800  : 		spark = &Sparks[iSpark];

	mov	eax, DWORD PTR _iSpark$[ebp]
	imul	eax, 72					; 00000048H
	add	eax, OFFSET FLAT:?Sparks@@3PAUSparkStruct@@A ; Sparks
	mov	DWORD PTR _spark$[ebp], eax

; 801  : 
; 802  : 		// See if this spark is active
; 803  : 		if (spark->Free) continue;

	mov	eax, DWORD PTR _spark$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L81867
	jmp	SHORT $L81865
$L81867:

; 804  : 
; 805  : #ifndef _PSX
; 806  : 		// Check against visimask
; 807  : 		if (CamVisiMask & spark->VisiMask) continue;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR ?CamVisiMask@@3_KA
	and	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	and	edx, DWORD PTR [eax+12]
	mov	DWORD PTR tv329[ebp], ecx
	mov	DWORD PTR tv329[ebp+4], edx
	mov	eax, DWORD PTR tv329[ebp]
	or	eax, DWORD PTR tv329[ebp+4]
	je	SHORT $L81868
	jmp	SHORT $L81865
$L81868:

; 808  : #endif
; 809  : 
; 810  : 		// See if it is time to kill the spark
; 811  : 		spark->Age += TimerDiff;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	edx, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 812  : 		if (spark->Age > MS2TIME(spark->Data->LifeTime)) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	imul	eax, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _spark$[ebp]
	cmp	DWORD PTR [edx+68], eax
	jbe	SHORT $L81869

; 813  : 			FreeSpark(spark);

	mov	eax, DWORD PTR _spark$[ebp]
	push	eax
	call	?FreeSpark@@YAXPAUSparkStruct@@@Z	; FreeSpark
	add	esp, 4

; 814  : 			continue;

	jmp	$L81865
$L81869:

; 815  : 		}
; 816  : 
; 817  : 		// Rotate the spark
; 818  : 		if (spark->Data->SparkType & SPARK_SPINS) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 16					; 00000010H
	je	SHORT $L81870

; 819  : 			spark->Spin += spark->SpinRate * TimeStep;

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+40]
$L81870:

; 820  : 		}
; 821  : 
; 822  : 		// Expand the spark
; 823  : 		if (spark->Data->SparkType & SPARK_GROWS) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 32					; 00000020H
	je	SHORT $L81871

; 824  : 			spark->Grow += spark->GrowRate * TimeStep;

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+48]
$L81871:

; 825  : //			if (spark->Grow < ZERO) spark->Grow = ZERO;
; 826  : 		}
; 827  : 
; 828  : 		// Get the forces on the spark from the force fields
; 829  : 		if (spark->Data->SparkType & SPARK_FIELD_AFFECT) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 8
	je	$L81872

; 830  : 			fieldData.ObjectID = FIELD_PARENT_NONE;

	mov	DWORD PTR _fieldData$[ebp], -1

; 831  : 			fieldData.Mass = spark->Data->Mass;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _fieldData$[ebp+28], edx

; 832  : 			fieldData.Pos = &spark->Pos;

	mov	eax, DWORD PTR _spark$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _fieldData$[ebp+8], eax

; 833  : 			fieldData.Vel = &spark->Vel;

	mov	eax, DWORD PTR _spark$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _fieldData$[ebp+12], eax

; 834  : 			fieldData.AngVel = &ZeroVector;

	mov	DWORD PTR _fieldData$[ebp+16], OFFSET FLAT:?ZeroVector@@3UVectorStruct@@A ; ZeroVector

; 835  : 			fieldData.Quat = &IdentityQuat;

	mov	DWORD PTR _fieldData$[ebp+24], OFFSET FLAT:?IdentityQuat@@3UQuaternionStruct@@A ; IdentityQuat

; 836  : 			fieldData.Mat = &Identity;

	mov	DWORD PTR _fieldData$[ebp+20], OFFSET FLAT:?Identity@@3TMatrixUnion@@A ; Identity

; 837  : 
; 838  : 			AllFieldImpulses(&fieldData, &imp, &angImp);

	lea	eax, DWORD PTR _angImp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _imp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fieldData$[ebp]
	push	edx
	call	?AllFieldImpulses@@YAXPAUFieldDataStruct@@PAUVectorStruct@@1@Z ; AllFieldImpulses
	add	esp, 12					; 0000000cH

; 839  : 
; 840  : 			// Calculate new velocity
; 841  : 			VecPlusEqScalarVec(&spark->Vel, ONE / spark->Data->Mass, &imp);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR [ecx+36]
	fmul	DWORD PTR _imp$[ebp]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR [ecx+36]
	fmul	DWORD PTR _imp$[ebp+4]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR [ecx+36]
	fmul	DWORD PTR _imp$[ebp+8]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+36]
$L81872:

; 842  : 		}
; 843  : 
; 844  : 		// Add frictional drag
; 845  : 		VecMulScalar(&spark->Vel, ONE - (spark->Data->Resistance * FRICTION_TIME_SCALE * TimeStep));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR __real@42f00000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fsubr	DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR __real@42f00000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fsubr	DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR __real@42f00000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fsubr	DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+36]

; 846  : 
; 847  : 		// Update position
; 848  : 		CopyVec(&spark->Pos, &oldPos);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _oldPos$[ebp], ecx
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _oldPos$[ebp+4], ecx
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _oldPos$[ebp+8], ecx

; 849  : 		VecPlusEqScalarVec(&spark->Pos, TimeStep, &spark->Vel);

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+24]

; 850  : 
; 851  : 		// Deal with collisions
; 852  : 		if (spark->Data->SparkType & SPARK_OBJECT_COLLIDE) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 2
	je	SHORT $L81876

; 853  : 			SparkObjectCollide(spark);

	mov	eax, DWORD PTR _spark$[ebp]
	push	eax
	call	?SparkObjectCollide@@YAXPAUSparkStruct@@@Z ; SparkObjectCollide
	add	esp, 4
$L81876:

; 854  : 		}
; 855  : 		if (spark->Data->SparkType & SPARK_WORLD_COLLIDE) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 1
	je	SHORT $L81877

; 856  : 			SparkWorldCollide(spark, &oldPos);

	lea	eax, DWORD PTR _oldPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spark$[ebp]
	push	ecx
	call	?SparkWorldCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z ; SparkWorldCollide
	add	esp, 8
$L81877:

; 857  : 		}
; 858  : #ifdef _PC
; 859  : 		if (spark->Data->SparkType & SPARK_CAMERA_COLLIDE) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 64					; 00000040H
	je	SHORT $L81878

; 860  : 			SparkCameraCollide(spark, &oldPos);

	lea	eax, DWORD PTR _oldPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spark$[ebp]
	push	ecx
	call	?SparkCameraCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z ; SparkCameraCollide
	add	esp, 8
$L81878:

; 861  : 		}
; 862  : #endif
; 863  : 
; 864  : 		// Update the trail
; 865  : 		if (spark->Trail != NULL) {

	mov	eax, DWORD PTR _spark$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $L81879

; 866  : 			spark->TrailTime += TimeStep;

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+60]

; 867  : 			if (spark->TrailTime > spark->Trail->Data->LifeTime / spark->Trail->MaxTrails) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	fild	DWORD PTR [ecx+156]
	fdivr	DWORD PTR [edx+44]
	mov	edx, DWORD PTR _spark$[ebp]
	fcomp	DWORD PTR [edx+60]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81880

; 868  : 				UpdateTrail(spark->Trail, &spark->Pos);

	mov	eax, DWORD PTR _spark$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?UpdateTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z ; UpdateTrail
	add	esp, 8

; 869  : 				spark->TrailTime = ZERO;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [eax+60], 0

; 870  : 			} else {

	jmp	SHORT $L81879
$L81880:

; 871  : 				ModifyFirstTrail(spark->Trail, &spark->Pos);

	mov	eax, DWORD PTR _spark$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?ModifyFirstTrail@@YAXPAUSparkTrailStruct@@PAUVectorStruct@@@Z ; ModifyFirstTrail
	add	esp, 8
$L81879:

; 872  : 			}
; 873  : 
; 874  : 		}
; 875  : 	}

	jmp	$L81865
$L81857:

; 876  : 
; 877  : 
; 878  : 
; 879  : #endif
; 880  : 
; 881  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessSparks@@YAXXZ ENDP				; ProcessSparks
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@40000000
EXTRN	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z:NEAR ; PointInCollPolyBounds
EXTRN	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z:NEAR ; LinePlaneIntersect
EXTRN	?CAM_MainCamera@@3PAUCameraStruct@@A:DWORD	; CAM_MainCamera
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SparkCameraCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
tv181 = -132						; size = 4
tv162 = -132						; size = 4
tv150 = -132						; size = 4
tv138 = -132						; size = 4
tv94 = -132						; size = 4
tv82 = -132						; size = 4
tv73 = -132						; size = 4
_collPoly$ = -64					; size = 4
_bBox$ = -60						; size = 24
_wPos$ = -36						; size = 12
_dPos$ = -24						; size = 12
_velDotNorm$ = -12					; size = 4
_depth$ = -8						; size = 4
_time$ = -4						; size = 4
_spark$ = 8						; size = 4
_oldPos$ = 12						; size = 4
?SparkCameraCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z PROC NEAR ; SparkCameraCollide, COMDAT

; 891  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 892  : 	REAL time, depth, velDotNorm;
; 893  : 	VEC dPos, wPos;
; 894  : 	BBOX bBox;
; 895  : 	NEWCOLLPOLY *collPoly;
; 896  : 
; 897  : 	collPoly = &CAM_MainCamera->CollPoly;

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	eax, 192				; 000000c0H
	mov	DWORD PTR _collPoly$[ebp], eax

; 898  : 
; 899  : 	// Quick bounding-box test
; 900  : 	SetBBox(&bBox, 
; 901  : 		Min(spark->Pos.v[X], oldPos->v[X]),
; 902  : 		Max(spark->Pos.v[X], oldPos->v[X]),
; 903  : 		Min(spark->Pos.v[Y], oldPos->v[Y]),
; 904  : 		Max(spark->Pos.v[Y], oldPos->v[Y]),
; 905  : 		Min(spark->Pos.v[Z], oldPos->v[Z]),
; 906  : 		Max(spark->Pos.v[Z], oldPos->v[Z]));

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82254
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $L82255
$L82254:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv73[ebp], edx
$L82255:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR _bBox$[ebp], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82256
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $L82257
$L82256:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv82[ebp], edx
$L82257:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bBox$[ebp+4], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82258
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $L82259
$L82258:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv94[ebp], edx
$L82259:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR _bBox$[ebp+8], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82260
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $L82261
$L82260:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv138[ebp], edx
$L82261:
	mov	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _bBox$[ebp+12], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82262
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $L82263
$L82262:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv150[ebp], edx
$L82263:
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR _bBox$[ebp+16], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82264
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $L82265
$L82264:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv162[ebp], edx
$L82265:
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR _bBox$[ebp+20], eax

; 907  : 	if(!BBTestXZY(&bBox, &collPoly->BBox)) return;

	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp]
	fcomp	DWORD PTR [eax+92]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82266
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+4]
	fcomp	DWORD PTR [ecx+88]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82266
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+16]
	fcomp	DWORD PTR [edx+108]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82266
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+20]
	fcomp	DWORD PTR [eax+104]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82266
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+8]
	fcomp	DWORD PTR [ecx+100]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82266
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+12]
	fcomp	DWORD PTR [edx+96]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82266
	mov	DWORD PTR tv181[ebp], 1
	jmp	SHORT $L82267
$L82266:
	mov	DWORD PTR tv181[ebp], 0
$L82267:
	cmp	DWORD PTR tv181[ebp], 0
	jne	SHORT $L81893
	jmp	$L81885
$L81893:

; 908  : 
; 909  : 	// Check for point passing through collision polygon
; 910  : 	if (!LinePlaneIntersect(oldPos, &spark->Pos, &collPoly->Plane, &time, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _collPoly$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _spark$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _oldPos$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L81894

; 911  : 		return;

	jmp	$L81885
$L81894:

; 912  : 	}
; 913  : 
; 914  : 	// Calculate the intersection point
; 915  : 	VecMinusVec(&spark->Pos, oldPos, &dPos);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dPos$[ebp]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dPos$[ebp+4]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dPos$[ebp+8]

; 916  : 	VecPlusScalarVec(oldPos, time, &dPos, &wPos);

	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp]
	mov	eax, DWORD PTR _oldPos$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _wPos$[ebp]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+4]
	mov	eax, DWORD PTR _oldPos$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _wPos$[ebp+4]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+8]
	mov	eax, DWORD PTR _oldPos$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _wPos$[ebp+8]

; 917  : 
; 918  : 	// Make sure the spark is travelling towards the poly
; 919  : 	velDotNorm = VecDotVec(&spark->Vel, PlaneNormal(&collPoly->Plane));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+32]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+36]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 920  : 	if (velDotNorm > ZERO) return;

	fld	DWORD PTR _velDotNorm$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81898
	jmp	$L81885
$L81898:

; 921  : 
; 922  : 
; 923  : 	// Check intersection point is within the polygon boundary
; 924  : 	if (!PointInCollPolyBounds(&wPos, collPoly)) {

	mov	eax, DWORD PTR _collPoly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wPos$[ebp]
	push	ecx
	call	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ; PointInCollPolyBounds
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L81899

; 925  : 		return;

	jmp	$L81885
$L81899:

; 926  : 	}
; 927  : 
; 928  : 	// Keep spark on inside of the poly
; 929  : 	VecPlusEqScalarVec(&spark->Pos, -depth + COLL_EPSILON, PlaneNormal(&collPoly->Plane));

	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+16]
	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+20]
	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+24]

; 930  : 	VecPlusEqScalarVec(&spark->Pos, TimeStep, &CAM_MainCamera->Vel);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+92]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+24]

; 931  : 
; 932  : 	// Rebound
; 933  : 	VecPlusEqScalarVec(&spark->Vel, -velDotNorm, PlaneNormal(&collPoly->Plane));

	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+28]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+32]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+36]

; 934  : 	VecMulScalar(&spark->Vel, (ONE - spark->Data->Friction));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+36]

; 935  : 	VecPlusEqScalarVec(&spark->Vel, -(spark->Data->Restitution * velDotNorm), PlaneNormal(&collPoly->Plane));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [ecx+48]
	fchs
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [ecx+48]
	fchs
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [ecx+48]
	fchs
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+36]
$L81885:

; 936  : 
; 937  : 
; 938  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SparkCameraCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z ENDP ; SparkCameraCollide
_TEXT	ENDS
EXTRN	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z:NEAR ; PosToCollGrid
; Function compile flags: /Odt /ZI
;	COMDAT ?SparkWorldCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
tv191 = -140						; size = 4
tv172 = -140						; size = 4
tv160 = -140						; size = 4
tv148 = -140						; size = 4
tv136 = -140						; size = 4
tv92 = -140						; size = 4
tv83 = -140						; size = 4
_collPoly$ = -72					; size = 4
_grid$ = -68						; size = 4
_bBox$ = -64						; size = 24
_wPos$ = -40						; size = 12
_dPos$ = -28						; size = 12
_velDotNorm$ = -16					; size = 4
_depth$ = -12						; size = 4
_time$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_spark$ = 8						; size = 4
_oldPos$ = 12						; size = 4
?SparkWorldCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z PROC NEAR ; SparkWorldCollide, COMDAT

; 948  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 949  : 	int iPoly;
; 950  : 	REAL time, depth, velDotNorm;
; 951  : 	VEC dPos, wPos;
; 952  : 	BBOX bBox;
; 953  : 	COLLGRID *grid;
; 954  : 	NEWCOLLPOLY *collPoly;
; 955  : 
; 956  : 	grid = PosToCollGrid(&spark->Pos);

	mov	eax, DWORD PTR _spark$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ; PosToCollGrid
	add	esp, 4
	mov	DWORD PTR _grid$[ebp], eax

; 957  : 	if (grid == NULL) return;

	cmp	DWORD PTR _grid$[ebp], 0
	jne	SHORT $L81925
	jmp	$L81915
$L81925:

; 958  : 
; 959  : 	for (iPoly = 0; iPoly < grid->NCollPolys; iPoly++)

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L81926
$L81927:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L81926:
	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR _iPoly$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$L81915

; 960  : 	{
; 961  : #ifndef _PSX
; 962  : 		collPoly = grid->CollPolyPtr[iPoly];

	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iPoly$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _collPoly$[ebp], eax

; 963  : #else
; 964  : 		collPoly = &COL_WorldCollPoly[grid->CollPolyIndices[iPoly]];
; 965  : #endif
; 966  : 
; 967  : 		if (PolyCameraOnly(collPoly)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $L81929
	jmp	SHORT $L81927
$L81929:

; 968  : 
; 969  : 		// Quick bounding-box test
; 970  : 		SetBBox(&bBox, 
; 971  : 			Min(spark->Pos.v[X], oldPos->v[X]),
; 972  : 			Max(spark->Pos.v[X], oldPos->v[X]),
; 973  : 			Min(spark->Pos.v[Y], oldPos->v[Y]),
; 974  : 			Max(spark->Pos.v[Y], oldPos->v[Y]),
; 975  : 			Min(spark->Pos.v[Z], oldPos->v[Z]),
; 976  : 			Max(spark->Pos.v[Z], oldPos->v[Z]));

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82274
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $L82275
$L82274:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv83[ebp], edx
$L82275:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _bBox$[ebp], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82276
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $L82277
$L82276:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv92[ebp], edx
$L82277:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR _bBox$[ebp+4], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82278
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $L82279
$L82278:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv136[ebp], edx
$L82279:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR _bBox$[ebp+8], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82280
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv148[ebp], eax
	jmp	SHORT $L82281
$L82280:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv148[ebp], edx
$L82281:
	mov	eax, DWORD PTR tv148[ebp]
	mov	DWORD PTR _bBox$[ebp+12], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82282
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv160[ebp], eax
	jmp	SHORT $L82283
$L82282:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv160[ebp], edx
$L82283:
	mov	eax, DWORD PTR tv160[ebp]
	mov	DWORD PTR _bBox$[ebp+16], eax
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82284
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv172[ebp], eax
	jmp	SHORT $L82285
$L82284:
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv172[ebp], edx
$L82285:
	mov	eax, DWORD PTR tv172[ebp]
	mov	DWORD PTR _bBox$[ebp+20], eax

; 977  : 		if(!BBTestYXZ(&bBox, &collPoly->BBox)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+8]
	fcomp	DWORD PTR [eax+100]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82286
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+12]
	fcomp	DWORD PTR [ecx+96]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82286
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp]
	fcomp	DWORD PTR [edx+92]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82286
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+4]
	fcomp	DWORD PTR [eax+88]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82286
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+16]
	fcomp	DWORD PTR [ecx+108]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82286
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+20]
	fcomp	DWORD PTR [edx+104]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82286
	mov	DWORD PTR tv191[ebp], 1
	jmp	SHORT $L82287
$L82286:
	mov	DWORD PTR tv191[ebp], 0
$L82287:
	cmp	DWORD PTR tv191[ebp], 0
	jne	SHORT $L81930
	jmp	$L81927
$L81930:

; 978  : 
; 979  : 		// Check for point passing through collision polygon
; 980  : 		if (!LinePlaneIntersect(oldPos, &spark->Pos, &collPoly->Plane, &time, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _collPoly$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _spark$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _oldPos$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L81931

; 981  : 			continue;

	jmp	$L81927
$L81931:

; 982  : 		}
; 983  : 
; 984  : 		// Calculate the intersection point
; 985  : 		VecMinusVec(&spark->Pos, oldPos, &dPos);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dPos$[ebp]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dPos$[ebp+4]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _oldPos$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dPos$[ebp+8]

; 986  : 		VecPlusScalarVec(oldPos, time, &dPos, &wPos);

	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp]
	mov	eax, DWORD PTR _oldPos$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _wPos$[ebp]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+4]
	mov	eax, DWORD PTR _oldPos$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _wPos$[ebp+4]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+8]
	mov	eax, DWORD PTR _oldPos$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _wPos$[ebp+8]

; 987  : 
; 988  : 		// Make sure the spark is travelling towards the poly
; 989  : 		velDotNorm = VecDotVec(&spark->Vel, PlaneNormal(&collPoly->Plane));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+32]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+36]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 990  : 		if (velDotNorm > ZERO) continue;

	fld	DWORD PTR _velDotNorm$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81935
	jmp	$L81927
$L81935:

; 991  : 
; 992  : 
; 993  : 		// Check intersection point is within the polygon boundary
; 994  : 		if (!PointInCollPolyBounds(&wPos, collPoly)) {

	mov	eax, DWORD PTR _collPoly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wPos$[ebp]
	push	ecx
	call	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ; PointInCollPolyBounds
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L81936

; 995  : 			continue;

	jmp	$L81927
$L81936:

; 996  : 		}
; 997  : 
; 998  : 		// Keep spark on inside of the poly
; 999  : 		VecPlusEqScalarVec(&spark->Pos, -depth, PlaneNormal(&collPoly->Plane));

	fld	DWORD PTR _depth$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+16]
	fld	DWORD PTR _depth$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+20]
	fld	DWORD PTR _depth$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+24]

; 1000 : 
; 1001 : 		// Rebound
; 1002 : 		VecPlusEqScalarVec(&spark->Vel, -velDotNorm, PlaneNormal(&collPoly->Plane));

	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+28]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+32]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+36]

; 1003 : 		VecMulScalar(&spark->Vel, (ONE - spark->Data->Friction));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _spark$[ebp]
	fmul	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+36]

; 1004 : 		VecPlusEqScalarVec(&spark->Vel, -(spark->Data->Restitution * velDotNorm), PlaneNormal(&collPoly->Plane));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [ecx+48]
	fchs
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [ecx+48]
	fchs
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [ecx+48]
	fchs
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+36]

; 1005 : 
; 1006 : 
; 1007 : 	}

	jmp	$L81927
$L81915:

; 1008 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SparkWorldCollide@@YAXPAUSparkStruct@@PAUVectorStruct@@@Z ENDP ; SparkWorldCollide
_TEXT	ENDS
PUBLIC	?SparkConvexCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z ; SparkConvexCollide
PUBLIC	?SparkSphereCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z ; SparkSphereCollide
EXTRN	?OBJ_ObjectHead@@3PAUobject_def@@A:DWORD	; OBJ_ObjectHead
; Function compile flags: /Odt /ZI
;	COMDAT ?SparkObjectCollide@@YAXPAUSparkStruct@@@Z
_TEXT	SEGMENT
tv146 = -72						; size = 4
_obj$ = -4						; size = 4
_spark$ = 8						; size = 4
?SparkObjectCollide@@YAXPAUSparkStruct@@@Z PROC NEAR	; SparkObjectCollide, COMDAT

; 1019 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1020 : 	OBJECT	*obj;
; 1021 : 
; 1022 : 	for (obj = OBJ_ObjectHead; obj != NULL; obj = obj->next) {

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj$[ebp], eax
	jmp	SHORT $L81950
$L81951:
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj$[ebp], ecx
$L81950:
	cmp	DWORD PTR _obj$[ebp], 0
	je	$L81948

; 1023 : 
; 1024 : 		// See if this object allows collisions
; 1025 : 		if (obj->CollType == COLL_TYPE_NONE) continue;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+660], 0
	jne	SHORT $L81953
	jmp	SHORT $L81951
$L81953:

; 1026 : 		if (obj->body.CollSkin.AllowObjColls == FALSE) continue;

	mov	eax, DWORD PTR _obj$[ebp]
	movzx	ecx, BYTE PTR [eax+477]
	test	ecx, ecx
	jne	SHORT $L81954
	jmp	SHORT $L81951
$L81954:

; 1027 : 
; 1028 : 		// Quick bounding box test
; 1029 : 		if(!PointInBBox(&spark->Pos, &obj->body.CollSkin.BBox)) continue;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+444]
	fcomp	DWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82290
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [edx+448]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82290
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [ecx+460]
	fcomp	DWORD PTR [edx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82290
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+464]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82290
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [edx+452]
	fcomp	DWORD PTR [eax+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82290
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [ecx+456]
	fcomp	DWORD PTR [edx+20]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82290
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $L82291
$L82290:
	mov	DWORD PTR tv146[ebp], 0
$L82291:
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $L81955
	jmp	$L81951
$L81955:

; 1030 : 
; 1031 : 		if (IsBodyConvex(&obj->body)) {

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+472], 0
	jne	SHORT $L81956

; 1032 : 			SparkConvexCollide(spark, &obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spark$[ebp]
	push	ecx
	call	?SparkConvexCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z ; SparkConvexCollide
	add	esp, 8

; 1033 : 		} else if (IsBodySphere(&obj->body)) {

	jmp	SHORT $L81957
$L81956:
	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+472], 1
	jne	SHORT $L81957

; 1034 : 			SparkSphereCollide(spark, &obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spark$[ebp]
	push	ecx
	call	?SparkSphereCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z ; SparkSphereCollide
	add	esp, 8
$L81957:

; 1035 : 		}
; 1036 : 	}

	jmp	$L81951
$L81948:

; 1037 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SparkObjectCollide@@YAXPAUSparkStruct@@@Z ENDP		; SparkObjectCollide
_TEXT	ENDS
EXTRN	?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z:NEAR ; PointInConvex
; Function compile flags: /Odt /ZI
;	COMDAT ?SparkConvexCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_plane$ = -40						; size = 16
_dVel$ = -24						; size = 12
_velDotNorm$ = -12					; size = 4
_depth$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_spark$ = 8						; size = 4
_body$ = 12						; size = 4
?SparkConvexCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z PROC NEAR ; SparkConvexCollide, COMDAT

; 1040 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 1041 : 	int iSkin;
; 1042 : 	REAL depth, velDotNorm;
; 1043 : 	VEC dVel;
; 1044 : 	PLANE plane;
; 1045 : 
; 1046 : 	for (iSkin = 0; iSkin < body->CollSkin.NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L81968
$L81969:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L81968:
	mov	eax, DWORD PTR _body$[ebp]
	movsx	ecx, WORD PTR [eax+392]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L81962

; 1047 : 	
; 1048 : 		if (!PointInConvex(&spark->Pos, &body->CollSkin.WorldConvex[iSkin], &plane, &depth)) continue;

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _plane$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _body$[ebp]
	add	edx, DWORD PTR [eax+384]
	push	edx
	mov	ecx, DWORD PTR _spark$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z ; PointInConvex
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L81971
	jmp	SHORT $L81969
$L81971:

; 1049 : 
; 1050 : 		// move spark out of object and rebound
; 1051 : 		VecPlusEqScalarVec(&spark->Pos, -depth + COLL_EPSILON, PlaneNormal(&plane));

	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	fmul	DWORD PTR _plane$[ebp]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+16]
	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	fmul	DWORD PTR _plane$[ebp+4]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+20]
	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	fmul	DWORD PTR _plane$[ebp+8]
	mov	eax, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+24]

; 1052 : 		velDotNorm = VecDotVec(&spark->Vel, PlaneNormal(&plane));

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR _plane$[ebp+4]
	fmul	DWORD PTR [ecx+32]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR _plane$[ebp+8]
	fmul	DWORD PTR [edx+36]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 1053 : 		VecPlusEqScalarVec(&spark->Vel, -(ONE + spark->Data->Restitution) * velDotNorm, PlaneNormal(&plane));

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [ecx+48]
	fchs
	fmul	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [ecx+48]
	fchs
	fmul	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR _plane$[ebp+4]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [ecx+48]
	fchs
	fmul	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR _plane$[ebp+8]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+36]

; 1054 : 
; 1055 : 		// Add simple friction
; 1056 : 		VecMinusVec(&body->Centre.Vel, &spark->Vel, &dVel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+32]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dVel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR [ecx+32]
	fstp	DWORD PTR _dVel$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _spark$[ebp]
	fld	DWORD PTR [eax+40]
	fsub	DWORD PTR [ecx+36]
	fstp	DWORD PTR _dVel$[ebp+8]

; 1057 : 		VecPlusEqScalarVec(&spark->Vel, spark->Data->Friction, &dVel);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR [ecx+44]
	fmul	DWORD PTR _dVel$[ebp]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR [ecx+44]
	fmul	DWORD PTR _dVel$[ebp+4]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fld	DWORD PTR [ecx+44]
	fmul	DWORD PTR _dVel$[ebp+8]
	mov	edx, DWORD PTR _spark$[ebp]
	fadd	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+36]

; 1058 : 	}

	jmp	$L81969
$L81962:

; 1059 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SparkConvexCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z ENDP ; SparkConvexCollide
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SparkSphereCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_spark$ = 8						; size = 4
_body$ = 12						; size = 4
?SparkSphereCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z PROC NEAR ; SparkSphereCollide, COMDAT

; 1062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1063 : 
; 1064 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SparkSphereCollide@@YAXPAUSparkStruct@@PAUNewBodyStruct@@@Z ENDP ; SparkSphereCollide
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z@4JA ; `CreateSpark'::`2'::__LINE__Var
PUBLIC	__real@46fffe00
PUBLIC	__real@3f000000
PUBLIC	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
EXTRN	__ftol2:NEAR
EXTRN	_rand:NEAR
;	COMDAT ?__LINE__Var@?1??CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z@4JA DD 0434H ; `CreateSpark'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z
_TEXT	SEGMENT
tv318 = -92						; size = 8
tv334 = -88						; size = 4
tv349 = -84						; size = 4
tv341 = -84						; size = 4
tv333 = -84						; size = 4
tv327 = -84						; size = 4
tv315 = -84						; size = 4
tv292 = -84						; size = 4
tv289 = -84						; size = 4
tv286 = -84						; size = 4
_spark$ = -16						; size = 4
_dV$ = -12						; size = 12
_type$ = 8						; size = 4
_pos$ = 12						; size = 4
_vel$ = 16						; size = 4
_velVar$ = 20						; size = 4
_mask$ = 24						; size = 8
?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z PROC NEAR ; CreateSpark, COMDAT

; 1076 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1077 : 
; 1078 : 	
; 1079 : #ifndef _PSX	
; 1080 : 
; 1081 : 	VEC dV;
; 1082 : 	SPARK *spark;
; 1083 : 
; 1084 : 
; 1085 : 	Assert(type < SPARK_NTYPES);

	push	OFFSET FLAT:??_C@_0IK@DNMHCLIC@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z@4JA
	add	eax, 9
	push	eax
	cmp	DWORD PTR _type$[ebp], 20		; 00000014H
	setl	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1086 : 
; 1087 : 	// Get the next available spark
; 1088 : 	spark = GetFreeSpark();

	call	?GetFreeSpark@@YAPAUSparkStruct@@XZ	; GetFreeSpark
	mov	DWORD PTR _spark$[ebp], eax

; 1089 : 
; 1090 : 	// make sure there were some left
; 1091 : 	if (spark == NULL) return FALSE;

	cmp	DWORD PTR _spark$[ebp], 0
	jne	SHORT $L81998
	xor	al, al
	jmp	$L81994
$L81998:

; 1092 : 
; 1093 : 	// Set the visimask
; 1094 : 	spark->VisiMask = mask;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _mask$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _mask$[ebp+4]
	mov	DWORD PTR [eax+12], edx

; 1095 : 
; 1096 : 	// Choose the random vector to add to the velocity
; 1097 : 	SetVec(&dV, velVar - frand(2 * velVar), velVar - frand(2 * velVar), velVar - frand(2 * velVar));

	call	_rand
	mov	DWORD PTR tv286[ebp], eax
	fild	DWORD PTR tv286[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _velVar$[ebp]
	fmulp	ST(1), ST(0)
	fsubr	DWORD PTR _velVar$[ebp]
	fstp	DWORD PTR _dV$[ebp]
	call	_rand
	mov	DWORD PTR tv289[ebp], eax
	fild	DWORD PTR tv289[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _velVar$[ebp]
	fmulp	ST(1), ST(0)
	fsubr	DWORD PTR _velVar$[ebp]
	fstp	DWORD PTR _dV$[ebp+4]
	call	_rand
	mov	DWORD PTR tv292[ebp], eax
	fild	DWORD PTR tv292[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _velVar$[ebp]
	fmulp	ST(1), ST(0)
	fsubr	DWORD PTR _velVar$[ebp]
	fstp	DWORD PTR _dV$[ebp+8]

; 1098 : 
; 1099 : 	// Generate the initial velocity
; 1100 : 	VecPlusVec(vel, &dV, &spark->Vel)

	mov	eax, DWORD PTR _vel$[ebp]
	fld	DWORD PTR _dV$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _vel$[ebp]
	fld	DWORD PTR _dV$[ebp+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _vel$[ebp]
	fld	DWORD PTR _dV$[ebp+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [ecx+36]

; 1101 : 
; 1102 : 	// Set the initial position
; 1103 : 	CopyVec(pos, &spark->Pos);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx

; 1104 : 
; 1105 : 	// Setup pointer to physical info for this spark type
; 1106 : 	spark->Data = &SparkData[type];

	mov	eax, DWORD PTR _type$[ebp]
	imul	eax, 84					; 00000054H
	add	eax, OFFSET FLAT:_SparkData
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1107 : 
; 1108 : 	// Set the death time
; 1109 : 	spark->Age = (long)frand(SparkData[type].LifeTimeVar);

	call	_rand
	mov	DWORD PTR tv315[ebp], eax
	fild	DWORD PTR tv315[ebp]
	fdiv	DWORD PTR __real@46fffe00
	mov	eax, DWORD PTR _type$[ebp]
	imul	eax, 84					; 00000054H
	mov	ecx, DWORD PTR _SparkData[eax+56]
	mov	DWORD PTR tv318[ebp], ecx
	mov	DWORD PTR tv318[ebp+4], 0
	fild	QWORD PTR tv318[ebp]
	fmulp	ST(1), ST(0)
	call	__ftol2
	mov	edx, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [edx+68], eax

; 1110 : 
; 1111 : 	// Set initial rotation
; 1112 : 	if (spark->Data->SparkType & SPARK_SPINS) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 16					; 00000010H
	je	SHORT $L82004

; 1113 : 		spark->Spin = frand(ONE);

	call	_rand
	mov	DWORD PTR tv327[ebp], eax
	fild	DWORD PTR tv327[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+40]

; 1114 : 		spark->SpinRate = spark->Data->SpinRateBase + (spark->Data->SpinRateVar * HALF) - frand(spark->Data->SpinRateVar);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+64]
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR __real@3f000000
	fadd	DWORD PTR [ecx+60]
	fstp	DWORD PTR tv333[ebp]
	call	_rand
	mov	DWORD PTR tv334[ebp], eax
	fild	DWORD PTR tv334[ebp]
	fdiv	DWORD PTR __real@46fffe00
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	fmul	DWORD PTR [edx+64]
	fsubr	DWORD PTR tv333[ebp]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+44]

; 1115 : 	} else {

	jmp	SHORT $L82007
$L82004:

; 1116 : 		spark->Spin = ZERO;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [eax+40], 0

; 1117 : 		spark->SpinRate = ZERO;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [eax+44], 0
$L82007:

; 1118 : 	}
; 1119 : 
; 1120 : 	// Set initial growth amount
; 1121 : 	spark->Grow = frand(spark->Data->SizeVar);

	call	_rand
	mov	DWORD PTR tv341[ebp], eax
	fild	DWORD PTR tv341[ebp]
	fdiv	DWORD PTR __real@46fffe00
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [edx+48]

; 1122 : 	if (spark->Data->SparkType & SPARK_GROWS) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 32					; 00000020H
	je	SHORT $L82009

; 1123 : 		spark->GrowRate = spark->Data->GrowRateBase + frand(spark->Data->GrowRateVar);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	esi, DWORD PTR [eax+64]
	call	_rand
	mov	DWORD PTR tv349[ebp], eax
	fild	DWORD PTR tv349[ebp]
	fdiv	DWORD PTR __real@46fffe00
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	fmul	DWORD PTR [edx+76]
	fadd	DWORD PTR [esi+72]
	mov	eax, DWORD PTR _spark$[ebp]
	fstp	DWORD PTR [eax+52]

; 1124 : 	} else {

	jmp	SHORT $L82011
$L82009:

; 1125 : 		spark->GrowRate = ZERO;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [eax+52], 0
$L82011:

; 1126 : 	}
; 1127 : 
; 1128 : 	// Set up the trail
; 1129 : 	if (spark->Data->SparkType & SPARK_CREATE_TRAIL) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 4
	je	SHORT $L82012

; 1130 : 		spark->Trail = GetFreeTrail(spark->Data->TrailType);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	?GetFreeTrail@@YAPAUSparkTrailStruct@@J@Z ; GetFreeTrail
	add	esp, 4
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 1131 : 		if (spark->Trail != NULL) {

	mov	eax, DWORD PTR _spark$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $L82013

; 1132 : 			CopyVec(&spark->Pos, &spark->Trail->Pos[0]);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+12], eax

; 1133 : 			spark->TrailTime = ZERO;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [eax+60], 0
$L82013:

; 1134 : 		}
; 1135 : 	} else {

	jmp	SHORT $L82014
$L82012:

; 1136 : 		spark->Trail = NULL;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	DWORD PTR [eax+56], 0
$L82014:

; 1137 : 	}
; 1138 : 
; 1139 : 	// Sucess
; 1140 : 	return TRUE;

	mov	al, 1
$L81994:

; 1141 : 
; 1142 : #endif
; 1143 : 
; 1144 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ENDP ; CreateSpark
_TEXT	ENDS
PUBLIC	__real@42c80000
PUBLIC	__real@44bb8000
PUBLIC	?SparkProbability@@YAMM@Z			; SparkProbability
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@44bb8000
CONST	SEGMENT
__real@44bb8000 DD 044bb8000r			; 1500
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SparkProbability@@YAMM@Z
_TEXT	SEGMENT
_prob$ = -4						; size = 4
_vel$ = 8						; size = 4
?SparkProbability@@YAMM@Z PROC NEAR			; SparkProbability, COMDAT

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1156 : 	REAL prob;
; 1157 : 
; 1158 : 	prob = (vel - MIN_SPARK_VEL) / (MAX_SPARK_VEL - MIN_SPARK_VEL);

	fld	DWORD PTR _vel$[ebp]
	fsub	DWORD PTR __real@42c80000
	fdiv	DWORD PTR __real@44bb8000
	fstp	DWORD PTR _prob$[ebp]

; 1159 : 
; 1160 : 	if (prob < ZERO) return ZERO;

	fld	DWORD PTR _prob$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82022
	fld	DWORD PTR __real@00000000
	jmp	SHORT $L82017
$L82022:

; 1161 : 	if (prob > ONE) return ONE;

	fld	DWORD PTR _prob$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82023
	fld	DWORD PTR __real@3f800000
	jmp	SHORT $L82017
$L82023:

; 1162 : 	return prob;

	fld	DWORD PTR _prob$[ebp]
$L82017:

; 1163 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SparkProbability@@YAMM@Z ENDP				; SparkProbability
_TEXT	ENDS
PUBLIC	?DrawSparkTrail@@YAXPAUSparkTrailStruct@@@Z	; DrawSparkTrail
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	__real@3727c5ac
PUBLIC	__real@40400000
EXTRN	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z:NEAR ; RotTransPersVector
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
EXTRN	?RenderStateChange@@3JA:DWORD			; RenderStateChange
EXTRN	?TextureStateChange@@3JA:DWORD			; TextureStateChange
EXTRN	?RenderTP@@3FA:WORD				; RenderTP
EXTRN	?RenderFog@@3FA:WORD				; RenderFog
EXTRN	?RenderAlphaSrc@@3FA:WORD			; RenderAlphaSrc
EXTRN	?RenderAlphaDest@@3FA:WORD			; RenderAlphaDest
EXTRN	?TexInfo@@3PAUTEXINFO@@A:DWORD			; TexInfo
EXTRN	?ViewMatrixScaled@@3TMatrixUnion@@A:BYTE	; ViewMatrixScaled
EXTRN	?ViewTransScaled@@3UVectorStruct@@A:BYTE	; ViewTransScaled
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DrawSparkTrail@@YAXPAUSparkTrailStruct@@@Z
_TEXT	SEGMENT
tv734 = -336						; size = 4
_vert$ = -268						; size = 4
_ePos$ = -264						; size = 32
_sPos$ = -232						; size = 32
_poly$ = -200						; size = 152
_width$ = -48						; size = 4
_dLen$ = -44						; size = 4
_dt$ = -40						; size = 4
_dy$ = -36						; size = 4
_dx$ = -32						; size = 4
_b$ = -28						; size = 4
_g$ = -24						; size = 4
_r$ = -20						; size = 4
_a$ = -16						; size = 4
_lastTrail$ = -12					; size = 4
_thisTrail$ = -8					; size = 4
_iTrail$ = -4						; size = 4
_trail$ = 8						; size = 4
?DrawSparkTrail@@YAXPAUSparkTrailStruct@@@Z PROC NEAR	; DrawSparkTrail, COMDAT

; 1174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi

; 1175 : 	int iTrail, thisTrail, lastTrail;
; 1176 : 	long a, r, g, b;
; 1177 : 	REAL dx, dy, dt, dLen, width;
; 1178 : 	DRAW_SEMI_POLY poly;
; 1179 : 	VERTEX_TEX1 sPos, ePos;
; 1180 : 	VERTEX_TEX1 *vert = poly.Verts;

	lea	eax, DWORD PTR _poly$[ebp+24]
	mov	DWORD PTR _vert$[ebp], eax

; 1181 : 
; 1182 : 	poly.Fog = FALSE;

	mov	DWORD PTR _poly$[ebp+12], 0

; 1183 : 	poly.VertNum = 4;

	mov	DWORD PTR _poly$[ebp+4], 4

; 1184 : 	poly.Tpage = TPAGE_FX1;

	mov	DWORD PTR _poly$[ebp+8], 27		; 0000001bH

; 1185 : 	poly.DrawFlag = D3DDP_DONOTUPDATEEXTENTS;

	mov	DWORD PTR _poly$[ebp], 8

; 1186 : 	poly.SemiType = TRUE;

	mov	DWORD PTR _poly$[ebp+16], 1

; 1187 : 
; 1188 : 	SET_TPAGE((short)poly.Tpage);

	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	movsx	ecx, WORD PTR _poly$[ebp+8]
	cmp	eax, ecx
	je	SHORT $L82044
	mov	ax, WORD PTR _poly$[ebp+8]
	mov	WORD PTR ?RenderTP@@3FA, ax		; RenderTP
	movsx	ecx, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	ecx, -1
	jne	SHORT $L82046
	push	0
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
	jmp	SHORT $L82044
$L82046:
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
$L82044:

; 1189 : 	vert[3].tu = trail->Data->U;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+120], eax

; 1190 : 	vert[3].tv = trail->Data->V;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+124], eax

; 1191 : 
; 1192 : 	vert[0].tu = trail->Data->U + trail->Data->Usize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+24]

; 1193 : 	vert[0].tv = trail->Data->V;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+28], eax

; 1194 : 
; 1195 : 	vert[1].tu = trail->Data->U + trail->Data->Usize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1196 : 	vert[1].tv = trail->Data->V + trail->Data->Vsize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx+4]
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+60]

; 1197 : 
; 1198 : 	vert[2].tu = trail->Data->U;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+88], eax

; 1199 : 	vert[2].tv = trail->Data->V + trail->Data->Vsize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx+4]
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+92]

; 1200 : 	
; 1201 : 
; 1202 : 	FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L82048
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82048:

; 1203 : 	ALPHA_SRC(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 2
	je	SHORT $L82049
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 2	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82049:

; 1204 : 	ALPHA_DEST(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 2
	je	SHORT $L82050
	mov	WORD PTR ?RenderAlphaDest@@3FA, 2	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82050:

; 1205 : 
; 1206 : 	thisTrail = trail->FirstTrail;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR _thisTrail$[ebp], ecx

; 1207 : 	lastTrail = (trail->FirstTrail - 1);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	sub	ecx, 1
	mov	DWORD PTR _lastTrail$[ebp], ecx

; 1208 : 	if (lastTrail < 0) lastTrail = trail->MaxTrails - 1;

	jns	SHORT $L82051
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	sub	ecx, 1
	mov	DWORD PTR _lastTrail$[ebp], ecx
$L82051:

; 1209 : 
; 1210 : 	// Calculate first section end coordinates
; 1211 : 	RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &trail->Pos[thisTrail], (REAL*)&ePos);

	lea	eax, DWORD PTR _ePos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisTrail$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1212 : 	RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &trail->Pos[lastTrail], (REAL*)&sPos);

	lea	eax, DWORD PTR _sPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastTrail$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1213 : 	dx = ePos.sx - sPos.sx;

	fld	DWORD PTR _ePos$[ebp]
	fsub	DWORD PTR _sPos$[ebp]
	fstp	DWORD PTR _dx$[ebp]

; 1214 : 	dy = ePos.sy - sPos.sy;

	fld	DWORD PTR _ePos$[ebp+4]
	fsub	DWORD PTR _sPos$[ebp+4]
	fstp	DWORD PTR _dy$[ebp]

; 1215 : 	dLen = (REAL)sqrt(dx * dx + dy * dy);

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _dx$[ebp]
	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _dy$[ebp]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dLen$[ebp]

; 1216 : 	dt = dx;

	mov	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _dt$[ebp], eax

; 1217 : 	dx = dy / dLen;

	fld	DWORD PTR _dy$[ebp]
	fdiv	DWORD PTR _dLen$[ebp]
	fstp	DWORD PTR _dx$[ebp]

; 1218 : 	dy = -dt / dLen;

	fld	DWORD PTR _dt$[ebp]
	fchs
	fdiv	DWORD PTR _dLen$[ebp]
	fstp	DWORD PTR _dy$[ebp]

; 1219 : 
; 1220 : 	// Set up first end vertices
; 1221 : 	width = trail->Data->Width;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _width$[ebp], edx

; 1222 : 	vert[2].sx = ePos.sx + dx * width * ePos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _ePos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR _ePos$[ebp]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+64]

; 1223 : 	vert[2].sy = ePos.sy + dy * width * ePos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _ePos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR _ePos$[ebp+4]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+68]

; 1224 : 	vert[2].sz = ePos.sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _ePos$[ebp+8]
	mov	DWORD PTR [eax+72], ecx

; 1225 : 	vert[2].rhw = ePos.rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _ePos$[ebp+12]
	mov	DWORD PTR [eax+76], ecx

; 1226 : 	vert[3].sx = ePos.sx - dx * width * ePos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _ePos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fsubr	DWORD PTR _ePos$[ebp]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+96]

; 1227 : 	vert[3].sy = ePos.sy - dy * width * ePos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _ePos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fsubr	DWORD PTR _ePos$[ebp+4]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+100]

; 1228 : 	vert[3].sz = ePos.sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _ePos$[ebp+8]
	mov	DWORD PTR [eax+104], ecx

; 1229 : 	vert[3].rhw = ePos.rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _ePos$[ebp+12]
	mov	DWORD PTR [eax+108], ecx

; 1230 : 
; 1231 : 	for (iTrail = 1; iTrail < trail->NTrails; iTrail++) {

	mov	DWORD PTR _iTrail$[ebp], 1
	jmp	SHORT $L82055
$L82056:
	mov	eax, DWORD PTR _iTrail$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTrail$[ebp], eax
$L82055:
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR _iTrail$[ebp]
	cmp	ecx, DWORD PTR [eax+160]
	jge	$L82026

; 1232 : 
; 1233 : 		// Get coordinates of next section
; 1234 : 		RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &trail->Pos[lastTrail], (REAL*)&sPos);

	lea	eax, DWORD PTR _sPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastTrail$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _trail$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 1235 : 		dx = ePos.sx - sPos.sx;

	fld	DWORD PTR _ePos$[ebp]
	fsub	DWORD PTR _sPos$[ebp]
	fstp	DWORD PTR _dx$[ebp]

; 1236 : 		dy = ePos.sy - sPos.sy;

	fld	DWORD PTR _ePos$[ebp+4]
	fsub	DWORD PTR _sPos$[ebp+4]
	fstp	DWORD PTR _dy$[ebp]

; 1237 : 		dLen = (REAL)sqrt(dx * dx + dy * dy);

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _dx$[ebp]
	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _dy$[ebp]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dLen$[ebp]

; 1238 : 		if (dLen < SMALL_REAL) {

	fld	DWORD PTR _dLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82060

; 1239 : 			continue;

	jmp	$L82056
$L82060:

; 1240 : 		}
; 1241 : 		dt = dx;

	mov	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR _dt$[ebp], eax

; 1242 : 		dx = dy / dLen;

	fld	DWORD PTR _dy$[ebp]
	fdiv	DWORD PTR _dLen$[ebp]
	fstp	DWORD PTR _dx$[ebp]

; 1243 : 		dy = -dt / dLen;

	fld	DWORD PTR _dt$[ebp]
	fchs
	fdiv	DWORD PTR _dLen$[ebp]
	fstp	DWORD PTR _dy$[ebp]

; 1244 : 
; 1245 : 		// Set up next end vertices
; 1246 : 		if (trail->Data->Type & TRAIL_SHRINKS) {

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 2
	je	SHORT $L82061

; 1247 : 			width = trail->Data->Width - (trail->Data->Width * iTrail) / trail->MaxTrails;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fild	DWORD PTR _iTrail$[ebp]
	fmul	DWORD PTR [eax+48]
	mov	edx, DWORD PTR _trail$[ebp]
	fidiv	DWORD PTR [edx+156]
	fsubr	DWORD PTR [ecx+48]
	fstp	DWORD PTR _width$[ebp]

; 1248 : 		} else if (trail->Data->Type & TRAIL_EXPANDS) {

	jmp	SHORT $L82062
$L82061:
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 4
	je	SHORT $L82063

; 1249 : 			width = trail->Data->Width + (3 * trail->Data->Width * iTrail) / (trail->MaxTrails * 2);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR __real@40400000
	fmul	DWORD PTR [eax+48]
	fimul	DWORD PTR _iTrail$[ebp]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+156]
	shl	eax, 1
	mov	DWORD PTR tv734[ebp], eax
	fidiv	DWORD PTR tv734[ebp]
	fadd	DWORD PTR [ecx+48]
	fstp	DWORD PTR _width$[ebp]

; 1250 : 		} else {

	jmp	SHORT $L82062
$L82063:

; 1251 : 			width = trail->Data->Width;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _width$[ebp], edx
$L82062:

; 1252 : 		}
; 1253 : 		vert[0].sx = sPos.sx - dx * width * sPos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _sPos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fsubr	DWORD PTR _sPos$[ebp]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax]

; 1254 : 		vert[0].sy = sPos.sy - dy * width * sPos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _sPos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fsubr	DWORD PTR _sPos$[ebp+4]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+4]

; 1255 : 		vert[0].sz = sPos.sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 1256 : 		vert[0].rhw = sPos.rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp+12]
	mov	DWORD PTR [eax+12], ecx

; 1257 : 		vert[1].sx = sPos.sx + dx * width * sPos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _sPos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR _sPos$[ebp]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+32]

; 1258 : 		vert[1].sy = sPos.sy + dy * width * sPos.rhw * RenderSettings.GeomPers;

	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _width$[ebp]
	fmul	DWORD PTR _sPos$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR _sPos$[ebp+4]
	mov	eax, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [eax+36]

; 1259 : 		vert[1].sz = sPos.sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp+8]
	mov	DWORD PTR [eax+40], ecx

; 1260 : 		vert[1].rhw = sPos.rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp+12]
	mov	DWORD PTR [eax+44], ecx

; 1261 : 
; 1262 : 		// Choose a colour
; 1263 : 		if (trail->Data->Type & TRAIL_FADES) {

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 1
	je	$L82065

; 1264 : 			a = trail->Data->A - iTrail * (trail->Data->A / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	esi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+24]
	cdq
	idiv	DWORD PTR [esi+160]
	imul	eax, DWORD PTR _iTrail$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	sub	ecx, eax
	mov	DWORD PTR _a$[ebp], ecx

; 1265 : 			r = trail->Data->R - iTrail * (trail->Data->R / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	esi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+28]
	cdq
	idiv	DWORD PTR [esi+160]
	imul	eax, DWORD PTR _iTrail$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	sub	ecx, eax
	mov	DWORD PTR _r$[ebp], ecx

; 1266 : 			g = trail->Data->G - iTrail * (trail->Data->G / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	esi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+32]
	cdq
	idiv	DWORD PTR [esi+160]
	imul	eax, DWORD PTR _iTrail$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	sub	ecx, eax
	mov	DWORD PTR _g$[ebp], ecx

; 1267 : 			b = trail->Data->B - iTrail * (trail->Data->B / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	esi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+36]
	cdq
	idiv	DWORD PTR [esi+160]
	imul	eax, DWORD PTR _iTrail$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	sub	ecx, eax
	mov	DWORD PTR _b$[ebp], ecx

; 1268 : 		} else {

	jmp	SHORT $L82066
$L82065:

; 1269 : 			a = trail->Data->A;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _a$[ebp], edx

; 1270 : 			r = trail->Data->R;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _r$[ebp], edx

; 1271 : 			g = trail->Data->G;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _g$[ebp], edx

; 1272 : 			b = trail->Data->B;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _b$[ebp], edx
$L82066:

; 1273 : 		}
; 1274 : 		vert[0].color = vert[1].color = r << 16 | g << 8 | b;

	mov	eax, DWORD PTR _r$[ebp]
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _g$[ebp]
	shl	ecx, 8
	or	eax, ecx
	or	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+48], eax
	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+16], edx

; 1275 : 		if (trail->Data->Type & TRAIL_FADES) {

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 1
	je	$L82067

; 1276 : 			a = trail->Data->A - (iTrail - 1) * (trail->Data->A / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	esi, DWORD PTR _iTrail$[ebp]
	sub	esi, 1
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	edi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+24]
	cdq
	idiv	DWORD PTR [edi+160]
	imul	esi, eax
	mov	ecx, DWORD PTR [ecx+24]
	sub	ecx, esi
	mov	DWORD PTR _a$[ebp], ecx

; 1277 : 			r = trail->Data->R - (iTrail - 1) * (trail->Data->R / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	esi, DWORD PTR _iTrail$[ebp]
	sub	esi, 1
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	edi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+28]
	cdq
	idiv	DWORD PTR [edi+160]
	imul	esi, eax
	mov	ecx, DWORD PTR [ecx+28]
	sub	ecx, esi
	mov	DWORD PTR _r$[ebp], ecx

; 1278 : 			g = trail->Data->G - (iTrail - 1) * (trail->Data->G / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	esi, DWORD PTR _iTrail$[ebp]
	sub	esi, 1
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	edi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+32]
	cdq
	idiv	DWORD PTR [edi+160]
	imul	esi, eax
	mov	ecx, DWORD PTR [ecx+32]
	sub	ecx, esi
	mov	DWORD PTR _g$[ebp], ecx

; 1279 : 			b = trail->Data->B - (iTrail - 1) * (trail->Data->B / trail->NTrails);

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	esi, DWORD PTR _iTrail$[ebp]
	sub	esi, 1
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	edi, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [eax+36]
	cdq
	idiv	DWORD PTR [edi+160]
	imul	esi, eax
	mov	ecx, DWORD PTR [ecx+36]
	sub	ecx, esi
	mov	DWORD PTR _b$[ebp], ecx

; 1280 : 		} else {

	jmp	SHORT $L82068
$L82067:

; 1281 : 			a = trail->Data->A;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _a$[ebp], edx

; 1282 : 			r = trail->Data->R;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _r$[ebp], edx

; 1283 : 			g = trail->Data->G;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _g$[ebp], edx

; 1284 : 			b = trail->Data->B;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _b$[ebp], edx
$L82068:

; 1285 : 		}
; 1286 : 		vert[2].color = vert[3].color = r << 16 | g << 8 | b;

	mov	eax, DWORD PTR _r$[ebp]
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _g$[ebp]
	shl	ecx, 8
	or	eax, ecx
	or	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	DWORD PTR [edx+112], eax
	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+80], edx

; 1287 : 
; 1288 : 		if (iTrail == trail->NTrails - 1) {

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	sub	ecx, 1
	cmp	DWORD PTR _iTrail$[ebp], ecx
	jne	$L82069

; 1289 : 			vert[3].tu = trail->Data->EndU;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+120], eax

; 1290 : 			vert[3].tv = trail->Data->EndV;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+124], eax

; 1291 : 
; 1292 : 			vert[0].tu = trail->Data->EndU + trail->Data->Usize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx+16]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+24]

; 1293 : 			vert[0].tv = trail->Data->EndV;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+28], eax

; 1294 : 
; 1295 : 			vert[1].tu = trail->Data->EndU + trail->Data->Usize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx+16]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1296 : 			vert[1].tv = trail->Data->EndV + trail->Data->Vsize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx+20]
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+60]

; 1297 : 
; 1298 : 			vert[2].tu = trail->Data->EndU;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _vert$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+88], eax

; 1299 : 			vert[2].tv = trail->Data->EndV + trail->Data->Vsize;

	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _trail$[ebp]
	mov	eax, DWORD PTR [edx+148]
	fld	DWORD PTR [ecx+20]
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _vert$[ebp]
	fstp	DWORD PTR [ecx+92]
$L82069:

; 1300 : 		}
; 1301 : 
; 1302 : 		// draw the poly
; 1303 : 		D3Ddevice->DrawPrimitive(D3DPT_TRIANGLEFAN, FVF_TEX1, poly.Verts, poly.VertNum, poly.DrawFlag);

	mov	eax, DWORD PTR _poly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _poly$[ebp+24]
	push	edx
	push	452					; 000001c4H
	push	6
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+112]

; 1304 : 
; 1305 : 		// copy last to next
; 1306 : 		ePos.sx = sPos.sx;

	mov	eax, DWORD PTR _sPos$[ebp]
	mov	DWORD PTR _ePos$[ebp], eax

; 1307 : 		ePos.sy = sPos.sy;

	mov	eax, DWORD PTR _sPos$[ebp+4]
	mov	DWORD PTR _ePos$[ebp+4], eax

; 1308 : 		ePos.sz = sPos.sz;

	mov	eax, DWORD PTR _sPos$[ebp+8]
	mov	DWORD PTR _ePos$[ebp+8], eax

; 1309 : 		ePos.rhw = sPos.rhw;

	mov	eax, DWORD PTR _sPos$[ebp+12]
	mov	DWORD PTR _ePos$[ebp+12], eax

; 1310 : 
; 1311 : 		vert[2].sx = vert[1].sx;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+64], edx

; 1312 : 		vert[2].sy = vert[1].sy;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+68], edx

; 1313 : 		vert[2].sz = vert[1].sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+72], edx

; 1314 : 		vert[2].rhw = vert[1].rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+76], edx

; 1315 : 		vert[3].sx = vert[0].sx;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+96], edx

; 1316 : 		vert[3].sy = vert[0].sy;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+100], edx

; 1317 : 		vert[3].sz = vert[0].sz;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+104], edx

; 1318 : 		vert[3].rhw = vert[0].rhw;

	mov	eax, DWORD PTR _vert$[ebp]
	mov	ecx, DWORD PTR _vert$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+108], edx

; 1319 : 
; 1320 : 		// move on
; 1321 : 		thisTrail = lastTrail;

	mov	eax, DWORD PTR _lastTrail$[ebp]
	mov	DWORD PTR _thisTrail$[ebp], eax

; 1322 : 		if (--lastTrail < 0) lastTrail = trail->MaxTrails - 1;

	mov	eax, DWORD PTR _lastTrail$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lastTrail$[ebp], eax
	jns	SHORT $L82070
	mov	eax, DWORD PTR _trail$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	sub	ecx, 1
	mov	DWORD PTR _lastTrail$[ebp], ecx
$L82070:

; 1323 : 
; 1324 : 	}

	jmp	$L82056
$L82026:

; 1325 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawSparkTrail@@YAXPAUSparkTrailStruct@@@Z ENDP	; DrawSparkTrail
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?DrawSparks@@YAXXZ				; DrawSparks
EXTRN	?RotationZ@@YAXPATMatrixUnion@@M@Z:NEAR		; RotationZ
EXTRN	?RenderAlpha@@3FA:WORD				; RenderAlpha
EXTRN	?RenderZwrite@@3FA:WORD				; RenderZwrite
EXTRN	?DrawFacingPoly@@YAXPAUVectorStruct@@PAUFACING_POLY@@JM@Z:NEAR ; DrawFacingPoly
EXTRN	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z:NEAR ; DrawFacingPolyRot
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\spark.cpp
;	COMDAT ?DrawSparks@@YAXXZ
_TEXT	SEGMENT
tv278 = -160						; size = 8
_spark$ = -88						; size = 4
_sparkPoly$ = -84					; size = 4
_poly$ = -80						; size = 32
_mat$ = -48						; size = 36
_semi$ = -12						; size = 4
_per$ = -8						; size = 4
_iSpark$ = -4						; size = 4
?DrawSparks@@YAXXZ PROC NEAR				; DrawSparks, COMDAT

; 1328 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi

; 1329 : 	int iSpark;
; 1330 : 	long per, semi;
; 1331 : 	MAT	mat;
; 1332 : 	FACING_POLY poly, *sparkPoly;
; 1333 : 	SPARK *spark;
; 1334 : 
; 1335 : 	ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L82080
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82080:

; 1336 : 	ALPHA_SRC(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 2
	je	SHORT $L82081
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 2	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82081:

; 1337 : 	ALPHA_DEST(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 2
	je	SHORT $L82082
	mov	WORD PTR ?RenderAlphaDest@@3FA, 2	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82082:

; 1338 : 
; 1339 : 	ZWRITE_OFF();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	je	SHORT $L82083
	mov	WORD PTR ?RenderZwrite@@3FA, 0		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82083:

; 1340 : 
; 1341 : 
; 1342 : 	// loop thru all sparks
; 1343 : 	for (iSpark = 0; iSpark < MAX_SPARKS; iSpark++) {

	mov	DWORD PTR _iSpark$[ebp], 0
	jmp	SHORT $L82084
$L82085:
	mov	eax, DWORD PTR _iSpark$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpark$[ebp], eax
$L82084:
	cmp	DWORD PTR _iSpark$[ebp], 1024		; 00000400H
	jge	$L82072

; 1344 : 		if (!Sparks[iSpark].Free) {

	mov	eax, DWORD PTR _iSpark$[ebp]
	imul	eax, 72					; 00000048H
	movzx	ecx, BYTE PTR ?Sparks@@3PAUSparkStruct@@A[eax]
	test	ecx, ecx
	jne	$L82087

; 1345 : 			spark = &Sparks[iSpark];

	mov	eax, DWORD PTR _iSpark$[ebp]
	imul	eax, 72					; 00000048H
	add	eax, OFFSET FLAT:?Sparks@@3PAUSparkStruct@@A ; Sparks
	mov	DWORD PTR _spark$[ebp], eax

; 1346 : 			sparkPoly = &spark->Data->FacingPoly;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _sparkPoly$[ebp], ecx

; 1347 : 
; 1348 : 			// Check against visimask
; 1349 : 			if (CamVisiMask & spark->VisiMask) continue;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR ?CamVisiMask@@3_KA
	and	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	and	edx, DWORD PTR [eax+12]
	mov	DWORD PTR tv278[ebp], ecx
	mov	DWORD PTR tv278[ebp+4], edx
	mov	eax, DWORD PTR tv278[ebp]
	or	eax, DWORD PTR tv278[ebp+4]
	je	SHORT $L82088
	jmp	SHORT $L82085
$L82088:

; 1350 : 
; 1351 : 			// Set up faceme info
; 1352 : 			poly.Tpage = sparkPoly->Tpage;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	cx, WORD PTR [eax+24]
	mov	WORD PTR _poly$[ebp+24], cx

; 1353 : 			poly.Xsize = sparkPoly->Xsize;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _poly$[ebp], ecx

; 1354 : 			poly.Ysize = sparkPoly->Ysize;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _poly$[ebp+4], ecx

; 1355 : 			poly.U = sparkPoly->U;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _poly$[ebp+8], ecx

; 1356 : 			poly.V = sparkPoly->V;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _poly$[ebp+12], ecx

; 1357 : 			poly.Usize = sparkPoly->Usize;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _poly$[ebp+16], ecx

; 1358 : 			poly.Vsize = sparkPoly->Vsize;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _poly$[ebp+20], ecx

; 1359 : 
; 1360 : 			poly.RGB = sparkPoly->RGB;

	mov	eax, DWORD PTR _sparkPoly$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _poly$[ebp+28], ecx

; 1361 : 
; 1362 : 			// Expand poly if spark
; 1363 : 			poly.Xsize += spark->Grow;

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+48]
	fstp	DWORD PTR _poly$[ebp]

; 1364 : 			poly.Ysize += spark->Grow;

	mov	eax, DWORD PTR _spark$[ebp]
	fld	DWORD PTR _poly$[ebp+4]
	fadd	DWORD PTR [eax+48]
	fstp	DWORD PTR _poly$[ebp+4]

; 1365 : 			if (poly.Xsize < 0.0f) {

	fld	DWORD PTR _poly$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82089

; 1366 : 				continue;

	jmp	$L82085
$L82089:

; 1367 : 			}
; 1368 : 			if (poly.Ysize < 0.0f) {

	fld	DWORD PTR _poly$[ebp+4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82090

; 1369 : 				continue;

	jmp	$L82085
$L82090:

; 1370 : 			}
; 1371 : 
; 1372 : 			// set the semi transparency flag
; 1373 : 			if (spark->Data->SparkType & SPARK_SEMI) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 128				; 00000080H
	je	$L82091

; 1374 : 				semi = 0;

	mov	DWORD PTR _semi$[ebp], 0

; 1375 : 				per = (100 * (spark->Data->LifeTime - spark->Age)) / spark->Data->LifeTime;

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _spark$[ebp]
	mov	eax, DWORD PTR [ecx+52]
	sub	eax, DWORD PTR [edx+68]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [ecx+64]
	xor	edx, edx
	div	DWORD PTR [ecx+52]
	mov	DWORD PTR _per$[ebp], eax

; 1376 : 				ModelChangeGouraud((MODEL_RGB*)&poly.RGB, per);

	cmp	DWORD PTR _per$[ebp], 100		; 00000064H
	je	SHORT $L82092
	movzx	eax, BYTE PTR _poly$[ebp+30]
	add	eax, 1
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	BYTE PTR _poly$[ebp+30], al
	movzx	eax, BYTE PTR _poly$[ebp+29]
	add	eax, 1
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	BYTE PTR _poly$[ebp+29], al
	movzx	eax, BYTE PTR _poly$[ebp+28]
	add	eax, 1
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	BYTE PTR _poly$[ebp+28], al
$L82092:

; 1377 : 				ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L82099
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82099:

; 1378 : 				ZWRITE_OFF();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	je	SHORT $L82100
	mov	WORD PTR ?RenderZwrite@@3FA, 0		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82100:

; 1379 : 			} else {

	jmp	SHORT $L82101
$L82091:

; 1380 : 				semi = -1;

	mov	DWORD PTR _semi$[ebp], -1

; 1381 : 				ALPHA_OFF();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	je	SHORT $L82102
	mov	WORD PTR ?RenderAlpha@@3FA, 0		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82102:

; 1382 : 				ZWRITE_ON();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	jne	SHORT $L82101
	mov	WORD PTR ?RenderZwrite@@3FA, 1		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L82101:

; 1383 : 			}
; 1384 : 
; 1385 : 			// Rotate the spark if necessary and then draw
; 1386 : 			if (spark->Data->SparkType & SPARK_SPINS) {

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 16					; 00000010H
	je	SHORT $L82104

; 1387 : 				RotationZ(&mat, spark->Spin);

	mov	eax, DWORD PTR _spark$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotationZ@@YAXPATMatrixUnion@@M@Z	; RotationZ
	add	esp, 8

; 1388 : 				DrawFacingPolyRot(&Sparks[iSpark].Pos, &mat, &poly, -1, 0);

	push	0
	push	-1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSpark$[ebp]
	imul	edx, 72					; 00000048H
	add	edx, OFFSET FLAT:?Sparks@@3PAUSparkStruct@@A+16
	push	edx
	call	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRot
	add	esp, 20					; 00000014H

; 1389 : 			} else {

	jmp	SHORT $L82087
$L82104:

; 1390 : 				DrawFacingPoly(&Sparks[iSpark].Pos, &poly, -1, 0);

	push	0
	push	-1
	lea	eax, DWORD PTR _poly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSpark$[ebp]
	imul	ecx, 72					; 00000048H
	add	ecx, OFFSET FLAT:?Sparks@@3PAUSparkStruct@@A+16
	push	ecx
	call	?DrawFacingPoly@@YAXPAUVectorStruct@@PAUFACING_POLY@@JM@Z ; DrawFacingPoly
	add	esp, 16					; 00000010H
$L82087:

; 1391 : 			}
; 1392 : 
; 1393 : 		}
; 1394 : 	}

	jmp	$L82085
$L82072:

; 1395 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawSparks@@YAXXZ ENDP					; DrawSparks
_TEXT	ENDS
PUBLIC	?DrawTrails@@YAXXZ				; DrawTrails
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawTrails@@YAXXZ
_TEXT	SEGMENT
_iTrail$ = -4						; size = 4
?DrawTrails@@YAXXZ PROC NEAR				; DrawTrails, COMDAT

; 1404 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1405 : 	int iTrail;
; 1406 : 
; 1407 : 	for (iTrail = 0; iTrail < MAX_TRAILS; iTrail++) {

	mov	DWORD PTR _iTrail$[ebp], 0
	jmp	SHORT $L82109
$L82110:
	mov	eax, DWORD PTR _iTrail$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTrail$[ebp], eax
$L82109:
	cmp	DWORD PTR _iTrail$[ebp], 128		; 00000080H
	jge	SHORT $L82107

; 1408 : 		if (SparkTrail[iTrail].Free) continue;

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	movzx	ecx, BYTE PTR ?SparkTrail@@3PAUSparkTrailStruct@@A[eax]
	test	ecx, ecx
	je	SHORT $L82112
	jmp	SHORT $L82110
$L82112:

; 1409 : 
; 1410 : 		DrawSparkTrail(&SparkTrail[iTrail]);

	mov	eax, DWORD PTR _iTrail$[ebp]
	imul	eax, 164				; 000000a4H
	add	eax, OFFSET FLAT:?SparkTrail@@3PAUSparkTrailStruct@@A ; SparkTrail
	push	eax
	call	?DrawSparkTrail@@YAXPAUSparkTrailStruct@@@Z ; DrawSparkTrail
	add	esp, 4

; 1411 : 	}

	jmp	SHORT $L82110
$L82107:

; 1412 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawTrails@@YAXXZ ENDP					; DrawTrails
_TEXT	ENDS
END
