; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\trigger.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IM@BLBFFEEF@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@PFKOMAFB@Can?8t?5alloc?5memory?5for?5triggers?$CB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTriggers@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeTriggers@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckTriggers@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetTriggerFlags@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??FreeTriggers@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadTriggers@@YAXPAD@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?Triggers@@3PAUTRIGGER@@A			; Triggers
PUBLIC	?TriggerNum@@3JA				; TriggerNum
EXTRN	?CAI_TriggerAiHome@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z:NEAR ; CAI_TriggerAiHome
EXTRN	?TriggerPiano@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z:NEAR ; TriggerPiano
EXTRN	?TriggerTrackDir@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z:NEAR ; TriggerTrackDir
EXTRN	?TriggerSplit@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z:NEAR ; TriggerSplit
EXTRN	?TriggerCamera@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z:NEAR ; TriggerCamera
_BSS	SEGMENT
?Triggers@@3PAUTRIGGER@@A DD 01H DUP (?)		; Triggers
?TriggerNum@@3JA DD 01H DUP (?)				; TriggerNum
_BSS	ENDS
_DATA	SEGMENT
_TriggerInfo DD	FLAT:?TriggerPiano@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z
	DD	00H
	DD	FLAT:?TriggerSplit@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z
	DD	01H
	DD	FLAT:?TriggerTrackDir@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z
	DD	01H
	DD	FLAT:?TriggerCamera@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z
	DD	00H
	DD	FLAT:?CAI_TriggerAiHome@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z
	DD	01H
_DATA	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?__LINE__Var@?1??LoadTriggers@@YAXPAD@Z@4JA	; `LoadTriggers'::`2'::__LINE__Var
PUBLIC	??_C@_0IM@BLBFFEEF@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	??_C@_0CB@PFKOMAFB@Can?8t?5alloc?5memory?5for?5triggers?$CB@ ; `string'
PUBLIC	__real@41000000
PUBLIC	?LoadTriggers@@YAXPAD@Z				; LoadTriggers
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z:NEAR ; RotTransVector
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_02JDPG@rb?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\trigger.cpp
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@BLBFFEEF@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IM@BLBFFEEF@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\trigg'
	DB	'er.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??LoadTriggers@@YAXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadTriggers@@YAXPAD@Z@4JA DD 02eH	; `LoadTriggers'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@PFKOMAFB@Can?8t?5alloc?5memory?5for?5triggers?$CB@
CONST	SEGMENT
??_C@_0CB@PFKOMAFB@Can?8t?5alloc?5memory?5for?5triggers?$CB@ DB 'Can''t a'
	DB	'lloc memory for triggers!', 00H		; `string'
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadTriggers@@YAXPAD@Z
_TEXT	SEGMENT
tv563 = -160						; size = 4
tv550 = -160						; size = 4
tv536 = -160						; size = 4
_vec$ = -92						; size = 12
_ftri$ = -80						; size = 68
_fp$ = -12						; size = 4
_time$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?LoadTriggers@@YAXPAD@Z PROC NEAR			; LoadTriggers, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi

; 47   : 	long i;
; 48   : 	REAL time;
; 49   : 	FILE *fp;
; 50   : 	FILE_TRIGGER ftri;
; 51   : 	VEC vec;
; 52   : 
; 53   : // zero misc
; 54   : 
; 55   : 	TriggerNum = 0;

	mov	DWORD PTR ?TriggerNum@@3JA, 0		; TriggerNum

; 56   : 	Triggers = NULL;

	mov	DWORD PTR ?Triggers@@3PAUTRIGGER@@A, 0	; Triggers

; 57   : 
; 58   : // open trigger file
; 59   : 
; 60   : 	fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 61   : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81378

; 62   : 	{
; 63   : 		return;

	jmp	$L81371
$L81378:

; 64   : 	}
; 65   : 
; 66   : // read trigger num
; 67   : 
; 68   : 	fread(&TriggerNum, sizeof(TriggerNum), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	push	OFFSET FLAT:?TriggerNum@@3JA		; TriggerNum
	call	_fread
	add	esp, 16					; 00000010H

; 69   : 	if (!TriggerNum)

	cmp	DWORD PTR ?TriggerNum@@3JA, 0		; TriggerNum
	jne	SHORT $L81379

; 70   : 	{
; 71   : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 72   : 		return;

	jmp	$L81371
$L81379:

; 73   : 	}
; 74   : 
; 75   : // alloc ram for triggers
; 76   : 
; 77   : 	Triggers = (TRIGGER*)malloc(sizeof(TRIGGER) * TriggerNum);

	push	OFFSET FLAT:??_C@_0IM@BLBFFEEF@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadTriggers@@YAXPAD@Z@4JA
	add	eax, 31					; 0000001fH
	push	eax
	mov	ecx, DWORD PTR ?TriggerNum@@3JA		; TriggerNum
	imul	ecx, 96					; 00000060H
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?Triggers@@3PAUTRIGGER@@A, eax ; Triggers

; 78   : 	if (!Triggers)

	cmp	DWORD PTR ?Triggers@@3PAUTRIGGER@@A, 0	; Triggers
	jne	SHORT $L81384

; 79   : 	{
; 80   : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 81   : 		Box(NULL, "Can't alloc memory for triggers!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CB@PFKOMAFB@Can?8t?5alloc?5memory?5for?5triggers?$CB@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 82   : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 83   : 		return;

	jmp	$L81371
$L81384:

; 84   : 	}
; 85   : 
; 86   : // load and convert each trigger
; 87   : 
; 88   : 	for (i = 0 ; i < TriggerNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81386
$L81387:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81386:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?TriggerNum@@3JA		; TriggerNum
	jge	$L81388

; 89   : 	{
; 90   : 
; 91   : // read file zone
; 92   : 
; 93   : 		fread(&ftri, sizeof(ftri), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	68					; 00000044H
	lea	ecx, DWORD PTR _ftri$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 94   : 
; 95   : // set misc
; 96   : 
; 97   : 		Triggers[i].ID = ftri.ID;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx

; 98   : 		Triggers[i].Flag = ftri.Flag;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+4]
	mov	DWORD PTR [ecx+eax+12], edx

; 99   : 		Triggers[i].GlobalFirst = TRUE;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	DWORD PTR [ecx+eax], 1

; 100  : 		Triggers[i].Function = TriggerInfo[ftri.ID].Func;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp]
	mov	edx, DWORD PTR _TriggerInfo[edx*8]
	mov	DWORD PTR [ecx+eax+92], edx

; 101  : 		Triggers[i].LocalPlayerOnly = TriggerInfo[ftri.ID].LocalPlayerOnly;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp]
	mov	edx, DWORD PTR _TriggerInfo[edx*8+4]
	mov	DWORD PTR [ecx+eax+16], edx

; 102  : 
; 103  : // set XYZ size
; 104  : 
; 105  : 		Triggers[i].Size[0] = ftri.Size[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+56]
	mov	DWORD PTR [ecx+eax+20], edx

; 106  : 		Triggers[i].Size[1] = ftri.Size[1];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+60]
	mov	DWORD PTR [ecx+eax+24], edx

; 107  : 		Triggers[i].Size[2] = ftri.Size[2];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+64]
	mov	DWORD PTR [ecx+eax+28], edx

; 108  : 
; 109  : // build 3 planes
; 110  : 
; 111  : 		Triggers[i].Plane[0].v[A] = ftri.Matrix.m[RX];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+20]
	mov	DWORD PTR [ecx+eax+32], edx

; 112  : 		Triggers[i].Plane[0].v[B] = ftri.Matrix.m[RY];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+24]
	mov	DWORD PTR [ecx+eax+36], edx

; 113  : 		Triggers[i].Plane[0].v[C] = ftri.Matrix.m[RZ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+28]
	mov	DWORD PTR [ecx+eax+40], edx

; 114  : 		Triggers[i].Plane[0].v[D] = -DotProduct(&ftri.Matrix.mv[R], &ftri.Pos);

	fld	DWORD PTR _ftri$[ebp+20]
	fmul	DWORD PTR _ftri$[ebp+8]
	fld	DWORD PTR _ftri$[ebp+24]
	fmul	DWORD PTR _ftri$[ebp+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ftri$[ebp+28]
	fmul	DWORD PTR _ftri$[ebp+16]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fstp	DWORD PTR [ecx+eax+44]

; 115  : 
; 116  : 		Triggers[i].Plane[1].v[A] = ftri.Matrix.m[UX];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+32]
	mov	DWORD PTR [ecx+eax+48], edx

; 117  : 		Triggers[i].Plane[1].v[B] = ftri.Matrix.m[UY];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+36]
	mov	DWORD PTR [ecx+eax+52], edx

; 118  : 		Triggers[i].Plane[1].v[C] = ftri.Matrix.m[UZ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+40]
	mov	DWORD PTR [ecx+eax+56], edx

; 119  : 		Triggers[i].Plane[1].v[D] = -DotProduct(&ftri.Matrix.mv[U], &ftri.Pos);

	fld	DWORD PTR _ftri$[ebp+32]
	fmul	DWORD PTR _ftri$[ebp+8]
	fld	DWORD PTR _ftri$[ebp+36]
	fmul	DWORD PTR _ftri$[ebp+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ftri$[ebp+40]
	fmul	DWORD PTR _ftri$[ebp+16]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fstp	DWORD PTR [ecx+eax+60]

; 120  : 
; 121  : 		Triggers[i].Plane[2].v[A] = ftri.Matrix.m[LX];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+44]
	mov	DWORD PTR [ecx+eax+64], edx

; 122  : 		Triggers[i].Plane[2].v[B] = ftri.Matrix.m[LY];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+48]
	mov	DWORD PTR [ecx+eax+68], edx

; 123  : 		Triggers[i].Plane[2].v[C] = ftri.Matrix.m[LZ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR _ftri$[ebp+52]
	mov	DWORD PTR [ecx+eax+72], edx

; 124  : 		Triggers[i].Plane[2].v[D] = -DotProduct(&ftri.Matrix.mv[L], &ftri.Pos);

	fld	DWORD PTR _ftri$[ebp+44]
	fmul	DWORD PTR _ftri$[ebp+8]
	fld	DWORD PTR _ftri$[ebp+48]
	fmul	DWORD PTR _ftri$[ebp+12]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _ftri$[ebp+52]
	fmul	DWORD PTR _ftri$[ebp+16]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fstp	DWORD PTR [ecx+eax+76]

; 125  : 
; 126  : // set vec?
; 127  : 
; 128  : 		vec.v[Y] = 0;

	mov	DWORD PTR _vec$[ebp+4], 0

; 129  : 
; 130  : 		if (Triggers[i].ID == TRIGGER_AIHOME)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	cmp	DWORD PTR [ecx+eax+8], 4
	jne	$L81389

; 131  : 		{
; 132  : 			if (Triggers[i].Flag < 8)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	cmp	DWORD PTR [ecx+eax+12], 8
	jge	SHORT $L81390

; 133  : 			{
; 134  : 				time = (float)Triggers[i].Flag / 8.0f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fild	DWORD PTR [ecx+eax+12]
	fdiv	DWORD PTR __real@41000000
	fstp	DWORD PTR _time$[ebp]

; 135  : 				vec.v[X] = -Triggers[i].Size[X];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR [ecx+eax+20]
	fchs
	fstp	DWORD PTR _vec$[ebp]

; 136  : 				vec.v[Z] = -Triggers[i].Size[Z] + Triggers[i].Size[Z] * time * 2;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR [ecx+eax+28]
	fchs
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR [eax+edx+28]
	fadd	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vec$[ebp+8]

; 137  : 			}
; 138  : 			else if (Triggers[i].Flag < 16)

	jmp	$L81392
$L81390:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	cmp	DWORD PTR [ecx+eax+12], 16		; 00000010H
	jge	SHORT $L81393

; 139  : 			{
; 140  : 				time = (float)(Triggers[i].Flag - 8) / 8.0f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR [ecx+eax+12]
	sub	edx, 8
	mov	DWORD PTR tv536[ebp], edx
	fild	DWORD PTR tv536[ebp]
	fdiv	DWORD PTR __real@41000000
	fstp	DWORD PTR _time$[ebp]

; 141  : 				vec.v[X] = -Triggers[i].Size[X] + Triggers[i].Size[X] * time * 2;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR [ecx+eax+20]
	fchs
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR [eax+edx+20]
	fadd	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vec$[ebp]

; 142  : 				vec.v[Z] = Triggers[i].Size[Z];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR [ecx+eax+28]
	mov	DWORD PTR _vec$[ebp+8], edx

; 143  : 			}
; 144  : 			else if (Triggers[i].Flag < 24)

	jmp	$L81392
$L81393:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	cmp	DWORD PTR [ecx+eax+12], 24		; 00000018H
	jge	SHORT $L81396

; 145  : 			{
; 146  : 				time = (float)(Triggers[i].Flag - 16) / 8.0f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR [ecx+eax+12]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR tv550[ebp], edx
	fild	DWORD PTR tv550[ebp]
	fdiv	DWORD PTR __real@41000000
	fstp	DWORD PTR _time$[ebp]

; 147  : 				vec.v[X] = Triggers[i].Size[X];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR [ecx+eax+20]
	mov	DWORD PTR _vec$[ebp], edx

; 148  : 				vec.v[Z] = Triggers[i].Size[Z] - Triggers[i].Size[Z] * time * 2;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR [edx+ecx+28]
	fadd	ST(0), ST(0)
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fsubr	DWORD PTR [ecx+eax+28]
	fstp	DWORD PTR _vec$[ebp+8]

; 149  : 			}
; 150  : 			else if (Triggers[i].Flag < 32)

	jmp	SHORT $L81392
$L81396:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	cmp	DWORD PTR [ecx+eax+12], 32		; 00000020H
	jge	SHORT $L81392

; 151  : 			{
; 152  : 				time = (float)(Triggers[i].Flag - 24) / 8.0f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR [ecx+eax+12]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR tv563[ebp], edx
	fild	DWORD PTR tv563[ebp]
	fdiv	DWORD PTR __real@41000000
	fstp	DWORD PTR _time$[ebp]

; 153  : 				vec.v[X] = Triggers[i].Size[X] - Triggers[i].Size[X] * time * 2;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR [edx+ecx+20]
	fadd	ST(0), ST(0)
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fsubr	DWORD PTR [ecx+eax+20]
	fstp	DWORD PTR _vec$[ebp]

; 154  : 				vec.v[Z] = -Triggers[i].Size[Z];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	fld	DWORD PTR [ecx+eax+28]
	fchs
	fstp	DWORD PTR _vec$[ebp+8]
$L81392:

; 155  : 			}
; 156  : 
; 157  : 			RotTransVector(&ftri.Matrix, &ftri.Pos, &vec, &Triggers[i].Vector);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	lea	edx, DWORD PTR [ecx+eax+80]
	push	edx
	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ftri$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ftri$[ebp+20]
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H
$L81389:

; 158  : 		}
; 159  : 	}

	jmp	$L81387
$L81388:

; 160  : 
; 161  : // close file
; 162  : 
; 163  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L81371:

; 164  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadTriggers@@YAXPAD@Z ENDP				; LoadTriggers
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??FreeTriggers@@YAXXZ@4JA	; `FreeTriggers'::`2'::__LINE__Var
PUBLIC	?FreeTriggers@@YAXXZ				; FreeTriggers
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??FreeTriggers@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??FreeTriggers@@YAXXZ@4JA DD 012eH	; `FreeTriggers'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?FreeTriggers@@YAXXZ
_TEXT	SEGMENT
?FreeTriggers@@YAXXZ PROC NEAR				; FreeTriggers, COMDAT

; 302  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 303  : 	free(Triggers);

	push	OFFSET FLAT:??_C@_0IM@BLBFFEEF@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeTriggers@@YAXXZ@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeTriggers@@YAXXZ ENDP				; FreeTriggers
_TEXT	ENDS
PUBLIC	?CheckTriggers@@YAXXZ				; CheckTriggers
EXTRN	?PLR_PlayerHead@@3PAUPlayerStruct@@A:DWORD	; PLR_PlayerHead
EXTRN	?PLR_LocalPlayer@@3PAUPlayerStruct@@A:DWORD	; PLR_LocalPlayer
EXTRN	?FrameCount@@3KA:DWORD				; FrameCount
; Function compile flags: /Odt /ZI
;	COMDAT ?CheckTriggers@@YAXXZ
_TEXT	SEGMENT
_player$ = -36						; size = 4
_pos$ = -32						; size = 4
_car$ = -28						; size = 4
_trigger$ = -24						; size = 4
_dist$ = -20						; size = 4
_flag$ = -16						; size = 4
_skip$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
?CheckTriggers@@YAXXZ PROC NEAR				; CheckTriggers, COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 312  : 	long i, k, skip, flag;
; 313  : 	float dist;
; 314  : 	TRIGGER *trigger;
; 315  : 	CAR *car;
; 316  : 	VEC *pos;
; 317  : 	PLAYER *player;
; 318  : 
; 319  : // loop thru all triggers
; 320  : 
; 321  : 	trigger = Triggers;

	mov	eax, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	DWORD PTR _trigger$[ebp], eax

; 322  : 	for (i = 0 ; i < TriggerNum ; i++, trigger++) if (trigger->ID < TRIGGER_NUM)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81417
$L81418:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _trigger$[ebp]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR _trigger$[ebp], ecx
$L81417:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?TriggerNum@@3JA		; TriggerNum
	jge	$L81407
	mov	eax, DWORD PTR _trigger$[ebp]
	cmp	DWORD PTR [eax+8], 5
	jge	$L81420

; 323  : 	{
; 324  : 
; 325  : // loop thru players
; 326  : 
; 327  : 		for (player = PLR_PlayerHead ; player != NULL ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L81421
$L81422:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L81421:
	cmp	DWORD PTR _player$[ebp], 0
	je	$L81420

; 328  : 		{
; 329  : 			car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 330  : 
; 331  : 			if (trigger->LocalPlayerOnly && car != &PLR_LocalPlayer->car)

	mov	eax, DWORD PTR _trigger$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L81424
	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	add	eax, 44					; 0000002cH
	cmp	DWORD PTR _car$[ebp], eax
	je	SHORT $L81424

; 332  : 				continue;

	jmp	SHORT $L81422
$L81424:

; 333  : 
; 334  : // inside trigger?
; 335  : 
; 336  : 			pos = &car->Body->Centre.Pos;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _pos$[ebp], ecx

; 337  : 
; 338  : 			skip = FALSE;

	mov	DWORD PTR _skip$[ebp], 0

; 339  : 			for (k = 0 ; k < 3 ; k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L81425
$L81426:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L81425:
	cmp	DWORD PTR _k$[ebp], 3
	jge	$L81427

; 340  : 			{
; 341  : 				dist = PlaneDist(&trigger->Plane[k], pos);

	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR _trigger$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+eax+32]
	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR _trigger$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+eax+36]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR _trigger$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+eax+40]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _trigger$[ebp]
	fadd	DWORD PTR [ecx+eax+44]
	fstp	DWORD PTR _dist$[ebp]

; 342  : 				if (dist < -trigger->Size[k] || dist > trigger->Size[k])

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _trigger$[ebp]
	fld	DWORD PTR [ecx+eax*4+20]
	fchs
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81429
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _trigger$[ebp]
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR [ecx+eax*4+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81428
$L81429:

; 343  : 				{
; 344  : 					skip = TRUE;

	mov	DWORD PTR _skip$[ebp], 1

; 345  : 					break;

	jmp	SHORT $L81427
$L81428:

; 346  : 				}
; 347  : 			}

	jmp	$L81426
$L81427:

; 348  : 
; 349  : // yep
; 350  : 
; 351  : 			if (!skip)

	cmp	DWORD PTR _skip$[ebp], 0
	jne	SHORT $L81430

; 352  : 			{
; 353  : 				flag = 0;

	mov	DWORD PTR _flag$[ebp], 0

; 354  : 				if (trigger->GlobalFirst) flag |= TRIGGER_GLOBAL_FIRST;

	mov	eax, DWORD PTR _trigger$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L81431
	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 1
	mov	DWORD PTR _flag$[ebp], eax
$L81431:

; 355  : 				if (trigger->FrameStamp != FrameCount) flag |= TRIGGER_FRAME_FIRST;

	mov	eax, DWORD PTR _trigger$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR ?FrameCount@@3KA		; FrameCount
	je	SHORT $L81432
	mov	eax, DWORD PTR _flag$[ebp]
	or	eax, 2
	mov	DWORD PTR _flag$[ebp], eax
$L81432:

; 356  : 
; 357  : 				if (trigger->Function) trigger->Function(player, flag, trigger->Flag, &trigger->Vector);

	mov	eax, DWORD PTR _trigger$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $L81433
	mov	eax, DWORD PTR _trigger$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _trigger$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	edx, DWORD PTR _trigger$[ebp]
	call	DWORD PTR [edx+92]
	add	esp, 16					; 00000010H
$L81433:

; 358  : 
; 359  : 				trigger->FrameStamp = FrameCount;

	mov	eax, DWORD PTR _trigger$[ebp]
	mov	ecx, DWORD PTR ?FrameCount@@3KA		; FrameCount
	mov	DWORD PTR [eax+4], ecx

; 360  : 				trigger->GlobalFirst = FALSE;

	mov	eax, DWORD PTR _trigger$[ebp]
	mov	DWORD PTR [eax], 0
$L81430:

; 361  : 			}
; 362  : 		}

	jmp	$L81422
$L81420:

; 363  : 	}
; 364  : }

	jmp	$L81418
$L81407:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckTriggers@@YAXXZ ENDP				; CheckTriggers
_TEXT	ENDS
PUBLIC	?ResetTriggerFlags@@YAXJ@Z			; ResetTriggerFlags
; Function compile flags: /Odt /ZI
;	COMDAT ?ResetTriggerFlags@@YAXJ@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ID$ = 8						; size = 4
?ResetTriggerFlags@@YAXJ@Z PROC NEAR			; ResetTriggerFlags, COMDAT

; 371  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 372  : 	long i;
; 373  : 
; 374  : 	for (i = 0 ; i < TriggerNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81438
$L81439:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81438:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?TriggerNum@@3JA		; TriggerNum
	jge	SHORT $L81436

; 375  : 	{
; 376  : 		if (Triggers[i].ID == ID)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR [ecx+eax+8]
	cmp	edx, DWORD PTR _ID$[ebp]
	jne	SHORT $L81441

; 377  : 		{
; 378  : 			Triggers[i].FrameStamp--;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	edx, DWORD PTR [ecx+eax+4]
	sub	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	DWORD PTR [ecx+eax+4], edx

; 379  : 			Triggers[i].GlobalFirst = TRUE;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR ?Triggers@@3PAUTRIGGER@@A ; Triggers
	mov	DWORD PTR [ecx+eax], 1
$L81441:

; 380  : 		}
; 381  : 	}

	jmp	SHORT $L81439
$L81436:

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetTriggerFlags@@YAXJ@Z ENDP				; ResetTriggerFlags
_TEXT	ENDS
END
