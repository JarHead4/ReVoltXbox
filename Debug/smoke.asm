; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\smoke.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IK@LNIOCEPL@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@PPHIHIGJ@Can?8t?5alloc?5memory?5for?5smoke?5eng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitSmoke@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KillSmoke@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocSmoke@@YAPAU_SMOKE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeSmoke@@YAXPAU_SMOKE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSmoke@@YAJPAUVectorStruct@@0MMMMMJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessSmoke@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawSmoke@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??KillSmoke@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??InitSmoke@@YAJXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?InitSmoke@@YAJXZ				; InitSmoke
PUBLIC	?__LINE__Var@?1??InitSmoke@@YAJXZ@4JA		; `InitSmoke'::`2'::__LINE__Var
PUBLIC	??_C@_0IK@LNIOCEPL@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	??_C@_0CE@PPHIHIGJ@Can?8t?5alloc?5memory?5for?5smoke?5eng@ ; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR?$AA@			; `string'
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
_BSS	SEGMENT
_UsedSmokeCount DD 01H DUP (?)
_SmokeList DD	01H DUP (?)
_UsedSmokeHead DD 01H DUP (?)
_FreeSmokeHead DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0IK@LNIOCEPL@c?3?2documents?5and?5settings?2jarhea@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\smoke.cpp
CONST	SEGMENT
??_C@_0IK@LNIOCEPL@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\smoke'
	DB	'.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??InitSmoke@@YAJXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??InitSmoke@@YAJXZ@4JA DD 016H		; `InitSmoke'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@PPHIHIGJ@Can?8t?5alloc?5memory?5for?5smoke?5eng@
CONST	SEGMENT
??_C@_0CE@PPHIHIGJ@Can?8t?5alloc?5memory?5for?5smoke?5eng@ DB 'Can''t all'
	DB	'oc memory for smoke engine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR?$AA@ DB 'ERROR', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitSmoke@@YAJXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?InitSmoke@@YAJXZ PROC NEAR				; InitSmoke, COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 23   : 	long i;
; 24   : 
; 25   : // alloc list memory
; 26   : 
; 27   : 	SmokeList = (SMOKE*)malloc(sizeof(SMOKE) * MAX_SMOKES);

	push	OFFSET FLAT:??_C@_0IK@LNIOCEPL@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitSmoke@@YAJXZ@4JA
	add	eax, 5
	push	eax
	push	31744					; 00007c00H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _SmokeList, eax

; 28   : 	if (!SmokeList)

	cmp	DWORD PTR _SmokeList, 0
	jne	SHORT $L76852

; 29   : 	{
; 30   : 		Box("ERROR", "Can't alloc memory for smoke engine", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CE@PPHIHIGJ@Can?8t?5alloc?5memory?5for?5smoke?5eng@
	push	OFFSET FLAT:??_C@_05MBDEGLCK@ERROR?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 31   : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 32   : 		return FALSE;

	xor	eax, eax
	jmp	$L76846
$L76852:

; 33   : 	}
; 34   : 
; 35   : // NULL used head
; 36   : 
; 37   : 	UsedSmokeHead = NULL;

	mov	DWORD PTR _UsedSmokeHead, 0

; 38   : 
; 39   : // link free list
; 40   : 
; 41   : 	FreeSmokeHead = SmokeList;

	mov	eax, DWORD PTR _SmokeList
	mov	DWORD PTR _FreeSmokeHead, eax

; 42   : 
; 43   : 	for (i = 0 ; i < MAX_SMOKES ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76855
$L76856:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76855:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $L76857

; 44   : 	{
; 45   : 		SmokeList[i].Prev = &SmokeList[i - 1];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	imul	eax, 124				; 0000007cH
	add	eax, DWORD PTR _SmokeList
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR _SmokeList
	mov	DWORD PTR [edx+ecx+116], eax

; 46   : 		SmokeList[i].Next = &SmokeList[i + 1];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	imul	eax, 124				; 0000007cH
	add	eax, DWORD PTR _SmokeList
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR _SmokeList
	mov	DWORD PTR [edx+ecx+120], eax

; 47   : 	}

	jmp	SHORT $L76856
$L76857:

; 48   : 
; 49   : // NULL first->Prev & last->Next
; 50   : 
; 51   : 	SmokeList[0].Prev = NULL;

	mov	eax, DWORD PTR _SmokeList
	mov	DWORD PTR [eax+116], 0

; 52   : 	SmokeList[MAX_SMOKES - 1].Next = NULL;

	mov	eax, DWORD PTR _SmokeList
	mov	DWORD PTR [eax+31740], 0

; 53   : 
; 54   : // zero count
; 55   : 
; 56   : 	UsedSmokeCount = 0;

	mov	DWORD PTR _UsedSmokeCount, 0

; 57   : 
; 58   : // return OK
; 59   : 
; 60   : 	return TRUE;

	mov	eax, 1
$L76846:

; 61   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSmoke@@YAJXZ ENDP					; InitSmoke
_TEXT	ENDS
PUBLIC	?KillSmoke@@YAXXZ				; KillSmoke
PUBLIC	?__LINE__Var@?1??KillSmoke@@YAXXZ@4JA		; `KillSmoke'::`2'::__LINE__Var
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??KillSmoke@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??KillSmoke@@YAXXZ@4JA DD 044H		; `KillSmoke'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?KillSmoke@@YAXXZ
_TEXT	SEGMENT
?KillSmoke@@YAXXZ PROC NEAR				; KillSmoke, COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 69   : 	free(SmokeList);

	push	OFFSET FLAT:??_C@_0IK@LNIOCEPL@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??KillSmoke@@YAXXZ@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _SmokeList
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 70   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?KillSmoke@@YAXXZ ENDP					; KillSmoke
_TEXT	ENDS
PUBLIC	?AllocSmoke@@YAPAU_SMOKE@@XZ			; AllocSmoke
; Function compile flags: /Odt /ZI
;	COMDAT ?AllocSmoke@@YAPAU_SMOKE@@XZ
_TEXT	SEGMENT
_smoke$ = -4						; size = 4
?AllocSmoke@@YAPAU_SMOKE@@XZ PROC NEAR			; AllocSmoke, COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 78   : 	SMOKE *smoke;
; 79   : 
; 80   : // return NULL if none free
; 81   : 
; 82   : 	if (!FreeSmokeHead)

	cmp	DWORD PTR _FreeSmokeHead, 0
	jne	SHORT $L76866

; 83   : 	{
; 84   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L76864
$L76866:

; 85   : 	}
; 86   : 
; 87   : // remove our smoke from free list
; 88   : 
; 89   : 	smoke = FreeSmokeHead;

	mov	eax, DWORD PTR _FreeSmokeHead
	mov	DWORD PTR _smoke$[ebp], eax

; 90   : 	FreeSmokeHead = smoke->Next;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _FreeSmokeHead, ecx

; 91   : 
; 92   : 	if (FreeSmokeHead)

	cmp	DWORD PTR _FreeSmokeHead, 0
	je	SHORT $L76867

; 93   : 	{
; 94   : 		FreeSmokeHead->Prev = NULL;

	mov	eax, DWORD PTR _FreeSmokeHead
	mov	DWORD PTR [eax+116], 0
$L76867:

; 95   : 	}
; 96   : 	
; 97   : // add to used list
; 98   : 
; 99   : 	smoke->Prev = NULL;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [eax+116], 0

; 100  : 	smoke->Next = UsedSmokeHead;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _UsedSmokeHead
	mov	DWORD PTR [eax+120], ecx

; 101  : 	UsedSmokeHead = smoke;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR _UsedSmokeHead, eax

; 102  : 
; 103  : 	if (smoke->Next)

	mov	eax, DWORD PTR _smoke$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $L76868

; 104  : 	{
; 105  : 		smoke->Next->Prev = smoke;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [ecx+116], edx
$L76868:

; 106  : 	}
; 107  : 
; 108  : // inc used count
; 109  : 
; 110  : 	UsedSmokeCount++;

	mov	eax, DWORD PTR _UsedSmokeCount
	add	eax, 1
	mov	DWORD PTR _UsedSmokeCount, eax

; 111  : 
; 112  : // return our smoke
; 113  : 
; 114  : 	return smoke;

	mov	eax, DWORD PTR _smoke$[ebp]
$L76864:

; 115  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocSmoke@@YAPAU_SMOKE@@XZ ENDP			; AllocSmoke
_TEXT	ENDS
PUBLIC	?FreeSmoke@@YAXPAU_SMOKE@@@Z			; FreeSmoke
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeSmoke@@YAXPAU_SMOKE@@@Z
_TEXT	SEGMENT
_smoke$ = 8						; size = 4
?FreeSmoke@@YAXPAU_SMOKE@@@Z PROC NEAR			; FreeSmoke, COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 123  : 
; 124  : // return if NULL ptr
; 125  : 
; 126  : 	if (!smoke)

	cmp	DWORD PTR _smoke$[ebp], 0
	jne	SHORT $L76872

; 127  : 	{
; 128  : 		return;

	jmp	SHORT $L76871
$L76872:

; 129  : 	}
; 130  : 
; 131  : // remove our smoke from used list
; 132  : 
; 133  : 	if (smoke->Prev)

	mov	eax, DWORD PTR _smoke$[ebp]
	cmp	DWORD PTR [eax+116], 0
	je	SHORT $L76873

; 134  : 	{
; 135  : 		smoke->Prev->Next = smoke->Next;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR [ecx+120], eax

; 136  : 	}
; 137  : 	else

	jmp	SHORT $L76874
$L76873:

; 138  : 	{
; 139  : 		UsedSmokeHead = smoke->Next;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _UsedSmokeHead, ecx
$L76874:

; 140  : 	}
; 141  : 
; 142  : 	if (smoke->Next)

	mov	eax, DWORD PTR _smoke$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $L76875

; 143  : 	{
; 144  : 		smoke->Next->Prev = smoke->Prev;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR [ecx+116], eax
$L76875:

; 145  : 	}
; 146  : 
; 147  : // add to free list
; 148  : 
; 149  : 	smoke->Prev = NULL;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [eax+116], 0

; 150  : 	smoke->Next = FreeSmokeHead;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _FreeSmokeHead
	mov	DWORD PTR [eax+120], ecx

; 151  : 	FreeSmokeHead = smoke;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR _FreeSmokeHead, eax

; 152  : 
; 153  : 	if (smoke->Next)

	mov	eax, DWORD PTR _smoke$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $L76876

; 154  : 	{
; 155  : 		smoke->Next->Prev = smoke;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [ecx+116], edx
$L76876:

; 156  : 	}
; 157  : 
; 158  : // dec used count
; 159  : 
; 160  : 	UsedSmokeCount--;

	mov	eax, DWORD PTR _UsedSmokeCount
	sub	eax, 1
	mov	DWORD PTR _UsedSmokeCount, eax
$L76871:

; 161  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeSmoke@@YAXPAU_SMOKE@@@Z ENDP			; FreeSmoke
_TEXT	ENDS
PUBLIC	?CreateSmoke@@YAJPAUVectorStruct@@0MMMMMJ@Z	; CreateSmoke
EXTRN	__fltused:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?CreateSmoke@@YAJPAUVectorStruct@@0MMMMMJ@Z
_TEXT	SEGMENT
_smoke$ = -4						; size = 4
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_size$ = 16						; size = 4
_growrate$ = 20						; size = 4
_age$ = 24						; size = 4
_spinstart$ = 28					; size = 4
_spinrate$ = 32						; size = 4
_rgb$ = 36						; size = 4
?CreateSmoke@@YAJPAUVectorStruct@@0MMMMMJ@Z PROC NEAR	; CreateSmoke, COMDAT

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 169  : 	SMOKE *smoke;
; 170  : 
; 171  : // alloc a smoke
; 172  : 
; 173  : 	smoke = AllocSmoke();

	call	?AllocSmoke@@YAPAU_SMOKE@@XZ		; AllocSmoke
	mov	DWORD PTR _smoke$[ebp], eax

; 174  : 	if (!smoke)

	cmp	DWORD PTR _smoke$[ebp], 0
	jne	SHORT $L76888

; 175  : 	{
; 176  : 		return FALSE;

	xor	eax, eax
	jmp	$L76886
$L76888:

; 177  : 	}
; 178  : 
; 179  : // setup smoke
; 180  : 
; 181  : 	smoke->Pos = *pos;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _smoke$[ebp]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 182  : 	smoke->Dir = *dir;

	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR _smoke$[ebp]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 183  : 	smoke->GrowRate = growrate;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _growrate$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 184  : 	smoke->AgeStart = smoke->Age = age;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _age$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	eax, DWORD PTR _age$[ebp]
	mov	DWORD PTR [edx], eax

; 185  : 	smoke->Spin = spinstart;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _spinstart$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 186  : 	smoke->SpinRate = spinrate;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _spinrate$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 187  : 
; 188  : // setup poly
; 189  : 
; 190  : 	smoke->Poly.Xsize = size;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+80], ecx

; 191  : 	smoke->Poly.Ysize = size;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 192  : 	smoke->Poly.U = 0.0f / 256.0f;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [eax+88], 0

; 193  : 	smoke->Poly.V = 0.0f / 256.0f;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [eax+92], 0

; 194  : 	smoke->Poly.Usize = 64.0f / 256.0f;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [eax+96], 1048576000		; 3e800000H

; 195  : 	smoke->Poly.Vsize = 64.0f / 256.0f;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	DWORD PTR [eax+100], 1048576000		; 3e800000H

; 196  : 	smoke->Poly.Tpage = TPAGE_FX1;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	WORD PTR [eax+104], 27			; 0000001bH

; 197  : 	smoke->rgb = rgb;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax+112], ecx

; 198  : 
; 199  : // return OK
; 200  : 
; 201  : 	return TRUE;

	mov	eax, 1
$L76886:

; 202  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateSmoke@@YAJPAUVectorStruct@@0MMMMMJ@Z ENDP	; CreateSmoke
_TEXT	ENDS
PUBLIC	?ProcessSmoke@@YAXXZ				; ProcessSmoke
PUBLIC	__real@00000000
PUBLIC	__real@42c80000
PUBLIC	__real@4b000000
EXTRN	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixZ
EXTRN	?TimeFactor@@3MA:DWORD				; TimeFactor
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ProcessSmoke@@YAXXZ
_TEXT	SEGMENT
__temp$76900 = -136					; size = 4
_smoketemp$ = -132					; size = 124
_smoke$ = -8						; size = 4
_per$ = -4						; size = 4
?ProcessSmoke@@YAXXZ PROC NEAR				; ProcessSmoke, COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi

; 210  : 	long per;
; 211  : 	SMOKE *smoke;
; 212  : 	SMOKE smoketemp;
; 213  : 
; 214  : // quit if none
; 215  : 
; 216  : 	if (!UsedSmokeCount)

	cmp	DWORD PTR _UsedSmokeCount, 0
	jne	SHORT $L76895

; 217  : 		return;

	jmp	$L76891
$L76895:

; 218  : 
; 219  : // loop thru all smokes
; 220  : 
; 221  : 	for (smoke = UsedSmokeHead ; smoke ; smoke = smoke->Next)

	mov	eax, DWORD PTR _UsedSmokeHead
	mov	DWORD PTR _smoke$[ebp], eax
	jmp	SHORT $L76896
$L76897:
	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _smoke$[ebp], ecx
$L76896:
	cmp	DWORD PTR _smoke$[ebp], 0
	je	$L76891

; 222  : 	{
; 223  : 
; 224  : // dec age
; 225  : 
; 226  : 		smoke->Age -= TimeFactor;

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	mov	ecx, DWORD PTR _smoke$[ebp]
	fstp	DWORD PTR [ecx+4]

; 227  : 		if (smoke->Age < 0)

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76899

; 228  : 		{
; 229  : 			smoketemp.Next = smoke->Next;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _smoketemp$[ebp+120], ecx

; 230  : 			FreeSmoke(smoke);

	mov	eax, DWORD PTR _smoke$[ebp]
	push	eax
	call	?FreeSmoke@@YAXPAU_SMOKE@@@Z		; FreeSmoke
	add	esp, 4

; 231  : 			smoke = &smoketemp;

	lea	eax, DWORD PTR _smoketemp$[ebp]
	mov	DWORD PTR _smoke$[ebp], eax

; 232  : 			continue;

	jmp	SHORT $L76897
$L76899:

; 233  : 		}
; 234  : 
; 235  : // rotate
; 236  : 
; 237  : 		smoke->Spin += smoke->SpinRate * TimeFactor;

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _smoke$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _smoke$[ebp]
	fstp	DWORD PTR [edx+8]

; 238  : 		RotMatrixZ(&smoke->Matrix, smoke->Spin);

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _smoke$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 239  : 
; 240  : // move
; 241  : 
; 242  : 		smoke->Pos.v[X] += smoke->Dir.v[X] * TimeFactor;

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _smoke$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _smoke$[ebp]
	fstp	DWORD PTR [edx+20]

; 243  : 		smoke->Pos.v[Y] += smoke->Dir.v[Y] * TimeFactor;

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _smoke$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _smoke$[ebp]
	fstp	DWORD PTR [edx+24]

; 244  : 		smoke->Pos.v[Z] += smoke->Dir.v[Z] * TimeFactor;

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _smoke$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _smoke$[ebp]
	fstp	DWORD PTR [edx+28]

; 245  : 
; 246  : // stretch
; 247  : 
; 248  : 		smoke->Poly.Xsize += smoke->GrowRate * TimeFactor;

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _smoke$[ebp]
	fadd	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _smoke$[ebp]
	fstp	DWORD PTR [edx+80]

; 249  : 		smoke->Poly.Ysize += smoke->GrowRate * TimeFactor;

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _smoke$[ebp]
	fadd	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _smoke$[ebp]
	fstp	DWORD PTR [edx+84]

; 250  : 
; 251  : // rgb
; 252  : 
; 253  : 		FTOL(smoke->Age * 100 / smoke->AgeStart, per);

	mov	eax, DWORD PTR _smoke$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _smoke$[ebp]
	fdiv	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$76900[ebp]
	mov	eax, DWORD PTR __temp$76900[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _per$[ebp], eax

; 254  : 		smoke->Poly.RGB = smoke->rgb;

	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR _smoke$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+108], edx

; 255  : 		ModelChangeGouraud((MODEL_RGB*)&smoke->Poly.RGB, per);

	cmp	DWORD PTR _per$[ebp], 100		; 00000064H
	je	SHORT $L76903
	mov	eax, DWORD PTR _smoke$[ebp]
	movzx	eax, BYTE PTR [eax+110]
	add	eax, 1
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	BYTE PTR [edx+110], al
	mov	eax, DWORD PTR _smoke$[ebp]
	movzx	eax, BYTE PTR [eax+109]
	add	eax, 1
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	BYTE PTR [edx+109], al
	mov	eax, DWORD PTR _smoke$[ebp]
	movzx	eax, BYTE PTR [eax+108]
	add	eax, 1
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _smoke$[ebp]
	mov	BYTE PTR [edx+108], al
$L76903:

; 256  : 	}

	jmp	$L76897
$L76891:

; 257  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessSmoke@@YAXXZ ENDP				; ProcessSmoke
_TEXT	ENDS
PUBLIC	?DrawSmoke@@YAXXZ				; DrawSmoke
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
EXTRN	?RenderStateChange@@3JA:DWORD			; RenderStateChange
EXTRN	?RenderAlpha@@3FA:WORD				; RenderAlpha
EXTRN	?RenderAlphaSrc@@3FA:WORD			; RenderAlphaSrc
EXTRN	?RenderAlphaDest@@3FA:WORD			; RenderAlphaDest
EXTRN	?RenderZwrite@@3FA:WORD				; RenderZwrite
EXTRN	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z:NEAR ; DrawFacingPolyRot
; Function compile flags: /Odt /ZI
;	COMDAT ?DrawSmoke@@YAXXZ
_TEXT	SEGMENT
_smoke$ = -4						; size = 4
?DrawSmoke@@YAXXZ PROC NEAR				; DrawSmoke, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 265  : 	SMOKE *smoke;
; 266  : 
; 267  : // quit if none
; 268  : 
; 269  : 	if (!UsedSmokeCount)

	cmp	DWORD PTR _UsedSmokeCount, 0
	jne	SHORT $L76914

; 270  : 		return;

	jmp	$L76912
$L76914:

; 271  : 
; 272  : // alpha on, z write off
; 273  : 
; 274  : 	ALPHA_ON();

	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	test	eax, eax
	jne	SHORT $L76915
	mov	WORD PTR ?RenderAlpha@@3FA, 1		; RenderAlpha
	movsx	eax, WORD PTR ?RenderAlpha@@3FA		; RenderAlpha
	push	eax
	push	27					; 0000001bH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L76915:

; 275  : 	ALPHA_SRC(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	cmp	eax, 2
	je	SHORT $L76916
	mov	WORD PTR ?RenderAlphaSrc@@3FA, 2	; RenderAlphaSrc
	movsx	eax, WORD PTR ?RenderAlphaSrc@@3FA	; RenderAlphaSrc
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L76916:

; 276  : 	ALPHA_DEST(D3DBLEND_ONE);

	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	cmp	eax, 2
	je	SHORT $L76917
	mov	WORD PTR ?RenderAlphaDest@@3FA, 2	; RenderAlphaDest
	movsx	eax, WORD PTR ?RenderAlphaDest@@3FA	; RenderAlphaDest
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L76917:

; 277  : 
; 278  : 	ZWRITE_OFF();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	je	SHORT $L76918
	mov	WORD PTR ?RenderZwrite@@3FA, 0		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L76918:

; 279  : 
; 280  : // loop thru all smokes
; 281  : 
; 282  : 	for (smoke = UsedSmokeHead ; smoke ; smoke = smoke->Next)

	mov	eax, DWORD PTR _UsedSmokeHead
	mov	DWORD PTR _smoke$[ebp], eax
	jmp	SHORT $L76919
$L76920:
	mov	eax, DWORD PTR _smoke$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _smoke$[ebp], ecx
$L76919:
	cmp	DWORD PTR _smoke$[ebp], 0
	je	SHORT $L76912

; 283  : 	{
; 284  : 		DrawFacingPolyRot(&smoke->Pos, &smoke->Matrix, &smoke->Poly, -1, 0.0f);

	push	0
	push	-1
	mov	eax, DWORD PTR _smoke$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _smoke$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _smoke$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?DrawFacingPolyRot@@YAXPAUVectorStruct@@PATMatrixUnion@@PAUFACING_POLY@@JM@Z ; DrawFacingPolyRot
	add	esp, 20					; 00000014H

; 285  : 	}

	jmp	SHORT $L76920
$L76912:

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawSmoke@@YAXXZ ENDP					; DrawSmoke
_TEXT	ENDS
END
