; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\ACM_Simplex..cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exp@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TestL1Solver@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z		; L1
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@c0000000
PUBLIC	__real@40000000
PUBLIC	__real@3f000000
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@00000000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\acm_simplex..cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z
_TEXT	SEGMENT
tv571 = -156						; size = 4
tv495 = -156						; size = 4
tv194 = -156						; size = 4
tv174 = -156						; size = 4
_big$ = -88						; size = 4
_test$ = -82						; size = 1
_stage$ = -81						; size = 1
_pivot$ = -80						; size = 4
_d$ = -76						; size = 4
_max$ = -72						; size = 4
_min$ = -68						; size = 4
_sum$ = -64						; size = 4
_in$ = -60						; size = 4
_kl$ = -56						; size = 4
_kr$ = -52						; size = 4
_kount$ = -48						; size = 4
_l$ = -44						; size = 4
_k$ = -40						; size = 4
_j$ = -36						; size = 4
_i$ = -32						; size = 4
_out$ = -28						; size = 4
_n2$ = -24						; size = 4
_n1$ = -20						; size = 4
_n$ = -16						; size = 4
_m2$ = -12						; size = 4
_m1$ = -8						; size = 4
_m$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_toler$ = 16						; size = 4
_x$ = 20						; size = 4
_e$ = 24						; size = 4
_s$ = 28						; size = 4
?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z PROC NEAR	; L1, COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi

; 48   : 	int		m, m1, m2, n, n1, n2, out, i, j, k, l, kount, kr, kl, in;
; 49   : 	REAL	sum;
; 50   : 	REAL	min, max, d, pivot;
; 51   : 	bool	stage, test;
; 52   : 
; 53   : 	// big must be set equal to any very large real constant.
; 54   :     const REAL big = 1.0e7f;

	mov	DWORD PTR _big$[ebp], 1259902592	; 4b189680H

; 55   : 	
; 56   : 	m = NRows(a);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4096]
	mov	DWORD PTR _m$[ebp], ecx

; 57   : 	n = NCols(a);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4100]
	mov	DWORD PTR _n$[ebp], ecx

; 58   : 
; 59   : 
; 60   : 	// initialization.
; 61   : 	m1 = m + 1;

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m1$[ebp], eax

; 62   : 	n1 = n + 1;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n1$[ebp], eax

; 63   : 	m2 = m + 2;

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 2
	mov	DWORD PTR _m2$[ebp], eax

; 64   : 	n2 = n + 2;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 2
	mov	DWORD PTR _n2$[ebp], eax

; 65   : 	
; 66   : 	for (j = 0; j < n; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L74865
$L74866:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74865:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $L74867

; 67   : 		a->m[m1][j] = (REAL)j;

	fild	DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _m1$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 68   :         x->v[j] = ZERO;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 69   : 	}

	jmp	SHORT $L74866
$L74867:

; 70   : 	for (i = 0; i < m; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74869
$L74870:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74869:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m$[ebp]
	jge	$L74871

; 71   :         a->m[i][n1] = (REAL)(n + i + 1);		// possible error (probably not)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR tv571[ebp], edx
	fild	DWORD PTR tv571[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 72   : 		a->m[i][n] = b->v[i];				

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx

; 73   : 		if (b->v[i] < ZERO) {

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L74873

; 74   : 			for (j = 0; j < n2; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L74874
$L74875:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74874:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n2$[ebp]
	jge	SHORT $L74873

; 75   : 				a->m[i][j] = -a->m[i][j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fchs
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 76   : 			}

	jmp	SHORT $L74875
$L74873:

; 77   : 		}
; 78   : 		e->v[i] = ZERO;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 79   : 	}

	jmp	$L74870
$L74871:

; 80   : 
; 81   : 	// compute the marginal costs.
; 82   : 	for (j = 0; j < n1; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L74877
$L74878:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74877:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n1$[ebp]
	jge	SHORT $L74879

; 83   : 		sum = ZERO;

	mov	DWORD PTR _sum$[ebp], 0

; 84   : 		for (i = 0; i < m; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74880
$L74881:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74880:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m$[ebp]
	jge	SHORT $L74882

; 85   : 			sum += a->m[i][j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR _sum$[ebp]
	fadd	DWORD PTR [eax+ecx*4]
	fstp	DWORD PTR _sum$[ebp]

; 86   : 		}

	jmp	SHORT $L74881
$L74882:

; 87   :         a->m[m][j] = sum;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _sum$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 88   : 	}

	jmp	SHORT $L74878
$L74879:

; 89   : 
; 90   : 	// stage i.
; 91   : 	// determine the vector to enter the basis.
; 92   : 	stage = TRUE;

	mov	BYTE PTR _stage$[ebp], 1

; 93   : 	test = FALSE;

	mov	BYTE PTR _test$[ebp], 0

; 94   : 	kount = -1;						// possible error

	mov	DWORD PTR _kount$[ebp], -1

; 95   : 	kr = 0;

	mov	DWORD PTR _kr$[ebp], 0

; 96   : 	kl = 0;

	mov	DWORD PTR _kl$[ebp], 0
$l70$74883:

; 97   : 
; 98   : l70:
; 99   : 	max = -ONE;

	mov	DWORD PTR _max$[ebp], -1082130432	; bf800000H

; 100  : 	for (j = kr; j < n; j++) {

	mov	eax, DWORD PTR _kr$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L74884
$L74885:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74884:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$L74886

; 101  : 		if (abs(a->m[m1][j]) <= (REAL)n) {

	mov	eax, DWORD PTR _m1$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L75125
	mov	edx, DWORD PTR _m1$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv174[ebp]
	jmp	SHORT $L75126
$L75125:
	mov	ecx, DWORD PTR _m1$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv174[ebp]
$L75126:
	fild	DWORD PTR _n$[ebp]
	fcomp	DWORD PTR tv174[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L74888

; 102  : 			d = abs(a->m[m][j]);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L75127
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv194[ebp]
	jmp	SHORT $L75128
$L75127:
	mov	ecx, DWORD PTR _m$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv194[ebp]
$L75128:
	mov	eax, DWORD PTR tv194[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 103  : 			if (d > max) {

	fld	DWORD PTR _d$[ebp]
	fcomp	DWORD PTR _max$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L74888

; 104  : 				max = d;

	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _max$[ebp], eax

; 105  : 				in = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _in$[ebp], eax
$L74888:

; 106  : 			}
; 107  : 		}
; 108  : 	}

	jmp	$L74885
$L74886:

; 109  : 	if (a->m[m][in] < ZERO) {

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $l100$74894

; 110  : 		for (i=0; i < m2; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74891
$L74892:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74891:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m2$[ebp]
	jge	SHORT $l100$74894

; 111  : 			a->m[i][in] = -a->m[i][in];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fchs
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 112  : 		}

	jmp	SHORT $L74892
$l100$74894:

; 113  : 	}
; 114  : 
; 115  : 	// determine the vector to leave the basis.
; 116  : l100:
; 117  : 	k = -1;

	mov	DWORD PTR _k$[ebp], -1

; 118  : 	for (i = kl; i < m; i++) {

	mov	eax, DWORD PTR _kl$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L74895
$L74896:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74895:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m$[ebp]
	jge	SHORT $l120$74899

; 119  : 		d = a->m[i][in];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 120  : 		if (d > toler) {

	fld	DWORD PTR _d$[ebp]
	fcomp	DWORD PTR _toler$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L74898

; 121  : 			k++;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 122  : 			b->v[k] = a->m[i][n1] / d;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fdiv	DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [eax+edx*4]

; 123  : 			s[k] = i;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 124  : 			test = TRUE;

	mov	BYTE PTR _test$[ebp], 1
$L74898:

; 125  : 		}
; 126  : 	}

	jmp	SHORT $L74896
$l120$74899:

; 127  : l120:
; 128  : 	if (k >= 0) {

	cmp	DWORD PTR _k$[ebp], 0
	jl	$L74900

; 129  : 		min = big;

	mov	eax, DWORD PTR _big$[ebp]
	mov	DWORD PTR _min$[ebp], eax

; 130  : 		for (i = 0; i <= k; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74901
$L74902:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74901:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jg	SHORT $L74903

; 131  : 			if (b->v[i] < min) {

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fcomp	DWORD PTR _min$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L74904

; 132  : 				j = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax

; 133  : 				min = b->v[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _min$[ebp], edx

; 134  : 				out = s[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _out$[ebp], edx
$L74904:

; 135  : 			}
; 136  : 		}

	jmp	SHORT $L74902
$L74903:

; 137  : 		b->v[j] = b->v[k];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 138  : 		s[j] = s[k];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 139  : 		k = k - 1;			//possible problem

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $L74905
$L74900:

; 140  : 	} else {
; 141  : 		test = FALSE;

	mov	BYTE PTR _test$[ebp], 0
$L74905:

; 142  : 	}
; 143  : 
; 144  : 	// check for linear dependence in stage i.
; 145  : 	if (!(test || !stage)) {

	movzx	eax, BYTE PTR _test$[ebp]
	test	eax, eax
	jne	SHORT $L74906
	movzx	eax, BYTE PTR _stage$[ebp]
	test	eax, eax
	je	SHORT $L74906

; 146  : 		for (i = 0; i < m2; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74907
$L74908:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74907:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m2$[ebp]
	jge	SHORT $L74909

; 147  : 			d = a->m[i][kr];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _kr$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 148  : 			a->m[i][kr] = a->m[i][in];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _kr$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 149  : 			a->m[i][in] = d;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 150  : 		}

	jmp	SHORT $L74908
$L74909:

; 151  : 		kr++;					// possible problem

	mov	eax, DWORD PTR _kr$[ebp]
	add	eax, 1
	mov	DWORD PTR _kr$[ebp], eax
	jmp	$l260$74910
$L74906:

; 152  : 		goto l260;
; 153  : 	}
; 154  : 	if (!test) {

	movzx	eax, BYTE PTR _test$[ebp]
	test	eax, eax
	jne	SHORT $L74912

; 155  : 		a->m[m1][n] = Real(2);

	mov	eax, DWORD PTR _m1$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1073741824	; 40000000H

; 156  : 		goto l350;

	jmp	$l350$74914
$L74912:

; 157  : 	}
; 158  : 	pivot = a->m[out][in];

	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pivot$[ebp], edx

; 159  : 	if (a->m[m][in] - pivot - pivot > toler) {

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fsub	DWORD PTR _pivot$[ebp]
	fsub	DWORD PTR _pivot$[ebp]
	fcomp	DWORD PTR _toler$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L74916

; 160  : 		for (j = kr; j < n1; j++) {

	mov	eax, DWORD PTR _kr$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L74917
$L74918:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74917:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n1$[ebp]
	jge	SHORT $L74919

; 161  : 			d = a->m[out][j];

	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 162  : 			a->m[m][j] = a->m[m][j] - d - d;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fsub	DWORD PTR _d$[ebp]
	fsub	DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 163  : 			a->m[out][j] = -d;

	fld	DWORD PTR _d$[ebp]
	fchs
	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 164  : 		}

	jmp	SHORT $L74918
$L74919:

; 165  : 		a->m[out][n1] = -a->m[out][n1];

	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fchs
	mov	edx, DWORD PTR _out$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _n1$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 166  : 		goto l120;

	jmp	$l120$74899
$L74916:

; 167  : 	}
; 168  : 
; 169  : 	// pivot on a(out,in).
; 170  : 	for (j = kr; j < n1; j++) {

	mov	eax, DWORD PTR _kr$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L74920
$L74921:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74920:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n1$[ebp]
	jge	SHORT $L74922

; 171  : 		if (j != in) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _in$[ebp]
	je	SHORT $L74923

; 172  : 			a->m[out][j] = a->m[out][j] / pivot;

	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fdiv	DWORD PTR _pivot$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fstp	DWORD PTR [edx+eax*4]
$L74923:

; 173  : 		}
; 174  : 	}

	jmp	SHORT $L74921
$L74922:

; 175  : 	for (i = 0; i < m1; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74924
$L74925:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74924:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m1$[ebp]
	jge	SHORT $L74926

; 176  : 		if (i != out) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _out$[ebp]
	je	SHORT $L74927

; 177  : 			d = a->m[i][in];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 178  : 			for (j = kr; j < n1; j++) {

	mov	eax, DWORD PTR _kr$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L74928
$L74929:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74928:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n1$[ebp]
	jge	SHORT $L74927

; 179  : 				if (j != in) {

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _in$[ebp]
	je	SHORT $L74931

; 180  : 					a->m[i][j] -= d * a->m[out][j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR _d$[ebp]
	fmul	DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	fsubr	DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fstp	DWORD PTR [edx+eax*4]
$L74931:

; 181  : 				}
; 182  : 			}

	jmp	SHORT $L74929
$L74927:

; 183  : 		}
; 184  : 	}

	jmp	SHORT $L74925
$L74926:

; 185  : 	for (i = 0; i < m1; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74932
$L74933:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74932:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m1$[ebp]
	jge	SHORT $L74934

; 186  : 		if (i != out) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _out$[ebp]
	je	SHORT $L74935

; 187  : 			a->m[i][in] = -a->m[i][in] / pivot;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fchs
	fdiv	DWORD PTR _pivot$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	fstp	DWORD PTR [edx+eax*4]
$L74935:

; 188  : 		}
; 189  : 	}

	jmp	SHORT $L74933
$L74934:

; 190  : 	a->m[out][in] = ONE / pivot;

	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _pivot$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 191  : 	d = a->m[out][n1];

	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 192  : 	a->m[out][n1] = a->m[m1][in];

	mov	eax, DWORD PTR _m1$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _n1$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 193  : 	a->m[m1][in] = d;

	mov	eax, DWORD PTR _m1$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 194  : 	kount++;						// possible error

	mov	eax, DWORD PTR _kount$[ebp]
	add	eax, 1
	mov	DWORD PTR _kount$[ebp], eax

; 195  : 	if (stage) {

	movzx	eax, BYTE PTR _stage$[ebp]
	test	eax, eax
	je	SHORT $L74936

; 196  : 	// interchange rows in stage i.
; 197  : 		kl++;

	mov	eax, DWORD PTR _kl$[ebp]
	add	eax, 1
	mov	DWORD PTR _kl$[ebp], eax

; 198  : 		for (j = kr; j < n2; j++) {

	mov	eax, DWORD PTR _kr$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L74937
$L74938:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74937:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n2$[ebp]
	jge	SHORT $l260$74910

; 199  : 			d = a->m[out][j];

	mov	eax, DWORD PTR _out$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 200  : 			a->m[out][j] = a->m[kount][j];

	mov	eax, DWORD PTR _kount$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 201  : 			a->m[kount][j] = d;

	mov	eax, DWORD PTR _kount$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 202  : 		}

	jmp	SHORT $L74938
$l260$74910:

; 203  : l260:
; 204  : 		if (kount + kr != n1 - 2) goto l70;		// possible error

	mov	eax, DWORD PTR _kount$[ebp]
	add	eax, DWORD PTR _kr$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	sub	ecx, 2
	cmp	eax, ecx
	je	SHORT $L74940
	jmp	$l70$74883
$L74940:

; 205  : 		// stage ii.
; 206  : 		stage = FALSE;

	mov	BYTE PTR _stage$[ebp], 0
$L74936:

; 207  : 	}
; 208  : 	
; 209  : 	// determine the vector to enter the basis.
; 210  : 	max = -big;

	fld	DWORD PTR _big$[ebp]
	fchs
	fstp	DWORD PTR _max$[ebp]

; 211  : 	for (j = kr; j < n; j++) {

	mov	eax, DWORD PTR _kr$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L74941
$L74942:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74941:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $l290$74949

; 212  : 		d = a->m[m][j];

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 213  : 		if (d >= ZERO) goto l280;

	fld	DWORD PTR _d$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L74944
	jmp	SHORT $l280$74945
$L74944:

; 214  : 		if (d > Real(-2)) goto l290;

	fld	DWORD PTR _d$[ebp]
	fcomp	DWORD PTR __real@c0000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L74948
	jmp	SHORT $l290$74949
$L74948:

; 215  :         d = - (d + Real(2));

	fld	DWORD PTR _d$[ebp]
	fadd	DWORD PTR __real@40000000
	fchs
	fstp	DWORD PTR _d$[ebp]
$l280$74945:

; 216  : l280:
; 217  : 		if (d <= max) goto l290;

	fld	DWORD PTR _d$[ebp]
	fcomp	DWORD PTR _max$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L74952
	jmp	SHORT $l290$74949
$L74952:

; 218  : 		max = d;

	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _max$[ebp], eax

; 219  : 		in = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _in$[ebp], eax

; 220  : 	}

	jmp	SHORT $L74942
$l290$74949:

; 221  : l290:
; 222  : 	if (max > toler) {

	fld	DWORD PTR _max$[ebp]
	fcomp	DWORD PTR _toler$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L74954

; 223  : 		if (a->m[m][in] <= ZERO) {

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L74955

; 224  : 			for (i = 0; i < m2; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74956
$L74957:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74956:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m2$[ebp]
	jge	SHORT $L74958

; 225  : 				a->m[i][in] = -a->m[i][in];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fchs
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 226  : 			}

	jmp	SHORT $L74957
$L74958:

; 227  : 			a->m[m][in] = a->m[m][in] - Real(2);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fsub	DWORD PTR __real@40000000
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	fstp	DWORD PTR [edx+eax*4]
$L74955:

; 228  : 		}
; 229  : 		goto l100;

	jmp	$l100$74894
$L74954:

; 230  : 	}
; 231  : 
; 232  : 	//prepare output.
; 233  : 	l = kl - 1;				// possible error

	mov	eax, DWORD PTR _kl$[ebp]
	sub	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 234  : 	for (i = 0; i < l; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74960
$L74961:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74960:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	jge	SHORT $L74962

; 235  : 		if (a->m[i][n] < ZERO) {

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L74963

; 236  : 			for (j = kr; j < n2; j++) {

	mov	eax, DWORD PTR _kr$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L74964
$L74965:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74964:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n2$[ebp]
	jge	SHORT $L74963

; 237  : 				a->m[i][j] = -a->m[i][j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fchs
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 238  : 			}

	jmp	SHORT $L74965
$L74963:

; 239  : 		}
; 240  : 	}

	jmp	SHORT $L74961
$L74962:

; 241  : 	a->m[m1][n] = ZERO;

	mov	eax, DWORD PTR _m1$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 242  : 	if (kr == 1) {

	cmp	DWORD PTR _kr$[ebp], 1
	jne	$l350$74914

; 243  : 		for (j = 0; j < n; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L74968
$L74969:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L74968:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$L74970

; 244  : 			d = abs(a->m[m][j]);

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L75129
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv495[ebp]
	jmp	SHORT $L75130
$L75129:
	mov	ecx, DWORD PTR _m$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv495[ebp]
$L75130:
	mov	eax, DWORD PTR tv495[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 245  : 			if ((d <= toler) || (Real(2 - d) <= toler)) goto l350;

	fld	DWORD PTR _d$[ebp]
	fcomp	DWORD PTR _toler$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $L74973
	fld	DWORD PTR __real@40000000
	fsub	DWORD PTR _d$[ebp]
	fmul	DWORD PTR __real@3f800000
	fcomp	DWORD PTR _toler$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L74972
$L74973:
	jmp	SHORT $l350$74914
$L74972:

; 246  : 		}

	jmp	$L74969
$L74970:

; 247  : 		a->m[m][n1] = ONE;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1065353216	; 3f800000H
$l350$74914:

; 248  : 	}
; 249  : l350:
; 250  : 	for (i = 0; i < m; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L74975
$L74976:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74975:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m$[ebp]
	jge	SHORT $L74977

; 251  : 		k = NearestInt(a->m[i][n1]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	mov	DWORD PTR _k$[ebp], eax

; 252  : 		d = a->m[i][n];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _d$[ebp], edx

; 253  : 		if (k <= 0) {

	cmp	DWORD PTR _k$[ebp], 0
	jg	SHORT $L74979

; 254  : 			k = -k;

	mov	eax, DWORD PTR _k$[ebp]
	neg	eax
	mov	DWORD PTR _k$[ebp], eax

; 255  : 			d = -d;

	fld	DWORD PTR _d$[ebp]
	fchs
	fstp	DWORD PTR _d$[ebp]
$L74979:

; 256  : 		}
; 257  : 		if (i < kl) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _kl$[ebp]
	jge	SHORT $L74980

; 258  : 			x->v[k] = d;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 259  : 		} else {

	jmp	SHORT $L74981
$L74980:

; 260  : 			k = k - n;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 261  : 			e->v[k] = d;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$L74981:

; 262  : 		}
; 263  : 	}

	jmp	$L74976
$L74977:

; 264  : 	a->m[m1][n1] = (REAL)kount;

	fild	DWORD PTR _kount$[ebp]
	mov	eax, DWORD PTR _m1$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 265  : 	a->m[m][n1] = (REAL)n1 - kr;

	fild	DWORD PTR _n1$[ebp]
	fisub	DWORD PTR _kr$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n1$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 266  : 	sum = ZERO;

	mov	DWORD PTR _sum$[ebp], 0

; 267  : 	for (i = kl; i < m; i++) {

	mov	eax, DWORD PTR _kl$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L74984
$L74985:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L74984:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _m$[ebp]
	jge	SHORT $L74986

; 268  : 		sum += a->m[i][n];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	fld	DWORD PTR _sum$[ebp]
	fadd	DWORD PTR [eax+ecx*4]
	fstp	DWORD PTR _sum$[ebp]

; 269  : 	}

	jmp	SHORT $L74985
$L74986:

; 270  : 	a->m[m][n] = sum;

	mov	eax, DWORD PTR _m$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _sum$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 271  : 
; 272  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z ENDP		; L1
_TEXT	ENDS
PUBLIC	?exp@@YAMM@Z					; exp
PUBLIC	?pow@@YAMMH@Z					; pow
PUBLIC	?TestL1Solver@@YAXXZ				; TestL1Solver
PUBLIC	__real@3e800000
PUBLIC	__real@41000000
EXTRN	?ClearBigMat@@YAXPAUBIGMAT@@@Z:NEAR		; ClearBigMat
EXTRN	?ClearBigVec@@YAXPAUBIGVEC@@@Z:NEAR		; ClearBigVec
EXTRN	?CopyBigMat@@YAXPAUBIGMAT@@0@Z:NEAR		; CopyBigMat
EXTRN	?CopyBigVec@@YAXPAUBIGVEC@@0@Z:NEAR		; CopyBigVec
EXTRN	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z:NEAR ; SolveLinearEquations
_BSS	SEGMENT
_Coef	DB	01008H DUP (?)
_OrigCoef DB	01008H DUP (?)
_Res	DB	084H DUP (?)
_NewRes	DB	084H DUP (?)
_OrigRes DB	084H DUP (?)
_Soln	DB	084H DUP (?)
_Work	DD	020H DUP (?)
_OrigRow DD	020H DUP (?)
_OrigCol DD	020H DUP (?)
_BSS	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?TestL1Solver@@YAXXZ
_TEXT	SEGMENT
tv383 = -80						; size = 4
tv374 = -80						; size = 4
tv340 = -80						; size = 4
_xx$ = -12						; size = 4
_kk$ = -8						; size = 4
_ii$ = -4						; size = 4
?TestL1Solver@@YAXXZ PROC NEAR				; TestL1Solver, COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 291  : 	int		ii, kk;
; 292  : 	REAL	xx;
; 293  : 
; 294  : 	/////////////////////////////////////////////////////////////////////
; 295  : 	// Test 1: Simple solution
; 296  : 	//
; 297  : 	SetBigMatSize(&Coef, 4, 4);

	mov	DWORD PTR _Coef+4096, 4
	mov	DWORD PTR _Coef+4100, 4

; 298  : 	SetBigVecSize(&Res, 4);

	mov	DWORD PTR _Res+128, 4

; 299  : 
; 300  : 	Coef.m[0][0] = 1.0f;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 301  : 	Coef.m[0][1] = 0.0f;

	mov	DWORD PTR _Coef+4, 0

; 302  : 	Coef.m[0][2] = 1.0f;

	mov	DWORD PTR _Coef+8, 1065353216		; 3f800000H

; 303  : 	Coef.m[0][3] = 0.0f;

	mov	DWORD PTR _Coef+12, 0

; 304  : 
; 305  : 	Coef.m[1][0] = 1.0f;

	mov	DWORD PTR _Coef+128, 1065353216		; 3f800000H

; 306  : 	Coef.m[1][1] = 0.0f;

	mov	DWORD PTR _Coef+132, 0

; 307  : 	Coef.m[1][2] = 1.0f;

	mov	DWORD PTR _Coef+136, 1065353216		; 3f800000H

; 308  : 	Coef.m[1][3] = 0.0f;

	mov	DWORD PTR _Coef+140, 0

; 309  : 
; 310  : 	Coef.m[2][0] = 0.0f;

	mov	DWORD PTR _Coef+256, 0

; 311  : 	Coef.m[2][1] = 1.0f;

	mov	DWORD PTR _Coef+260, 1065353216		; 3f800000H

; 312  : 	Coef.m[2][2] = 0.0f;

	mov	DWORD PTR _Coef+264, 0

; 313  : 	Coef.m[2][3] = 1.0f;

	mov	DWORD PTR _Coef+268, 1065353216		; 3f800000H

; 314  : 
; 315  : 	Coef.m[3][0] = 0.0f;

	mov	DWORD PTR _Coef+384, 0

; 316  : 	Coef.m[3][1] = 1.0f;

	mov	DWORD PTR _Coef+388, 1065353216		; 3f800000H

; 317  : 	Coef.m[3][2] = 1.0f;

	mov	DWORD PTR _Coef+392, 1065353216		; 3f800000H

; 318  : 	Coef.m[3][3] = 1.0f;

	mov	DWORD PTR _Coef+396, 1065353216		; 3f800000H

; 319  : 
; 320  : 	Res.v[0] = 2.0f;

	mov	DWORD PTR _Res, 1073741824		; 40000000H

; 321  : 	Res.v[1] = 2.0f;

	mov	DWORD PTR _Res+4, 1073741824		; 40000000H

; 322  : 	Res.v[2] = 2.0f;

	mov	DWORD PTR _Res+8, 1073741824		; 40000000H

; 323  : 	Res.v[3] = 2.0f;

	mov	DWORD PTR _Res+12, 1073741824		; 40000000H

; 324  : 
; 325  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 326  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 327  : 
; 328  : 	L1(&Coef, &Res, 0.0001f, &Soln, &NewRes, Work);

	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z	; L1
	add	esp, 24					; 00000018H

; 329  : 	SolveLinearEquations(&OrigCoef, &OrigRes, 0.0001f, 0.0001f, OrigRow, OrigCol, &NewRes, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_OrigCoef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 330  : 
; 331  : 	/////////////////////////////////////////////////////////////////////
; 332  : 	// Test 2:
; 333  : 	//
; 334  : 	SetBigMatSize(&Coef, 2, 2);

	mov	DWORD PTR _Coef+4096, 2
	mov	DWORD PTR _Coef+4100, 2

; 335  : 	SetBigVecSize(&Res, 2);

	mov	DWORD PTR _Res+128, 2

; 336  : 
; 337  : 	Coef.m[0][0] = 1.0f;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 338  : 	Coef.m[0][1] = 0.0f;

	mov	DWORD PTR _Coef+4, 0

; 339  : 	Coef.m[1][0] = 1.01f;

	mov	DWORD PTR _Coef+128, 1065437102		; 3f8147aeH

; 340  : 	Coef.m[1][1] = 0.0f;

	mov	DWORD PTR _Coef+132, 0

; 341  : 
; 342  : 	Res.v[0] = 2.0f;

	mov	DWORD PTR _Res, 1073741824		; 40000000H

; 343  : 	Res.v[1] = 1.0f;

	mov	DWORD PTR _Res+4, 1065353216		; 3f800000H

; 344  : 
; 345  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 346  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 347  : 
; 348  : 	L1(&Coef, &Res, 0.0001f, &Soln, &NewRes, Work);

	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z	; L1
	add	esp, 24					; 00000018H

; 349  : 	SolveLinearEquations(&OrigCoef, &OrigRes, 0.0001f, 0.0001f, OrigRow, OrigCol, &NewRes, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_OrigCoef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 350  : 
; 351  : 
; 352  : 	/////////////////////////////////////////////////////////////////////
; 353  : 	// Test 3:
; 354  : 	//
; 355  : 	SetBigMatSize(&Coef, 5, 5);

	mov	DWORD PTR _Coef+4096, 5
	mov	DWORD PTR _Coef+4100, 5

; 356  : 	SetBigVecSize(&Res, 5);

	mov	DWORD PTR _Res+128, 5

; 357  : 	SetBigVecSize(&Soln, 5);

	mov	DWORD PTR _Soln+128, 5

; 358  : 	for (ii = 0; ii < NRows(&Coef); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L75001
$L75002:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L75001:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	SHORT $L75003

; 359  : 		xx = (ii + 1) * Real(0.25);

	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR tv340[ebp], eax
	fild	DWORD PTR tv340[ebp]
	fmul	DWORD PTR __real@3e800000
	fstp	DWORD PTR _xx$[ebp]

; 360  : 		for (kk = 0; kk < NRows(&Coef); kk++) {

	mov	DWORD PTR _kk$[ebp], 0
	jmp	SHORT $L75005
$L75006:
	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _kk$[ebp], eax
$L75005:
	mov	eax, DWORD PTR _kk$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	SHORT $L75007

; 361  : 			Coef.m[ii][kk] = (REAL)pow(xx, kk + 1);

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _kk$[ebp]
	fstp	DWORD PTR _Coef[edx+eax*4]

; 362  : 		}

	jmp	SHORT $L75006
$L75007:

; 363  : 		Res.v[ii] = xx * (REAL)exp(-xx);

	fld	DWORD PTR _xx$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fmul	DWORD PTR _xx$[ebp]
	mov	eax, DWORD PTR _ii$[ebp]
	fstp	DWORD PTR _Res[eax*4]

; 364  : 	}

	jmp	$L75002
$L75003:

; 365  : 
; 366  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 367  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 368  : 
; 369  : 	L1(&Coef, &Res, 0.0001f, &Soln, &NewRes, Work);

	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z	; L1
	add	esp, 24					; 00000018H

; 370  : 	SolveLinearEquations(&OrigCoef, &OrigRes, 0.0001f, 0.0001f, OrigRow, OrigCol, &NewRes, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_OrigCoef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 371  : 
; 372  : 	/////////////////////////////////////////////////////////////////////
; 373  : 	// Test 4: 
; 374  : 	//
; 375  : 	SetBigMatSize(&Coef, 9, 9);

	mov	DWORD PTR _Coef+4096, 9
	mov	DWORD PTR _Coef+4100, 9

; 376  : 	SetBigVecSize(&Res, 9);

	mov	DWORD PTR _Res+128, 9

; 377  : 	SetBigVecSize(&Soln, 9);

	mov	DWORD PTR _Soln+128, 9

; 378  : 	ClearBigMat(&Coef);

	push	OFFSET FLAT:_Coef
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 379  : 	ClearBigVec(&Res);

	push	OFFSET FLAT:_Res
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 380  : 
; 381  : 	for (ii = 0; ii < NRows(&Coef); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L75010
$L75011:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L75010:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	$L75012

; 382  : 		xx = ii / Real(8.0);

	fild	DWORD PTR _ii$[ebp]
	fdiv	DWORD PTR __real@41000000
	fstp	DWORD PTR _xx$[ebp]

; 383  : 		Coef.m[ii][0] = ONE;

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	mov	DWORD PTR _Coef[eax], 1065353216	; 3f800000H

; 384  : 		Coef.m[ii][1] = xx;

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _xx$[ebp]
	mov	DWORD PTR _Coef[eax+4], ecx

; 385  : 		Coef.m[ii][2] = xx - ONE;

	fld	DWORD PTR _xx$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	fstp	DWORD PTR _Coef[eax+8]

; 386  : 		Coef.m[ii][3] = (REAL)pow(xx, 2);

	push	2
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+12]

; 387  : 		Coef.m[ii][4] = (REAL)pow(xx, 2) - xx;

	push	2
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsub	DWORD PTR _xx$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+16]

; 388  : 		Coef.m[ii][5] = (REAL)pow(xx, 3);

	push	3
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+20]

; 389  : 		Coef.m[ii][6] = (REAL)pow(xx, 3) - (REAL)pow(xx, 2);

	push	3
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	fstp	DWORD PTR tv374[ebp]
	add	esp, 8
	push	2
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsubr	DWORD PTR tv374[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	fstp	DWORD PTR _Coef[edx+24]

; 390  : 		Coef.m[ii][7] = (REAL)pow(xx, 4);

	push	4
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+28]

; 391  : 		Coef.m[ii][8] = (REAL)pow(xx, 4) - (REAL)pow(xx, 3);

	push	4
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	fstp	DWORD PTR tv383[ebp]
	add	esp, 8
	push	3
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsubr	DWORD PTR tv383[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	fstp	DWORD PTR _Coef[edx+32]

; 392  : 		Res.v[ii] = (REAL)exp(xx);

	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	mov	ecx, DWORD PTR _ii$[ebp]
	fstp	DWORD PTR _Res[ecx*4]

; 393  : 	}

	jmp	$L75011
$L75012:

; 394  : 
; 395  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 396  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 397  : 
; 398  : 	L1(&Coef, &Res, 0.0001f, &Soln, &NewRes, Work);

	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z	; L1
	add	esp, 24					; 00000018H

; 399  : 	SolveLinearEquations(&OrigCoef, &OrigRes, 0.0001f, 0.0001f, OrigRow, OrigCol, &NewRes, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_OrigCoef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 400  : 
; 401  : 	/////////////////////////////////////////////////////////////////////
; 402  : 	// Test 5: 
; 403  : 	//
; 404  : 	SetBigMatSize(&Coef, 2, 2);

	mov	DWORD PTR _Coef+4096, 2
	mov	DWORD PTR _Coef+4100, 2

; 405  : 	SetBigVecSize(&Res, 2);

	mov	DWORD PTR _Res+128, 2

; 406  : 	SetBigVecSize(&Soln, 2);

	mov	DWORD PTR _Soln+128, 2

; 407  : 	ClearBigMat(&Coef);

	push	OFFSET FLAT:_Coef
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 408  : 	ClearBigVec(&Res);

	push	OFFSET FLAT:_Res
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 409  : 
; 410  : 	Coef.m[0][0] = ONE;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 411  : 	Coef.m[0][1] = ZERO;

	mov	DWORD PTR _Coef+4, 0

; 412  : 	Coef.m[1][0] = ZERO;

	mov	DWORD PTR _Coef+128, 0

; 413  : 	Coef.m[1][1] = 0.00001f;

	mov	DWORD PTR _Coef+132, 925353388		; 3727c5acH

; 414  : 	Res.v[0] = ONE;

	mov	DWORD PTR _Res, 1065353216		; 3f800000H

; 415  : 	Res.v[1] = 1.00001f;

	mov	DWORD PTR _Res+4, 1065353300		; 3f800054H

; 416  : 
; 417  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 418  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 419  : 
; 420  : 	L1(&Coef, &Res, 0.0001f, &Soln, &NewRes, Work);

	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?L1@@YAXPAUBIGMAT@@PAUBIGVEC@@M11PAH@Z	; L1
	add	esp, 24					; 00000018H

; 421  : 	SolveLinearEquations(&OrigCoef, &OrigRes, 0.0001f, 0.0001f, OrigRow, OrigCol, &NewRes, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_OrigCoef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 422  : 
; 423  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TestL1Solver@@YAXXZ ENDP				; TestL1Solver
_TEXT	ENDS
PUBLIC	_expf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?exp@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?exp@@YAMM@Z PROC NEAR					; exp, COMDAT

; 553  :         {return (expf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_expf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?exp@@YAMM@Z ENDP					; exp
_TEXT	ENDS
EXTRN	_exp:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _expf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_expf	PROC NEAR					; COMDAT

; 448  :         {return ((float)exp((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_exp
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_expf	ENDP
_TEXT	ENDS
PUBLIC	??$_Pow_int@M@@YAMMH@Z				; _Pow_int<float>
; Function compile flags: /Odt /ZI
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?pow@@YAMMH@Z PROC NEAR					; pow, COMDAT

; 573  :         {return (_Pow_int(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __Y$[ebp]
	push	eax
	mov	ecx, DWORD PTR __X$[ebp]
	push	ecx
	call	??$_Pow_int@M@@YAMMH@Z			; _Pow_int<float>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pow@@YAMMH@Z ENDP					; pow
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT
tv74 = -76						; size = 4
__Z$75047 = -8						; size = 4
__N$ = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
??$_Pow_int@M@@YAMMH@Z PROC NEAR			; _Pow_int<float>, COMDAT

; 517  :         {unsigned int _N;

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 518  :         if (_Y >= 0)

	cmp	DWORD PTR __Y$[ebp], 0
	jl	SHORT $L75045

; 519  :                 _N = _Y;

	mov	eax, DWORD PTR __Y$[ebp]
	mov	DWORD PTR __N$[ebp], eax

; 520  :         else

	jmp	SHORT $L75046
$L75045:

; 521  :                 _N = -_Y;

	mov	eax, DWORD PTR __Y$[ebp]
	neg	eax
	mov	DWORD PTR __N$[ebp], eax
$L75046:

; 522  :         for (_Ty _Z = _Ty(1); ; _X *= _X)

	mov	DWORD PTR __Z$75047[ebp], 1065353216	; 3f800000H
	jmp	SHORT $L75048
$L75049:
	fld	DWORD PTR __X$[ebp]
	fmul	DWORD PTR __X$[ebp]
	fstp	DWORD PTR __X$[ebp]
$L75048:

; 523  :                 {if ((_N & 1) != 0)

	mov	eax, DWORD PTR __N$[ebp]
	and	eax, 1
	je	SHORT $L75051

; 524  :                         _Z *= _X;

	fld	DWORD PTR __Z$75047[ebp]
	fmul	DWORD PTR __X$[ebp]
	fstp	DWORD PTR __Z$75047[ebp]
$L75051:

; 525  :                 if ((_N >>= 1) == 0)

	mov	eax, DWORD PTR __N$[ebp]
	shr	eax, 1
	mov	DWORD PTR __N$[ebp], eax
	cmp	DWORD PTR __N$[ebp], 0
	jne	SHORT $L75052

; 526  :                         return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

	cmp	DWORD PTR __Y$[ebp], 0
	jge	SHORT $L75157
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR __Z$75047[ebp]
	fstp	DWORD PTR tv74[ebp]
	jmp	SHORT $L75158
$L75157:
	mov	eax, DWORD PTR __Z$75047[ebp]
	mov	DWORD PTR tv74[ebp], eax
$L75158:
	fld	DWORD PTR tv74[ebp]
	jmp	SHORT $L75043
$L75052:
	jmp	SHORT $L75049
$L75043:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pow_int@M@@YAMMH@Z ENDP				; _Pow_int<float>
_TEXT	ENDS
END
