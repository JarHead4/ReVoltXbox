; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Ghost.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IK@EFOHEDLB@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BBHIDGIA@Ghost?4tad?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LKDHDEO@Ghost?4dat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitGhostData@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndGhostData@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBestGhostData@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearBestGhostData@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SwitchGhostDataStores@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StoreGhostData@@YA_NPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterpGhostData@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadGhostData@@YA_NPAULEVELINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveGhostData@@YA_NPAULEVELINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitGhostLight@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??StoreGhostData@@YA_NPAUCarStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A	; GHO_BestGhostInfo
PUBLIC	?GHO_BestFrame@@3JA				; GHO_BestFrame
PUBLIC	?GhostSolid@@3JA				; GhostSolid
PUBLIC	?GHO_GhostPlayer@@3PAUPlayerStruct@@A		; GHO_GhostPlayer
PUBLIC	?GHO_GhostExists@@3_NA				; GHO_GhostExists
PUBLIC	?GhostLight@@3PAULIGHT@@A			; GhostLight
PUBLIC	?BestGhostData@@3PAUGhostDataStruct@@A		; BestGhostData
PUBLIC	?GhostInfo@@3PAUGhostInfoStruct@@A		; GhostInfo
PUBLIC	?GhostData@@3PAUGhostDataStruct@@A		; GhostData
PUBLIC	?DBG_dt@@3MA					; DBG_dt
_BSS	SEGMENT
?GHO_BestFrame@@3JA DD 01H DUP (?)			; GHO_BestFrame
?GhostSolid@@3JA DD 01H DUP (?)				; GhostSolid
?GHO_GhostPlayer@@3PAUPlayerStruct@@A DD 01H DUP (?)	; GHO_GhostPlayer
?GHO_GhostExists@@3_NA DB 01H DUP (?)			; GHO_GhostExists
	ALIGN	4

?GhostLight@@3PAULIGHT@@A DD 01H DUP (?)		; GhostLight
_GhostInfoStore1 DB 074H DUP (?)
_GhostDataStore1 DB 0445c0H DUP (?)
_GhostInfoStore2 DB 074H DUP (?)
_GhostDataStore2 DB 0445c0H DUP (?)
?DBG_dt@@3MA DD	01H DUP (?)				; DBG_dt
_BSS	ENDS
_DATA	SEGMENT
?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A DD FLAT:_GhostInfoStore1 ; GHO_BestGhostInfo
?BestGhostData@@3PAUGhostDataStruct@@A DD FLAT:_GhostDataStore1 ; BestGhostData
?GhostInfo@@3PAUGhostInfoStruct@@A DD FLAT:_GhostInfoStore2 ; GhostInfo
?GhostData@@3PAUGhostDataStruct@@A DD FLAT:_GhostDataStore2 ; GhostData
_DATA	ENDS
PUBLIC	?InitGhostData@@YAXPAUPlayerStruct@@@Z		; InitGhostData
EXTRN	_strncpy:NEAR
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\ghost.cpp
;	COMDAT ?InitGhostData@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_player$ = 8						; size = 4
?InitGhostData@@YAXPAUPlayerStruct@@@Z PROC NEAR	; InitGhostData, COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 48   : 
; 49   : 	GhostInfo->CarID = player->car.CarID;

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+812]
	mov	DWORD PTR [eax], edx

; 50   : 	strncpy(GhostInfo->PlayerName, player->PlayerName, MAX_PLAYER_NAME); 

	push	64					; 00000040H
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 10244				; 00002804H
	push	eax
	mov	ecx, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	add	ecx, 4
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 51   : 	GhostInfo->NFrames = 0;

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	DWORD PTR [eax+112], 0

; 52   : 
; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitGhostData@@YAXPAUPlayerStruct@@@Z ENDP		; InitGhostData
_TEXT	ENDS
PUBLIC	?EndGhostData@@YAXPAUPlayerStruct@@@Z		; EndGhostData
; Function compile flags: /Odt /ZI
;	COMDAT ?EndGhostData@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_player$ = 8						; size = 4
?EndGhostData@@YAXPAUPlayerStruct@@@Z PROC NEAR		; EndGhostData, COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 57   : 	GhostInfo->Time[GHOST_LAP_TIME] = player->car.LastLapTime;

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+3472]
	mov	DWORD PTR [eax+108], edx

; 58   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EndGhostData@@YAXPAUPlayerStruct@@@Z ENDP		; EndGhostData
_TEXT	ENDS
PUBLIC	?InitBestGhostData@@YAXXZ			; InitBestGhostData
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?SetupCar@@YAXPAUPlayerStruct@@H@Z:NEAR		; SetupCar
; Function compile flags: /Odt /ZI
;	COMDAT ?InitBestGhostData@@YAXXZ
_TEXT	SEGMENT
?InitBestGhostData@@YAXXZ PROC NEAR			; InitBestGhostData, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 62   : 	if (!GHO_GhostPlayer)

	cmp	DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A, 0 ; GHO_GhostPlayer
	jne	SHORT $L81158

; 63   : 		return;

	jmp	SHORT $L81157
$L81158:

; 64   : 
; 65   : 	GHO_BestFrame = 0;

	mov	DWORD PTR ?GHO_BestFrame@@3JA, 0	; GHO_BestFrame

; 66   : 	GHO_GhostPlayer->car.CurrentLapTime = 0;

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	DWORD PTR [eax+3468], 0

; 67   : 	GHO_GhostPlayer->car.CurrentLapStartTime = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	DWORD PTR [ecx+3544], eax

; 68   : 	strncpy(GHO_BestGhostInfo->PlayerName, GHO_GhostPlayer->PlayerName, MAX_PLAYER_NAME);

	push	64					; 00000040H
	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	add	eax, 10244				; 00002804H
	push	eax
	mov	ecx, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	add	ecx, 4
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 69   : 
; 70   : 	if (GHO_GhostPlayer->car.CarID != GHO_BestGhostInfo->CarID)

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	edx, DWORD PTR [eax+812]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $L81157

; 71   : 		SetupCar(GHO_GhostPlayer, GHO_BestGhostInfo->CarID);

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	push	edx
	call	?SetupCar@@YAXPAUPlayerStruct@@H@Z	; SetupCar
	add	esp, 8
$L81157:

; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitBestGhostData@@YAXXZ ENDP				; InitBestGhostData
_TEXT	ENDS
PUBLIC	?ClearBestGhostData@@YAXXZ			; ClearBestGhostData
PUBLIC	__real@42c80000
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ClearBestGhostData@@YAXXZ
_TEXT	SEGMENT
_iWheel$ = -4						; size = 4
?ClearBestGhostData@@YAXXZ PROC NEAR			; ClearBestGhostData, COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 77   : 	int iWheel;
; 78   : 
; 79   : 	GHO_BestFrame = 0;

	mov	DWORD PTR ?GHO_BestFrame@@3JA, 0	; GHO_BestFrame

; 80   : 	GHO_BestGhostInfo->Time[GHOST_LAP_TIME] = MAKE_TIME(10, 0, 0);

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	DWORD PTR [eax+108], 600000		; 000927c0H

; 81   : 	GHO_BestGhostInfo->CarID = 0;

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	DWORD PTR [eax], 0

; 82   : 	GHO_BestGhostInfo->PlayerName[0] = '\0';

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	BYTE PTR [eax+4], 0

; 83   : 	GHO_BestGhostInfo->NFrames = 1;

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	DWORD PTR [eax+112], 1

; 84   : 
; 85   : 	BestGhostData[0].Time = MAKE_TIME(0, 0, 0);

	mov	eax, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	DWORD PTR [eax], 0

; 86   : 	BestGhostData[1].Time = MAKE_TIME(10, 0, 0);

	mov	eax, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	DWORD PTR [eax+28], 600000		; 000927c0H

; 87   : 	CopyVec(&GHO_GhostPlayer->car.Body->Centre.Pos, &BestGhostData[0].Pos); 

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+12], eax

; 88   : #pragma warning(disable : 4244)
; 89   : 	BestGhostData[0].Quat.v[VX] = (char)(GHOST_VECTOR_SCALE * GHO_GhostPlayer->car.Body->Centre.Quat.v[VX]);

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+68]
	call	__ftol2
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	BYTE PTR [edx+16], al

; 90   : 	BestGhostData[0].Quat.v[VY] = (char)(GHOST_VECTOR_SCALE * GHO_GhostPlayer->car.Body->Centre.Quat.v[VY]);

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+72]
	call	__ftol2
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	BYTE PTR [edx+17], al

; 91   : 	BestGhostData[0].Quat.v[VZ] = (char)(GHOST_VECTOR_SCALE * GHO_GhostPlayer->car.Body->Centre.Quat.v[VZ]);

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+76]
	call	__ftol2
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	BYTE PTR [edx+18], al

; 92   : 	BestGhostData[0].Quat.v[S] = (char)(GHOST_VECTOR_SCALE * GHO_GhostPlayer->car.Body->Centre.Quat.v[S]);

	mov	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+80]
	call	__ftol2
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	BYTE PTR [edx+19], al

; 93   : #pragma warning(default : 4244)
; 94   : 
; 95   : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L81167
$L81168:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L81167:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	SHORT $L81169

; 96   : 		BestGhostData[0].WheelAngle[iWheel] = 0;

	mov	eax, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	add	eax, DWORD PTR _iWheel$[ebp]
	mov	BYTE PTR [eax+20], 0

; 97   : 		BestGhostData[0].WheelPos[iWheel] = 0;

	mov	eax, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	add	eax, DWORD PTR _iWheel$[ebp]
	mov	BYTE PTR [eax+24], 0

; 98   : 	}

	jmp	SHORT $L81168
$L81169:

; 99   : 
; 100  : 	GHO_GhostExists = FALSE;

	mov	BYTE PTR ?GHO_GhostExists@@3_NA, 0	; GHO_GhostExists

; 101  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearBestGhostData@@YAXXZ ENDP				; ClearBestGhostData
_TEXT	ENDS
PUBLIC	?SwitchGhostDataStores@@YAXXZ			; SwitchGhostDataStores
; Function compile flags: /Odt /ZI
;	COMDAT ?SwitchGhostDataStores@@YAXXZ
_TEXT	SEGMENT
_tmpInfo$ = -8						; size = 4
_tmpData$ = -4						; size = 4
?SwitchGhostDataStores@@YAXXZ PROC NEAR			; SwitchGhostDataStores, COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 112  : 	GHOST_DATA *tmpData;
; 113  : 	GHOST_INFO *tmpInfo;
; 114  : 
; 115  : 	if (GhostInfo->NFrames == 0) return;

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	cmp	DWORD PTR [eax+112], 0
	jne	SHORT $L81174
	jmp	SHORT $L81171
$L81174:

; 116  : 
; 117  : 	tmpData = GhostData;

	mov	eax, DWORD PTR ?GhostData@@3PAUGhostDataStruct@@A ; GhostData
	mov	DWORD PTR _tmpData$[ebp], eax

; 118  : 	tmpInfo = GhostInfo;

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	DWORD PTR _tmpInfo$[ebp], eax

; 119  : 	GhostData = BestGhostData;

	mov	eax, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	DWORD PTR ?GhostData@@3PAUGhostDataStruct@@A, eax ; GhostData

; 120  : 	GhostInfo = GHO_BestGhostInfo;

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A, eax ; GhostInfo

; 121  : 	BestGhostData = tmpData;

	mov	eax, DWORD PTR _tmpData$[ebp]
	mov	DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A, eax ; BestGhostData

; 122  : 	GHO_BestGhostInfo = tmpInfo;

	mov	eax, DWORD PTR _tmpInfo$[ebp]
	mov	DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A, eax ; GHO_BestGhostInfo

; 123  : 	if (GHO_BestGhostInfo->NFrames < GHOST_DATA_MAX) {

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	cmp	DWORD PTR [eax+112], 10000		; 00002710H
	jge	SHORT $L81175

; 124  : 		BestGhostData[GHO_BestGhostInfo->NFrames].Time = GHO_BestGhostInfo->Time[GHOST_LAP_TIME];

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR [edx+ecx], eax
$L81175:

; 125  : 	}
; 126  : 
; 127  : 
; 128  : 	GHO_GhostExists = TRUE;

	mov	BYTE PTR ?GHO_GhostExists@@3_NA, 1	; GHO_GhostExists
$L81171:

; 129  : 
; 130  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SwitchGhostDataStores@@YAXXZ ENDP			; SwitchGhostDataStores
_TEXT	ENDS
PUBLIC	?StoreGhostData@@YA_NPAUCarStruct@@@Z		; StoreGhostData
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?__LINE__Var@?1??StoreGhostData@@YA_NPAUCarStruct@@@Z@4JA ; `StoreGhostData'::`2'::__LINE__Var
PUBLIC	??_C@_0IK@EFOHEDLB@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	__real@40a00000
PUBLIC	__real@3f800000
PUBLIC	__real@3727c5ac
PUBLIC	__real@00000000
PUBLIC	__real@43fa0000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3f59999a
EXTRN	?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z:NEAR	; LerpQuat
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0IK@EFOHEDLB@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IK@EFOHEDLB@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\ghost'
	DB	'.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??StoreGhostData@@YA_NPAUCarStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??StoreGhostData@@YA_NPAUCarStruct@@@Z@4JA DD 08eH ; `StoreGhostData'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?StoreGhostData@@YA_NPAUCarStruct@@@Z
_TEXT	SEGMENT
tv581 = -168						; size = 4
tv579 = -168						; size = 4
tv577 = -168						; size = 4
tv575 = -168						; size = 4
tv573 = -168						; size = 4
tv571 = -168						; size = 4
tv569 = -168						; size = 4
tv567 = -168						; size = 4
tv540 = -168						; size = 4
tv532 = -168						; size = 4
tv239 = -165						; size = 1
_qLen$81220 = -100					; size = 4
_quatOkay$81204 = -94					; size = 1
_posOkay$81203 = -93					; size = 1
_nextData$81202 = -92					; size = 4
_lastData$81201 = -88					; size = 4
_nextQuat$81200 = -84					; size = 16
_lastQuat$81199 = -68					; size = 16
_intQuat$81198 = -52					; size = 16
_dR$81197 = -36						; size = 12
_intPos$81196 = -24					; size = 12
_dt$81195 = -12						; size = 4
_data$ = -8						; size = 4
_iWheel$ = -4						; size = 4
_car$ = 8						; size = 4
?StoreGhostData@@YA_NPAUCarStruct@@@Z PROC NEAR		; StoreGhostData, COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi

; 143  : 	int iWheel;
; 144  : 	GHOST_DATA *data;
; 145  : 	
; 146  : 
; 147  : 	// Make sure there is enough space in the data array
; 148  : 	if (GhostInfo->NFrames >= GHOST_DATA_MAX) {

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	cmp	DWORD PTR [eax+112], 10000		; 00002710H
	jl	SHORT $L81183

; 149  : 		return FALSE;

	xor	al, al
	jmp	$L81180
$L81183:

; 150  : 	}
; 151  : 
; 152  : 	// Make sure enough time has passed
; 153  : 	if (car->CurrentLapTime - GhostData[GhostInfo->NFrames - 1].Time < GHOST_MIN_TIMESTEP) {

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 1
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR ?GhostData@@3PAUGhostDataStruct@@A ; GhostData
	mov	edx, DWORD PTR [edx+3424]
	sub	edx, DWORD PTR [eax+ecx]
	cmp	edx, 75					; 0000004bH
	jge	SHORT $L81184

; 154  : 		return FALSE;

	xor	al, al
	jmp	$L81180
$L81184:

; 155  : 	}
; 156  : 
; 157  : 	// Store current car data for later replay
; 158  : 	data = &GhostData[GhostInfo->NFrames];

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?GhostData@@3PAUGhostDataStruct@@A ; GhostData
	mov	DWORD PTR _data$[ebp], ecx

; 159  : 
; 160  : 	data->Time = car->CurrentLapTime;

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3424]
	mov	DWORD PTR [eax], edx

; 161  : 	CopyVec(&car->Body->Centre.Pos, &data->Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+12], eax

; 162  : 
; 163  : 	data->Quat.v[VX] = (char)(GHOST_VECTOR_SCALE * car->Body->Centre.Quat.v[VX]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+68]
	call	__ftol2
	mov	edx, DWORD PTR _data$[ebp]
	mov	BYTE PTR [edx+16], al

; 164  : 	data->Quat.v[VY] = (char)(GHOST_VECTOR_SCALE * car->Body->Centre.Quat.v[VY]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+72]
	call	__ftol2
	mov	edx, DWORD PTR _data$[ebp]
	mov	BYTE PTR [edx+17], al

; 165  : 	data->Quat.v[VZ] = (char)(GHOST_VECTOR_SCALE * car->Body->Centre.Quat.v[VZ]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+76]
	call	__ftol2
	mov	edx, DWORD PTR _data$[ebp]
	mov	BYTE PTR [edx+18], al

; 166  : 	data->Quat.v[S] = (char)(GHOST_VECTOR_SCALE * car->Body->Centre.Quat.v[S]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR __real@42c80000
	fmul	DWORD PTR [ecx+80]
	call	__ftol2
	mov	edx, DWORD PTR _data$[ebp]
	mov	BYTE PTR [edx+19], al

; 167  : 
; 168  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L81189
$L81190:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L81189:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	SHORT $L81191

; 169  : 		data->WheelPos[iWheel] = (char)(GHOST_WHEEL_SCALE * car->Wheel[iWheel].Pos);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR __real@40a00000
	fmul	DWORD PTR [ecx+eax+1640]
	call	__ftol2
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, DWORD PTR _iWheel$[ebp]
	mov	BYTE PTR [edx+24], al

; 170  : 		data->WheelAngle[iWheel] = (char)(GHOST_ANGLE_SCALE * car->Wheel[iWheel].TurnAngle);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR __real@40a00000
	fmul	DWORD PTR [ecx+eax+1852]
	call	__ftol2
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, DWORD PTR _iWheel$[ebp]
	mov	BYTE PTR [edx+20], al

; 171  : 	}

	jmp	SHORT $L81190
$L81191:

; 172  : 
; 173  : 	// See if there was sufficient deviation from the interpolated values obtained from previous stored data
; 174  : 	if (GhostInfo->NFrames > 2) {

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	cmp	DWORD PTR [eax+112], 2
	jle	$L81194

; 175  : 		REAL dt;
; 176  : 		VEC intPos, dR;
; 177  : 		QUATERNION intQuat, lastQuat, nextQuat;
; 178  : 		GHOST_DATA *lastData = &GhostData[GhostInfo->NFrames - 2];

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 2
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?GhostData@@3PAUGhostDataStruct@@A ; GhostData
	mov	DWORD PTR _lastData$81201[ebp], ecx

; 179  : 		GHOST_DATA *nextData = &GhostData[GhostInfo->NFrames - 1];

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 1
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?GhostData@@3PAUGhostDataStruct@@A ; GhostData
	mov	DWORD PTR _nextData$81202[ebp], ecx

; 180  : 		bool posOkay = FALSE;

	mov	BYTE PTR _posOkay$81203[ebp], 0

; 181  : 		bool quatOkay = FALSE;

	mov	BYTE PTR _quatOkay$81204[ebp], 0

; 182  : 
; 183  : 		// position
; 184  : 		VecMinusVec(&nextData->Pos, &lastData->Pos, &dR);

	mov	eax, DWORD PTR _nextData$81202[ebp]
	mov	ecx, DWORD PTR _lastData$81201[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$81197[ebp]
	mov	eax, DWORD PTR _nextData$81202[ebp]
	mov	ecx, DWORD PTR _lastData$81201[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$81197[ebp+4]
	mov	eax, DWORD PTR _nextData$81202[ebp]
	mov	ecx, DWORD PTR _lastData$81201[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dR$81197[ebp+8]

; 185  : 		dt = Real(nextData->Time - lastData->Time);

	mov	eax, DWORD PTR _nextData$81202[ebp]
	mov	ecx, DWORD PTR _lastData$81201[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv532[ebp], edx
	fild	DWORD PTR tv532[ebp]
	fmul	DWORD PTR __real@3f800000
	fstp	DWORD PTR _dt$81195[ebp]

; 186  : 		if (dt > SMALL_REAL) {

	fld	DWORD PTR _dt$81195[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81206

; 187  : 			dt = Real(data->Time - lastData->Time) / dt;

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _lastData$81201[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv540[ebp], edx
	fild	DWORD PTR tv540[ebp]
	fmul	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _dt$81195[ebp]
	fstp	DWORD PTR _dt$81195[ebp]

; 188  : 		} else {

	jmp	SHORT $L81208
$L81206:

; 189  : 			dt = ZERO;

	mov	DWORD PTR _dt$81195[ebp], 0
$L81208:

; 190  : 		}
; 191  : 		Assert(dt >= ZERO);

	fld	DWORD PTR _dt$81195[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81433
	mov	BYTE PTR tv239[ebp], 1
	jmp	SHORT $L81434
$L81433:
	mov	BYTE PTR tv239[ebp], 0
$L81434:
	push	OFFSET FLAT:??_C@_0IK@EFOHEDLB@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??StoreGhostData@@YA_NPAUCarStruct@@@Z@4JA
	add	eax, 49					; 00000031H
	push	eax
	mov	cl, BYTE PTR tv239[ebp]
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 192  : 		VecPlusScalarVec(&lastData->Pos, dt, &dR, &intPos);

	fld	DWORD PTR _dt$81195[ebp]
	fmul	DWORD PTR _dR$81197[ebp]
	mov	eax, DWORD PTR _lastData$81201[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _intPos$81196[ebp]
	fld	DWORD PTR _dt$81195[ebp]
	fmul	DWORD PTR _dR$81197[ebp+4]
	mov	eax, DWORD PTR _lastData$81201[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _intPos$81196[ebp+4]
	fld	DWORD PTR _dt$81195[ebp]
	fmul	DWORD PTR _dR$81197[ebp+8]
	mov	eax, DWORD PTR _lastData$81201[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _intPos$81196[ebp+8]

; 193  : 
; 194  : 		VecMinusVec(&intPos, &car->Body->Centre.Pos, &dR);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _intPos$81196[ebp]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR$81197[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _intPos$81196[ebp+4]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dR$81197[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _intPos$81196[ebp+8]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dR$81197[ebp+8]

; 195  : 		if (VecDotVec(&dR, &dR) < GHOST_POS_DEVIATION) {

	fld	DWORD PTR _dR$81197[ebp]
	fmul	DWORD PTR _dR$81197[ebp]
	fld	DWORD PTR _dR$81197[ebp+4]
	fmul	DWORD PTR _dR$81197[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$81197[ebp+8]
	fmul	DWORD PTR _dR$81197[ebp+8]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@43fa0000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81211

; 196  : 			posOkay = TRUE;

	mov	BYTE PTR _posOkay$81203[ebp], 1
$L81211:

; 197  : 		}
; 198  : 
; 199  : 		// quaternion
; 200  : 		lastQuat.v[VX] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[VX]);

	mov	eax, DWORD PTR _lastData$81201[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	mov	DWORD PTR tv567[ebp], ecx
	fild	DWORD PTR tv567[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$81199[ebp]

; 201  : 		lastQuat.v[VY] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[VY]);

	mov	eax, DWORD PTR _lastData$81201[ebp]
	movsx	ecx, BYTE PTR [eax+17]
	mov	DWORD PTR tv569[ebp], ecx
	fild	DWORD PTR tv569[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$81199[ebp+4]

; 202  : 		lastQuat.v[VZ] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[VZ]);

	mov	eax, DWORD PTR _lastData$81201[ebp]
	movsx	ecx, BYTE PTR [eax+18]
	mov	DWORD PTR tv571[ebp], ecx
	fild	DWORD PTR tv571[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$81199[ebp+8]

; 203  : 		lastQuat.v[S] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[S]);

	mov	eax, DWORD PTR _lastData$81201[ebp]
	movsx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR tv573[ebp], ecx
	fild	DWORD PTR tv573[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$81199[ebp+12]

; 204  : 		nextQuat.v[VX] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[VX]);

	mov	eax, DWORD PTR _nextData$81202[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	mov	DWORD PTR tv575[ebp], ecx
	fild	DWORD PTR tv575[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$81200[ebp]

; 205  : 		nextQuat.v[VY] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[VY]);

	mov	eax, DWORD PTR _nextData$81202[ebp]
	movsx	ecx, BYTE PTR [eax+17]
	mov	DWORD PTR tv577[ebp], ecx
	fild	DWORD PTR tv577[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$81200[ebp+4]

; 206  : 		nextQuat.v[VZ] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[VZ]);

	mov	eax, DWORD PTR _nextData$81202[ebp]
	movsx	ecx, BYTE PTR [eax+18]
	mov	DWORD PTR tv579[ebp], ecx
	fild	DWORD PTR tv579[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$81200[ebp+8]

; 207  : 		nextQuat.v[S] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[S]);

	mov	eax, DWORD PTR _nextData$81202[ebp]
	movsx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR tv581[ebp], ecx
	fild	DWORD PTR tv581[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$81200[ebp+12]

; 208  : 		LerpQuat(&lastQuat, &nextQuat, dt, &intQuat);

	lea	eax, DWORD PTR _intQuat$81198[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$81195[ebp]
	push	ecx
	lea	edx, DWORD PTR _nextQuat$81200[ebp]
	push	edx
	lea	eax, DWORD PTR _lastQuat$81199[ebp]
	push	eax
	call	?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ; LerpQuat
	add	esp, 16					; 00000010H

; 209  : 		NormalizeQuat(&intQuat);

	fld	DWORD PTR _intQuat$81198[ebp]
	fmul	DWORD PTR _intQuat$81198[ebp]
	fld	DWORD PTR _intQuat$81198[ebp+4]
	fmul	DWORD PTR _intQuat$81198[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _intQuat$81198[ebp+8]
	fmul	DWORD PTR _intQuat$81198[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _intQuat$81198[ebp+12]
	fmul	DWORD PTR _intQuat$81198[ebp+12]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$81220[ebp]
	fld	DWORD PTR _qLen$81220[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81222
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$81220[ebp]
	fstp	DWORD PTR _qLen$81220[ebp]
	fld	DWORD PTR _intQuat$81198[ebp]
	fmul	DWORD PTR _qLen$81220[ebp]
	fstp	DWORD PTR _intQuat$81198[ebp]
	fld	DWORD PTR _intQuat$81198[ebp+4]
	fmul	DWORD PTR _qLen$81220[ebp]
	fstp	DWORD PTR _intQuat$81198[ebp+4]
	fld	DWORD PTR _intQuat$81198[ebp+8]
	fmul	DWORD PTR _qLen$81220[ebp]
	fstp	DWORD PTR _intQuat$81198[ebp+8]
	fld	DWORD PTR _intQuat$81198[ebp+12]
	fmul	DWORD PTR _qLen$81220[ebp]
	fstp	DWORD PTR _intQuat$81198[ebp+12]
$L81222:

; 210  : 		if (QuatDotQuat(&intQuat, &car->Body->Centre.Quat) > GHOST_QUAT_DEVIATION) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _intQuat$81198[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _intQuat$81198[ebp+4]
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR _intQuat$81198[ebp+8]
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _intQuat$81198[ebp+12]
	fmul	DWORD PTR [ecx+80]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@3f59999a
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81223

; 211  : 			quatOkay = TRUE;

	mov	BYTE PTR _quatOkay$81204[ebp], 1
$L81223:

; 212  : 		}
; 213  : 
; 214  : 	
; 215  : 		if (posOkay && quatOkay) return FALSE;

	movzx	eax, BYTE PTR _posOkay$81203[ebp]
	test	eax, eax
	je	SHORT $L81194
	movzx	eax, BYTE PTR _quatOkay$81204[ebp]
	test	eax, eax
	je	SHORT $L81194
	xor	al, al
	jmp	SHORT $L81180
$L81194:

; 216  : 
; 217  : 	}
; 218  : 
; 219  : 	GhostInfo->NFrames++;

	mov	eax, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	ecx, DWORD PTR [eax+112]
	add	ecx, 1
	mov	edx, DWORD PTR ?GhostInfo@@3PAUGhostInfoStruct@@A ; GhostInfo
	mov	DWORD PTR [edx+112], ecx

; 220  : 
; 221  : 	return TRUE;

	mov	al, 1
$L81180:

; 222  : 
; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StoreGhostData@@YA_NPAUCarStruct@@@Z ENDP		; StoreGhostData
_TEXT	ENDS
PUBLIC	?InterpGhostData@@YAXPAUCarStruct@@@Z		; InterpGhostData
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
EXTRN	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z:NEAR ; VecMulMat
EXTRN	?MatMulMat@@YAXPATMatrixUnion@@00@Z:NEAR	; MatMulMat
EXTRN	?RotationX@@YAXPATMatrixUnion@@M@Z:NEAR		; RotationX
EXTRN	?RotationY@@YAXPATMatrixUnion@@M@Z:NEAR		; RotationY
EXTRN	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z:NEAR ; QuatToMat
EXTRN	?DownVec@@3UVectorStruct@@A:BYTE		; DownVec
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?GoodWrap@@YAMPAMMM@Z:NEAR			; GoodWrap
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InterpGhostData@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
tv887 = -168						; size = 4
tv883 = -168						; size = 4
tv842 = -168						; size = 4
tv840 = -168						; size = 4
tv838 = -168						; size = 4
tv836 = -168						; size = 4
tv834 = -168						; size = 4
tv832 = -168						; size = 4
tv830 = -168						; size = 4
tv828 = -168						; size = 4
tv780 = -168						; size = 4
tv772 = -168						; size = 4
_qLen$81259 = -100					; size = 4
_nextData$ = -96					; size = 4
_lastData$ = -92					; size = 4
_iWheel$ = -88						; size = 4
_nextQuat$ = -84					; size = 16
_lastQuat$ = -68					; size = 16
_tmpMat$ = -52						; size = 36
_dR$ = -16						; size = 12
_dt$ = -4						; size = 4
_car$ = 8						; size = 4
?InterpGhostData@@YAXPAUCarStruct@@@Z PROC NEAR		; InterpGhostData, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi
$L81237:

; 234  : 	REAL dt;
; 235  : 	VEC dR;
; 236  : 	MAT tmpMat;
; 237  : 	QUATERNION lastQuat, nextQuat;
; 238  : 	int iWheel;
; 239  : 
; 240  : 	GHOST_DATA *lastData, *nextData;
; 241  : 
; 242  : 	// Figure out which element of the data is just behind current lap time
; 243  : 	while ((GHO_BestFrame > 0) && (car->CurrentLapTime < BestGhostData[GHO_BestFrame - 1].Time)) {

	cmp	DWORD PTR ?GHO_BestFrame@@3JA, 0	; GHO_BestFrame
	jle	SHORT $L81240
	mov	eax, DWORD PTR ?GHO_BestFrame@@3JA	; GHO_BestFrame
	sub	eax, 1
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	ecx, DWORD PTR [ecx+3424]
	cmp	ecx, DWORD PTR [edx+eax]
	jge	SHORT $L81240

; 244  : 		GHO_BestFrame--;

	mov	eax, DWORD PTR ?GHO_BestFrame@@3JA	; GHO_BestFrame
	sub	eax, 1
	mov	DWORD PTR ?GHO_BestFrame@@3JA, eax	; GHO_BestFrame

; 245  : 	}

	jmp	SHORT $L81237
$L81240:

; 246  : 	while ((GHO_BestFrame < GHO_BestGhostInfo->NFrames - 1) && (car->CurrentLapTime > BestGhostData[GHO_BestFrame + 1].Time)) {

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 1
	cmp	DWORD PTR ?GHO_BestFrame@@3JA, ecx	; GHO_BestFrame
	jge	SHORT $L81241
	mov	eax, DWORD PTR ?GHO_BestFrame@@3JA	; GHO_BestFrame
	add	eax, 1
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	ecx, DWORD PTR [ecx+3424]
	cmp	ecx, DWORD PTR [edx+eax]
	jle	SHORT $L81241

; 247  : 		GHO_BestFrame++;

	mov	eax, DWORD PTR ?GHO_BestFrame@@3JA	; GHO_BestFrame
	add	eax, 1
	mov	DWORD PTR ?GHO_BestFrame@@3JA, eax	; GHO_BestFrame

; 248  : 	}

	jmp	SHORT $L81240
$L81241:

; 249  : 	lastData = &BestGhostData[GHO_BestFrame];

	mov	eax, DWORD PTR ?GHO_BestFrame@@3JA	; GHO_BestFrame
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	DWORD PTR _lastData$[ebp], eax

; 250  : 	nextData = &BestGhostData[GHO_BestFrame + 1];

	mov	eax, DWORD PTR ?GHO_BestFrame@@3JA	; GHO_BestFrame
	add	eax, 1
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	DWORD PTR _nextData$[ebp], eax

; 251  : 
; 252  : 	// Keep frame number within bounds of data (last item is used as a buffer)
; 253  : 	if (GHO_BestFrame > GHO_BestGhostInfo->NFrames - 3) {

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 3
	cmp	DWORD PTR ?GHO_BestFrame@@3JA, ecx	; GHO_BestFrame
	jle	SHORT $L81242

; 254  : 		lastData = &BestGhostData[GHO_BestGhostInfo->NFrames - 2];

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 2
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	DWORD PTR _lastData$[ebp], ecx

; 255  : 		nextData = &BestGhostData[GHO_BestGhostInfo->NFrames - 2];

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 2
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	mov	DWORD PTR _nextData$[ebp], ecx

; 256  : 		GHO_BestFrame = GHO_BestGhostInfo->NFrames - 2;

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax+112]
	sub	ecx, 2
	mov	DWORD PTR ?GHO_BestFrame@@3JA, ecx	; GHO_BestFrame
$L81242:

; 257  : 	}
; 258  : 
; 259  : 	// Calculate new position
; 260  : 	CopyVec(&car->Body->Centre.Pos, &car->Body->Centre.OldPos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+16], ecx

; 261  : 	VecMinusVec(&nextData->Pos, &lastData->Pos, &dR);

	mov	eax, DWORD PTR _nextData$[ebp]
	mov	ecx, DWORD PTR _lastData$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _nextData$[ebp]
	mov	ecx, DWORD PTR _lastData$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _nextData$[ebp]
	mov	ecx, DWORD PTR _lastData$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dR$[ebp+8]

; 262  : 	dt = Real(nextData->Time - lastData->Time);

	mov	eax, DWORD PTR _nextData$[ebp]
	mov	ecx, DWORD PTR _lastData$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv772[ebp], edx
	fild	DWORD PTR tv772[ebp]
	fmul	DWORD PTR __real@3f800000
	fstp	DWORD PTR _dt$[ebp]

; 263  : 	if (dt > SMALL_REAL) {

	fld	DWORD PTR _dt$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81244

; 264  : 		dt = Real(car->CurrentLapTime - lastData->Time) / dt;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _lastData$[ebp]
	mov	edx, DWORD PTR [eax+3424]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv780[ebp], edx
	fild	DWORD PTR tv780[ebp]
	fmul	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _dt$[ebp]
	fstp	DWORD PTR _dt$[ebp]

; 265  : 	} else {

	jmp	SHORT $L81246
$L81244:

; 266  : 		dt = ZERO;

	mov	DWORD PTR _dt$[ebp], 0
$L81246:

; 267  : 	}
; 268  : 	if (dt < ZERO) dt = ZERO;

	fld	DWORD PTR _dt$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81247
	mov	DWORD PTR _dt$[ebp], 0
$L81247:

; 269  : 	if (dt > ONE) dt = ONE;

	fld	DWORD PTR _dt$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81248
	mov	DWORD PTR _dt$[ebp], 1065353216		; 3f800000H
$L81248:

; 270  : 
; 271  : 	DBG_dt = dt;

	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR ?DBG_dt@@3MA, eax

; 272  : 
; 273  : 	VecPlusScalarVec(&lastData->Pos, dt, &dR, &car->Body->Centre.Pos);

	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _lastData$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+20]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _lastData$[ebp]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+24]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _lastData$[ebp]
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+28]

; 274  : 
; 275  : 	// Calculate ghost velocity
; 276  : 	if (TimeStep > SMALL_REAL) {

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81249

; 277  : 		VecMinusVec(&car->Body->Centre.Pos, &car->Body->Centre.OldPos, &car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+40]

; 278  : 		VecDivScalar(&car->Body->Centre.Vel, TimeStep);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+32]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+36]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+36]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+40]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+40]

; 279  : 	} else {

	jmp	SHORT $L81250
$L81249:

; 280  : 		SetVecZero(&car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+32], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+36], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+40], 0
$L81250:

; 281  : 	}
; 282  : 
; 283  : 	lastQuat.v[VX] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[VX]);

	mov	eax, DWORD PTR _lastData$[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	mov	DWORD PTR tv828[ebp], ecx
	fild	DWORD PTR tv828[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$[ebp]

; 284  : 	lastQuat.v[VY] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[VY]);

	mov	eax, DWORD PTR _lastData$[ebp]
	movsx	ecx, BYTE PTR [eax+17]
	mov	DWORD PTR tv830[ebp], ecx
	fild	DWORD PTR tv830[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$[ebp+4]

; 285  : 	lastQuat.v[VZ] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[VZ]);

	mov	eax, DWORD PTR _lastData$[ebp]
	movsx	ecx, BYTE PTR [eax+18]
	mov	DWORD PTR tv832[ebp], ecx
	fild	DWORD PTR tv832[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$[ebp+8]

; 286  : 	lastQuat.v[S] = GHOST_VECTOR_INVSCALE * (REAL)(lastData->Quat.v[S]);

	mov	eax, DWORD PTR _lastData$[ebp]
	movsx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR tv834[ebp], ecx
	fild	DWORD PTR tv834[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _lastQuat$[ebp+12]

; 287  : 	nextQuat.v[VX] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[VX]);

	mov	eax, DWORD PTR _nextData$[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	mov	DWORD PTR tv836[ebp], ecx
	fild	DWORD PTR tv836[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$[ebp]

; 288  : 	nextQuat.v[VY] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[VY]);

	mov	eax, DWORD PTR _nextData$[ebp]
	movsx	ecx, BYTE PTR [eax+17]
	mov	DWORD PTR tv838[ebp], ecx
	fild	DWORD PTR tv838[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$[ebp+4]

; 289  : 	nextQuat.v[VZ] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[VZ]);

	mov	eax, DWORD PTR _nextData$[ebp]
	movsx	ecx, BYTE PTR [eax+18]
	mov	DWORD PTR tv840[ebp], ecx
	fild	DWORD PTR tv840[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$[ebp+8]

; 290  : 	nextQuat.v[S] = GHOST_VECTOR_INVSCALE * (REAL)(nextData->Quat.v[S]);

	mov	eax, DWORD PTR _nextData$[ebp]
	movsx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR tv842[ebp], ecx
	fild	DWORD PTR tv842[ebp]
	fmul	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR _nextQuat$[ebp+12]

; 291  : //	SLerpQuat(&lastQuat, &nextQuat, dt, &car->Body->Centre.Quat);
; 292  : //	CopyQuat(&lastQuat, &car->Body->Centre.Quat);
; 293  : 	LerpQuat(&lastQuat, &nextQuat, dt, &car->Body->Centre.Quat);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _dt$[ebp]
	push	edx
	lea	eax, DWORD PTR _nextQuat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lastQuat$[ebp]
	push	ecx
	call	?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ; LerpQuat
	add	esp, 16					; 00000010H

; 294  : 	NormalizeQuat(&car->Body->Centre.Quat);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+68]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR [eax+80]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$81259[ebp]
	fld	DWORD PTR _qLen$81259[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81261
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$81259[ebp]
	fstp	DWORD PTR _qLen$81259[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _qLen$81259[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+68]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _qLen$81259[ebp]
	fmul	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+72]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _qLen$81259[ebp]
	fmul	DWORD PTR [ecx+76]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+76]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _qLen$81259[ebp]
	fmul	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+80]
$L81261:

; 295  : 	QuatToMat(&car->Body->Centre.Quat, &car->Body->Centre.WMatrix);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 68					; 00000044H
	push	eax
	call	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z ; QuatToMat
	add	esp, 8

; 296  : 
; 297  : 	// Set the wheel positions
; 298  : 	car->Revs = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3504], 0

; 299  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L81262
$L81263:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L81262:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L81264

; 300  : 		car->Wheel[iWheel].Pos = GHOST_WHEEL_INVSCALE * (REAL)lastData->WheelPos[iWheel];

	mov	eax, DWORD PTR _lastData$[ebp]
	add	eax, DWORD PTR _iWheel$[ebp]
	movsx	ecx, BYTE PTR [eax+24]
	mov	DWORD PTR tv883[ebp], ecx
	fild	DWORD PTR tv883[ebp]
	fmul	DWORD PTR __real@3e4ccccd
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1640]

; 301  : 		car->Wheel[iWheel].TurnAngle = GHOST_ANGLE_INVSCALE * (REAL)lastData->WheelAngle[iWheel];

	mov	eax, DWORD PTR _lastData$[ebp]
	add	eax, DWORD PTR _iWheel$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	mov	DWORD PTR tv887[ebp], ecx
	fild	DWORD PTR tv887[ebp]
	fmul	DWORD PTR __real@3e4ccccd
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1852]

; 302  : 		
; 303  : 		// Wheel position
; 304  : 		VecPlusScalarVec(&car->WheelOffset[iWheel], car->Wheel[iWheel].Pos, &DownVec, &dR);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _iWheel$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+ecx+1640]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A
	mov	ecx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [ecx+eax+3184]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _iWheel$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+ecx+1640]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	mov	ecx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [ecx+eax+3188]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _iWheel$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+ecx+1640]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	mov	ecx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [ecx+eax+3192]
	fstp	DWORD PTR _dR$[ebp+8]

; 305  : 		VecMulMat(&dR, &car->Body->Centre.WMatrix, &car->Wheel[iWheel].WPos);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1720]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 100				; 00000064H
	push	ecx
	lea	edx, DWORD PTR _dR$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 306  : 		VecPlusEqVec(&car->Wheel[iWheel].WPos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+eax+1720]
	fadd	DWORD PTR [edx+20]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1720]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+eax+1724]
	fadd	DWORD PTR [edx+24]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1724]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+eax+1728]
	fadd	DWORD PTR [edx+28]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1728]

; 307  : 
; 308  : 		// Calculate wheel angular velocity
; 309  : 		car->Wheel[iWheel].AngVel = VecDotVec(&car->Body->Centre.Vel, &car->Body->Centre.WMatrix.mv[L]) / car->Wheel[iWheel].Radius;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+128]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+132]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	fdiv	DWORD PTR [ecx+eax+1580]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1652]

; 310  : 		car->Wheel[iWheel].AngPos += TimeStep * car->Wheel[iWheel].AngVel;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _iWheel$[ebp]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+ecx+1652]
	mov	ecx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [ecx+eax+1644]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1644]

; 311  : 		GoodWrap(&car->Wheel[iWheel].AngPos, ZERO, FULL_CIRCLE);

	push	1086918619				; 40c90fdbH
	push	0
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1644]
	push	edx
	call	?GoodWrap@@YAMPAMMM@Z			; GoodWrap
	fstp	ST(0)
	add	esp, 12					; 0000000cH

; 312  : 		car->Revs += car->Wheel[iWheel].AngVel;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+3504]
	fadd	DWORD PTR [edx+eax+1652]
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+3504]

; 313  : 		
; 314  : 		// Wheel matrix
; 315  : 		RotationY(&tmpMat, car->Wheel[iWheel].TurnAngle);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1852]
	push	edx
	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	call	?RotationY@@YAXPATMatrixUnion@@M@Z	; RotationY
	add	esp, 8

; 316  : 		MatMulMat(&tmpMat, &car->Body->Centre.WMatrix, &car->Wheel[iWheel].Axes);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1768]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 100				; 00000064H
	push	ecx
	lea	edx, DWORD PTR _tmpMat$[ebp]
	push	edx
	call	?MatMulMat@@YAXPATMatrixUnion@@00@Z	; MatMulMat
	add	esp, 12					; 0000000cH

; 317  : 		RotationX(&tmpMat, car->Wheel[iWheel].AngPos);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1644]
	push	edx
	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	call	?RotationX@@YAXPATMatrixUnion@@M@Z	; RotationX
	add	esp, 8

; 318  : 		MatMulMat(&tmpMat, &car->Wheel[iWheel].Axes, &car->Wheel[iWheel].WMatrix);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1684]
	push	edx
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1768]
	push	edx
	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	call	?MatMulMat@@YAXPATMatrixUnion@@00@Z	; MatMulMat
	add	esp, 12					; 0000000cH

; 319  : 	}

	jmp	$L81263
$L81264:

; 320  : 	car->Revs *= Real(0.25);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3504]
	fmul	DWORD PTR __real@3e800000
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+3504]

; 321  : 
; 322  : 	// set light params
; 323  : 	CopyVec(&car->Body->Centre.Pos, (VEC*)&GhostLight->x);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+8], eax

; 324  : 	GhostLight->r = 0;

	mov	eax, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	DWORD PTR [eax+88], 0

; 325  : 	GhostLight->g = 32;

	mov	eax, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	DWORD PTR [eax+92], 32			; 00000020H

; 326  : 	GhostLight->b = 64;

	mov	eax, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	DWORD PTR [eax+96], 64			; 00000040H

; 327  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InterpGhostData@@YAXPAUCarStruct@@@Z ENDP		; InterpGhostData
_TEXT	ENDS
PUBLIC	?LoadGhostData@@YA_NPAULEVELINFO@@@Z		; LoadGhostData
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_09BBHIDGIA@Ghost?4tad?$AA@		; `string'
PUBLIC	??_C@_09LKDHDEO@Ghost?4dat?$AA@			; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	?GetLevelFilename@@YAPADPADJ@Z:NEAR		; GetLevelFilename
EXTRN	?GameSettings@@3UGAME_SETTINGS@@A:BYTE		; GameSettings
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBHIDGIA@Ghost?4tad?$AA@
CONST	SEGMENT
??_C@_09BBHIDGIA@Ghost?4tad?$AA@ DB 'Ghost.tad', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKDHDEO@Ghost?4dat?$AA@
CONST	SEGMENT
??_C@_09LKDHDEO@Ghost?4dat?$AA@ DB 'Ghost.dat', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadGhostData@@YA_NPAULEVELINFO@@@Z
_TEXT	SEGMENT
_fp$ = -8						; size = 4
_nRead$ = -4						; size = 4
_levelInfo$ = 8						; size = 4
?LoadGhostData@@YA_NPAULEVELINFO@@@Z PROC NEAR		; LoadGhostData, COMDAT

; 337  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 338  : 	size_t	nRead;
; 339  : 	FILE	*fp;
; 340  : 
; 341  : 	// open the ghost data filename
; 342  : 	if (GameSettings.Mirrored)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+16, 0
	je	SHORT $L81276

; 343  : 		fp = fopen(GetLevelFilename(GHOST_FILENAME_MIRRORED, FILENAME_GAME_SETTINGS), "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09BBHIDGIA@Ghost?4tad?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 344  : 	else

	jmp	SHORT $L81279
$L81276:

; 345  : 		fp = fopen(GetLevelFilename(GHOST_FILENAME, FILENAME_GAME_SETTINGS), "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09LKDHDEO@Ghost?4dat?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
$L81279:

; 346  : 
; 347  : 	if (fp == NULL) {

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81281

; 348  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81273
$L81281:

; 349  : 	}
; 350  : 
; 351  : 	// Read the ghost info header
; 352  : 	nRead = fread(GHO_BestGhostInfo, sizeof(GHOST_INFO), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	116					; 00000074H
	mov	ecx, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 353  : 	if (nRead < 1) {

	cmp	DWORD PTR _nRead$[ebp], 1
	jae	SHORT $L81283

; 354  : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 355  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81273
$L81283:

; 356  : 	}
; 357  : 
; 358  : 	// Read the ghost data
; 359  : 	nRead = fread(BestGhostData, sizeof(GHOST_DATA), GHOST_DATA_MAX, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	10000					; 00002710H
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 360  : 	if (nRead < GHOST_DATA_MAX) {

	cmp	DWORD PTR _nRead$[ebp], 10000		; 00002710H
	jae	SHORT $L81285

; 361  : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 362  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81273
$L81285:

; 363  : 	}
; 364  : 
; 365  : 	// Success!
; 366  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 367  : 	return TRUE;

	mov	al, 1
$L81273:

; 368  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadGhostData@@YA_NPAULEVELINFO@@@Z ENDP		; LoadGhostData
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?SaveGhostData@@YA_NPAULEVELINFO@@@Z		; SaveGhostData
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
EXTRN	_fwrite:NEAR
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\ghost.cpp
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SaveGhostData@@YA_NPAULEVELINFO@@@Z
_TEXT	SEGMENT
_fp$ = -8						; size = 4
_nWritten$ = -4						; size = 4
_levelInfo$ = 8						; size = 4
?SaveGhostData@@YA_NPAULEVELINFO@@@Z PROC NEAR		; SaveGhostData, COMDAT

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 379  : 	int		nWritten;
; 380  : 	FILE	*fp;
; 381  : 
; 382  : 	// Make sure there is some ghost data
; 383  : 	if (!GHO_GhostExists) {

	movzx	eax, BYTE PTR ?GHO_GhostExists@@3_NA	; GHO_GhostExists
	test	eax, eax
	jne	SHORT $L81291

; 384  : 		return FALSE;

	xor	al, al
	jmp	$L81288
$L81291:

; 385  : 	}
; 386  : 
; 387  : 	// open the ghost data filename
; 388  : 	if (GameSettings.Mirrored) {

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+16, 0
	je	SHORT $L81292

; 389  : 		fp = fopen(GetLevelFilename(GHOST_FILENAME_MIRRORED, FILENAME_GAME_SETTINGS), "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09BBHIDGIA@Ghost?4tad?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 390  : 	} else {

	jmp	SHORT $L81294
$L81292:

; 391  : 		fp = fopen(GetLevelFilename(GHOST_FILENAME, FILENAME_GAME_SETTINGS), "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09LKDHDEO@Ghost?4dat?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
$L81294:

; 392  : 	}
; 393  : 
; 394  : 	if (fp == NULL) {

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81295

; 395  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81288
$L81295:

; 396  : 	}
; 397  : 
; 398  : 	// write the info 
; 399  : 	nWritten = fwrite(GHO_BestGhostInfo, sizeof(GHOST_INFO), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	116					; 00000074H
	mov	ecx, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nWritten$[ebp], eax

; 400  : 	if (nWritten < 1) {

	cmp	DWORD PTR _nWritten$[ebp], 1
	jge	SHORT $L81297

; 401  : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 402  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81288
$L81297:

; 403  : 	}
; 404  : 
; 405  : 	// write the data
; 406  : 	nWritten = fwrite(BestGhostData, sizeof(GHOST_DATA), GHOST_DATA_MAX, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	10000					; 00002710H
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?BestGhostData@@3PAUGhostDataStruct@@A ; BestGhostData
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nWritten$[ebp], eax

; 407  : 	if (nWritten < GHOST_DATA_MAX) {

	cmp	DWORD PTR _nWritten$[ebp], 10000	; 00002710H
	jge	SHORT $L81299

; 408  : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 409  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81288
$L81299:

; 410  : 	}
; 411  : 
; 412  : 	// Success!
; 413  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 414  : 	return TRUE;

	mov	al, 1
$L81288:

; 415  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SaveGhostData@@YA_NPAULEVELINFO@@@Z ENDP		; SaveGhostData
_TEXT	ENDS
PUBLIC	?InitGhostLight@@YAXXZ				; InitGhostLight
EXTRN	?AllocLight@@YAPAULIGHT@@XZ:NEAR		; AllocLight
; Function compile flags: /Odt /ZI
;	COMDAT ?InitGhostLight@@YAXXZ
_TEXT	SEGMENT
?InitGhostLight@@YAXXZ PROC NEAR			; InitGhostLight, COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 425  : 	if ((GhostLight = AllocLight()))

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	DWORD PTR ?GhostLight@@3PAULIGHT@@A, eax ; GhostLight
	cmp	DWORD PTR ?GhostLight@@3PAULIGHT@@A, 0	; GhostLight
	je	SHORT $L81302

; 426  : 	{
; 427  : 		GhostLight->Reach = 768;

	mov	eax, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	DWORD PTR [eax+12], 1145044992		; 44400000H

; 428  : 		GhostLight->Flag = LIGHT_FIXED | LIGHT_MOVING;

	mov	eax, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	BYTE PTR [eax+100], 3

; 429  : 		GhostLight->Type = LIGHT_OMNI;

	mov	eax, DWORD PTR ?GhostLight@@3PAULIGHT@@A ; GhostLight
	mov	BYTE PTR [eax+101], 0
$L81302:

; 430  : 	}
; 431  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitGhostLight@@YAXXZ ENDP				; InitGhostLight
_TEXT	ENDS
END
