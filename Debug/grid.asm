; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\grid.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@CBHHMMPN@Could?5not?5alloc?5memory?5for?5objec@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GJECKEDO@GRD_AllocGrid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CDFFDALI@GRD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@JIBIIPMG@Could?5not?5alloc?5memory?5for?5objec@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GRD_AllocGrids@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GRD_FreeGrids@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GRD_UpdateObjGrid@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GRD_RemoveObject@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GRD_ResetObjPairs@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GRD_ObjectPair@@YAJPAUobject_def@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GRD_GridNodes@@YAXPAU_AINODE@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?s_PointLine@@YAMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??GRD_FreeGrids@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??GRD_AllocGrids@@YAJXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A			; ObjGrid
PUBLIC	?NodeGrid@@3PAPAU_NODEGRIDUNIT@@A		; NodeGrid
_BSS	SEGMENT
?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A DD 04H DUP (?)		; ObjGrid
?NodeGrid@@3PAPAU_NODEGRIDUNIT@@A DD 04H DUP (?)	; NodeGrid
_BSS	ENDS
PUBLIC	?__LINE__Var@?1??GRD_AllocGrids@@YAJXZ@4JA	; `GRD_AllocGrids'::`2'::__LINE__Var
PUBLIC	??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	??_C@_0CO@CBHHMMPN@Could?5not?5alloc?5memory?5for?5objec@ ; `string'
PUBLIC	??_C@_0O@GJECKEDO@GRD_AllocGrid?$AA@		; `string'
PUBLIC	??_C@_03CDFFDALI@GRD?$AA@			; `string'
PUBLIC	??_C@_0CO@JIBIIPMG@Could?5not?5alloc?5memory?5for?5objec@ ; `string'
PUBLIC	?GRD_AllocGrids@@YAJXZ				; GRD_AllocGrids
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
EXTRN	?Error@@YAXPAD00J@Z:NEAR			; Error
EXTRN	_memset:NEAR
_BSS	SEGMENT
_s_ObjPair DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\grid.cpp
CONST	SEGMENT
??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\grid.'
	DB	'cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GRD_AllocGrids@@YAJXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GRD_AllocGrids@@YAJXZ@4JA DD 04dH	; `GRD_AllocGrids'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CO@CBHHMMPN@Could?5not?5alloc?5memory?5for?5objec@
CONST	SEGMENT
??_C@_0CO@CBHHMMPN@Could?5not?5alloc?5memory?5for?5objec@ DB 'Could not a'
	DB	'lloc memory for object grid system', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GJECKEDO@GRD_AllocGrid?$AA@
CONST	SEGMENT
??_C@_0O@GJECKEDO@GRD_AllocGrid?$AA@ DB 'GRD_AllocGrid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CDFFDALI@GRD?$AA@
CONST	SEGMENT
??_C@_03CDFFDALI@GRD?$AA@ DB 'GRD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JIBIIPMG@Could?5not?5alloc?5memory?5for?5objec@
CONST	SEGMENT
??_C@_0CO@JIBIIPMG@Could?5not?5alloc?5memory?5for?5objec@ DB 'Could not a'
	DB	'lloc memory for object pair buffer', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?GRD_AllocGrids@@YAJXZ
_TEXT	SEGMENT
_ii$ = -4						; size = 4
?GRD_AllocGrids@@YAJXZ PROC NEAR			; GRD_AllocGrids, COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 78   : 	long	ii;
; 79   : 
; 80   : 	for (ii = 0; ii < MAX_GRIDS; ii++)

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L80919
$L80920:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L80919:
	cmp	DWORD PTR _ii$[ebp], 4
	jge	$L80921

; 81   : 	{
; 82   : 		ObjGrid[ii] = (OBJGRIDUNIT *)malloc(OBJ_GRID_SIZE * sizeof(OBJGRIDUNIT));

	push	OFFSET FLAT:??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??GRD_AllocGrids@@YAJXZ@4JA
	add	eax, 5
	push	eax
	push	4096					; 00001000H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[ecx*4], eax

; 83   : 		if (!ObjGrid[ii])

	mov	eax, DWORD PTR _ii$[ebp]
	cmp	DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[eax*4], 0
	jne	SHORT $L80926

; 84   : 		{
; 85   : 			Error("GRD", "GRD_AllocGrid", "Could not alloc memory for object grid system", 1);		

	push	1
	push	OFFSET FLAT:??_C@_0CO@CBHHMMPN@Could?5not?5alloc?5memory?5for?5objec@
	push	OFFSET FLAT:??_C@_0O@GJECKEDO@GRD_AllocGrid?$AA@
	push	OFFSET FLAT:??_C@_03CDFFDALI@GRD?$AA@
	call	?Error@@YAXPAD00J@Z			; Error
	add	esp, 16					; 00000010H

; 86   : 			return(FALSE);

	xor	eax, eax
	jmp	$L80917
$L80926:

; 87   : 		}
; 88   : 		memset(ObjGrid[ii], 0, OBJ_GRID_SIZE * sizeof(OBJGRIDUNIT));		// Initialise pointers to NULL (memset, rather than memclr for N64 compatability)

	push	4096					; 00001000H
	push	0
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[eax*4]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 89   : 
; 90   : 		NodeGrid[ii] = (NODEGRIDUNIT *)malloc(NODE_GRID_SIZE * sizeof(NODEGRIDUNIT));

	push	OFFSET FLAT:??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??GRD_AllocGrids@@YAJXZ@4JA
	add	eax, 13					; 0000000dH
	push	eax
	push	4096					; 00001000H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	DWORD PTR ?NodeGrid@@3PAPAU_NODEGRIDUNIT@@A[ecx*4], eax

; 91   : 		if (!NodeGrid[ii])

	mov	eax, DWORD PTR _ii$[ebp]
	cmp	DWORD PTR ?NodeGrid@@3PAPAU_NODEGRIDUNIT@@A[eax*4], 0
	jne	SHORT $L80933

; 92   : 		{
; 93   : 			Error("GRD", "GRD_AllocGrid", "Could not alloc memory for object grid system", 1);		

	push	1
	push	OFFSET FLAT:??_C@_0CO@CBHHMMPN@Could?5not?5alloc?5memory?5for?5objec@
	push	OFFSET FLAT:??_C@_0O@GJECKEDO@GRD_AllocGrid?$AA@
	push	OFFSET FLAT:??_C@_03CDFFDALI@GRD?$AA@
	call	?Error@@YAXPAD00J@Z			; Error
	add	esp, 16					; 00000010H

; 94   : 			return(FALSE);

	xor	eax, eax
	jmp	SHORT $L80917
$L80933:

; 95   : 		}
; 96   : 		memset(NodeGrid[ii], 0, NODE_GRID_SIZE * sizeof(NODEGRIDUNIT));		// Initialise pointers to NULL (memset, rather than memclr for N64 compatability)

	push	4096					; 00001000H
	push	0
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR ?NodeGrid@@3PAPAU_NODEGRIDUNIT@@A[eax*4]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 97   : 	}

	jmp	$L80920
$L80921:

; 98   : 
; 99   : 	s_ObjPair = (char *)malloc(MAX_OBJECTS * MAX_OBJECTS);

	push	OFFSET FLAT:??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??GRD_AllocGrids@@YAJXZ@4JA
	add	eax, 22					; 00000016H
	push	eax
	push	16384					; 00004000H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _s_ObjPair, eax

; 100  : 	if (!s_ObjPair)

	cmp	DWORD PTR _s_ObjPair, 0
	jne	SHORT $L80936

; 101  : 	{
; 102  : 		Error("GRD", "GRD_AllocGrid", "Could not alloc memory for object pair buffer", 1);		

	push	1
	push	OFFSET FLAT:??_C@_0CO@JIBIIPMG@Could?5not?5alloc?5memory?5for?5objec@
	push	OFFSET FLAT:??_C@_0O@GJECKEDO@GRD_AllocGrid?$AA@
	push	OFFSET FLAT:??_C@_03CDFFDALI@GRD?$AA@
	call	?Error@@YAXPAD00J@Z			; Error
	add	esp, 16					; 00000010H

; 103  : 		return(FALSE);

	xor	eax, eax
	jmp	SHORT $L80917
$L80936:

; 104  : 	}
; 105  : 	memset(s_ObjPair, 0, MAX_OBJECTS * MAX_OBJECTS);

	push	16384					; 00004000H
	push	0
	mov	eax, DWORD PTR _s_ObjPair
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 106  : 
; 107  : 	return (TRUE);

	mov	eax, 1
$L80917:

; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GRD_AllocGrids@@YAJXZ ENDP				; GRD_AllocGrids
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??GRD_FreeGrids@@YAXXZ@4JA	; `GRD_FreeGrids'::`2'::__LINE__Var
PUBLIC	?GRD_FreeGrids@@YAXXZ				; GRD_FreeGrids
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??GRD_FreeGrids@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GRD_FreeGrids@@YAXXZ@4JA DD 077H	; `GRD_FreeGrids'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?GRD_FreeGrids@@YAXXZ
_TEXT	SEGMENT
_ii$ = -4						; size = 4
?GRD_FreeGrids@@YAXXZ PROC NEAR				; GRD_FreeGrids, COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 120  : 	long	ii;
; 121  : 
; 122  : 	for (ii = 0; ii < MAX_GRIDS; ii++)

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L80942
$L80943:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L80942:
	cmp	DWORD PTR _ii$[ebp], 4
	jge	SHORT $L80944

; 123  : 	{
; 124  : 		free(ObjGrid[ii]);

	push	OFFSET FLAT:??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??GRD_FreeGrids@@YAXXZ@4JA
	add	eax, 5
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[ecx*4]
	push	edx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 125  : 		free(NodeGrid[ii]);

	push	OFFSET FLAT:??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??GRD_FreeGrids@@YAXXZ@4JA
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR ?NodeGrid@@3PAPAU_NODEGRIDUNIT@@A[ecx*4]
	push	edx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 126  : 	}

	jmp	SHORT $L80943
$L80944:

; 127  : 	free(s_ObjPair);

	push	OFFSET FLAT:??_C@_0IJ@PNNPNFEI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??GRD_FreeGrids@@YAXXZ@4JA
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _s_ObjPair
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GRD_FreeGrids@@YAXXZ ENDP				; GRD_FreeGrids
_TEXT	ENDS
PUBLIC	__real@47000000
PUBLIC	?GRD_UpdateObjGrid@@YAXXZ			; GRD_UpdateObjGrid
EXTRN	__ftol2:NEAR
EXTRN	__fltused:NEAR
EXTRN	?OBJ_ObjectHead@@3PAUobject_def@@A:DWORD	; OBJ_ObjectHead
;	COMDAT __real@47000000
CONST	SEGMENT
__real@47000000 DD 047000000r			; 32768
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?GRD_UpdateObjGrid@@YAXXZ
_TEXT	SEGMENT
_TempObj$ = -36						; size = 4
_Obj$ = -32						; size = 4
_Grid$ = -28						; size = 4
_zOff$ = -24						; size = 4
_xOff$ = -20						; size = 4
_zShift$ = -16						; size = 4
_xShift$ = -12						; size = 4
_z$ = -8						; size = 4
_x$ = -4						; size = 4
?GRD_UpdateObjGrid@@YAXXZ PROC NEAR			; GRD_UpdateObjGrid, COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 141  : 	long	x, z;
; 142  : 	long   	xShift, zShift;
; 143  : 	long 	xOff, zOff;
; 144  : 	long   	Grid;
; 145  : 	OBJECT 	*Obj;
; 146  : 	OBJECT 	*TempObj;
; 147  : 
; 148  : 	for (zShift = 0; zShift < MAX_SHIFTS; zShift++)

	mov	DWORD PTR _zShift$[ebp], 0
	jmp	SHORT $L80958
$L80959:
	mov	eax, DWORD PTR _zShift$[ebp]
	add	eax, 1
	mov	DWORD PTR _zShift$[ebp], eax
$L80958:
	cmp	DWORD PTR _zShift$[ebp], 2
	jge	$L80948

; 149  : 	{
; 150  : 		zOff = zShift * OBJ_SHIFT_OFFSET;

	mov	eax, DWORD PTR _zShift$[ebp]
	shl	eax, 10					; 0000000aH
	mov	DWORD PTR _zOff$[ebp], eax

; 151  : 		for (xShift = 0; xShift < MAX_SHIFTS; xShift++)

	mov	DWORD PTR _xShift$[ebp], 0
	jmp	SHORT $L80961
$L80962:
	mov	eax, DWORD PTR _xShift$[ebp]
	add	eax, 1
	mov	DWORD PTR _xShift$[ebp], eax
$L80961:
	cmp	DWORD PTR _xShift$[ebp], 2
	jge	$L80963

; 152  : 		{
; 153  : 			xOff = xShift * OBJ_SHIFT_OFFSET;

	mov	eax, DWORD PTR _xShift$[ebp]
	shl	eax, 10					; 0000000aH
	mov	DWORD PTR _xOff$[ebp], eax

; 154  : 			Grid = xShift + (zShift * MAX_SHIFTS);

	mov	eax, DWORD PTR _zShift$[ebp]
	mov	ecx, DWORD PTR _xShift$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _Grid$[ebp], edx

; 155  : 			for (Obj = OBJ_ObjectHead; Obj; Obj = Obj->next)

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _Obj$[ebp], eax
	jmp	SHORT $L80964
$L80965:
	mov	eax, DWORD PTR _Obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _Obj$[ebp], ecx
$L80964:
	cmp	DWORD PTR _Obj$[ebp], 0
	je	$L80966

; 156  : 			{										   									// First off, generate x & z indices for grid access
; 157  : 				x = (long)(Obj->body.Centre.Pos.v[X] + 32768 - xOff) / OBJ_UNIT_SIZE;  	// !MT! This needs to be done with shifts on PSX

	mov	eax, DWORD PTR _Obj$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR __real@47000000
	fisub	DWORD PTR _xOff$[ebp]
	call	__ftol2
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	DWORD PTR _x$[ebp], eax

; 158  : 				z = (long)(Obj->body.Centre.Pos.v[Z] + 32768 - zOff) / OBJ_UNIT_SIZE;  	// !MT! So OBJ_UNIT_SIZE would need to be a power of 2

	mov	eax, DWORD PTR _Obj$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR __real@47000000
	fisub	DWORD PTR _zOff$[ebp]
	call	__ftol2
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	mov	DWORD PTR _z$[ebp], eax

; 159  : 				if (x < 0) continue;													// Bounds check x & z

	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $L80969
	jmp	SHORT $L80965
$L80969:

; 160  : 				if (z < 0) continue;

	cmp	DWORD PTR _z$[ebp], 0
	jge	SHORT $L80970
	jmp	SHORT $L80965
$L80970:

; 161  : 				if (x > (OBJ_GRID_WIDTH - 1)) continue;

	cmp	DWORD PTR _x$[ebp], 31			; 0000001fH
	jle	SHORT $L80971
	jmp	SHORT $L80965
$L80971:

; 162  : 				if (z > (OBJ_GRID_WIDTH - 1)) continue;

	cmp	DWORD PTR _z$[ebp], 31			; 0000001fH
	jle	SHORT $L80972
	jmp	SHORT $L80965
$L80972:

; 163  : 				if ((Obj->flag.IsInGrid) && (x == Obj->GridX[Grid])
; 164  : 				   && (z == Obj->GridZ[Grid])) continue;

	mov	eax, DWORD PTR _Obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $L80973
	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+716]
	cmp	DWORD PTR _x$[ebp], edx
	jne	SHORT $L80973
	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+724]
	cmp	DWORD PTR _z$[ebp], edx
	jne	SHORT $L80973
	jmp	$L80965
$L80973:

; 165  : 
; 166  : 				if (ObjGrid[Grid][x + (z * OBJ_GRID_WIDTH)].ObjHead)

	mov	eax, DWORD PTR _z$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _Grid$[ebp]
	mov	edx, DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[ecx*4]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L80974

; 167  : 				{
; 168  : 					TempObj = ObjGrid[Grid][x + (z * OBJ_GRID_WIDTH)].ObjHead;

	mov	eax, DWORD PTR _z$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _Grid$[ebp]
	mov	edx, DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[ecx*4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _TempObj$[ebp], eax

; 169  : 					ObjGrid[Grid][x + (z * OBJ_GRID_WIDTH)].ObjHead = Obj;

	mov	eax, DWORD PTR _z$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _Grid$[ebp]
	mov	edx, DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[ecx*4]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 170  : 					Obj->GridNext[Grid] = TempObj;

	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	edx, DWORD PTR _TempObj$[ebp]
	mov	DWORD PTR [ecx+eax*4+748], edx

; 171  : 					Obj->GridPrev[Grid] = NULL;

	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	DWORD PTR [ecx+eax*4+732], 0

; 172  : 					TempObj->GridPrev[Grid] = Obj;

	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _TempObj$[ebp]
	mov	edx, DWORD PTR _Obj$[ebp]
	mov	DWORD PTR [ecx+eax*4+732], edx

; 173  : 				}
; 174  : 				else

	jmp	SHORT $L80975
$L80974:

; 175  : 				{
; 176  : 					ObjGrid[Grid][x + (z * OBJ_GRID_WIDTH)].ObjHead = Obj;

	mov	eax, DWORD PTR _z$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _Grid$[ebp]
	mov	edx, DWORD PTR ?ObjGrid@@3PAPAU_OBJGRIDUNIT@@A[ecx*4]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 177  : 					Obj->GridPrev[Grid] = NULL;

	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	DWORD PTR [ecx+eax*4+732], 0

; 178  : 					Obj->GridNext[Grid] = NULL;

	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	DWORD PTR [ecx+eax*4+748], 0
$L80975:

; 179  : 				}
; 180  : 				Obj->GridX[Grid] = (unsigned short)x;							// Update current grid location

	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	dx, WORD PTR _x$[ebp]
	mov	WORD PTR [ecx+eax*2+716], dx

; 181  : 				Obj->GridZ[Grid] = (unsigned short)z;

	mov	eax, DWORD PTR _Grid$[ebp]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	dx, WORD PTR _z$[ebp]
	mov	WORD PTR [ecx+eax*2+724], dx

; 182  : 				Obj->flag.IsInGrid = 1;											// Mark object as being in grid

	mov	eax, DWORD PTR _Obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	or	ecx, 4
	mov	edx, DWORD PTR _Obj$[ebp]
	mov	DWORD PTR [edx+580], ecx

; 183  : 			}

	jmp	$L80965
$L80966:

; 184  : 		}

	jmp	$L80962
$L80963:

; 185  : 	}

	jmp	$L80959
$L80948:

; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GRD_UpdateObjGrid@@YAXXZ ENDP				; GRD_UpdateObjGrid
_TEXT	ENDS
PUBLIC	?GRD_RemoveObject@@YAXPAUobject_def@@@Z		; GRD_RemoveObject
; Function compile flags: /Odt /ZI
;	COMDAT ?GRD_RemoveObject@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_Obj$ = 8						; size = 4
?GRD_RemoveObject@@YAXPAUobject_def@@@Z PROC NEAR	; GRD_RemoveObject, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 192  : #if 0
; 193  : 	long	ii;
; 194  : 	long	Offset;
; 195  : 
; 196  : 	Assert((bool)Obj->flag.IsInGrid);
; 197  : 
; 198  : 	for (ii = 0; ii < MAX_GRIDS; ii++)
; 199  : 	{
; 200  : 		Offset = Obj->GridX[ii] + (Obj->GridZ[ii] * OBJ_GRID_WIDTH);
; 201  : 		if (ObjGrid[ii][Offset].ObjHead)
; 202  : 		{																				// Remove object from this list
; 203  : 			if (Obj->GridPrev[ii] == NULL)
; 204  : 			{																			// Object is at head of list
; 205  : 				if (Obj->GridNext[ii] == NULL)
; 206  : 				{																		// Object is only one in list
; 207  : 					ObjGrid[ii][Offset].ObjHead = NULL;
; 208  : 				}
; 209  : 				else
; 210  : 				{
; 211  : 					Obj->GridNext[ii]->GridPrev[ii] = NULL;
; 212  : 					ObjGrid[ii][Offset].ObjHead = Obj->GridNext[ii];
; 213  : 				}
; 214  : 			}
; 215  : 			else
; 216  : 			{																			// Object is mid-list
; 217  : 				Obj->GridPrev[ii]->GridNext[ii] = Obj->GridNext[ii];
; 218  : 				if (Obj->GridNext[ii] != NULL)
; 219  : 				{
; 220  : 					Obj->GridNext[ii]->GridPrev[ii] = Obj->GridPrev[ii];
; 221  : 				}
; 222  : 			}
; 223  : 		}
; 224  : 	}
; 225  : 	Obj->flag.IsInGrid = 0;															// Mark object as not in grid yet
; 226  : #endif
; 227  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GRD_RemoveObject@@YAXPAUobject_def@@@Z ENDP		; GRD_RemoveObject
_TEXT	ENDS
PUBLIC	?GRD_ResetObjPairs@@YAXXZ			; GRD_ResetObjPairs
; Function compile flags: /Odt /ZI
;	COMDAT ?GRD_ResetObjPairs@@YAXXZ
_TEXT	SEGMENT
?GRD_ResetObjPairs@@YAXXZ PROC NEAR			; GRD_ResetObjPairs, COMDAT

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 239  : 	memset(s_ObjPair, 0, MAX_OBJECTS * MAX_OBJECTS);

	push	16384					; 00004000H
	push	0
	mov	eax, DWORD PTR _s_ObjPair
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 240  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GRD_ResetObjPairs@@YAXXZ ENDP				; GRD_ResetObjPairs
_TEXT	ENDS
PUBLIC	?GRD_ObjectPair@@YAJPAUobject_def@@0@Z		; GRD_ObjectPair
; Function compile flags: /Odt /ZI
;	COMDAT ?GRD_ObjectPair@@YAJPAUobject_def@@0@Z
_TEXT	SEGMENT
_jj$ = -8						; size = 4
_ii$ = -4						; size = 4
_Obj1$ = 8						; size = 4
_Obj2$ = 12						; size = 4
?GRD_ObjectPair@@YAJPAUobject_def@@0@Z PROC NEAR	; GRD_ObjectPair, COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 246  : 	long	ii, jj;
; 247  : 
; 248  : 	ii = Obj1->ObjID;

	mov	eax, DWORD PTR _Obj1$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	mov	DWORD PTR _ii$[ebp], ecx

; 249  : 	jj = Obj2->ObjID;

	mov	eax, DWORD PTR _Obj2$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	mov	DWORD PTR _jj$[ebp], ecx

; 250  : 
; 251  : 	if (s_ObjPair[ii + (jj * MAX_OBJECTS)])

	mov	eax, DWORD PTR _jj$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _s_ObjPair
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $L80990

; 252  : 	{
; 253  : 		return(TRUE);

	mov	eax, 1
	jmp	SHORT $L80987
$L80990:

; 254  : 	}
; 255  : 	else
; 256  : 	{
; 257  : 		s_ObjPair[ii + (jj * MAX_OBJECTS)] = (char)0xFF;

	mov	eax, DWORD PTR _jj$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _s_ObjPair
	mov	BYTE PTR [ecx+eax], -1

; 258  : 		return(FALSE);

	xor	eax, eax
$L80987:

; 259  : 	}
; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GRD_ObjectPair@@YAJPAUobject_def@@0@Z ENDP		; GRD_ObjectPair
_TEXT	ENDS
PUBLIC	?GRD_GridNodes@@YAXPAU_AINODE@@J@Z		; GRD_GridNodes
; Function compile flags: /Odt /ZI
;	COMDAT ?GRD_GridNodes@@YAXPAU_AINODE@@J@Z
_TEXT	SEGMENT
_Src$ = 8						; size = 4
_Num$ = 12						; size = 4
?GRD_GridNodes@@YAXPAU_AINODE@@J@Z PROC NEAR		; GRD_GridNodes, COMDAT

; 276  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 277  : /*	long	ii;
; 278  : 	long	Include;
; 279  : 	REAL	xUnit, zUnit;
; 280  : 	REAL	x0, z0, x1, z1;
; 281  : 	long	xCnt, zCnt, nodeCnt;
; 282  : 	long   	xShift, zShift;
; 283  : 	long 	xOff, zOff;
; 284  : 	long   	Grid;
; 285  : 	AINODE 	*Node;
; 286  : 	AINODE 	*TempNode;
; 287  : 
; 288  : 	for (zShift = 0; zShift < MAX_SHIFTS; zShift++)
; 289  : 	{
; 290  : 		zOff = zShift * NODE_SHIFT_OFFSET;
; 291  : 		for (xShift = 0; xShift < MAX_SHIFTS; xShift++)
; 292  : 		{
; 293  : 			xOff = xShift * NODE_SHIFT_OFFSET;
; 294  : 			Grid = xShift + (zShift * MAX_SHIFTS);
; 295  : 			for (zCnt = 0; zCnt < NODE_GRID_WIDTH; zCnt++)
; 296  : 			{
; 297  : 				zUnit = (REAL)(zCnt * NODE_UNIT_SIZE) - 32768 + zOff;
; 298  : 				for (xCnt = 0; xCnt < NODE_GRID_WIDTH; xCnt++)
; 299  : 				{
; 300  : 					xUnit = (REAL)(xCnt * NODE_UNIT_SIZE) - 32768 + xOff;
; 301  : 					for (nodeCnt = 0, Node = Src; nodeCnt < Num; nodeCnt++, Node++)
; 302  : 					{
; 303  : 						Include = FALSE;
; 304  : 
; 305  : 						// Check if either node vertex is inside this grid square
; 306  : 						x0 = Node->Node[0].Pos.v[X];
; 307  : 						z0 = Node->Node[0].Pos.v[Z];
; 308  : 						x1 = Node->Node[1].Pos.v[X];
; 309  : 						z1 = Node->Node[1].Pos.v[Z];
; 310  : 						if ((x0 >= xUnit) && (x0 < (xUnit + NODE_UNIT_SIZE)) && (z0 >= zUnit) && (z0 < (zUnit + NODE_UNIT_SIZE))) Include = TRUE;
; 311  : 						if ((x1 >= xUnit) && (x1 < (xUnit + NODE_UNIT_SIZE)) && (z1 >= zUnit) && (z1 < (zUnit + NODE_UNIT_SIZE))) Include = TRUE;
; 312  : 
; 313  : 						if(!Include)
; 314  : 						{
; 315  : 							// Check for node/grid line intersections
; 316  : 							if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit + NODE_GRID_WIDTH, zUnit)) { Include = TRUE; }
; 317  : 							if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit + NODE_GRID_WIDTH, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 318  : 							if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 319  : 							if (s_LineIntersect(x0, z0, x1, z1, xUnit + NODE_GRID_WIDTH, zUnit, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 320  : 
; 321  : 							for (ii = 0; ii < MAX_AINODE_LINKS; ii++)
; 322  : 							{	
; 323  : 								if (!Node->Next[ii]) continue;
; 324  : 								if(!Include)
; 325  : 								{
; 326  : 									x0 = Node->Node[0].Pos.v[X];
; 327  : 									z0 = Node->Node[0].Pos.v[Z];
; 328  : 									x1 = Node->Next[ii]->Node[1].Pos.v[X];
; 329  : 									z1 = Node->Next[ii]->Node[1].Pos.v[Z];
; 330  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit + NODE_GRID_WIDTH, zUnit)) { Include = TRUE; }
; 331  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit + NODE_GRID_WIDTH, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 332  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 333  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit + NODE_GRID_WIDTH, zUnit, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 334  : 								}
; 335  : 								if(!Include)
; 336  : 								{
; 337  : 									x0 = Node->Next[ii]->Node[0].Pos.v[X];
; 338  : 									z0 = Node->Next[ii]->Node[0].Pos.v[Z];
; 339  : 									x1 = Node->Next[ii]->Node[1].Pos.v[X];
; 340  : 									z1 = Node->Next[ii]->Node[1].Pos.v[Z];
; 341  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit + NODE_GRID_WIDTH, zUnit)) { Include = TRUE; }
; 342  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit + NODE_GRID_WIDTH, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 343  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 344  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit + NODE_GRID_WIDTH, zUnit, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 345  : 								}
; 346  : 								if(!Include)
; 347  : 								{
; 348  : 									x0 = Node->Next[ii]->Node[1].Pos.v[X];
; 349  : 									z0 = Node->Next[ii]->Node[1].Pos.v[Z];
; 350  : 									x1 = Node->Node[1].Pos.v[X];
; 351  : 									z1 = Node->Node[1].Pos.v[Z];
; 352  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit + NODE_GRID_WIDTH, zUnit)) { Include = TRUE; }
; 353  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit + NODE_GRID_WIDTH, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 354  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit, zUnit, xUnit, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 355  : 									if (s_LineIntersect(x0, z0, x1, z1, xUnit + NODE_GRID_WIDTH, zUnit, xUnit + NODE_GRID_WIDTH, zUnit + NODE_GRID_WIDTH)) { Include = TRUE; }
; 356  : 								}
; 357  : 							}
; 358  : 						}
; 359  : 
; 360  : 						if(!Include)
; 361  : 						{
; 362  : 							for (ii = 0; ii < MAX_AINODE_LINKS; ii++)
; 363  : 							{
; 364  : 								Include = FALSE;
; 365  : 								// This node and each forward node is used to form a polygon, and each grid square vertex is tested against
; 366  : 								// it to see if the two intersect - if they do then the nodes are added.
; 367  : 								if (!Node->Next[ii]) continue;
; 368  : 								if (s_PointInNodePoly(xUnit, zUnit, Node, ii))
; 369  : 								{
; 370  : 									Include = TRUE;
; 371  : 									break;
; 372  : 								}
; 373  : 								if (s_PointInNodePoly(xUnit + NODE_UNIT_SIZE, zUnit, Node, ii))
; 374  : 								{
; 375  : 									Include = TRUE;
; 376  : 									break;
; 377  : 								}
; 378  : 								if (s_PointInNodePoly(xUnit, zUnit + NODE_UNIT_SIZE, Node, ii))
; 379  : 								{
; 380  : 									Include = TRUE;
; 381  : 									break;
; 382  : 								}
; 383  : 								if (s_PointInNodePoly(xUnit + NODE_UNIT_SIZE, zUnit + NODE_UNIT_SIZE, Node, ii))
; 384  : 								{
; 385  : 									Include = TRUE;
; 386  : 									break;
; 387  : 								}
; 388  : 							}
; 389  : 						}
; 390  : 						
; 391  : 						if (Include)
; 392  : 						{
; 393  : 							if (NodeGrid[Grid][xCnt + (zCnt * NODE_GRID_WIDTH)].NodeHead)
; 394  : 							{
; 395  :  								for (TempNode = NodeGrid[Grid][xCnt + (zCnt * NODE_GRID_WIDTH)].NodeHead; TempNode; TempNode = TempNode->GridNext[Grid])
; 396  : 								{
; 397  : 									if (TempNode == Node)
; 398  : 									{
; 399  : 										Include = FALSE;
; 400  : 									}
; 401  : 								}
; 402  : 							}
; 403  : 
; 404  : 							if (Include)
; 405  : 							{
; 406  : 								if (NodeGrid[Grid][xCnt + (zCnt * NODE_GRID_WIDTH)].NodeHead)
; 407  : 								{
; 408  : 									TempNode = NodeGrid[Grid][xCnt + (zCnt * NODE_GRID_WIDTH)].NodeHead;
; 409  : 									NodeGrid[Grid][xCnt + (zCnt * NODE_GRID_WIDTH)].NodeHead = Node;
; 410  : 									Node->GridNext[Grid] = TempNode;
; 411  : 									Node->GridPrev[Grid] = NULL;
; 412  : 									TempNode->GridPrev[Grid] = Node;
; 413  : 								}
; 414  : 								else
; 415  : 								{
; 416  : 									NodeGrid[Grid][xCnt + (zCnt * NODE_GRID_WIDTH)].NodeHead = Node;
; 417  : 									Node->GridPrev[Grid] = NULL;
; 418  : 									Node->GridNext[Grid] = NULL;
; 419  : 								}
; 420  : 							}
; 421  : 						}
; 422  : 					}
; 423  : 				}
; 424  : 			}
; 425  : 		}
; 426  : 	}*/
; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GRD_GridNodes@@YAXPAU_AINODE@@J@Z ENDP			; GRD_GridNodes
_TEXT	ENDS
END
