; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\ainode.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@MKKNDDPP@Couldn?8t?5alloc?5memory?5for?5AI?5nod@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NEFBJFKJ@Warning?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@BCCLPHDD@AI?5node?5?$CFld?5is?5outside?5all?5AI?5zo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadAiNodes@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeAiNodes@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ZoneAiNodes@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AIN_NearestNode@@YAPAU_AINODE@@PAUPlayerStruct@@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AIN_GetForwardNode@@YAPAU_AINODE@@PAUPlayerStruct@@MPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AIN_PriChoice@@YAJPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??ZoneAiNodes@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??FreeAiNodes@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadAiNodes@@YAXPAD@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?AiNode@@3PAU_AINODE@@A				; AiNode
PUBLIC	?AiNodeZone@@3PAUAINODE_ZONE@@A			; AiNodeZone
PUBLIC	?AiNodeNum@@3JA					; AiNodeNum
PUBLIC	?AiStartNode@@3JA				; AiStartNode
PUBLIC	?AiNodeTotalDist@@3MA				; AiNodeTotalDist
_BSS	SEGMENT
?AiNode@@3PAU_AINODE@@A DD 01H DUP (?)			; AiNode
?AiNodeZone@@3PAUAINODE_ZONE@@A DD 01H DUP (?)		; AiNodeZone
?AiNodeNum@@3JA DD 01H DUP (?)				; AiNodeNum
?AiStartNode@@3JA DD 01H DUP (?)			; AiStartNode
?AiNodeTotalDist@@3MA DD 01H DUP (?)			; AiNodeTotalDist
_BSS	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?__LINE__Var@?1??LoadAiNodes@@YAXPAD@Z@4JA	; `LoadAiNodes'::`2'::__LINE__Var
PUBLIC	??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?LoadAiNodes@@YAXPAD@Z				; LoadAiNodes
PUBLIC	__real@40000000
PUBLIC	__real@3f800000
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	__fltused:NEAR
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
;	COMDAT ??_C@_02JDPG@rb?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\ainode.cpp
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\ainod'
	DB	'e.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??LoadAiNodes@@YAXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadAiNodes@@YAXPAD@Z@4JA DD 02dH	; `LoadAiNodes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadAiNodes@@YAXPAD@Z
_TEXT	SEGMENT
__mul$81089 = -92					; size = 4
_fan$ = -88						; size = 76
_fp$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?LoadAiNodes@@YAXPAD@Z PROC NEAR			; LoadAiNodes, COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi

; 46   : 	long 		i, j;
; 47   : 	FILE 		*fp;
; 48   : 	FILE_AINODE fan;
; 49   : 
; 50   : // open ai node file
; 51   : 
; 52   : 	AiNode = NULL;

	mov	DWORD PTR ?AiNode@@3PAU_AINODE@@A, 0	; AiNode

; 53   : 	AiNodeNum = 0;

	mov	DWORD PTR ?AiNodeNum@@3JA, 0		; AiNodeNum

; 54   : 
; 55   : 	fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 56   : 	if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81079
	jmp	$L81073
$L81079:

; 57   : 
; 58   : // alloc ram
; 59   : 
; 60   : 	fread(&AiNodeNum, sizeof(AiNodeNum), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	push	OFFSET FLAT:?AiNodeNum@@3JA		; AiNodeNum
	call	_fread
	add	esp, 16					; 00000010H

; 61   : 	if (!AiNodeNum) return;

	cmp	DWORD PTR ?AiNodeNum@@3JA, 0		; AiNodeNum
	jne	SHORT $L81080
	jmp	$L81073
$L81080:

; 62   : 
; 63   : 	AiNode = (AINODE*)malloc(sizeof(AINODE) * AiNodeNum);

	push	OFFSET FLAT:??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadAiNodes@@YAXPAD@Z@4JA
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR ?AiNodeNum@@3JA		; AiNodeNum
	imul	ecx, 104				; 00000068H
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?AiNode@@3PAU_AINODE@@A, eax	; AiNode

; 64   : 	if (!AiNode)

	cmp	DWORD PTR ?AiNode@@3PAU_AINODE@@A, 0	; AiNode
	jne	SHORT $L81085

; 65   : 	{
; 66   : 		AiNodeNum = 0;

	mov	DWORD PTR ?AiNodeNum@@3JA, 0		; AiNodeNum

; 67   : 		return;

	jmp	$L81073
$L81085:

; 68   : 	}
; 69   : 
; 70   : // loop thru all ai nodes
; 71   : 
; 72   : 	for (i = 0 ; i < AiNodeNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81086
$L81087:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81086:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?AiNodeNum@@3JA		; AiNodeNum
	jge	$L81088

; 73   : 	{
; 74   : 
; 75   : // load one file ai node
; 76   : 
; 77   : 		fread(&fan, sizeof(fan), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	76					; 0000004cH
	lea	ecx, DWORD PTR _fan$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 78   : 
; 79   : // setup ai node
; 80   : 
; 81   : 		AiNode[i].Node[0] = fan.Node[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	lea	edx, DWORD PTR [ecx+eax+36]
	mov	eax, DWORD PTR _fan$[ebp+44]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _fan$[ebp+48]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _fan$[ebp+52]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _fan$[ebp+56]
	mov	DWORD PTR [edx+12], ecx

; 82   : 		AiNode[i].Node[1] = fan.Node[1];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	lea	edx, DWORD PTR [ecx+eax+52]
	mov	eax, DWORD PTR _fan$[ebp+60]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _fan$[ebp+64]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _fan$[ebp+68]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _fan$[ebp+72]
	mov	DWORD PTR [edx+12], ecx

; 83   : 
; 84   : 		AiNode[i].Centre.v[X] = (fan.Node[0].Pos.v[X] + fan.Node[1].Pos.v[X]) / 2;

	fld	DWORD PTR _fan$[ebp+48]
	fadd	DWORD PTR _fan$[ebp+64]
	fdiv	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [ecx+eax+72]

; 85   : 		AiNode[i].Centre.v[Y] = (fan.Node[0].Pos.v[Y] + fan.Node[1].Pos.v[Y]) / 2;

	fld	DWORD PTR _fan$[ebp+52]
	fadd	DWORD PTR _fan$[ebp+68]
	fdiv	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [ecx+eax+76]

; 86   : 		AiNode[i].Centre.v[Z] = (fan.Node[0].Pos.v[Z] + fan.Node[1].Pos.v[Z]) / 2;

	fld	DWORD PTR _fan$[ebp+56]
	fadd	DWORD PTR _fan$[ebp+72]
	fdiv	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [ecx+eax+80]

; 87   : 		AiNode[i].RVec.v[X] = fan.Node[1].Pos.v[X] - AiNode[i].Centre.v[X];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR _fan$[ebp+64]
	fsub	DWORD PTR [ecx+eax+72]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [eax+edx+84]

; 88   : 		AiNode[i].RVec.v[Y] = fan.Node[1].Pos.v[Y] - AiNode[i].Centre.v[Y];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR _fan$[ebp+68]
	fsub	DWORD PTR [ecx+eax+76]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [eax+edx+88]

; 89   : 		AiNode[i].RVec.v[Z] = fan.Node[1].Pos.v[Z] - AiNode[i].Centre.v[Z];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR _fan$[ebp+72]
	fsub	DWORD PTR [ecx+eax+80]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [eax+edx+92]

; 90   : 		NormalizeVector(&AiNode[i].RVec);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	esi, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR [edx+eax+84]
	fmul	DWORD PTR [esi+ecx+84]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	esi, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR [edx+eax+88]
	fmul	DWORD PTR [esi+ecx+88]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 104				; 00000068H
	mov	edx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	esi, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR [edx+eax+92]
	fmul	DWORD PTR [esi+ecx+92]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81089[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR __mul$81089[ebp]
	fmul	DWORD PTR [ecx+eax+84]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [eax+edx+84]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR __mul$81089[ebp]
	fmul	DWORD PTR [ecx+eax+88]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [eax+edx+88]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR __mul$81089[ebp]
	fmul	DWORD PTR [ecx+eax+92]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fstp	DWORD PTR [eax+edx+92]

; 91   : 
; 92   : 		AiNode[i].Priority = fan.Priority;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	dl, BYTE PTR _fan$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 93   : 		AiNode[i].StartNode = fan.StartNode;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	dl, BYTE PTR _fan$[ebp+1]
	mov	BYTE PTR [ecx+eax+1], dl

; 94   : 		AiNode[i].RacingLine = fan.RacingLine;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _fan$[ebp+4]
	mov	DWORD PTR [ecx+eax+4], edx

; 95   : 		AiNode[i].RacingLineSpeed = fan.RacingLineSpeed;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _fan$[ebp+20]
	mov	DWORD PTR [ecx+eax+12], edx

; 96   : 		AiNode[i].CentreSpeed = fan.CentreSpeed;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _fan$[ebp+24]
	mov	DWORD PTR [ecx+eax+16], edx

; 97   : 		AiNode[i].FinishDist = fan.FinishDist;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _fan$[ebp+8]
	mov	DWORD PTR [ecx+eax+8], edx

; 98   : 
; 99   : 		for (j = 0 ; j < MAX_AINODE_LINKS ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81091
$L81092:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81091:
	cmp	DWORD PTR _j$[ebp], 2
	jge	$L81093

; 100  : 		{
; 101  : 			if (fan.Prev[j] != -1)

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _fan$[ebp+eax*4+28], -1
	je	SHORT $L81094

; 102  : 				AiNode[i].Prev[j] = AiNode + fan.Prev[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _fan$[ebp+eax*4+28]
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	add	edx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4+20], ecx

; 103  : 			else

	jmp	SHORT $L81095
$L81094:

; 104  : 				AiNode[i].Prev[j] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4+20], 0
$L81095:

; 105  : 
; 106  : 			if (fan.Next[j] != -1)

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _fan$[ebp+eax*4+36], -1
	je	SHORT $L81096

; 107  : 				AiNode[i].Next[j] = AiNode + fan.Next[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _fan$[ebp+eax*4+36]
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 104				; 00000068H
	add	edx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4+28], ecx

; 108  : 			else

	jmp	SHORT $L81097
$L81096:

; 109  : 				AiNode[i].Next[j] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4+28], 0
$L81097:

; 110  : 		}

	jmp	$L81092
$L81093:

; 111  : 	}

	jmp	$L81087
$L81088:

; 112  : 
; 113  : // load start node
; 114  : 
; 115  : 	fread(&AiStartNode, sizeof(AiStartNode), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	push	OFFSET FLAT:?AiStartNode@@3JA		; AiStartNode
	call	_fread
	add	esp, 16					; 00000010H

; 116  : 
; 117  : // load total dist
; 118  : 
; 119  : 	fread(&AiNodeTotalDist, sizeof(AiNodeTotalDist), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	push	OFFSET FLAT:?AiNodeTotalDist@@3MA	; AiNodeTotalDist
	call	_fread
	add	esp, 16					; 00000010H

; 120  : 
; 121  : // close ai node file
; 122  : 
; 123  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L81073:

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadAiNodes@@YAXPAD@Z ENDP				; LoadAiNodes
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??FreeAiNodes@@YAXXZ@4JA		; `FreeAiNodes'::`2'::__LINE__Var
PUBLIC	?FreeAiNodes@@YAXXZ				; FreeAiNodes
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??FreeAiNodes@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??FreeAiNodes@@YAXXZ@4JA DD 0f1H		; `FreeAiNodes'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?FreeAiNodes@@YAXXZ
_TEXT	SEGMENT
?FreeAiNodes@@YAXXZ PROC NEAR				; FreeAiNodes, COMDAT

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 242  : 	free(AiNode);

	push	OFFSET FLAT:??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeAiNodes@@YAXXZ@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 243  : 	free(AiNodeZone);

	push	OFFSET FLAT:??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeAiNodes@@YAXXZ@4JA
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A ; AiNodeZone
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 244  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeAiNodes@@YAXXZ ENDP				; FreeAiNodes
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??ZoneAiNodes@@YAXXZ@4JA		; `ZoneAiNodes'::`2'::__LINE__Var
PUBLIC	??_C@_0CK@MKKNDDPP@Couldn?8t?5alloc?5memory?5for?5AI?5nod@ ; `string'
PUBLIC	??_C@_08NEFBJFKJ@Warning?$CB?$AA@		; `string'
PUBLIC	??_C@_0CF@BCCLPHDD@AI?5node?5?$CFld?5is?5outside?5all?5AI?5zo@ ; `string'
PUBLIC	?ZoneAiNodes@@YAXXZ				; ZoneAiNodes
EXTRN	?AiZoneNum@@3JA:DWORD				; AiZoneNum
EXTRN	?AiZones@@3PAUAIZONE@@A:DWORD			; AiZones
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	__imp__wsprintfA:NEAR
;	COMDAT ?__LINE__Var@?1??ZoneAiNodes@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ZoneAiNodes@@YAXXZ@4JA DD 0fbH		; `ZoneAiNodes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CK@MKKNDDPP@Couldn?8t?5alloc?5memory?5for?5AI?5nod@
CONST	SEGMENT
??_C@_0CK@MKKNDDPP@Couldn?8t?5alloc?5memory?5for?5AI?5nod@ DB 'Couldn''t '
	DB	'alloc memory for AI node zoning!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NEFBJFKJ@Warning?$CB?$AA@
CONST	SEGMENT
??_C@_08NEFBJFKJ@Warning?$CB?$AA@ DB 'Warning!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BCCLPHDD@AI?5node?5?$CFld?5is?5outside?5all?5AI?5zo@
CONST	SEGMENT
??_C@_0CF@BCCLPHDD@AI?5node?5?$CFld?5is?5outside?5all?5AI?5zo@ DB 'AI nod'
	DB	'e %ld is outside all AI zones!', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ZoneAiNodes@@YAXXZ
_TEXT	SEGMENT
_lastnode$ = -148					; size = 4
_buf$ = -144						; size = 128
_dist$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
?ZoneAiNodes@@YAXXZ PROC NEAR				; ZoneAiNodes, COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi

; 252  : 	long i, j, k;
; 253  : 	REAL dist;
; 254  : 	char buf[128];
; 255  : 	AINODE *lastnode;
; 256  : 
; 257  : // quit if no zones
; 258  : 
; 259  : 	if (!AiZoneNum)

	cmp	DWORD PTR ?AiZoneNum@@3JA, 0		; AiZoneNum
	jne	SHORT $L81111

; 260  : 	{
; 261  : 		AiNodeZone = NULL;

	mov	DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A, 0 ; AiNodeZone

; 262  : 		return;

	jmp	$L81104
$L81111:

; 263  : 	}
; 264  : 
; 265  : // alloc ram
; 266  : 
; 267  : 	AiNodeZone = (AINODE_ZONE*)malloc(sizeof(AINODE_ZONE) * AiZoneNum);

	push	OFFSET FLAT:??_C@_0IL@EIIKIOBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??ZoneAiNodes@@YAXXZ@4JA
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	shl	ecx, 3
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A, eax ; AiNodeZone

; 268  : 	if (!AiNodeZone)

	cmp	DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A, 0 ; AiNodeZone
	jne	SHORT $L81115

; 269  : 	{
; 270  : #ifdef _PC
; 271  : 		Box("Warning!", "Couldn't alloc memory for AI node zoning!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CK@MKKNDDPP@Couldn?8t?5alloc?5memory?5for?5AI?5nod@
	push	OFFSET FLAT:??_C@_08NEFBJFKJ@Warning?$CB?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 272  : #endif
; 273  : #ifdef _N64
; 274  : 		printf("<!> WARN: Couldn't alloc memory for AI node zoning.\n");
; 275  : #endif
; 276  : 		return;

	jmp	$L81104
$L81115:

; 277  : 	}
; 278  : 
; 279  : // find each nodes zone ID
; 280  : 
; 281  : 	for (i = 0 ; i < AiNodeNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81118
$L81119:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81118:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?AiNodeNum@@3JA		; AiNodeNum
	jge	$L81120

; 282  : 	{
; 283  : 		AiNode[i].ZoneID = LONG_MAX;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	DWORD PTR [ecx+eax+68], 2147483647	; 7fffffffH

; 284  : 
; 285  : 		for (j = 0 ; j < AiZoneNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81121
$L81122:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81121:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	jge	$L81123

; 286  : 		{
; 287  : 			for (k = 0 ; k < 3 ; k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L81124
$L81125:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L81124:
	cmp	DWORD PTR _k$[ebp], 3
	jge	$L81126

; 288  : 			{
; 289  : 				dist = PlaneDist(&AiZones[j].Plane[k], &AiNode[i].Centre);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 80					; 00000050H
	add	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _k$[ebp]
	shl	edx, 4
	mov	esi, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR [esi+eax+72]
	fmul	DWORD PTR [ecx+edx+28]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 80					; 00000050H
	add	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _k$[ebp]
	shl	edx, 4
	mov	esi, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR [esi+eax+76]
	fmul	DWORD PTR [ecx+edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 80					; 00000050H
	add	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _k$[ebp]
	shl	edx, 4
	mov	esi, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	fld	DWORD PTR [esi+eax+80]
	fmul	DWORD PTR [ecx+edx+36]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 80					; 00000050H
	add	eax, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	ecx, DWORD PTR _k$[ebp]
	shl	ecx, 4
	fadd	DWORD PTR [eax+ecx+40]
	fstp	DWORD PTR _dist$[ebp]

; 290  : 				if (dist < -AiZones[j].Size[k] || dist > AiZones[j].Size[k]) break;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 80					; 00000050H
	add	eax, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	ecx, DWORD PTR _k$[ebp]
	fld	DWORD PTR [eax+ecx*4+16]
	fchs
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81128
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 80					; 00000050H
	add	eax, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	ecx, DWORD PTR _k$[ebp]
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR [eax+ecx*4+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81127
$L81128:
	jmp	SHORT $L81126
$L81127:

; 291  : 			}

	jmp	$L81125
$L81126:

; 292  : 
; 293  : 			if (k == 3 && j < AiNode[i].ZoneID)

	cmp	DWORD PTR _k$[ebp], 3
	jne	SHORT $L81129
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+68]
	jge	SHORT $L81129

; 294  : 			{
; 295  : 				AiNode[i].ZoneID = j;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax+68], edx
$L81129:

; 296  : 			}
; 297  : 		}

	jmp	$L81122
$L81123:

; 298  : 
; 299  : 		if (AiNode[i].ZoneID == LONG_MAX)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	cmp	DWORD PTR [ecx+eax+68], 2147483647	; 7fffffffH
	jne	SHORT $L81130

; 300  : 		{
; 301  : #ifdef _PC
; 302  : 			wsprintf(buf, "AI node %ld is outside all AI zones!", i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CF@BCCLPHDD@AI?5node?5?$CFld?5is?5outside?5all?5AI?5zo@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 303  : 			Box(NULL, buf, MB_OK);

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH
$L81130:

; 304  : #endif
; 305  : #ifdef _N64
; 306  : 			printf("<!> WARN: AI node %ld is outside all AI zones.\n", i);
; 307  : #endif
; 308  : 		}
; 309  : 	}

	jmp	$L81119
$L81120:

; 310  : 
; 311  : // setup each zone header
; 312  : 
; 313  : 	for (i = 0 ; i < AiZoneNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81132
$L81133:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81132:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	jge	$L81104

; 314  : 	{
; 315  : 		AiNodeZone[i].Count = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A ; AiNodeZone
	mov	DWORD PTR [ecx+eax*8], 0

; 316  : 		AiNodeZone[i].FirstNode = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A ; AiNodeZone
	mov	DWORD PTR [ecx+eax*8+4], 0

; 317  : 
; 318  : 		for (j = 0 ; j < AiNodeNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81135
$L81136:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81135:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?AiNodeNum@@3JA		; AiNodeNum
	jge	$L81137

; 319  : 		{
; 320  : 			if (AiNode[j].ZoneID == i)

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR [ecx+eax+68]
	cmp	edx, DWORD PTR _i$[ebp]
	jne	$L81138

; 321  : 			{
; 322  : 				if (!AiNodeZone[i].Count)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A ; AiNodeZone
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $L81139

; 323  : 				{
; 324  : 					AiNodeZone[i].FirstNode = &AiNode[j];

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A ; AiNodeZone
	mov	DWORD PTR [edx+ecx*8+4], eax

; 325  : 					AiNode[j].ZonePrev = NULL;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	DWORD PTR [ecx+eax+96], 0

; 326  : 				}
; 327  : 				else

	jmp	SHORT $L81140
$L81139:

; 328  : 				{
; 329  : 					lastnode->ZoneNext = &AiNode[j];

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	ecx, DWORD PTR _lastnode$[ebp]
	mov	DWORD PTR [ecx+100], eax

; 330  : 					AiNode[j].ZonePrev = lastnode;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	edx, DWORD PTR _lastnode$[ebp]
	mov	DWORD PTR [ecx+eax+96], edx
$L81140:

; 331  : 				}
; 332  : 
; 333  : 				AiNode[j].ZoneNext = NULL;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	DWORD PTR [ecx+eax+100], 0

; 334  : 				AiNodeZone[i].Count++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A ; AiNodeZone
	mov	edx, DWORD PTR [ecx+eax*8]
	add	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiNodeZone@@3PAUAINODE_ZONE@@A ; AiNodeZone
	mov	DWORD PTR [ecx+eax*8], edx

; 335  : 				lastnode = &AiNode[j];

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	DWORD PTR _lastnode$[ebp], eax
$L81138:

; 336  : 			}
; 337  : 		}

	jmp	$L81136
$L81137:

; 338  : 	}

	jmp	$L81133
$L81104:

; 339  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ZoneAiNodes@@YAXXZ ENDP				; ZoneAiNodes
_TEXT	ENDS
PUBLIC	?AIN_NearestNode@@YAPAU_AINODE@@PAUPlayerStruct@@PAM@Z ; AIN_NearestNode
; Function compile flags: /Odt /ZI
;	COMDAT ?AIN_NearestNode@@YAPAU_AINODE@@PAUPlayerStruct@@PAM@Z
_TEXT	SEGMENT
_NearNode$ = -4						; size = 4
_Player$ = 8						; size = 4
_Dist$ = 12						; size = 4
?AIN_NearestNode@@YAPAU_AINODE@@PAUPlayerStruct@@PAM@Z PROC NEAR ; AIN_NearestNode, COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 352  : 	AINODE		*NearNode = NULL;

	mov	DWORD PTR _NearNode$[ebp], 0

; 353  : /*	long		Grid;
; 354  : 	VEC			CarPos;
; 355  : 	VEC			temp;
; 356  : 	long   		xShift, zShift;
; 357  : 	long		xOff, zOff;
; 358  : 	AINODE		*Node;
; 359  : 	REAL		tDist, Nearest;
; 360  : 	CAR			*Car;
; 361  : 
; 362  : 	Car = &Player->car;
; 363  : 	Nearest = 65535 * 2;
; 364  : 	CarPos = Car->Body->Centre.Pos;
; 365  : 	for (zShift = 0; zShift < MAX_SHIFTS; zShift++)
; 366  : 	{
; 367  : 		zOff = (long) ((REAL)((CarPos.v[Z] + 32768) - (zShift * NODE_SHIFT_OFFSET)) / NODE_UNIT_SIZE);
; 368  : 		for (xShift = 0; xShift < MAX_SHIFTS; xShift++)
; 369  : 		{
; 370  : 			xOff = (long) ((REAL)((CarPos.v[X] + 32768) - (xShift * NODE_SHIFT_OFFSET)) / NODE_UNIT_SIZE);
; 371  : 			Grid = xShift + (zShift * MAX_SHIFTS);
; 372  : 
; 373  : 			if (NodeGrid[Grid][xOff + (zOff * NODE_GRID_WIDTH)].NodeHead)
; 374  : 			{
; 375  : 				for (Node = NodeGrid[Grid][xOff + (zOff * NODE_GRID_WIDTH)].NodeHead ; Node; Node = Node->GridNext[Grid])
; 376  : 				{
; 377  : 					temp.v[X] = Node->Centre.v[X] - CarPos.v[X];
; 378  : 					temp.v[Y] = Node->Centre.v[Y] - CarPos.v[Y];
; 379  : 					temp.v[Z] = Node->Centre.v[Z] - CarPos.v[Z];
; 380  : 
; 381  : 					tDist = abs(VecLen(&temp));
; 382  : 
; 383  : 					if (tDist < Nearest)
; 384  : 					{
; 385  : 						Nearest = tDist;
; 386  : 						NearNode = Node;
; 387  : 					}
; 388  : 				}
; 389  : 			}
; 390  : 		}
; 391  : 	}
; 392  : 	
; 393  : 	*Dist = Nearest;*/
; 394  : 	return(NearNode);

	mov	eax, DWORD PTR _NearNode$[ebp]

; 395  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AIN_NearestNode@@YAPAU_AINODE@@PAUPlayerStruct@@PAM@Z ENDP ; AIN_NearestNode
_TEXT	ENDS
PUBLIC	?AIN_GetForwardNode@@YAPAU_AINODE@@PAUPlayerStruct@@MPAM@Z ; AIN_GetForwardNode
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@00000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AIN_GetForwardNode@@YAPAU_AINODE@@PAUPlayerStruct@@MPAM@Z
_TEXT	SEGMENT
tv237 = -124						; size = 4
_CarPos$ = -56						; size = 12
_Vec2$ = -44						; size = 12
_Vec1$ = -32						; size = 12
_RChoice$ = -20						; size = 4
_dp$ = -16						; size = 4
_NearestFwd$ = -12					; size = 4
_Nearest$ = -8						; size = 4
_NearNode$ = -4						; size = 4
_Player$ = 8						; size = 4
_MinDist$ = 12						; size = 4
_Dist$ = 16						; size = 4
?AIN_GetForwardNode@@YAPAU_AINODE@@PAUPlayerStruct@@MPAM@Z PROC NEAR ; AIN_GetForwardNode, COMDAT

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 407  : 	AINODE	*NearNode;
; 408  : //	AINODE NearNodeFwd;
; 409  : 	REAL	Nearest, NearestFwd; 
; 410  : 	REAL	dp;
; 411  : 	long	RChoice;
; 412  : 	VEC		Vec1, Vec2;
; 413  : 	VEC		CarPos;
; 414  : 
; 415  : 	NearNode = AIN_NearestNode(Player, &Nearest);

	lea	eax, DWORD PTR _Nearest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Player$[ebp]
	push	ecx
	call	?AIN_NearestNode@@YAPAU_AINODE@@PAUPlayerStruct@@PAM@Z ; AIN_NearestNode
	add	esp, 8
	mov	DWORD PTR _NearNode$[ebp], eax

; 416  : 	if (!NearNode) return (NULL);

	cmp	DWORD PTR _NearNode$[ebp], 0
	jne	SHORT $L81159
	xor	eax, eax
	jmp	$L81150
$L81159:

; 417  : 	CarPos = Player->car.Body->Centre.Pos;

	mov	eax, DWORD PTR _Player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _CarPos$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _CarPos$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _CarPos$[ebp+8], ecx

; 418  : 	RChoice = Player->CarAI.RouteChoice;

	mov	eax, DWORD PTR _Player$[ebp]
	mov	ecx, DWORD PTR [eax+10152]
	mov	DWORD PTR _RChoice$[ebp], ecx

; 419  : 	
; 420  : 	NearestFwd = -1;

	mov	DWORD PTR _NearestFwd$[ebp], -1082130432 ; bf800000H
$L81161:

; 421  : 
; 422  : 	while(NearestFwd < MinDist)

	fld	DWORD PTR _NearestFwd$[ebp]
	fcomp	DWORD PTR _MinDist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	$L81162

; 423  : 	{
; 424  : 		if (!NearNode->Next[RChoice])

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	cmp	DWORD PTR [ecx+eax*4+28], 0
	jne	SHORT $L81163

; 425  : 		{
; 426  : 			*Dist = Nearest;

	mov	eax, DWORD PTR _Dist$[ebp]
	mov	ecx, DWORD PTR _Nearest$[ebp]
	mov	DWORD PTR [eax], ecx

; 427  : 			return(NearNode);

	mov	eax, DWORD PTR _NearNode$[ebp]
	jmp	$L81150
$L81163:

; 428  : 		}
; 429  : 		Vec1.v[X] = NearNode->Centre.v[X] - CarPos.v[X];

	mov	eax, DWORD PTR _NearNode$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR _CarPos$[ebp]
	fstp	DWORD PTR _Vec1$[ebp]

; 430  : 		Vec1.v[Y] = NearNode->Centre.v[Y] - CarPos.v[Y];

	mov	eax, DWORD PTR _NearNode$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR _CarPos$[ebp+4]
	fstp	DWORD PTR _Vec1$[ebp+4]

; 431  : 		Vec1.v[Z] = NearNode->Centre.v[Z] - CarPos.v[Z];

	mov	eax, DWORD PTR _NearNode$[ebp]
	fld	DWORD PTR [eax+80]
	fsub	DWORD PTR _CarPos$[ebp+8]
	fstp	DWORD PTR _Vec1$[ebp+8]

; 432  : 		Vec2.v[X] = NearNode->Next[RChoice]->Centre.v[X] - NearNode->Centre.v[X];

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	eax, DWORD PTR _NearNode$[ebp]
	fld	DWORD PTR [edx+72]
	fsub	DWORD PTR [eax+72]
	fstp	DWORD PTR _Vec2$[ebp]

; 433  : 		Vec2.v[Y] = NearNode->Next[RChoice]->Centre.v[Y] - NearNode->Centre.v[Y];

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	eax, DWORD PTR _NearNode$[ebp]
	fld	DWORD PTR [edx+76]
	fsub	DWORD PTR [eax+76]
	fstp	DWORD PTR _Vec2$[ebp+4]

; 434  : 		Vec2.v[Z] =	NearNode->Next[RChoice]->Centre.v[Z] - NearNode->Centre.v[Z];

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	eax, DWORD PTR _NearNode$[ebp]
	fld	DWORD PTR [edx+80]
	fsub	DWORD PTR [eax+80]
	fstp	DWORD PTR _Vec2$[ebp+8]

; 435  : 	
; 436  : 		dp = DotProduct(&Vec1, &Vec2);

	fld	DWORD PTR _Vec1$[ebp]
	fmul	DWORD PTR _Vec2$[ebp]
	fld	DWORD PTR _Vec1$[ebp+4]
	fmul	DWORD PTR _Vec2$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _Vec1$[ebp+8]
	fmul	DWORD PTR _Vec2$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dp$[ebp]

; 437  : 		if (dp > 0.5) 

	fld	DWORD PTR _dp$[ebp]
	fcomp	QWORD PTR __real@3fe0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81164

; 438  : 		{
; 439  : 			Vec2.v[X] = NearNode->Next[RChoice]->Centre.v[X] - CarPos.v[X];

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	fld	DWORD PTR [edx+72]
	fsub	DWORD PTR _CarPos$[ebp]
	fstp	DWORD PTR _Vec2$[ebp]

; 440  : 			Vec2.v[Y] = NearNode->Next[RChoice]->Centre.v[Y] - CarPos.v[Y];

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	fld	DWORD PTR [edx+76]
	fsub	DWORD PTR _CarPos$[ebp+4]
	fstp	DWORD PTR _Vec2$[ebp+4]

; 441  : 			Vec2.v[Z] =	NearNode->Next[RChoice]->Centre.v[Z] - CarPos.v[Z];

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	fld	DWORD PTR [edx+80]
	fsub	DWORD PTR _CarPos$[ebp+8]
	fstp	DWORD PTR _Vec2$[ebp+8]

; 442  : 			NearestFwd = abs(VecLen(&Vec2)); 

	fld	DWORD PTR _Vec2$[ebp]
	fmul	DWORD PTR _Vec2$[ebp]
	fld	DWORD PTR _Vec2$[ebp+4]
	fmul	DWORD PTR _Vec2$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _Vec2$[ebp+8]
	fmul	DWORD PTR _Vec2$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81298
	fld	DWORD PTR _Vec2$[ebp]
	fmul	DWORD PTR _Vec2$[ebp]
	fld	DWORD PTR _Vec2$[ebp+4]
	fmul	DWORD PTR _Vec2$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _Vec2$[ebp+8]
	fmul	DWORD PTR _Vec2$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR tv237[ebp]
	jmp	SHORT $L81299
$L81298:
	fld	DWORD PTR _Vec2$[ebp]
	fmul	DWORD PTR _Vec2$[ebp]
	fld	DWORD PTR _Vec2$[ebp+4]
	fmul	DWORD PTR _Vec2$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _Vec2$[ebp+8]
	fmul	DWORD PTR _Vec2$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fchs
	fstp	DWORD PTR tv237[ebp]
$L81299:
	mov	eax, DWORD PTR tv237[ebp]
	mov	DWORD PTR _NearestFwd$[ebp], eax
$L81164:

; 443  : 		}
; 444  : 		NearNode = NearNode->Next[RChoice];

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	DWORD PTR _NearNode$[ebp], edx

; 445  : 	}

	jmp	$L81161
$L81162:

; 446  : 	*Dist = NearestFwd;

	mov	eax, DWORD PTR _Dist$[ebp]
	mov	ecx, DWORD PTR _NearestFwd$[ebp]
	mov	DWORD PTR [eax], ecx

; 447  : 	return(NearNode->Next[RChoice]);

	mov	eax, DWORD PTR _RChoice$[ebp]
	mov	ecx, DWORD PTR _NearNode$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+28]
$L81150:

; 448  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AIN_GetForwardNode@@YAPAU_AINODE@@PAUPlayerStruct@@MPAM@Z ENDP ; AIN_GetForwardNode
_TEXT	ENDS
PUBLIC	?AIN_PriChoice@@YAJPAUPlayerStruct@@@Z		; AIN_PriChoice
; Function compile flags: /Odt /ZI
;	COMDAT ?AIN_PriChoice@@YAJPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_Player$ = 8						; size = 4
?AIN_PriChoice@@YAJPAUPlayerStruct@@@Z PROC NEAR	; AIN_PriChoice, COMDAT

; 454  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 455  : //	long	Choice;
; 456  : 
; 457  : 	return(1);

	mov	eax, 1

; 458  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AIN_PriChoice@@YAJPAUPlayerStruct@@@Z ENDP		; AIN_PriChoice
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
END
