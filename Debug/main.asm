; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\main.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@INLIKAPM@CarInfo?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HJANMIO@yak?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FLDKIHPE@?9nosound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@CGLPJNPE@?9nocolorkey?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LOODJHJA@?9carinfo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JMGGPHIA@?9rightaboutnow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EPCJCNHC@?9window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NPICAKHM@?9normalpriority?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@GMMHILHE@?9paulsgotnewbansheedrivers?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@KJBKENPN@?9matttneedsvisicockingperpolytur@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LBELJDMF@?9editscale?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@JEDGNGHG@Revolt?5is?5already?5running?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@EENGBAHE@C?3?2Windows?2Temp?2ReVolt?4log?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@JFAHOJE@Can?8t?5initialize?5COM?5library?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PEANDJCI@gfx?2font1?4bmp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@IKBJKENM@gfx?2title?4bmp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DEGNDLFE@Can?8t?5create?5ghost?5player?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@MBMPPHHG@Can?8t?5create?5local?5player?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@CDDCENDO@Can?8t?5create?5computer?5player?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@BAOHMLDO@Can?8t?5create?5player?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitWin@@YA_NPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Box@@YAJPAD0J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Vblank@@YAXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowFunc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Go@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoFront@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupGame@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlayeresFullArray@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlayersTrial@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlayersSingle@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlayersNetwork@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckCheatStrings@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?DEBUG_CollGrid@@3JA				; DEBUG_CollGrid
PUBLIC	?DEBUG_NCols@@3HA				; DEBUG_NCols
PUBLIC	?DEBUG_LastNCols@@3HA				; DEBUG_LastNCols
PUBLIC	?DEBUG_N2Cols@@3HA				; DEBUG_N2Cols
PUBLIC	?DEBUG_dR@@3UVectorStruct@@A			; DEBUG_dR
PUBLIC	?DEBUG_Impulse@@3UVectorStruct@@A		; DEBUG_Impulse
PUBLIC	?DEBUG_AngImpulse@@3UVectorStruct@@A		; DEBUG_AngImpulse
PUBLIC	?DEBUG_SNorm@@3PAUVectorStruct@@A		; DEBUG_SNorm
PUBLIC	?DEBUG_Faces@@3PAUFACING_POLY@@A		; DEBUG_Faces
PUBLIC	?CarInfoFile@@3PADA				; CarInfoFile
PUBLIC	??_C@_0M@INLIKAPM@CarInfo?4txt?$AA@		; `string'
PUBLIC	?CheatStrings@@3PAPADA				; CheatStrings
PUBLIC	??_C@_03HJANMIO@yak?$AA@			; `string'
PUBLIC	?Everything@@3DA				; Everything
PUBLIC	?NoGamma@@3DA					; NoGamma
PUBLIC	?AppRestore@@3DA				; AppRestore
PUBLIC	?QuitGame@@3DA					; QuitGame
PUBLIC	?FullScreen@@3DA				; FullScreen
PUBLIC	?FrameCount@@3KA				; FrameCount
PUBLIC	?FrameCountLast@@3KA				; FrameCountLast
PUBLIC	?FrameTime@@3KA					; FrameTime
PUBLIC	?FrameTimeLast@@3KA				; FrameTimeLast
PUBLIC	?FrameRate@@3KA					; FrameRate
PUBLIC	?DetailMenuTogg@@3DA				; DetailMenuTogg
PUBLIC	?EditMode@@3JA					; EditMode
PUBLIC	?TimeFactor@@3MA				; TimeFactor
PUBLIC	?TimeStep@@3MA					; TimeStep
PUBLIC	?EditScale@@3MA					; EditScale
PUBLIC	?hwnd@@3PAUHWND__@@A				; hwnd
PUBLIC	?TitleHbm@@3PAUHBITMAP__@@A			; TitleHbm
PUBLIC	?Event@@3P6AXXZA				; Event
PUBLIC	?GameSettings@@3UGAME_SETTINGS@@A		; GameSettings
PUBLIC	?RenderSettings@@3URENDER_SETTINGS@@A		; RenderSettings
_BSS	SEGMENT
?DEBUG_CollGrid@@3JA DD 01H DUP (?)			; DEBUG_CollGrid
?DEBUG_NCols@@3HA DD 01H DUP (?)			; DEBUG_NCols
?DEBUG_LastNCols@@3HA DD 01H DUP (?)			; DEBUG_LastNCols
?DEBUG_N2Cols@@3HA DD 01H DUP (?)			; DEBUG_N2Cols
?DEBUG_dR@@3UVectorStruct@@A DB 0cH DUP (?)		; DEBUG_dR
?DEBUG_Impulse@@3UVectorStruct@@A DB 0cH DUP (?)	; DEBUG_Impulse
?DEBUG_AngImpulse@@3UVectorStruct@@A DB 0cH DUP (?)	; DEBUG_AngImpulse
?DEBUG_SNorm@@3PAUVectorStruct@@A DB 0c00H DUP (?)	; DEBUG_SNorm
?DEBUG_Faces@@3PAUFACING_POLY@@A DB 02000H DUP (?)	; DEBUG_Faces
?NoGamma@@3DA DB 01H DUP (?)				; NoGamma
	ALIGN	4

?AppRestore@@3DA DB 01H DUP (?)				; AppRestore
	ALIGN	4

?QuitGame@@3DA DB 01H DUP (?)				; QuitGame
	ALIGN	4

?FrameCount@@3KA DD 01H DUP (?)				; FrameCount
?FrameCountLast@@3KA DD 01H DUP (?)			; FrameCountLast
?FrameTime@@3KA DD 01H DUP (?)				; FrameTime
?FrameTimeLast@@3KA DD 01H DUP (?)			; FrameTimeLast
?FrameRate@@3KA DD 01H DUP (?)				; FrameRate
?DetailMenuTogg@@3DA DB 01H DUP (?)			; DetailMenuTogg
	ALIGN	4

?EditMode@@3JA DD 01H DUP (?)				; EditMode
?TimeFactor@@3MA DD 01H DUP (?)				; TimeFactor
?TimeStep@@3MA DD 01H DUP (?)				; TimeStep
?hwnd@@3PAUHWND__@@A DD 01H DUP (?)			; hwnd
?TitleHbm@@3PAUHBITMAP__@@A DD 01H DUP (?)		; TitleHbm
?Event@@3P6AXXZA DD 01H DUP (?)				; Event
?GameSettings@@3UGAME_SETTINGS@@A DB 020H DUP (?)	; GameSettings
?RenderSettings@@3URENDER_SETTINGS@@A DB 064H DUP (?)	; RenderSettings
_BSS	ENDS
_DATA	SEGMENT
?Everything@@3DA DB 01H					; Everything
?FullScreen@@3DA DB 01H					; FullScreen
	ORG $+2
?EditScale@@3MA DD 03f800000r			; 1	; EditScale
_DATA	ENDS
;	COMDAT ??_C@_0M@INLIKAPM@CarInfo?4txt?$AA@
CONST	SEGMENT
??_C@_0M@INLIKAPM@CarInfo?4txt?$AA@ DB 'CarInfo.txt', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?CarInfoFile@@3PADA DD FLAT:??_C@_0M@INLIKAPM@CarInfo?4txt?$AA@ ; CarInfoFile
_WinName DB	'Revolt', 00H
_AppActive DB	01H
_ActivePriority DD 080H
_DATA	ENDS
;	COMDAT ??_C@_03HJANMIO@yak?$AA@
CONST	SEGMENT
??_C@_03HJANMIO@yak?$AA@ DB 'yak', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?CheatStrings@@3PAPADA DD FLAT:??_C@_03HJANMIO@yak?$AA@	; CheatStrings
	DD	00H
_DATA	ENDS
PUBLIC	??_C@_08FLDKIHPE@?9nosound?$AA@			; `string'
PUBLIC	??_C@_0M@CGLPJNPE@?9nocolorkey?$AA@		; `string'
PUBLIC	??_C@_08LOODJHJA@?9carinfo?$AA@			; `string'
PUBLIC	??_C@_0P@JMGGPHIA@?9rightaboutnow?$AA@		; `string'
PUBLIC	??_C@_07EPCJCNHC@?9window?$AA@			; `string'
PUBLIC	??_C@_0BA@NPICAKHM@?9normalpriority?$AA@	; `string'
PUBLIC	??_C@_0BL@GMMHILHE@?9paulsgotnewbansheedrivers?$AA@ ; `string'
PUBLIC	??_C@_0CH@KJBKENPN@?9matttneedsvisicockingperpolytur@ ; `string'
PUBLIC	??_C@_0L@LBELJDMF@?9editscale?$AA@		; `string'
PUBLIC	??_C@_0BL@JEDGNGHG@Revolt?5is?5already?5running?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BL@EENGBAHE@C?3?2Windows?2Temp?2ReVolt?4log?$AA@ ; `string'
PUBLIC	??_C@_0BO@JFAHOJE@Can?8t?5initialize?5COM?5library?$CB?$AA@ ; `string'
PUBLIC	_WinMain@16
PUBLIC	?InitWin@@YA_NPAUHINSTANCE__@@H@Z		; InitWin
PUBLIC	?Box@@YAJPAD0J@Z				; Box
PUBLIC	?Go@@YAXXZ					; Go
EXTRN	__imp__CoInitialize@4:NEAR
EXTRN	__imp__CoUninitialize@0:NEAR
EXTRN	?DestroyCarInfo@@YAXXZ:NEAR			; DestroyCarInfo
EXTRN	?LobbyRegister@@YAXXZ:NEAR			; LobbyRegister
EXTRN	?KillPlay@@YAXXZ:NEAR				; KillPlay
EXTRN	?InitDD@@YAHXZ:NEAR				; InitDD
EXTRN	?ReleaseDX@@YAXXZ:NEAR				; ReleaseDX
EXTRN	?ReleaseD3D@@YAXXZ:NEAR				; ReleaseD3D
EXTRN	?SetAllCarCoMs@@YAXXZ:NEAR			; SetAllCarCoMs
EXTRN	?GetDrawDevices@@YAXXZ:NEAR			; GetDrawDevices
EXTRN	__imp__QueryPerformanceFrequency@4:NEAR
EXTRN	?DD@@3PAUIDirectDraw4@@A:DWORD			; DD
EXTRN	?NoColorKey@@3JA:DWORD				; NoColorKey
EXTRN	?InitInput@@YAJPAUHINSTANCE__@@@Z:NEAR		; InitInput
EXTRN	?KillInput@@YAXXZ:NEAR				; KillInput
EXTRN	?VisiPerPoly@@3JA:DWORD				; VisiPerPoly
EXTRN	___argc:DWORD
EXTRN	___argv:DWORD
EXTRN	_atof:NEAR
EXTRN	__imp__TranslateMessage@4:NEAR
EXTRN	__imp__DispatchMessageA@4:NEAR
EXTRN	__imp__PeekMessageA@20:NEAR
EXTRN	__fltused:NEAR
EXTRN	_srand:NEAR
EXTRN	?FindLevels@@YAXXZ:NEAR				; FindLevels
EXTRN	?FreeLevels@@YAXXZ:NEAR				; FreeLevels
EXTRN	?GetLevelNum@@YAJPAD@Z:NEAR			; GetLevelNum
EXTRN	__imp__FindWindowA@8:NEAR
EXTRN	?ReadAllCarInfo@@YA_NPAD@Z:NEAR			; ReadAllCarInfo
EXTRN	?CheckMemoryAllocation@@YAXXZ:NEAR		; CheckMemoryAllocation
EXTRN	?DBG_LogFile@@3PADA:DWORD			; DBG_LogFile
EXTRN	?InitLogFile@@YAXXZ:NEAR			; InitLogFile
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?TimerFreq@@3KA:DWORD				; TimerFreq
EXTRN	?InitSound@@YAJXZ:NEAR				; InitSound
EXTRN	?ReleaseSound@@YAXXZ:NEAR			; ReleaseSound
EXTRN	?GetRegistrySettings@@YAXXZ:NEAR		; GetRegistrySettings
EXTRN	?SetRegistrySettings@@YAXXZ:NEAR		; SetRegistrySettings
EXTRN	?RegistrySettings@@3UREGISTRY_SETTINGS@@A:BYTE	; RegistrySettings
EXTRN	?SoundOff@@3JA:DWORD				; SoundOff
EXTRN	?CreateTPages@@YA_NH@Z:NEAR			; CreateTPages
EXTRN	?DestroyTPages@@YAXXZ:NEAR			; DestroyTPages
EXTRN	?FreeTextures@@YAXXZ:NEAR			; FreeTextures
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_08FLDKIHPE@?9nosound?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\main.cpp
CONST	SEGMENT
??_C@_08FLDKIHPE@?9nosound?$AA@ DB '-nosound', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CGLPJNPE@?9nocolorkey?$AA@
CONST	SEGMENT
??_C@_0M@CGLPJNPE@?9nocolorkey?$AA@ DB '-nocolorkey', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LOODJHJA@?9carinfo?$AA@
CONST	SEGMENT
??_C@_08LOODJHJA@?9carinfo?$AA@ DB '-carinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JMGGPHIA@?9rightaboutnow?$AA@
CONST	SEGMENT
??_C@_0P@JMGGPHIA@?9rightaboutnow?$AA@ DB '-rightaboutnow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EPCJCNHC@?9window?$AA@
CONST	SEGMENT
??_C@_07EPCJCNHC@?9window?$AA@ DB '-window', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NPICAKHM@?9normalpriority?$AA@
CONST	SEGMENT
??_C@_0BA@NPICAKHM@?9normalpriority?$AA@ DB '-normalpriority', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GMMHILHE@?9paulsgotnewbansheedrivers?$AA@
CONST	SEGMENT
??_C@_0BL@GMMHILHE@?9paulsgotnewbansheedrivers?$AA@ DB '-paulsgotnewbansh'
	DB	'eedrivers', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KJBKENPN@?9matttneedsvisicockingperpolytur@
CONST	SEGMENT
??_C@_0CH@KJBKENPN@?9matttneedsvisicockingperpolytur@ DB '-matttneedsvisi'
	DB	'cockingperpolyturnedoff', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LBELJDMF@?9editscale?$AA@
CONST	SEGMENT
??_C@_0L@LBELJDMF@?9editscale?$AA@ DB '-editscale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JEDGNGHG@Revolt?5is?5already?5running?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@JEDGNGHG@Revolt?5is?5already?5running?$CB?$AA@ DB 'Revolt is al'
	DB	'ready running!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EENGBAHE@C?3?2Windows?2Temp?2ReVolt?4log?$AA@
CONST	SEGMENT
??_C@_0BL@EENGBAHE@C?3?2Windows?2Temp?2ReVolt?4log?$AA@ DB 'C:\Windows\Te'
	DB	'mp\ReVolt.log', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JFAHOJE@Can?8t?5initialize?5COM?5library?$CB?$AA@
CONST	SEGMENT
??_C@_0BO@JFAHOJE@Can?8t?5initialize?5COM?5library?$CB?$AA@ DB 'Can''t in'
	DB	'itialize COM library!', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_time$ = -44						; size = 8
_r$ = -36						; size = 4
_msg$ = -32						; size = 28
_i$ = -1						; size = 1
_hThisInst$ = 8						; size = 4
_hPrevInst$ = 12					; size = 4
_lpszArgs$ = 16						; size = 4
_nWinMode$ = 20						; size = 4
_WinMain@16 PROC NEAR					; COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 96   : 	char i;
; 97   : 	MSG msg;
; 98   : 	HRESULT r;
; 99   : 	LARGE_INTEGER time;
; 100  : 
; 101  : // parse command line args
; 102  : 
; 103  : 	for (i = 1 ; i < __argc ; i++)

	mov	BYTE PTR _i$[ebp], 1
	jmp	SHORT $L82108
$L82109:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L82108:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, DWORD PTR ___argc
	jge	$L82110

; 104  : 	{
; 105  : 
; 106  : // no sound
; 107  : 
; 108  : 		if (!strcmp(__argv[i], "-nosound"))

	push	OFFSET FLAT:??_C@_08FLDKIHPE@?9nosound?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82111

; 109  : 		{
; 110  : 			SoundOff = TRUE;

	mov	DWORD PTR ?SoundOff@@3JA, 1		; SoundOff

; 111  : 			continue;

	jmp	SHORT $L82109
$L82111:

; 112  : 		}
; 113  : 
; 114  : // no colorkey
; 115  : 
; 116  : 		if (!strcmp(__argv[i], "-nocolorkey"))

	push	OFFSET FLAT:??_C@_0M@CGLPJNPE@?9nocolorkey?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82113

; 117  : 		{
; 118  : 			NoColorKey = TRUE;

	mov	DWORD PTR ?NoColorKey@@3JA, 1		; NoColorKey

; 119  : 			continue;

	jmp	SHORT $L82109
$L82113:

; 120  : 		}
; 121  : 
; 122  : // carinfo file
; 123  : 
; 124  : 		if (!strcmp(__argv[i], "-carinfo"))

	push	OFFSET FLAT:??_C@_08LOODJHJA@?9carinfo?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82115

; 125  : 		{
; 126  : 			CarInfoFile = __argv[++i];

	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
	movsx	ecx, BYTE PTR _i$[ebp]
	mov	edx, DWORD PTR ___argv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR ?CarInfoFile@@3PADA, eax	; CarInfoFile

; 127  : 			continue;

	jmp	$L82109
$L82115:

; 128  : 		}
; 129  : 
; 130  : // everything
; 131  : 
; 132  : 		if (!strcmp(__argv[i], "-rightaboutnow"))

	push	OFFSET FLAT:??_C@_0P@JMGGPHIA@?9rightaboutnow?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82117

; 133  : 		{
; 134  : 			Everything = TRUE;

	mov	BYTE PTR ?Everything@@3DA, 1		; Everything

; 135  : 			continue;

	jmp	$L82109
$L82117:

; 136  : 		}
; 137  : 
; 138  : // window
; 139  : 
; 140  : 		if (!strcmp(__argv[i], "-window"))

	push	OFFSET FLAT:??_C@_07EPCJCNHC@?9window?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82119

; 141  : 		{
; 142  : 			FullScreen = FALSE;

	mov	BYTE PTR ?FullScreen@@3DA, 0		; FullScreen

; 143  : 			continue;

	jmp	$L82109
$L82119:

; 144  : 		}
; 145  : 
; 146  : // normal priority
; 147  : 
; 148  : 		if (!strcmp(__argv[i], "-normalpriority"))

	push	OFFSET FLAT:??_C@_0BA@NPICAKHM@?9normalpriority?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82121

; 149  : 		{
; 150  : 			ActivePriority = NORMAL_PRIORITY_CLASS;

	mov	DWORD PTR _ActivePriority, 32		; 00000020H

; 151  : 			continue;

	jmp	$L82109
$L82121:

; 152  : 		}
; 153  : 
; 154  : // no gamma control
; 155  : 
; 156  : 		if (!strcmp(__argv[i], "-paulsgotnewbansheedrivers"))

	push	OFFSET FLAT:??_C@_0BL@GMMHILHE@?9paulsgotnewbansheedrivers?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82123

; 157  : 		{
; 158  : 			NoGamma = TRUE;

	mov	BYTE PTR ?NoGamma@@3DA, 1		; NoGamma

; 159  : 			continue;

	jmp	$L82109
$L82123:

; 160  : 		}
; 161  : 
; 162  : // no visicock per poly
; 163  : 
; 164  : 		if (!strcmp(__argv[i], "-matttneedsvisicockingperpolyturnedoff"))

	push	OFFSET FLAT:??_C@_0CH@KJBKENPN@?9matttneedsvisicockingperpolytur@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82125

; 165  : 		{
; 166  : 			VisiPerPoly = FALSE;

	mov	DWORD PTR ?VisiPerPoly@@3JA, 0		; VisiPerPoly

; 167  : 			continue;

	jmp	$L82109
$L82125:

; 168  : 		}
; 169  : 
; 170  : // edit scale
; 171  : 
; 172  : 		if (!strcmp(__argv[i], "-editscale"))

	push	OFFSET FLAT:??_C@_0L@LBELJDMF@?9editscale?$AA@
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR ___argv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82127

; 173  : 		{
; 174  : 			EditScale = (float)atof(__argv[++i]);

	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
	movsx	ecx, BYTE PTR _i$[ebp]
	mov	edx, DWORD PTR ___argv
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_atof
	add	esp, 4
	fstp	DWORD PTR ?EditScale@@3MA		; EditScale

; 175  : 			continue;

	jmp	$L82109
$L82127:

; 176  : 		}
; 177  : 	}

	jmp	$L82109
$L82110:

; 178  : 
; 179  : // revolt already running?
; 180  : 
; 181  : 	if (FindWindow(WinName, WinName) && FullScreen)

	push	OFFSET FLAT:_WinName
	push	OFFSET FLAT:_WinName
	call	DWORD PTR __imp__FindWindowA@8
	test	eax, eax
	je	SHORT $L82130
	movsx	eax, BYTE PTR ?FullScreen@@3DA		; FullScreen
	test	eax, eax
	je	SHORT $L82130

; 182  : 	{
; 183  : 		Box(NULL, "Revolt is already running!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0BL@JEDGNGHG@Revolt?5is?5already?5running?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 184  : 		return FALSE;

	xor	eax, eax
	jmp	$L82103
$L82130:

; 185  : 	}
; 186  : 
; 187  : // init log file?
; 188  : 
; 189  : #if USE_DEBUG_ROUTINES
; 190  : 	DBG_LogFile = "C:\\Windows\\Temp\\ReVolt.log";

	mov	DWORD PTR ?DBG_LogFile@@3PADA, OFFSET FLAT:??_C@_0BL@EENGBAHE@C?3?2Windows?2Temp?2ReVolt?4log?$AA@ ; DBG_LogFile

; 191  : 	InitLogFile();

	call	?InitLogFile@@YAXXZ			; InitLogFile

; 192  : #endif
; 193  : 
; 194  : // Initialize COM library
; 195  : 
; 196  : 	r = CoInitialize(NULL);

	push	0
	call	DWORD PTR __imp__CoInitialize@4
	mov	DWORD PTR _r$[ebp], eax

; 197  : 	if (r != S_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L82134

; 198  : 	{
; 199  : 		Box(NULL, "Can't initialize COM library!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0BO@JFAHOJE@Can?8t?5initialize?5COM?5library?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 200  : 		return FALSE;

	xor	eax, eax
	jmp	$L82103
$L82134:

; 201  : 	}
; 202  : 
; 203  : // register for lobby support
; 204  : 
; 205  : 	LobbyRegister();

	call	?LobbyRegister@@YAXXZ			; LobbyRegister

; 206  : 
; 207  : // get registry settings
; 208  : 
; 209  : 	GetRegistrySettings();

	call	?GetRegistrySettings@@YAXXZ		; GetRegistrySettings

; 210  : 
; 211  : // init window
; 212  : 
; 213  : 	if (!InitWin(hThisInst, nWinMode))

	mov	eax, DWORD PTR _nWinMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hThisInst$[ebp]
	push	ecx
	call	?InitWin@@YA_NPAUHINSTANCE__@@H@Z	; InitWin
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82136

; 214  : 		return FALSE;

	xor	eax, eax
	jmp	$L82103
$L82136:

; 215  : 
; 216  : // find levels
; 217  : 
; 218  : 	FindLevels();

	call	?FindLevels@@YAXXZ			; FindLevels

; 219  : 	GameSettings.Level = GetLevelNum(RegistrySettings.LevelDir);

	push	OFFSET FLAT:?RegistrySettings@@3UREGISTRY_SETTINGS@@A+124
	call	?GetLevelNum@@YAJPAD@Z			; GetLevelNum
	add	esp, 4
	mov	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4, eax

; 220  : 	if (GameSettings.Level == -1)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4, -1
	jne	SHORT $L82137

; 221  : 		GameSettings.Level = 0;

	mov	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4, 0
$L82137:

; 222  : 
; 223  : // read car info
; 224  : 
; 225  : 	if (!ReadAllCarInfo(CarInfoFile))

	mov	eax, DWORD PTR ?CarInfoFile@@3PADA	; CarInfoFile
	push	eax
	call	?ReadAllCarInfo@@YA_NPAD@Z		; ReadAllCarInfo
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L82138

; 226  : 		return FALSE;

	xor	eax, eax
	jmp	$L82103
$L82138:

; 227  : 
; 228  : 	SetAllCarCoMs();

	call	?SetAllCarCoMs@@YAXXZ			; SetAllCarCoMs

; 229  : 
; 230  : // create tpage mem
; 231  : 
; 232  : 	if (!CreateTPages(TPAGE_NUM))

	push	31					; 0000001fH
	call	?CreateTPages@@YA_NH@Z			; CreateTPages
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L82139

; 233  : 		return FALSE;

	xor	eax, eax
	jmp	$L82103
$L82139:

; 234  : 
; 235  : // get timer freq
; 236  : 
; 237  : 	QueryPerformanceFrequency(&time);

	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 238  : 	TimerFreq = time.LowPart;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR ?TimerFreq@@3KA, eax		; TimerFreq

; 239  : 
; 240  : // set rand seed
; 241  : 
; 242  : 	srand(CurrentTimer());

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	push	eax
	call	_srand
	add	esp, 4

; 243  : 
; 244  : // get all available draw devices
; 245  : 
; 246  : 	GetDrawDevices();

	call	?GetDrawDevices@@YAXXZ			; GetDrawDevices

; 247  : 
; 248  : // init DX misc
; 249  : 
; 250  : 	InitInput(hThisInst);

	mov	eax, DWORD PTR _hThisInst$[ebp]
	push	eax
	call	?InitInput@@YAJPAUHINSTANCE__@@@Z	; InitInput
	add	esp, 4

; 251  : 
; 252  : 	if (!InitDD())

	call	?InitDD@@YAHXZ				; InitDD
	test	eax, eax
	jne	SHORT $L82140

; 253  : 	{
; 254  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame
$L82140:

; 255  : 	}
; 256  : 
; 257  : // init sound system
; 258  : 
; 259  : 	InitSound();

	call	?InitSound@@YAJXZ			; InitSound

; 260  : 
; 261  : // check for legal IP
; 262  : 
; 263  : 	#if CHECK_IP
; 264  : 	if (!CheckLegalIP())
; 265  : 	{
; 266  : 		Box(NULL, "Illegal copy of Revolt!", MB_OK);
; 267  : 		QuitGame = TRUE;
; 268  : 	}
; 269  : 	#endif
; 270  : 
; 271  : // set start event
; 272  : 
; 273  : 	Event = Go;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?Go@@YAXXZ ; Event, Go
$L82142:

; 274  : 
; 275  : // main loop
; 276  : 
; 277  : 	while (!QuitGame)

	movsx	eax, BYTE PTR ?QuitGame@@3DA		; QuitGame
	test	eax, eax
	jne	SHORT $L82143

; 278  : 	{
; 279  : 
; 280  : // message?
; 281  : 
; 282  : 		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))

	push	1
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	test	eax, eax
	je	SHORT $L82144

; 283  : 		{
; 284  : 			if (msg.message == WM_QUIT)

	cmp	DWORD PTR _msg$[ebp+4], 18		; 00000012H
	jne	SHORT $L82145

; 285  : 			{
; 286  : 				QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 287  : 			}
; 288  : 			else

	jmp	SHORT $L82144
$L82145:

; 289  : 			{
; 290  : 				TranslateMessage(&msg);

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4

; 291  : 				DispatchMessage(&msg);

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
$L82144:

; 292  : 			}
; 293  : 		}
; 294  : 
; 295  : // handle current event
; 296  : 
; 297  : 		if (AppActive)

	movsx	eax, BYTE PTR _AppActive
	test	eax, eax
	je	SHORT $L82147

; 298  : 			Event();

	call	DWORD PTR ?Event@@3P6AXXZA		; Event
$L82147:

; 299  : 	}

	jmp	SHORT $L82142
$L82143:

; 300  : 
; 301  : // release DX misc
; 302  : 
; 303  : 	DD->RestoreDisplayMode();

	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+76]

; 304  : 	FreeTextures();

	call	?FreeTextures@@YAXXZ			; FreeTextures

; 305  : 	KillInput();

	call	?KillInput@@YAXXZ			; KillInput

; 306  : 	KillPlay();

	call	?KillPlay@@YAXXZ			; KillPlay

; 307  : 	ReleaseD3D();

	call	?ReleaseD3D@@YAXXZ			; ReleaseD3D

; 308  : 	ReleaseDX();

	call	?ReleaseDX@@YAXXZ			; ReleaseDX

; 309  : 
; 310  : // release sound system
; 311  : 
; 312  : 	ReleaseSound();

	call	?ReleaseSound@@YAXXZ			; ReleaseSound

; 313  : 
; 314  : // destroy tpage mem
; 315  : 
; 316  : 	DestroyTPages();

	call	?DestroyTPages@@YAXXZ			; DestroyTPages

; 317  : 
; 318  : // kill car info
; 319  : 
; 320  : 	DestroyCarInfo();

	call	?DestroyCarInfo@@YAXXZ			; DestroyCarInfo

; 321  : 
; 322  : // free levels
; 323  : 
; 324  : 	FreeLevels();

	call	?FreeLevels@@YAXXZ			; FreeLevels

; 325  : 
; 326  : // save registry settings
; 327  : 
; 328  : 	SetRegistrySettings();

	call	?SetRegistrySettings@@YAXXZ		; SetRegistrySettings

; 329  : 
; 330  : // free COM library
; 331  : 
; 332  : 	CoUninitialize();

	call	DWORD PTR __imp__CoUninitialize@0

; 333  : 
; 334  : // See if we have forgotten to release anything
; 335  : 
; 336  : #if USE_DEBUG_ROUTINES
; 337  : 	CheckMemoryAllocation();

	call	?CheckMemoryAllocation@@YAXXZ		; CheckMemoryAllocation

; 338  : #endif
; 339  : 
; 340  : // return
; 341  : 
; 342  : 	return msg.wParam;

	mov	eax, DWORD PTR _msg$[ebp+8]
$L82103:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
PUBLIC	?WindowFunc@@YGJPAUHWND__@@IIJ@Z		; WindowFunc
EXTRN	__imp__UpdateWindow@4:NEAR
EXTRN	__imp__GetStockObject@4:NEAR
EXTRN	__imp__SetCursor@4:NEAR
EXTRN	__imp__GetSystemMetrics@4:NEAR
EXTRN	__imp__RegisterClassA@4:NEAR
EXTRN	__imp__CreateWindowExA@48:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
_BSS	SEGMENT
_wcl	DB	028H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?InitWin@@YA_NPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_cy$ = -12						; size = 4
_by$ = -8						; size = 4
_bx$ = -4						; size = 4
_hThisInst$ = 8						; size = 4
_nWinMode$ = 12						; size = 4
?InitWin@@YA_NPAUHINSTANCE__@@H@Z PROC NEAR		; InitWin, COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 352  : 	long bx, by, cy;
; 353  : 
; 354  : // define / register windows class
; 355  : 
; 356  : 	wcl.style = CS_HREDRAW | CS_VREDRAW;

	mov	DWORD PTR _wcl, 3

; 357  : 	wcl.lpfnWndProc = WindowFunc;

	mov	DWORD PTR _wcl+4, OFFSET FLAT:?WindowFunc@@YGJPAUHWND__@@IIJ@Z ; WindowFunc

; 358  : 	wcl.hInstance = hThisInst;

	mov	eax, DWORD PTR _hThisInst$[ebp]
	mov	DWORD PTR _wcl+16, eax

; 359  : 	wcl.lpszClassName = WinName;

	mov	DWORD PTR _wcl+36, OFFSET FLAT:_WinName

; 360  : 
; 361  : 	wcl.hIcon = NULL;

	mov	DWORD PTR _wcl+20, 0

; 362  : 	wcl.hCursor = LoadCursor(NULL, IDC_CROSS);

	push	32515					; 00007f03H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wcl+24, eax

; 363  : 	wcl.lpszMenuName = NULL;

	mov	DWORD PTR _wcl+32, 0

; 364  : 
; 365  : 	wcl.cbClsExtra = 0;

	mov	DWORD PTR _wcl+8, 0

; 366  : 	wcl.cbWndExtra = 0;

	mov	DWORD PTR _wcl+12, 0

; 367  : 	wcl.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);

	push	4
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wcl+28, eax

; 368  : 
; 369  : 	if (!RegisterClass(&wcl)) return FALSE;

	push	OFFSET FLAT:_wcl
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	eax, ax
	test	eax, eax
	jne	SHORT $L82159
	xor	al, al
	jmp	$L82151
$L82159:

; 370  : 
; 371  : // create / show a window
; 372  : 
; 373  : 	if (FullScreen)

	movsx	eax, BYTE PTR ?FullScreen@@3DA		; FullScreen
	test	eax, eax
	je	SHORT $L82160

; 374  : 	{
; 375  : 		hwnd = CreateWindow(WinName, WinName, WS_POPUP,
; 376  : 			0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),
; 377  : 			NULL, NULL, hThisInst, NULL);

	push	0
	mov	eax, DWORD PTR _hThisInst$[ebp]
	push	eax
	push	0
	push	0
	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	push	eax
	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	push	eax
	push	0
	push	0
	push	-2147483648				; 80000000H
	push	OFFSET FLAT:_WinName
	push	OFFSET FLAT:_WinName
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR ?hwnd@@3PAUHWND__@@A, eax	; hwnd

; 378  : 	}
; 379  : 	else

	jmp	$L82161
$L82160:

; 380  : 	{
; 381  : 		bx = GetSystemMetrics(SM_CXSIZEFRAME);

	push	32					; 00000020H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _bx$[ebp], eax

; 382  : 		by = GetSystemMetrics(SM_CYSIZEFRAME);

	push	33					; 00000021H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _by$[ebp], eax

; 383  : 		cy = GetSystemMetrics(SM_CYCAPTION);

	push	4
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _cy$[ebp], eax

; 384  : 
; 385  : 		hwnd = CreateWindow(WinName, WinName, WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
; 386  : 			(GetSystemMetrics(SM_CXSCREEN) - RegistrySettings.ScreenWidth) / 2 - bx, (GetSystemMetrics(SM_CYSCREEN) - RegistrySettings.ScreenHeight) / 2 - by - cy / 2,
; 387  : 			RegistrySettings.ScreenWidth + bx + bx, RegistrySettings.ScreenHeight + by + by + cy,
; 388  : 			NULL, NULL, hThisInst, NULL);

	push	0
	mov	eax, DWORD PTR _hThisInst$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+36
	add	ecx, DWORD PTR _by$[ebp]
	add	ecx, DWORD PTR _by$[ebp]
	add	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+32
	add	edx, DWORD PTR _bx$[ebp]
	add	edx, DWORD PTR _bx$[ebp]
	push	edx
	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	ecx, eax
	sub	ecx, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+36
	shr	ecx, 1
	sub	ecx, DWORD PTR _by$[ebp]
	mov	eax, DWORD PTR _cy$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	push	ecx
	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	sub	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+32
	shr	eax, 1
	sub	eax, DWORD PTR _bx$[ebp]
	push	eax
	push	13041664				; 00c70000H
	push	OFFSET FLAT:_WinName
	push	OFFSET FLAT:_WinName
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR ?hwnd@@3PAUHWND__@@A, eax	; hwnd
$L82161:

; 389  : 	}
; 390  : 
; 391  : 	if (!hwnd) return FALSE;

	cmp	DWORD PTR ?hwnd@@3PAUHWND__@@A, 0	; hwnd
	jne	SHORT $L82162
	xor	al, al
	jmp	SHORT $L82151
$L82162:

; 392  : 
; 393  : 	ShowWindow(hwnd, nWinMode);

	mov	eax, DWORD PTR _nWinMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 394  : 	UpdateWindow(hwnd);

	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	call	DWORD PTR __imp__UpdateWindow@4

; 395  : 	SetCursor(NULL);

	push	0
	call	DWORD PTR __imp__SetCursor@4

; 396  : 
; 397  : // return ok
; 398  : 
; 399  : 	return TRUE;

	mov	al, 1
$L82151:

; 400  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitWin@@YA_NPAUHINSTANCE__@@H@Z ENDP			; InitWin
_TEXT	ENDS
EXTRN	__imp__MessageBoxA@16:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?Box@@YAJPAD0J@Z
_TEXT	SEGMENT
_title$ = 8						; size = 4
_mess$ = 12						; size = 4
_flag$ = 16						; size = 4
?Box@@YAJPAD0J@Z PROC NEAR				; Box, COMDAT

; 407  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 408  : 	if (DD)

	cmp	DWORD PTR ?DD@@3PAUIDirectDraw4@@A, 0	; DD
	je	SHORT $L82168

; 409  : 		DD->FlipToGDISurface();

	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+40]
$L82168:

; 410  : 	return MessageBox(hwnd, mess, title, flag);

	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _title$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mess$[ebp]
	push	edx
	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 411  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Box@@YAJPAD0J@Z ENDP					; Box
_TEXT	ENDS
PUBLIC	?Vblank@@YAXD@Z					; Vblank
; Function compile flags: /Odt /ZI
;	COMDAT ?Vblank@@YAXD@Z
_TEXT	SEGMENT
_count$ = 8						; size = 1
?Vblank@@YAXD@Z PROC NEAR				; Vblank, COMDAT

; 418  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 419  : 	for ( ; count ; count--)

	jmp	SHORT $L82172
$L82173:
	mov	al, BYTE PTR _count$[ebp]
	sub	al, 1
	mov	BYTE PTR _count$[ebp], al
$L82172:
	movsx	eax, BYTE PTR _count$[ebp]
	test	eax, eax
	je	SHORT $L82171
$L82176:

; 420  : 	{
; 421  : 		while (DD->WaitForVerticalBlank(DDWAITVB_BLOCKBEGIN, NULL) != DD_OK);

	push	0
	push	1
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+88]
	test	eax, eax
	je	SHORT $L82177
	jmp	SHORT $L82176
$L82177:

; 422  : 	}

	jmp	SHORT $L82173
$L82171:

; 423  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Vblank@@YAXD@Z ENDP					; Vblank
_TEXT	ENDS
EXTRN	__imp__GetCurrentProcess@0:NEAR
EXTRN	__imp__DefWindowProcA@16:NEAR
EXTRN	__imp__PostQuitMessage@4:NEAR
EXTRN	?PauseAllSfx@@YAXXZ:NEAR			; PauseAllSfx
EXTRN	?ResumeAllSfx@@YAXXZ:NEAR			; ResumeAllSfx
EXTRN	__imp__SetPriorityClass@8:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?WindowFunc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv64 = -72						; size = 4
_handle$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WindowFunc@@YGJPAUHWND__@@IIJ@Z PROC NEAR		; WindowFunc, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 431  : 	HANDLE handle;
; 432  : 
; 433  : // handle message
; 434  : 
; 435  : 	switch (message)

	mov	eax, DWORD PTR _message$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 2
	je	$L82195
	cmp	DWORD PTR tv64[ebp], 28			; 0000001cH
	je	SHORT $L82189
	cmp	DWORD PTR tv64[ebp], 32			; 00000020H
	je	SHORT $L82192
	jmp	$L82186
$L82189:

; 436  : 	{
; 437  : 
; 438  : // set AppActive
; 439  : 
; 440  : 		case WM_ACTIVATEAPP:
; 441  : 			AppActive = wParam;

	mov	al, BYTE PTR _wParam$[ebp]
	mov	BYTE PTR _AppActive, al

; 442  : 			AppRestore = wParam;

	mov	al, BYTE PTR _wParam$[ebp]
	mov	BYTE PTR ?AppRestore@@3DA, al		; AppRestore

; 443  : 
; 444  : 			handle = GetCurrentProcess();

	call	DWORD PTR __imp__GetCurrentProcess@0
	mov	DWORD PTR _handle$[ebp], eax

; 445  : 
; 446  : 			if (AppActive)

	movsx	eax, BYTE PTR _AppActive
	test	eax, eax
	je	SHORT $L82190

; 447  : 			{
; 448  : 				SetPriorityClass(handle, ActivePriority);

	mov	eax, DWORD PTR _ActivePriority
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetPriorityClass@8

; 449  : 				ResumeAllSfx();

	call	?ResumeAllSfx@@YAXXZ			; ResumeAllSfx

; 450  : 			}
; 451  : 			else

	jmp	SHORT $L82191
$L82190:

; 452  : 			{
; 453  : 				SetPriorityClass(handle, IDLE_PRIORITY_CLASS);

	push	64					; 00000040H
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	DWORD PTR __imp__SetPriorityClass@8

; 454  : 				PauseAllSfx();

	call	?PauseAllSfx@@YAXXZ			; PauseAllSfx
$L82191:

; 455  : 			}
; 456  : 
; 457  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L82183
$L82192:

; 458  : 
; 459  : // no cursor
; 460  : 
; 461  : 		case WM_SETCURSOR:
; 462  : 			if (FullScreen)

	movsx	eax, BYTE PTR ?FullScreen@@3DA		; FullScreen
	test	eax, eax
	je	SHORT $L82193

; 463  : 			{
; 464  : 				SetCursor(NULL);

	push	0
	call	DWORD PTR __imp__SetCursor@4

; 465  : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L82183
$L82193:

; 466  : 			}
; 467  : 			else
; 468  : 			{
; 469  : 				SetCursor(wcl.hCursor);

	mov	eax, DWORD PTR _wcl+24
	push	eax
	call	DWORD PTR __imp__SetCursor@4

; 470  : 				break;

	jmp	SHORT $L82186
$L82195:

; 471  : 			}
; 472  : 
; 473  : // terminating
; 474  : 
; 475  : 		case WM_DESTROY:
; 476  : 			PostQuitMessage(0);

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 477  : 
; 478  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L82183
$L82186:

; 479  : 	}
; 480  : 
; 481  : // default windows processing
; 482  : 
; 483  : 	return DefWindowProc(hwnd, message, wParam, lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
$L82183:

; 484  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?WindowFunc@@YGJPAUHWND__@@IIJ@Z ENDP			; WindowFunc
_TEXT	ENDS
PUBLIC	?GoFront@@YAXXZ					; GoFront
; Function compile flags: /Odt /ZI
;	COMDAT ?Go@@YAXXZ
_TEXT	SEGMENT
?Go@@YAXXZ PROC NEAR					; Go, COMDAT

; 491  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 492  : 
; 493  : // setup front end
; 494  : 
; 495  : 	Event = GoFront;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?GoFront@@YAXXZ ; Event, GoFront

; 496  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Go@@YAXXZ ENDP						; Go
_TEXT	ENDS
PUBLIC	??_C@_0O@PEANDJCI@gfx?2font1?4bmp?$AA@		; `string'
PUBLIC	??_C@_0O@IKBJKENM@gfx?2title?4bmp?$AA@		; `string'
EXTRN	?LoadBitmapA@@YAHPADPAPAUHBITMAP__@@@Z:NEAR	; LoadBitmapA
EXTRN	?SetViewport@@YAXMMMMM@Z:NEAR			; SetViewport
EXTRN	?InitD3D@@YAHKKKK@Z:NEAR			; InitD3D
EXTRN	?SetupDxState@@YAXXZ:NEAR			; SetupDxState
EXTRN	?ScreenXsize@@3KA:DWORD				; ScreenXsize
EXTRN	?ScreenYsize@@3KA:DWORD				; ScreenYsize
EXTRN	?DisplayModeCount@@3JA:DWORD			; DisplayModeCount
EXTRN	?DrawDevices@@3PAUDRAW_DEVICE@@A:BYTE		; DrawDevices
EXTRN	?MainMenu@@YAXXZ:NEAR				; MainMenu
EXTRN	?MenuCount@@3FA:WORD				; MenuCount
EXTRN	?BaseGeomPers@@3MA:DWORD			; BaseGeomPers
EXTRN	?TestConjGrad@@YAXXZ:NEAR			; TestConjGrad
EXTRN	?GetTextureFormat@@YAXJ@Z:NEAR			; GetTextureFormat
EXTRN	?LoadMipTexture@@YA_NPADDJJJJ@Z:NEAR		; LoadMipTexture
EXTRN	?InitTextures@@YAXXZ:NEAR			; InitTextures
EXTRN	?SetNearFar@@YAXMM@Z:NEAR			; SetNearFar
;	COMDAT ??_C@_0O@PEANDJCI@gfx?2font1?4bmp?$AA@
CONST	SEGMENT
??_C@_0O@PEANDJCI@gfx?2font1?4bmp?$AA@ DB 'gfx\font1.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IKBJKENM@gfx?2title?4bmp?$AA@
CONST	SEGMENT
??_C@_0O@IKBJKENM@gfx?2title?4bmp?$AA@ DB 'gfx\title.bmp', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?GoFront@@YAXXZ
_TEXT	SEGMENT
tv157 = -80						; size = 8
tv153 = -72						; size = 8
?GoFront@@YAXXZ PROC NEAR				; GoFront, COMDAT

; 503  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 504  : 
; 505  : // test linear problem solver??? (eh?)
; 506  : 
; 507  : #if DEBUG_SOLVER
; 508  : 	TestConjGrad();

	call	?TestConjGrad@@YAXXZ			; TestConjGrad

; 509  : #endif
; 510  : 
; 511  : // init D3D
; 512  : 
; 513  : 	if (!InitD3D(DrawDevices[RegistrySettings.DrawDevice].DisplayMode[DisplayModeCount].Width, DrawDevices[RegistrySettings.DrawDevice].DisplayMode[DisplayModeCount].Height, DrawDevices[RegistrySettings.DrawDevice].DisplayMode[DisplayModeCount].Bpp, 0))

	push	0
	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DisplayModeCount@@3JA	; DisplayModeCount
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+ecx+144]
	push	edx
	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DisplayModeCount@@3JA	; DisplayModeCount
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+ecx+140]
	push	edx
	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DisplayModeCount@@3JA	; DisplayModeCount
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+ecx+136]
	push	edx
	call	?InitD3D@@YAHKKKK@Z			; InitD3D
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L82202

; 514  : 	{
; 515  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 516  : 		return;

	jmp	$L82201
$L82202:

; 517  : 	}
; 518  : 
; 519  : 	GetTextureFormat(RegistrySettings.TextureBpp);

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+56
	push	eax
	call	?GetTextureFormat@@YAXJ@Z		; GetTextureFormat
	add	esp, 4

; 520  : 	InitTextures();

	call	?InitTextures@@YAXXZ			; InitTextures

; 521  : 
; 522  : // setup states
; 523  : 
; 524  : 	SetupDxState();

	call	?SetupDxState@@YAXXZ			; SetupDxState

; 525  : 
; 526  : // set geom vars
; 527  : 
; 528  : 	RenderSettings.GeomPers = BaseGeomPers;

	mov	eax, DWORD PTR ?BaseGeomPers@@3MA
	mov	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A, eax

; 529  : 	SetNearFar(48.0f, 4096.0f);

	push	1166016512				; 45800000H
	push	1111490560				; 42400000H
	call	?SetNearFar@@YAXMM@Z			; SetNearFar
	add	esp, 8

; 530  : 	SetViewport(0, 0, (float)ScreenXsize, (float)ScreenYsize, RenderSettings.GeomPers);

	mov	eax, DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	push	eax
	mov	ecx, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR tv153[ebp], ecx
	mov	DWORD PTR tv153[ebp+4], 0
	fild	QWORD PTR tv153[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR tv157[ebp], edx
	mov	DWORD PTR tv157[ebp+4], 0
	fild	QWORD PTR tv157[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	push	0
	call	?SetViewport@@YAXMMMMM@Z		; SetViewport
	add	esp, 20					; 00000014H

; 531  : 
; 532  : // setup main menu
; 533  : 
; 534  : 	LoadMipTexture("gfx\\font1.bmp", TPAGE_FONT, 256, 256, 0, 1);

	push	1
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	push	22					; 00000016H
	push	OFFSET FLAT:??_C@_0O@PEANDJCI@gfx?2font1?4bmp?$AA@
	call	?LoadMipTexture@@YA_NPADDJJJJ@Z		; LoadMipTexture
	add	esp, 24					; 00000018H

; 535  : 
; 536  : 	LoadBitmap("gfx\\title.bmp", &TitleHbm);

	push	OFFSET FLAT:?TitleHbm@@3PAUHBITMAP__@@A	; TitleHbm
	push	OFFSET FLAT:??_C@_0O@IKBJKENM@gfx?2title?4bmp?$AA@
	call	?LoadBitmapA@@YAHPADPAPAUHBITMAP__@@@Z	; LoadBitmapA
	add	esp, 8

; 537  : 
; 538  : 	MenuCount = 0;

	mov	WORD PTR ?MenuCount@@3FA, 0		; MenuCount

; 539  : 	Event = MainMenu;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?MainMenu@@YAXXZ ; Event, MainMenu
$L82201:

; 540  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoFront@@YAXXZ ENDP					; GoFront
_TEXT	ENDS
PUBLIC	?SetupGame@@YAXXZ				; SetupGame
PUBLIC	?InitPlayersTrial@@YAXXZ			; InitPlayersTrial
PUBLIC	?InitPlayersSingle@@YAXXZ			; InitPlayersSingle
PUBLIC	?InitPlayersNetwork@@YAXXZ			; InitPlayersNetwork
EXTRN	?FreeBitmap@@YAHPAUHBITMAP__@@@Z:NEAR		; FreeBitmap
EXTRN	?SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z:NEAR ; SetCameraFollow
EXTRN	?CAM_MainCamera@@3PAUCameraStruct@@A:DWORD	; CAM_MainCamera
EXTRN	?CurrentDrawDevice@@3JA:DWORD			; CurrentDrawDevice
EXTRN	?GRD_AllocGrids@@YAJXZ:NEAR			; GRD_AllocGrids
EXTRN	?LEV_InitLevel@@YAXXZ:NEAR			; LEV_InitLevel
EXTRN	?GLP_GameLoop@@YAXXZ:NEAR			; GLP_GameLoop
EXTRN	?UpdateTimeFactor@@YAXXZ:NEAR			; UpdateTimeFactor
EXTRN	?TotalRaceTime@@3KA:DWORD			; TotalRaceTime
EXTRN	?TimeQueue@@3JA:DWORD				; TimeQueue
EXTRN	?PickTextureSets@@YAXJ@Z:NEAR			; PickTextureSets
EXTRN	?PLR_LocalPlayer@@3PAUPlayerStruct@@A:DWORD	; PLR_LocalPlayer
; Function compile flags: /Odt /ZI
;	COMDAT ?SetupGame@@YAXXZ
_TEXT	SEGMENT
?SetupGame@@YAXXZ PROC NEAR				; SetupGame, COMDAT

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 548  : 
; 549  : // kill title bitmap + textures
; 550  : 
; 551  : 	FreeBitmap(TitleHbm);

	mov	eax, DWORD PTR ?TitleHbm@@3PAUHBITMAP__@@A ; TitleHbm
	push	eax
	call	?FreeBitmap@@YAHPAUHBITMAP__@@@Z	; FreeBitmap
	add	esp, 4

; 552  : 	FreeTextures();

	call	?FreeTextures@@YAXXZ			; FreeTextures

; 553  : 
; 554  : // draw device changed?
; 555  : 
; 556  : 	if (RegistrySettings.DrawDevice != (DWORD)CurrentDrawDevice)

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	cmp	eax, DWORD PTR ?CurrentDrawDevice@@3JA	; CurrentDrawDevice
	je	SHORT $L82211

; 557  : 	{
; 558  : 		DD->FlipToGDISurface();

	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+40]

; 559  : 		FreeTextures();

	call	?FreeTextures@@YAXXZ			; FreeTextures

; 560  : 		ReleaseD3D();

	call	?ReleaseD3D@@YAXXZ			; ReleaseD3D

; 561  : 		InitDD();

	call	?InitDD@@YAHXZ				; InitDD
$L82211:

; 562  : 	}
; 563  : 
; 564  : // init D3D
; 565  : 
; 566  : 	if (!InitD3D(DrawDevices[RegistrySettings.DrawDevice].DisplayMode[DisplayModeCount].Width, DrawDevices[RegistrySettings.DrawDevice].DisplayMode[DisplayModeCount].Height, DrawDevices[RegistrySettings.DrawDevice].DisplayMode[DisplayModeCount].Bpp, 0))

	push	0
	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DisplayModeCount@@3JA	; DisplayModeCount
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+ecx+144]
	push	edx
	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DisplayModeCount@@3JA	; DisplayModeCount
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+ecx+140]
	push	edx
	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DisplayModeCount@@3JA	; DisplayModeCount
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+ecx+136]
	push	edx
	call	?InitD3D@@YAHKKKK@Z			; InitD3D
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L82212

; 567  : 	{
; 568  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 569  : 		return;

	jmp	$L82209
$L82212:

; 570  : 	}
; 571  : 
; 572  : 	GetTextureFormat(RegistrySettings.TextureBpp);

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+56
	push	eax
	call	?GetTextureFormat@@YAXJ@Z		; GetTextureFormat
	add	esp, 4

; 573  : 	InitTextures();

	call	?InitTextures@@YAXXZ			; InitTextures

; 574  : 
; 575  : // setup states
; 576  : 
; 577  : 	SetupDxState();

	call	?SetupDxState@@YAXXZ			; SetupDxState

; 578  : 
; 579  : // pick texture sets
; 580  : 
; 581  : 	if (GameSettings.GameType == GAMETYPE_TRIAL)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 0
	jne	SHORT $L82213

; 582  : 		PickTextureSets(2);

	push	2
	call	?PickTextureSets@@YAXJ@Z		; PickTextureSets
	add	esp, 4

; 583  : 	else

	jmp	SHORT $L82214
$L82213:

; 584  : 		PickTextureSets(MAX_NUM_PLAYERS);

	push	12					; 0000000cH
	call	?PickTextureSets@@YAXJ@Z		; PickTextureSets
	add	esp, 4
$L82214:

; 585  : 
; 586  : // initialise object grid system
; 587  : 
; 588  : 	if (!GRD_AllocGrids())

	call	?GRD_AllocGrids@@YAJXZ			; GRD_AllocGrids
	test	eax, eax
	jne	SHORT $L82215

; 589  : 	{
; 590  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame
$L82215:

; 591  : 	}
; 592  : 
; 593  : // init level
; 594  : 
; 595  : 	LEV_InitLevel();

	call	?LEV_InitLevel@@YAXXZ			; LEV_InitLevel

; 596  : 
; 597  : // init players
; 598  : 
; 599  : 	if (GameSettings.GameType == GAMETYPE_TRIAL) {

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 0
	jne	SHORT $L82216

; 600  : 		InitPlayersTrial();

	call	?InitPlayersTrial@@YAXXZ		; InitPlayersTrial

; 601  : 		//InitPlayeresFullArray();
; 602  : 	} else if (GameSettings.GameType == GAMETYPE_SINGLE) {

	jmp	SHORT $L82217
$L82216:
	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A, 1
	jne	SHORT $L82218

; 603  : 		InitPlayersSingle();

	call	?InitPlayersSingle@@YAXXZ		; InitPlayersSingle

; 604  : 	} else {

	jmp	SHORT $L82217
$L82218:

; 605  : 		InitPlayersNetwork();

	call	?InitPlayersNetwork@@YAXXZ		; InitPlayersNetwork
$L82217:

; 606  : 	}
; 607  : 
; 608  : // Set camera to follow car
; 609  : 
; 610  : 	SetCameraFollow(CAM_MainCamera, PLR_LocalPlayer->ownobj, CAM_FOLLOW_BEHIND);

	push	0
	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	push	edx
	call	?SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ; SetCameraFollow
	add	esp, 12					; 0000000cH

; 611  : 
; 612  : // go game loop
; 613  : 
; 614  : 	TotalRaceTime = 0;

	mov	DWORD PTR ?TotalRaceTime@@3KA, 0	; TotalRaceTime

; 615  : 	TimeQueue = 0;

	mov	DWORD PTR ?TimeQueue@@3JA, 0		; TimeQueue

; 616  : 	UpdateTimeFactor();

	call	?UpdateTimeFactor@@YAXXZ		; UpdateTimeFactor

; 617  : 	Event = GLP_GameLoop;

	mov	DWORD PTR ?Event@@3P6AXXZA, OFFSET FLAT:?GLP_GameLoop@@YAXXZ ; Event, GLP_GameLoop
$L82209:

; 618  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupGame@@YAXXZ ENDP					; SetupGame
_TEXT	ENDS
PUBLIC	??_C@_0BL@DEGNDLFE@Can?8t?5create?5ghost?5player?$CB?$AA@ ; `string'
PUBLIC	?InitPlayeresFullArray@@YAXXZ			; InitPlayeresFullArray
EXTRN	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; PLR_CreatePlayer
EXTRN	?InitGhostData@@YAXPAUPlayerStruct@@@Z:NEAR	; InitGhostData
EXTRN	?InitBestGhostData@@YAXXZ:NEAR			; InitBestGhostData
EXTRN	?ClearBestGhostData@@YAXXZ:NEAR			; ClearBestGhostData
EXTRN	?LoadGhostData@@YA_NPAULEVELINFO@@@Z:NEAR	; LoadGhostData
EXTRN	?InitGhostLight@@YAXXZ:NEAR			; InitGhostLight
EXTRN	?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A:DWORD ; GHO_BestGhostInfo
EXTRN	?GHO_GhostPlayer@@3PAUPlayerStruct@@A:DWORD	; GHO_GhostPlayer
EXTRN	?GHO_GhostExists@@3_NA:BYTE			; GHO_GhostExists
EXTRN	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; GetCarGrid
EXTRN	?LevelInf@@3PAULEVELINFO@@A:DWORD		; LevelInf
EXTRN	?CountdownTime@@3KA:DWORD			; CountdownTime
EXTRN	?CountdownEndTime@@3KA:DWORD			; CountdownEndTime
;	COMDAT ??_C@_0BL@DEGNDLFE@Can?8t?5create?5ghost?5player?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@DEGNDLFE@Can?8t?5create?5ghost?5player?$CB?$AA@ DB 'Can''t crea'
	DB	'te ghost player!', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitPlayeresFullArray@@YAXXZ
_TEXT	SEGMENT
_anotherPlayer$ = -72					; size = 4
_sepVec$ = -68						; size = 12
_pos$ = -56						; size = 12
_mat$ = -44						; size = 36
_sep$ = -8						; size = 4
_playerCarID$ = -4					; size = 4
?InitPlayeresFullArray@@YAXXZ PROC NEAR			; InitPlayeresFullArray, COMDAT

; 629  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 630  : 	int		playerCarID;
; 631  : 	REAL	sep;
; 632  : 	MAT	mat;
; 633  : 	VEC	pos, sepVec;
; 634  : 	PLAYER	*anotherPlayer;
; 635  : 
; 636  : 	SetVec(&sepVec, ONE, ZERO, ZERO);

	mov	DWORD PTR _sepVec$[ebp], 1065353216	; 3f800000H
	mov	DWORD PTR _sepVec$[ebp+4], 0
	mov	DWORD PTR _sepVec$[ebp+8], 0

; 637  : 	sep = Real(100);

	mov	DWORD PTR _sep$[ebp], 1120403456	; 42c80000H

; 638  : 
; 639  : 	for (playerCarID = 0; playerCarID < 6; playerCarID++) {

	mov	DWORD PTR _playerCarID$[ebp], 0
	jmp	SHORT $L82230
$L82231:
	mov	eax, DWORD PTR _playerCarID$[ebp]
	add	eax, 1
	mov	DWORD PTR _playerCarID$[ebp], eax
$L82230:
	cmp	DWORD PTR _playerCarID$[ebp], 6
	jge	SHORT $L82232

; 640  : 		
; 641  : 		GetCarGrid(playerCarID, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _playerCarID$[ebp]
	push	edx
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 642  : 		//VecPlusScalarVec(&LEV_StartPos, playerCarID * sep, &sepVec, &pos);
; 643  : 		anotherPlayer =  PLR_CreatePlayer(PLAYER_LOCAL, CTRL_TYPE_KBD, 1, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	1
	push	1
	push	1
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	mov	DWORD PTR _anotherPlayer$[ebp], eax

; 644  : 		if (anotherPlayer == NULL) {

	cmp	DWORD PTR _anotherPlayer$[ebp], 0
	jne	SHORT $L82233

; 645  : 			return;

	jmp	$L82222
$L82233:

; 646  : 		}
; 647  : 		if (playerCarID == 0) {

	cmp	DWORD PTR _playerCarID$[ebp], 0
	jne	SHORT $L82234

; 648  : 			PLR_LocalPlayer = anotherPlayer;

	mov	eax, DWORD PTR _anotherPlayer$[ebp]
	mov	DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A, eax ; PLR_LocalPlayer
$L82234:

; 649  : 		}
; 650  : 	}

	jmp	SHORT $L82231
$L82232:

; 651  : 
; 652  : 	// Create the ghost
; 653  : 	GHO_GhostExists = LoadGhostData(&LevelInf[GameSettings.Level]);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	call	?LoadGhostData@@YA_NPAULEVELINFO@@@Z	; LoadGhostData
	add	esp, 4
	mov	BYTE PTR ?GHO_GhostExists@@3_NA, al	; GHO_GhostExists

; 654  : 
; 655  : 	if (GHO_GhostExists)

	movzx	eax, BYTE PTR ?GHO_GhostExists@@3_NA	; GHO_GhostExists
	test	eax, eax
	je	SHORT $L82235

; 656  : 		playerCarID = GHO_BestGhostInfo->CarID;

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _playerCarID$[ebp], ecx

; 657  : 	else

	jmp	SHORT $L82236
$L82235:

; 658  : 		playerCarID = 0;

	mov	DWORD PTR _playerCarID$[ebp], 0
$L82236:

; 659  : 
; 660  : 	GetCarGrid(0, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 661  : 	GHO_GhostPlayer = PLR_CreatePlayer(PLAYER_GHOST, CTRL_TYPE_NONE, playerCarID, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _playerCarID$[ebp]
	push	edx
	push	0
	push	4
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A, eax ; GHO_GhostPlayer

; 662  : 	if (GHO_GhostPlayer == NULL)

	cmp	DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A, 0 ; GHO_GhostPlayer
	jne	SHORT $L82237

; 663  : 	{
; 664  : 		Box(NULL, "Can't create ghost player!", MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:??_C@_0BL@DEGNDLFE@Can?8t?5create?5ghost?5player?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 665  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 666  : 		return;

	jmp	SHORT $L82222
$L82237:

; 667  : 	}
; 668  : 
; 669  : 	if (!GHO_GhostExists)

	movzx	eax, BYTE PTR ?GHO_GhostExists@@3_NA	; GHO_GhostExists
	test	eax, eax
	jne	SHORT $L82239

; 670  : 		ClearBestGhostData();

	call	?ClearBestGhostData@@YAXXZ		; ClearBestGhostData
$L82239:

; 671  : 
; 672  : 	InitGhostData(PLR_LocalPlayer);

	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	push	eax
	call	?InitGhostData@@YAXPAUPlayerStruct@@@Z	; InitGhostData
	add	esp, 4

; 673  : 	InitBestGhostData();

	call	?InitBestGhostData@@YAXXZ		; InitBestGhostData

; 674  : 	InitGhostLight();

	call	?InitGhostLight@@YAXXZ			; InitGhostLight

; 675  : 
; 676  : 	// get countdown timer
; 677  : 	CountdownEndTime = CurrentTimer() + MS2TIME(COUNTDOWN_START);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	add	ecx, eax
	mov	DWORD PTR ?CountdownEndTime@@3KA, ecx	; CountdownEndTime

; 678  : 	CountdownTime = TRUE;

	mov	DWORD PTR ?CountdownTime@@3KA, 1	; CountdownTime
$L82222:

; 679  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlayeresFullArray@@YAXXZ ENDP			; InitPlayeresFullArray
_TEXT	ENDS
PUBLIC	??_C@_0BL@MBMPPHHG@Can?8t?5create?5local?5player?$CB?$AA@ ; `string'
EXTRN	?NCarTypes@@3JA:DWORD				; NCarTypes
EXTRN	?CurrentJoystick@@3JA:DWORD			; CurrentJoystick
EXTRN	?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A:DWORD	; PLR_LocalCtrlType
;	COMDAT ??_C@_0BL@MBMPPHHG@Can?8t?5create?5local?5player?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@MBMPPHHG@Can?8t?5create?5local?5player?$CB?$AA@ DB 'Can''t crea'
	DB	'te local player!', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitPlayersTrial@@YAXXZ
_TEXT	SEGMENT
_pos$ = -52						; size = 12
_mat$ = -40						; size = 36
_playerCarID$ = -4					; size = 4
?InitPlayersTrial@@YAXXZ PROC NEAR			; InitPlayersTrial, COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 687  : 	int playerCarID;
; 688  : 	MAT mat;
; 689  : 	VEC pos;
; 690  : 
; 691  : // Set up local player
; 692  : 
; 693  : 	if (GameSettings.CarID < (DWORD)NCarTypes)

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+24
	cmp	eax, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	jae	SHORT $L82247

; 694  : 		playerCarID = GameSettings.CarID;

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+24
	mov	DWORD PTR _playerCarID$[ebp], eax

; 695  : 	else

	jmp	SHORT $L82248
$L82247:

; 696  : 		playerCarID = 0;

	mov	DWORD PTR _playerCarID$[ebp], 0
$L82248:

; 697  : 
; 698  : 	if (CurrentJoystick != -1) PLR_LocalCtrlType = CTRL_TYPE_JOY;

	cmp	DWORD PTR ?CurrentJoystick@@3JA, -1	; CurrentJoystick
	je	SHORT $L82249
	mov	DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A, 2 ; PLR_LocalCtrlType

; 699  : 	else PLR_LocalCtrlType = CTRL_TYPE_KBD;

	jmp	SHORT $L82250
$L82249:
	mov	DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A, 1 ; PLR_LocalCtrlType
$L82250:

; 700  : 
; 701  : 	GetCarGrid(0, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 702  : 
; 703  : 	PLR_LocalPlayer = PLR_CreatePlayer(PLAYER_LOCAL, PLR_LocalCtrlType, playerCarID, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _playerCarID$[ebp]
	push	edx
	mov	eax, DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A ; PLR_LocalCtrlType
	push	eax
	push	1
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A, eax ; PLR_LocalPlayer

; 704  : 	if (PLR_LocalPlayer == NULL)

	cmp	DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A, 0 ; PLR_LocalPlayer
	jne	SHORT $L82251

; 705  : 	{
; 706  : 		Box(NULL, "Can't create local player!", MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:??_C@_0BL@MBMPPHHG@Can?8t?5create?5local?5player?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 707  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 708  : 		return;

	jmp	$L82242
$L82251:

; 709  : 	}
; 710  : 
; 711  : // Setup ghost car
; 712  : 
; 713  : 	GHO_GhostExists = LoadGhostData(&LevelInf[GameSettings.Level]);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	call	?LoadGhostData@@YA_NPAULEVELINFO@@@Z	; LoadGhostData
	add	esp, 4
	mov	BYTE PTR ?GHO_GhostExists@@3_NA, al	; GHO_GhostExists

; 714  : 
; 715  : 	if (GHO_GhostExists)

	movzx	eax, BYTE PTR ?GHO_GhostExists@@3_NA	; GHO_GhostExists
	test	eax, eax
	je	SHORT $L82253

; 716  : 		playerCarID = GHO_BestGhostInfo->CarID;

	mov	eax, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _playerCarID$[ebp], ecx

; 717  : 	else

	jmp	SHORT $L82254
$L82253:

; 718  : 		playerCarID = 0;

	mov	DWORD PTR _playerCarID$[ebp], 0
$L82254:

; 719  : 
; 720  : 	GetCarGrid(0, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 721  : 	GHO_GhostPlayer = PLR_CreatePlayer(PLAYER_GHOST, CTRL_TYPE_NONE, playerCarID, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _playerCarID$[ebp]
	push	edx
	push	0
	push	4
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A, eax ; GHO_GhostPlayer

; 722  : 	if (GHO_GhostPlayer == NULL)

	cmp	DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A, 0 ; GHO_GhostPlayer
	jne	SHORT $L82255

; 723  : 	{
; 724  : 		Box(NULL, "Can't create ghost player!", MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:??_C@_0BL@DEGNDLFE@Can?8t?5create?5ghost?5player?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 725  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 726  : 		return;

	jmp	SHORT $L82242
$L82255:

; 727  : 	}
; 728  : 
; 729  : 	if (!GHO_GhostExists)

	movzx	eax, BYTE PTR ?GHO_GhostExists@@3_NA	; GHO_GhostExists
	test	eax, eax
	jne	SHORT $L82256

; 730  : 		ClearBestGhostData();

	call	?ClearBestGhostData@@YAXXZ		; ClearBestGhostData
$L82256:

; 731  : 
; 732  : 	InitGhostData(PLR_LocalPlayer);

	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	push	eax
	call	?InitGhostData@@YAXPAUPlayerStruct@@@Z	; InitGhostData
	add	esp, 4

; 733  : 	InitBestGhostData();

	call	?InitBestGhostData@@YAXXZ		; InitBestGhostData

; 734  : 	InitGhostLight();

	call	?InitGhostLight@@YAXXZ			; InitGhostLight

; 735  : 
; 736  : // get countdown timer
; 737  : 
; 738  : 	CountdownEndTime = CurrentTimer() + MS2TIME(COUNTDOWN_START);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	add	ecx, eax
	mov	DWORD PTR ?CountdownEndTime@@3KA, ecx	; CountdownEndTime

; 739  : 	CountdownTime = TRUE;

	mov	DWORD PTR ?CountdownTime@@3KA, 1	; CountdownTime
$L82242:

; 740  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlayersTrial@@YAXXZ ENDP				; InitPlayersTrial
_TEXT	ENDS
PUBLIC	??_C@_0BO@CDDCENDO@Can?8t?5create?5computer?5player?$CB?$AA@ ; `string'
;	COMDAT ??_C@_0BO@CDDCENDO@Can?8t?5create?5computer?5player?$CB?$AA@
CONST	SEGMENT
??_C@_0BO@CDDCENDO@Can?8t?5create?5computer?5player?$CB?$AA@ DB 'Can''t c'
	DB	'reate computer player!', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitPlayersSingle@@YAXXZ
_TEXT	SEGMENT
_pos$ = -52						; size = 12
_mat$ = -40						; size = 36
_playerCarID$ = -4					; size = 4
?InitPlayersSingle@@YAXXZ PROC NEAR			; InitPlayersSingle, COMDAT

; 747  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 748  : 	int playerCarID;
; 749  : 	MAT mat;
; 750  : 	VEC pos;
; 751  : 
; 752  : // Set up the local player
; 753  : 
; 754  : 	if (GameSettings.CarID < (DWORD)NCarTypes)

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+24
	cmp	eax, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	jae	SHORT $L82264

; 755  : 		playerCarID = GameSettings.CarID;

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+24
	mov	DWORD PTR _playerCarID$[ebp], eax

; 756  : 	else

	jmp	SHORT $L82265
$L82264:

; 757  : 		playerCarID = 0;

	mov	DWORD PTR _playerCarID$[ebp], 0
$L82265:

; 758  : 
; 759  : 	if (CurrentJoystick != -1) PLR_LocalCtrlType = CTRL_TYPE_JOY;

	cmp	DWORD PTR ?CurrentJoystick@@3JA, -1	; CurrentJoystick
	je	SHORT $L82266
	mov	DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A, 2 ; PLR_LocalCtrlType

; 760  : 	else PLR_LocalCtrlType = CTRL_TYPE_KBD;

	jmp	SHORT $L82267
$L82266:
	mov	DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A, 1 ; PLR_LocalCtrlType
$L82267:

; 761  : 
; 762  : 	GetCarGrid(0, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 763  : 	PLR_LocalPlayer = PLR_CreatePlayer(PLAYER_LOCAL, CTRL_TYPE_KBD, playerCarID, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _playerCarID$[ebp]
	push	edx
	push	1
	push	1
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A, eax ; PLR_LocalPlayer

; 764  : 	if (PLR_LocalPlayer == NULL)

	cmp	DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A, 0 ; PLR_LocalPlayer
	jne	SHORT $L82268

; 765  : 	{
; 766  : 		Box(NULL, "Can't create local player!", MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:??_C@_0BL@MBMPPHHG@Can?8t?5create?5local?5player?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 767  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 768  : 		return;

	jmp	SHORT $L82259
$L82268:

; 769  : 	}
; 770  : 
; 771  : 	GetCarGrid(1, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	1
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 772  : 	if(!PLR_CreatePlayer(PLAYER_CPU, CTRL_TYPE_CPU, 0, &pos, &mat))

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	push	3
	push	3
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $L82269

; 773  : 	{
; 774  : 		Box(NULL, "Can't create computer player!", MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:??_C@_0BO@CDDCENDO@Can?8t?5create?5computer?5player?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 775  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 776  : 		return;

	jmp	SHORT $L82259
$L82269:

; 777  : 	}
; 778  : 
; 779  : 
; 780  : // no ghost
; 781  : 
; 782  : 	GHO_GhostExists = FALSE;

	mov	BYTE PTR ?GHO_GhostExists@@3_NA, 0	; GHO_GhostExists

; 783  : 	GHO_GhostPlayer = NULL;

	mov	DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A, 0 ; GHO_GhostPlayer

; 784  : 
; 785  : // get countdown timer
; 786  : 
; 787  : 	CountdownEndTime = CurrentTimer() + MS2TIME(COUNTDOWN_START);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	add	ecx, eax
	mov	DWORD PTR ?CountdownEndTime@@3KA, ecx	; CountdownEndTime

; 788  : 	CountdownTime = TRUE;

	mov	DWORD PTR ?CountdownTime@@3KA, 1	; CountdownTime
$L82259:

; 789  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlayersSingle@@YAXXZ ENDP				; InitPlayersSingle
_TEXT	ENDS
PUBLIC	??_C@_0BH@BAOHMLDO@Can?8t?5create?5player?5?$CFs?$AA@ ; `string'
EXTRN	?LocalPlayerID@@3KA:DWORD			; LocalPlayerID
EXTRN	?StartData@@3USTART_DATA@@A:BYTE		; StartData
EXTRN	__imp__wsprintfA:NEAR
EXTRN	_strncpy:NEAR
;	COMDAT ??_C@_0BH@BAOHMLDO@Can?8t?5create?5player?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BH@BAOHMLDO@Can?8t?5create?5player?5?$CFs?$AA@ DB 'Can''t create p'
	DB	'layer %s', 00H				; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitPlayersNetwork@@YAXXZ
_TEXT	SEGMENT
_buf$ = -312						; size = 256
_pos$ = -56						; size = 12
_mat$ = -44						; size = 36
_player$ = -8						; size = 4
_i$ = -4						; size = 4
?InitPlayersNetwork@@YAXXZ PROC NEAR			; InitPlayersNetwork, COMDAT

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	push	ebx
	push	esi
	push	edi

; 797  : 	int i;
; 798  : 	PLAYER *player;
; 799  : 	MAT mat;
; 800  : 	VEC pos;
; 801  : 	char buf[256];
; 802  : 
; 803  : // setup local player control type
; 804  : 
; 805  : 	if (CurrentJoystick != -1) PLR_LocalCtrlType = CTRL_TYPE_JOY;

	cmp	DWORD PTR ?CurrentJoystick@@3JA, -1	; CurrentJoystick
	je	SHORT $L82279
	mov	DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A, 2 ; PLR_LocalCtrlType

; 806  : 	else PLR_LocalCtrlType = CTRL_TYPE_KBD;

	jmp	SHORT $L82280
$L82279:
	mov	DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A, 1 ; PLR_LocalCtrlType
$L82280:

; 807  : 
; 808  : // create all players
; 809  : 
; 810  : 	for (i = 0 ; i < StartData.PlayerNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82281
$L82282:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82281:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?StartData@@3USTART_DATA@@A
	jge	$L82283

; 811  : 	{
; 812  : 		GetCarGrid(StartData.PlayerData[i].GridNum, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR ?StartData@@3USTART_DATA@@A[edx+20]
	push	eax
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 813  : 
; 814  : 		if (StartData.PlayerData[i].PlayerID == LocalPlayerID)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR ?StartData@@3USTART_DATA@@A[eax+28]
	cmp	ecx, DWORD PTR ?LocalPlayerID@@3KA	; LocalPlayerID
	jne	SHORT $L82284

; 815  : 			PLR_LocalPlayer = player = PLR_CreatePlayer(PLAYER_LOCAL, PLR_LocalCtrlType, StartData.PlayerData[i].CarID, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR ?StartData@@3USTART_DATA@@A[edx+24]
	push	eax
	mov	ecx, DWORD PTR ?PLR_LocalCtrlType@@3W4CTRL_TYPE@@A ; PLR_LocalCtrlType
	push	ecx
	push	1
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	mov	DWORD PTR _player$[ebp], eax
	mov	edx, DWORD PTR _player$[ebp]
	mov	DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A, edx ; PLR_LocalPlayer

; 816  : 		else

	jmp	SHORT $L82285
$L82284:

; 817  : 			player = PLR_CreatePlayer(PLAYER_REMOTE, CTRL_TYPE_NONE, StartData.PlayerData[i].CarID, &pos, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR ?StartData@@3USTART_DATA@@A[edx+24]
	push	eax
	push	0
	push	2
	call	?PLR_CreatePlayer@@YAPAUPlayerStruct@@W4PLAYER_TYPE@@W4CTRL_TYPE@@JPAUVectorStruct@@PATMatrixUnion@@@Z ; PLR_CreatePlayer
	add	esp, 20					; 00000014H
	mov	DWORD PTR _player$[ebp], eax
$L82285:

; 818  : 
; 819  : 		if (!player)

	cmp	DWORD PTR _player$[ebp], 0
	jne	SHORT $L82286

; 820  : 		{
; 821  : 			wsprintf(buf, "Can't create player %s", StartData.PlayerData[i].Name);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, OFFSET FLAT:?StartData@@3USTART_DATA@@A+32
	push	eax
	push	OFFSET FLAT:??_C@_0BH@BAOHMLDO@Can?8t?5create?5player?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 822  : 			Box(NULL, buf, MB_OK);

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 823  : 			QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 824  : 			return;

	jmp	SHORT $L82273
$L82286:

; 825  : 		}
; 826  : 
; 827  : 		player->PlayerID = StartData.PlayerData[i].PlayerID;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR ?StartData@@3USTART_DATA@@A[eax+28]
	mov	DWORD PTR [ecx+10308], edx

; 828  : 		strncpy(player->PlayerName, StartData.PlayerData[i].Name, MAX_PLAYER_NAME);

	push	64					; 00000040H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, OFFSET FLAT:?StartData@@3USTART_DATA@@A+32
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 10244				; 00002804H
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 829  : 	}

	jmp	$L82282
$L82283:

; 830  : 
; 831  : // no ghost
; 832  : 
; 833  : 	GHO_GhostExists = FALSE;

	mov	BYTE PTR ?GHO_GhostExists@@3_NA, 0	; GHO_GhostExists

; 834  : 	GHO_GhostPlayer = NULL;

	mov	DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A, 0 ; GHO_GhostPlayer

; 835  : 
; 836  : // get countdown timer
; 837  : 
; 838  : //	RemoteSync();
; 839  : 	CountdownEndTime = CurrentTimer() + MS2TIME(COUNTDOWN_START);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	add	ecx, eax
	mov	DWORD PTR ?CountdownEndTime@@3KA, ecx	; CountdownEndTime

; 840  : 	CountdownTime = TRUE;

	mov	DWORD PTR ?CountdownTime@@3KA, 1	; CountdownTime
$L82273:

; 841  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlayersNetwork@@YAXXZ ENDP				; InitPlayersNetwork
_TEXT	ENDS
PUBLIC	?CheckCheatStrings@@YAXXZ			; CheckCheatStrings
EXTRN	?GetKeyPress@@YAEXZ:NEAR			; GetKeyPress
EXTRN	?PlaySfx@@YAXJJJJ@Z:NEAR			; PlaySfx
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
EXTRN	_strlen:NEAR
_BSS	SEGMENT
_CheatStringBuffer DB 011H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?CheckCheatStrings@@YAXXZ
_TEXT	SEGMENT
tv129 = -76						; size = 4
_ch$ = -5						; size = 1
_flag$ = -4						; size = 4
?CheckCheatStrings@@YAXXZ PROC NEAR			; CheckCheatStrings, COMDAT

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 849  : 	long flag;
; 850  : 	unsigned char ch;
; 851  : 
; 852  : // update buffer
; 853  : 
; 854  : 	ch = GetKeyPress();

	call	?GetKeyPress@@YAEXZ			; GetKeyPress
	mov	BYTE PTR _ch$[ebp], al

; 855  : 	if (!ch) return;

	movzx	eax, BYTE PTR _ch$[ebp]
	test	eax, eax
	jne	SHORT $L82293
	jmp	$L82290
$L82293:

; 856  : 
; 857  : 	memcpy(CheatStringBuffer, CheatStringBuffer + 1, MAX_CHEAT_STRING_BUFFER - 1);

	push	15					; 0000000fH
	push	OFFSET FLAT:_CheatStringBuffer+1
	push	OFFSET FLAT:_CheatStringBuffer
	call	_memcpy
	add	esp, 12					; 0000000cH

; 858  : 	CheatStringBuffer[MAX_CHEAT_STRING_BUFFER - 1] = ch;

	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR _CheatStringBuffer+15, al

; 859  : 	CheatStringBuffer[MAX_CHEAT_STRING_BUFFER] = 0;

	mov	BYTE PTR _CheatStringBuffer+16, 0

; 860  : 
; 861  : // look for cheat string
; 862  : 
; 863  : 	flag = 0;

	mov	DWORD PTR _flag$[ebp], 0
$L82295:

; 864  : 
; 865  : 	while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $L82296

; 866  : 	{
; 867  : 		if (!CheatStrings[flag])

	mov	eax, DWORD PTR _flag$[ebp]
	cmp	DWORD PTR ?CheatStrings@@3PAPADA[eax*4], 0
	jne	SHORT $L82297

; 868  : 			return;

	jmp	$L82290
$L82297:

; 869  : 
; 870  : 		if (!strcmp(&CheatStringBuffer[16 - strlen(CheatStrings[flag])], CheatStrings[flag]))

	mov	eax, DWORD PTR _flag$[ebp]
	mov	ecx, DWORD PTR ?CheatStrings@@3PAPADA[eax*4]
	push	ecx
	mov	edx, DWORD PTR _flag$[ebp]
	mov	eax, DWORD PTR ?CheatStrings@@3PAPADA[edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, 16					; 00000010H
	sub	ecx, eax
	add	ecx, OFFSET FLAT:_CheatStringBuffer
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82298

; 871  : 			break;

	jmp	SHORT $L82296
$L82298:

; 872  : 
; 873  : 		flag++;

	mov	eax, DWORD PTR _flag$[ebp]
	add	eax, 1
	mov	DWORD PTR _flag$[ebp], eax

; 874  : 	}

	jmp	SHORT $L82295
$L82296:

; 875  : 
; 876  : // act
; 877  : 
; 878  : 	ZeroMemory(CheatStringBuffer, MAX_CHEAT_STRING_BUFFER);

	push	16					; 00000010H
	push	0
	push	OFFSET FLAT:_CheatStringBuffer
	call	_memset
	add	esp, 12					; 0000000cH

; 879  : 	PlaySfx(SFX_HONK, SFX_MAX_VOL, SFX_CENTRE_PAN, 22050);

	push	22050					; 00005622H
	push	64					; 00000040H
	push	127					; 0000007fH
	push	1
	call	?PlaySfx@@YAXJJJJ@Z			; PlaySfx
	add	esp, 16					; 00000010H

; 880  : 
; 881  : 	switch (flag)

	mov	eax, DWORD PTR _flag$[ebp]
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $L82303
	jmp	SHORT $L82290
$L82303:

; 882  : 	{
; 883  : 		case 0:
; 884  : 			Everything = !Everything;

	movsx	eax, BYTE PTR ?Everything@@3DA		; Everything
	neg	eax
	sbb	al, al
	inc	al
	mov	BYTE PTR ?Everything@@3DA, al		; Everything
$L82290:

; 885  : 		break;
; 886  : 	}
; 887  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckCheatStrings@@YAXXZ ENDP				; CheckCheatStrings
_TEXT	ENDS
END
