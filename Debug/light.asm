; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\light.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NMEENOGA@Omni?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LMJAABCC@Omni?5Normal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CFIJCNIK@Spot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GCKNOGIL@Spot?5Normal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HKDPFFHN@World?5Only?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CBIFMCE@Objects?5Only?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KAHJBDOH@World?5and?5Objects?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IDDGKHFD@X?5Y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KIBLPEJA@X?5Z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CJDPGPNI@Z?5Y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01MMEEDKFM@X?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NFFPALBN@Y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01POHCFINO@Z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JCBBMBIP@Camera?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MFLOHCHP@World?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MIGHMCBI@li?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@LDPPJMHM@Saved?5Light?5File?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KDBOCEAF@lit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OGNLDANN@RGB?5?$CFld?5?$CFld?5?$CFld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EIJPKPMB@Reach?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HMGNNLP@Flicker?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LDIGKJBL@Flicker?5Speed?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LMDIMKBF@Cone?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BNNKLDPF@edit?2omni?4m?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JNPPPCPI@edit?2spot?4m?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitLights@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocLight@@YAPAULIGHT@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeLight@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessLights@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessOneLight@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPermLight@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightPermOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightPermOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightPermSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightPermSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckCubeLight@@YADPAUCUBE_HEADER@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckInstanceLight@@YAFPAUINSTANCE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckInstanceLightEdit@@YAFPAUINSTANCE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightPermOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightPermOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightPermSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightPermSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPermLightInstance@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadLights@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveLights@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawFileLights@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EditFileLights@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisplayLightInfo@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadEditLightModels@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeEditLightModels@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?Light@@3PAULIGHT@@A				; Light
PUBLIC	?CurrentEditLight@@3PAULIGHT@@A			; CurrentEditLight
PUBLIC	?TotalLightCount@@3FA				; TotalLightCount
PUBLIC	??_C@_04NMEENOGA@Omni?$AA@			; `string'
PUBLIC	??_C@_0M@LMJAABCC@Omni?5Normal?$AA@		; `string'
PUBLIC	??_C@_04CFIJCNIK@Spot?$AA@			; `string'
PUBLIC	??_C@_0M@GCKNOGIL@Spot?5Normal?$AA@		; `string'
PUBLIC	??_C@_0L@HKDPFFHN@World?5Only?$AA@		; `string'
PUBLIC	??_C@_0N@CBIFMCE@Objects?5Only?$AA@		; `string'
PUBLIC	??_C@_0BC@KAHJBDOH@World?5and?5Objects?$AA@	; `string'
PUBLIC	??_C@_03IDDGKHFD@X?5Y?$AA@			; `string'
PUBLIC	??_C@_03KIBLPEJA@X?5Z?$AA@			; `string'
PUBLIC	??_C@_03CJDPGPNI@Z?5Y?$AA@			; `string'
PUBLIC	??_C@_01MMEEDKFM@X?$AA@				; `string'
PUBLIC	??_C@_01NFFPALBN@Y?$AA@				; `string'
PUBLIC	??_C@_01POHCFINO@Z?$AA@				; `string'
PUBLIC	??_C@_06JCBBMBIP@Camera?$AA@			; `string'
PUBLIC	??_C@_05MFLOHCHP@World?$AA@			; `string'
PUBLIC	??_C@_03GCDBBDDL@Off?$AA@			; `string'
PUBLIC	??_C@_02IAAGKKDJ@On?$AA@			; `string'
_BSS	SEGMENT
?Light@@3PAULIGHT@@A DB 030c0H DUP (?)			; Light
?CurrentEditLight@@3PAULIGHT@@A DD 01H DUP (?)		; CurrentEditLight
?TotalLightCount@@3FA DW 01H DUP (?)			; TotalLightCount
	ALIGN	4

_LightAxis DB	01H DUP (?)
	ALIGN	4

_LightAxisType DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04NMEENOGA@Omni?$AA@
CONST	SEGMENT
??_C@_04NMEENOGA@Omni?$AA@ DB 'Omni', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMJAABCC@Omni?5Normal?$AA@
CONST	SEGMENT
??_C@_0M@LMJAABCC@Omni?5Normal?$AA@ DB 'Omni Normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CFIJCNIK@Spot?$AA@
CONST	SEGMENT
??_C@_04CFIJCNIK@Spot?$AA@ DB 'Spot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GCKNOGIL@Spot?5Normal?$AA@
CONST	SEGMENT
??_C@_0M@GCKNOGIL@Spot?5Normal?$AA@ DB 'Spot Normal', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_LightNames DD	FLAT:??_C@_04NMEENOGA@Omni?$AA@
	DD	FLAT:??_C@_0M@LMJAABCC@Omni?5Normal?$AA@
	DD	FLAT:??_C@_04CFIJCNIK@Spot?$AA@
	DD	FLAT:??_C@_0M@GCKNOGIL@Spot?5Normal?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0L@HKDPFFHN@World?5Only?$AA@
CONST	SEGMENT
??_C@_0L@HKDPFFHN@World?5Only?$AA@ DB 'World Only', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBIFMCE@Objects?5Only?$AA@
CONST	SEGMENT
??_C@_0N@CBIFMCE@Objects?5Only?$AA@ DB 'Objects Only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KAHJBDOH@World?5and?5Objects?$AA@
CONST	SEGMENT
??_C@_0BC@KAHJBDOH@World?5and?5Objects?$AA@ DB 'World and Objects', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_LightFlags DD	FLAT:??_C@_0L@HKDPFFHN@World?5Only?$AA@
	DD	FLAT:??_C@_0N@CBIFMCE@Objects?5Only?$AA@
	DD	FLAT:??_C@_0BC@KAHJBDOH@World?5and?5Objects?$AA@
_DATA	ENDS
;	COMDAT ??_C@_03IDDGKHFD@X?5Y?$AA@
CONST	SEGMENT
??_C@_03IDDGKHFD@X?5Y?$AA@ DB 'X Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KIBLPEJA@X?5Z?$AA@
CONST	SEGMENT
??_C@_03KIBLPEJA@X?5Z?$AA@ DB 'X Z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJDPGPNI@Z?5Y?$AA@
CONST	SEGMENT
??_C@_03CJDPGPNI@Z?5Y?$AA@ DB 'Z Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MMEEDKFM@X?$AA@
CONST	SEGMENT
??_C@_01MMEEDKFM@X?$AA@ DB 'X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NFFPALBN@Y?$AA@
CONST	SEGMENT
??_C@_01NFFPALBN@Y?$AA@ DB 'Y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01POHCFINO@Z?$AA@
CONST	SEGMENT
??_C@_01POHCFINO@Z?$AA@ DB 'Z', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_LightAxisNames DD FLAT:??_C@_03IDDGKHFD@X?5Y?$AA@
	DD	FLAT:??_C@_03KIBLPEJA@X?5Z?$AA@
	DD	FLAT:??_C@_03CJDPGPNI@Z?5Y?$AA@
	DD	FLAT:??_C@_01MMEEDKFM@X?$AA@
	DD	FLAT:??_C@_01NFFPALBN@Y?$AA@
	DD	FLAT:??_C@_01POHCFINO@Z?$AA@
_DATA	ENDS
;	COMDAT ??_C@_06JCBBMBIP@Camera?$AA@
CONST	SEGMENT
??_C@_06JCBBMBIP@Camera?$AA@ DB 'Camera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFLOHCHP@World?$AA@
CONST	SEGMENT
??_C@_05MFLOHCHP@World?$AA@ DB 'World', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_LightAxisTypeNames DD FLAT:??_C@_06JCBBMBIP@Camera?$AA@
	DD	FLAT:??_C@_05MFLOHCHP@World?$AA@
_DATA	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off?$AA@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off?$AA@ DB 'Off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On?$AA@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On?$AA@ DB 'On', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_LightFlickerNames DD FLAT:??_C@_03GCDBBDDL@Off?$AA@
	DD	FLAT:??_C@_02IAAGKKDJ@On?$AA@
_DATA	ENDS
PUBLIC	?InitLights@@YAXXZ				; InitLights
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\light.cpp
;	COMDAT ?InitLights@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 2
?InitLights@@YAXXZ PROC NEAR				; InitLights, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 74   : 	short i;
; 75   : 
; 76   : 	for (i = 0 ; i < LIGHT_MAX ; i++) Light[i].Flag = 0;

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81240
$L81241:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L81240:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 120				; 00000078H
	jge	SHORT $L81238
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	mov	BYTE PTR ?Light@@3PAULIGHT@@A[eax+100], 0
	jmp	SHORT $L81241
$L81238:

; 77   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitLights@@YAXXZ ENDP					; InitLights
_TEXT	ENDS
PUBLIC	?AllocLight@@YAPAULIGHT@@XZ			; AllocLight
; Function compile flags: /Odt /ZI
;	COMDAT ?AllocLight@@YAPAULIGHT@@XZ
_TEXT	SEGMENT
_i$ = -4						; size = 2
?AllocLight@@YAPAULIGHT@@XZ PROC NEAR			; AllocLight, COMDAT

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 85   : 	short i;
; 86   : 
; 87   : // find free slot
; 88   : 
; 89   : 	for (i = 0 ; i < LIGHT_MAX ; i++) if (!Light[i].Flag)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81247
$L81248:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L81247:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 120				; 00000078H
	jge	SHORT $L81249
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	movzx	ecx, BYTE PTR ?Light@@3PAULIGHT@@A[eax+100]
	test	ecx, ecx
	jne	SHORT $L81250

; 90   : 	{
; 91   : 		return &Light[i];

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	add	eax, OFFSET FLAT:?Light@@3PAULIGHT@@A	; Light
	jmp	SHORT $L81245
$L81250:

; 92   : 	}
; 93   : 
; 94   : // no slots
; 95   : 
; 96   : 	return NULL;

	jmp	SHORT $L81248
$L81249:
	xor	eax, eax
$L81245:

; 97   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocLight@@YAPAULIGHT@@XZ ENDP			; AllocLight
_TEXT	ENDS
PUBLIC	?FreeLight@@YAXPAULIGHT@@@Z			; FreeLight
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeLight@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT
_light$ = 8						; size = 4
?FreeLight@@YAXPAULIGHT@@@Z PROC NEAR			; FreeLight, COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 105  : 	light->Flag = 0;

	mov	eax, DWORD PTR _light$[ebp]
	mov	BYTE PTR [eax+100], 0

; 106  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeLight@@YAXPAULIGHT@@@Z ENDP			; FreeLight
_TEXT	ENDS
PUBLIC	?ProcessLights@@YAXXZ				; ProcessLights
PUBLIC	?ProcessOneLight@@YAXPAULIGHT@@@Z		; ProcessOneLight
EXTRN	_rand:NEAR
EXTRN	__ftol2:NEAR
EXTRN	?TimeFactor@@3MA:DWORD				; TimeFactor
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
_BSS	SEGMENT
	ALIGN	4

_AffectFixedLightCount DW 01H DUP (?)
	ALIGN	4

_AffectMovingLightCount DW 01H DUP (?)
	ALIGN	4

_AffectFixedLights DD 078H DUP (?)
_AffectMovingLights DD 078H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?ProcessLights@@YAXXZ
_TEXT	SEGMENT
_tf$ = -12						; size = 4
_l$ = -8						; size = 4
_i$ = -4						; size = 2
?ProcessLights@@YAXXZ PROC NEAR				; ProcessLights, COMDAT

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 114  : 	short i;
; 115  : 	LIGHT *l;
; 116  : 	long tf;
; 117  : 
; 118  : // not if lights off
; 119  : 
; 120  : 	if (!RenderSettings.Light)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+88, 0
	jne	SHORT $L81260

; 121  : 		return;

	jmp	$L81256
$L81260:

; 122  : 
; 123  : // zero fixed / moving / total count
; 124  : 
; 125  : 	AffectFixedLightCount = 0;

	mov	WORD PTR _AffectFixedLightCount, 0

; 126  : 	AffectMovingLightCount = 0;

	mov	WORD PTR _AffectMovingLightCount, 0

; 127  : 	TotalLightCount = 0;

	mov	WORD PTR ?TotalLightCount@@3FA, 0	; TotalLightCount

; 128  : 
; 129  : // loop thru active
; 130  : 
; 131  : 	tf = (long)TimeFactor;

	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	call	__ftol2
	mov	DWORD PTR _tf$[ebp], eax

; 132  : 	l = Light;

	mov	DWORD PTR _l$[ebp], OFFSET FLAT:?Light@@3PAULIGHT@@A ; Light

; 133  : 
; 134  : 	for (i = 0 ; i < LIGHT_MAX ; i++, l++) if (l->Flag)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81262
$L81263:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _l$[ebp], ecx
$L81262:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 120				; 00000078H
	jge	$L81256
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	test	ecx, ecx
	je	$L81265

; 135  : 	{
; 136  : 
; 137  : // inc total count
; 138  : 
; 139  : 		TotalLightCount++;

	mov	ax, WORD PTR ?TotalLightCount@@3FA	; TotalLightCount
	add	ax, 1
	mov	WORD PTR ?TotalLightCount@@3FA, ax	; TotalLightCount

; 140  : 
; 141  : // flicker?
; 142  : 
; 143  : 		if (l->Flag & LIGHT_FLICKER)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 16					; 00000010H
	je	SHORT $L81266

; 144  : 		{
; 145  : 			if ((rand() % l->Speed) < tf)

	call	_rand
	mov	ecx, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [ecx+102]
	cdq
	idiv	ecx
	cmp	edx, DWORD PTR _tf$[ebp]
	jge	SHORT $L81266

; 146  : 				l->Flag ^= LIGHT_OFF;

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	xor	ecx, 8
	mov	edx, DWORD PTR _l$[ebp]
	mov	BYTE PTR [edx+100], cl
$L81266:

; 147  : 		}
; 148  : 
; 149  : // off?
; 150  : 
; 151  : 		if (l->Flag & LIGHT_OFF)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 8
	je	SHORT $L81268

; 152  : 			continue;

	jmp	SHORT $L81263
$L81268:

; 153  : 
; 154  : // update tables
; 155  : 
; 156  : 		if (l->Flag & LIGHT_FIXED)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 1
	je	SHORT $L81269

; 157  : 			AffectFixedLights[AffectFixedLightCount++] = l;

	movsx	eax, WORD PTR _AffectFixedLightCount
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _AffectFixedLights[eax*4], ecx
	mov	dx, WORD PTR _AffectFixedLightCount
	add	dx, 1
	mov	WORD PTR _AffectFixedLightCount, dx
$L81269:

; 158  : 
; 159  : 		if (l->Flag & LIGHT_MOVING)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 2
	je	SHORT $L81270

; 160  : 			AffectMovingLights[AffectMovingLightCount++] = l;

	movsx	eax, WORD PTR _AffectMovingLightCount
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _AffectMovingLights[eax*4], ecx
	mov	dx, WORD PTR _AffectMovingLightCount
	add	dx, 1
	mov	WORD PTR _AffectMovingLightCount, dx
$L81270:

; 161  : 
; 162  : // update square reach / bounding box / cone mul
; 163  : 
; 164  : 		ProcessOneLight(l);

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	call	?ProcessOneLight@@YAXPAULIGHT@@@Z	; ProcessOneLight
	add	esp, 4
$L81265:

; 165  : 	}
; 166  : }

	jmp	$L81263
$L81256:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessLights@@YAXXZ ENDP				; ProcessLights
_TEXT	ENDS
PUBLIC	__real@43340000
EXTRN	__fltused:NEAR
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ProcessOneLight@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT
_l$ = 8							; size = 4
?ProcessOneLight@@YAXPAULIGHT@@@Z PROC NEAR		; ProcessOneLight, COMDAT

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 174  : 
; 175  : // set square reach
; 176  : 
; 177  : 	l->SquareReach = l->Reach * l->Reach;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [edx+16]

; 178  : 
; 179  : // set bounding box
; 180  : 
; 181  : 	l->Xmin = l->x - l->Reach;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [edx+20]

; 182  : 	l->Xmax = l->x + l->Reach;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [edx+24]

; 183  : 	l->Ymin = l->y - l->Reach;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [edx+28]

; 184  : 	l->Ymax = l->y + l->Reach;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [edx+32]

; 185  : 	l->Zmin = l->z - l->Reach;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [edx+36]

; 186  : 	l->Zmax = l->z + l->Reach;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [edx+40]

; 187  : 
; 188  : // set cone mul
; 189  : 
; 190  : 	l->ConeMul = 180 / l->Cone;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR __real@43340000
	fdiv	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _l$[ebp]
	fstp	DWORD PTR [ecx+84]

; 191  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessOneLight@@YAXPAULIGHT@@@Z ENDP			; ProcessOneLight
_TEXT	ENDS
PUBLIC	?AddPermLight@@YAXPAULIGHT@@@Z			; AddPermLight
PUBLIC	?AddCubeLightPermOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermOmni
PUBLIC	?AddCubeLightPermOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermOmniNormal
PUBLIC	?AddCubeLightPermSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermSpot
PUBLIC	?AddCubeLightPermSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermSpotNormal
PUBLIC	?sqrt@@YAMM@Z					; sqrt
EXTRN	?World@@3UWORLD@@A:BYTE				; World
; Function compile flags: /Odt /ZI
;	COMDAT ?AddPermLight@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT
tv142 = -88						; size = 4
_cube$ = -20						; size = 4
_dz$ = -16						; size = 4
_dy$ = -12						; size = 4
_dx$ = -8						; size = 4
_i$ = -4						; size = 2
_light$ = 8						; size = 4
?AddPermLight@@YAXPAULIGHT@@@Z PROC NEAR		; AddPermLight, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 199  : 	short i;
; 200  : 	float dx, dy, dz;
; 201  : 	CUBE_HEADER *cube;
; 202  : 
; 203  : // valid light?
; 204  : 
; 205  : 	if (!light->Flag) return;

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	test	ecx, ecx
	jne	SHORT $L81282
	jmp	$L81276
$L81282:

; 206  : 
; 207  : // make sure all vars up to date
; 208  : 
; 209  : 	ProcessOneLight(light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	call	?ProcessOneLight@@YAXPAULIGHT@@@Z	; ProcessOneLight
	add	esp, 4

; 210  : 
; 211  : // loop thru cubes
; 212  : 
; 213  : 	cube = World.Cube;

	mov	eax, DWORD PTR ?World@@3UWORLD@@A+8
	mov	DWORD PTR _cube$[ebp], eax

; 214  : 
; 215  : 	for (i = 0 ; i < World.CubeNum ; i++, cube++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81283
$L81284:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _cube$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR _cube$[ebp], ecx
$L81283:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?World@@3UWORLD@@A
	jge	$L81276

; 216  : 	{
; 217  : 
; 218  : // bounding boxes qualify?
; 219  : 
; 220  : 		if (cube->Xmin > light->Xmax || cube->Xmax < light->Xmin ||	cube->Ymin > light->Ymax || cube->Ymax < light->Ymin ||	cube->Zmin > light->Zmax || cube->Zmax < light->Zmin) continue;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81287
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+20]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81287
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+24]
	fcomp	DWORD PTR [ecx+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81287
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+28]
	fcomp	DWORD PTR [ecx+28]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81287
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+32]
	fcomp	DWORD PTR [ecx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81287
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+36]
	fcomp	DWORD PTR [ecx+36]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81286
$L81287:
	jmp	$L81284
$L81286:

; 221  : 
; 222  : // radius test qualify?
; 223  : 
; 224  : 		dx = cube->CentreX - light->x;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dx$[ebp]

; 225  : 		dy = cube->CentreY - light->y;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dy$[ebp]

; 226  : 		dz = cube->CentreZ - light->z;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dz$[ebp]

; 227  : 		if ((float)sqrt(dx * dx + dy * dy + dz * dz) > light->Reach + cube->Radius) continue;

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _dx$[ebp]
	fld	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _dy$[ebp]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dz$[ebp]
	fmul	DWORD PTR _dz$[ebp]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _cube$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81289
	jmp	$L81284
$L81289:

; 228  : 
; 229  : // yep, do it
; 230  : 
; 231  : 		switch (light->Type)

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	mov	DWORD PTR tv142[ebp], ecx
	cmp	DWORD PTR tv142[ebp], 3
	ja	SHORT $L81291
	mov	edx, DWORD PTR tv142[ebp]
	jmp	DWORD PTR $L82603[edx*4]
$L81294:

; 232  : 		{
; 233  : 			case LIGHT_OMNI:
; 234  : 				AddCubeLightPermOmni(cube, light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightPermOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermOmni
	add	esp, 8

; 235  : 			break;

	jmp	SHORT $L81291
$L81295:

; 236  : 			case LIGHT_OMNINORMAL:
; 237  : 				AddCubeLightPermOmniNormal(cube, light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightPermOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermOmniNormal
	add	esp, 8

; 238  : 			break;

	jmp	SHORT $L81291
$L81296:

; 239  : 			case LIGHT_SPOT:
; 240  : 				AddCubeLightPermSpot(cube, light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightPermSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermSpot
	add	esp, 8

; 241  : 			break;

	jmp	SHORT $L81291
$L81297:

; 242  : 			case LIGHT_SPOTNORMAL:
; 243  : 				AddCubeLightPermSpotNormal(cube, light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightPermSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightPermSpotNormal
	add	esp, 8
$L81291:

; 244  : 			break;
; 245  : 		}
; 246  : 	}

	jmp	$L81284
$L81276:

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L82603:
	DD	$L81294
	DD	$L81295
	DD	$L81296
	DD	$L81297
?AddPermLight@@YAXPAULIGHT@@@Z ENDP			; AddPermLight
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@43800000
PUBLIC	__real@4b000000
_BSS	SEGMENT
_LightDelta DB	0cH DUP (?)
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AddCubeLightPermOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__i$81321 = -48						; size = 4
__temp$81318 = -44					; size = 4
_col$ = -40						; size = 4
_rgb$ = -36						; size = 12
_j$ = -24						; size = 2
_i$ = -20						; size = 2
_mul$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightPermOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightPermOmni, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 255  : 	WORLD_POLY *p;
; 256  : 	WORLD_VERTEX **v;
; 257  : 	float squaredist;
; 258  : 	long mul;
; 259  : 	short i, j;
; 260  : 	long rgb[3];
; 261  : 	MODEL_RGB *col;
; 262  : 
; 263  : // loop thru polys
; 264  : 
; 265  : 	p = cube->Model.PolyPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _p$[ebp], ecx

; 266  : 	for (i = 0 ; i < cube->Model.PolyNum ; i++, p++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81310
$L81311:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _p$[ebp], ecx
$L81310:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cube$[ebp]
	movsx	edx, WORD PTR [ecx+72]
	cmp	eax, edx
	jge	$L81301

; 267  : 	{
; 268  : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _v$[ebp], eax

; 269  : 		col = (MODEL_RGB*)&p->rgb0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], eax

; 270  : 
; 271  : 		for (j = (p->Type & POLY_QUAD) ? 4 : 3 ; j ; j--, v++, col++)

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $L81314
$L81315:
	mov	ax, WORD PTR _j$[ebp]
	sub	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 4
	mov	DWORD PTR _col$[ebp], edx
$L81314:
	movsx	eax, WORD PTR _j$[ebp]
	test	eax, eax
	je	$L81316

; 272  : 		{
; 273  : 			LightDelta.v[X] = light->x - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 274  : 			LightDelta.v[Y] = light->y - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 275  : 			LightDelta.v[Z] = light->z - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 276  : 
; 277  : 			squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 278  : 			if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81317

; 279  : 			{
; 280  : 				FTOL((1 - squaredist / light->SquareReach) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81318[ebp]
	mov	eax, DWORD PTR __temp$81318[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 281  : 
; 282  : 				rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 283  : 				rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 284  : 				rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 285  : 
; 286  : 				ModelAddGouraud(col, rgb, col);

	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	add	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81321[ebp], ecx
	cmp	DWORD PTR __i$81321[ebp], 255		; 000000ffH
	jle	SHORT $L81323
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH
	jmp	SHORT $L81324
$L81323:
	cmp	DWORD PTR __i$81321[ebp], 0
	jge	SHORT $L81325
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 0
	jmp	SHORT $L81324
$L81325:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81321[ebp]
	mov	BYTE PTR [eax+2], cl
$L81324:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	add	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81321[ebp], ecx
	cmp	DWORD PTR __i$81321[ebp], 255		; 000000ffH
	jle	SHORT $L81329
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
	jmp	SHORT $L81330
$L81329:
	cmp	DWORD PTR __i$81321[ebp], 0
	jge	SHORT $L81331
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 0
	jmp	SHORT $L81330
$L81331:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81321[ebp]
	mov	BYTE PTR [eax+1], cl
$L81330:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81321[ebp], ecx
	cmp	DWORD PTR __i$81321[ebp], 255		; 000000ffH
	jle	SHORT $L81335
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	jmp	SHORT $L81317
$L81335:
	cmp	DWORD PTR __i$81321[ebp], 0
	jge	SHORT $L81337
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 0
	jmp	SHORT $L81317
$L81337:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81321[ebp]
	mov	BYTE PTR [eax], cl
$L81317:

; 287  : 			}
; 288  : 		}

	jmp	$L81315
$L81316:

; 289  : 	}

	jmp	$L81311
$L81301:

; 290  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightPermOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; AddCubeLightPermOmni
_TEXT	ENDS
PUBLIC	__real@00000000
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AddCubeLightPermOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__i$81370 = -56						; size = 4
__temp$81367 = -52					; size = 4
_col$ = -48						; size = 4
_rgb$ = -44						; size = 12
_j$ = -32						; size = 2
_i$ = -28						; size = 2
_mul$ = -24						; size = 4
_dist$ = -20						; size = 4
_ang$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightPermOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightPermOmniNormal, COMDAT

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 298  : 	WORLD_POLY *p;
; 299  : 	WORLD_VERTEX **v;
; 300  : 	float squaredist, ang, dist;
; 301  : 	long mul;
; 302  : 	short i, j;
; 303  : 	long rgb[3];
; 304  : 	MODEL_RGB *col;
; 305  : 
; 306  : // loop thru polys
; 307  : 
; 308  : 	p = cube->Model.PolyPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _p$[ebp], ecx

; 309  : 	for (i = 0 ; i < cube->Model.PolyNum ; i++, p++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81354
$L81355:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _p$[ebp], ecx
$L81354:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cube$[ebp]
	movsx	edx, WORD PTR [ecx+72]
	cmp	eax, edx
	jge	$L81343

; 310  : 	{
; 311  : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _v$[ebp], eax

; 312  : 		col = (MODEL_RGB*)&p->rgb0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], eax

; 313  : 
; 314  : 		for (j = (p->Type & POLY_QUAD) ? 4 : 3 ; j ; j--, v++, col++)

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $L81358
$L81359:
	mov	ax, WORD PTR _j$[ebp]
	sub	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 4
	mov	DWORD PTR _col$[ebp], edx
$L81358:
	movsx	eax, WORD PTR _j$[ebp]
	test	eax, eax
	je	$L81360

; 315  : 		{
; 316  : 			LightDelta.v[X] = light->x - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 317  : 			LightDelta.v[Y] = light->y - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 318  : 			LightDelta.v[Z] = light->z - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 319  : 
; 320  : 			ang = DotProduct(&LightDelta, (VEC*)&(*v)->nx);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 321  : 			if (ang > 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81364

; 322  : 			{
; 323  : 				squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 324  : 				if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81364

; 325  : 				{
; 326  : 					dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 327  : 					FTOL(((1 - squaredist / light->SquareReach) * (ang / dist)) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81367[ebp]
	mov	eax, DWORD PTR __temp$81367[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 328  : 		
; 329  : 					rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 330  : 					rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 331  : 					rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 332  : 
; 333  : 					ModelAddGouraud(col, rgb, col);

	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	add	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81370[ebp], ecx
	cmp	DWORD PTR __i$81370[ebp], 255		; 000000ffH
	jle	SHORT $L81372
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH
	jmp	SHORT $L81373
$L81372:
	cmp	DWORD PTR __i$81370[ebp], 0
	jge	SHORT $L81374
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 0
	jmp	SHORT $L81373
$L81374:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81370[ebp]
	mov	BYTE PTR [eax+2], cl
$L81373:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	add	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81370[ebp], ecx
	cmp	DWORD PTR __i$81370[ebp], 255		; 000000ffH
	jle	SHORT $L81378
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
	jmp	SHORT $L81379
$L81378:
	cmp	DWORD PTR __i$81370[ebp], 0
	jge	SHORT $L81380
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 0
	jmp	SHORT $L81379
$L81380:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81370[ebp]
	mov	BYTE PTR [eax+1], cl
$L81379:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81370[ebp], ecx
	cmp	DWORD PTR __i$81370[ebp], 255		; 000000ffH
	jle	SHORT $L81384
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	jmp	SHORT $L81364
$L81384:
	cmp	DWORD PTR __i$81370[ebp], 0
	jge	SHORT $L81386
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 0
	jmp	SHORT $L81364
$L81386:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81370[ebp]
	mov	BYTE PTR [eax], cl
$L81364:

; 334  : 				}
; 335  : 			}
; 336  : 		}

	jmp	$L81359
$L81360:

; 337  : 	}

	jmp	$L81355
$L81343:

; 338  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightPermOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; AddCubeLightPermOmniNormal
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddCubeLightPermSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__i$81416 = -56						; size = 4
__temp$81413 = -52					; size = 4
_col$ = -48						; size = 4
_rgb$ = -44						; size = 12
_j$ = -32						; size = 2
_i$ = -28						; size = 2
_mul$ = -24						; size = 4
_dist$ = -20						; size = 4
_cone$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightPermSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightPermSpot, COMDAT

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 346  : 	WORLD_POLY *p;
; 347  : 	WORLD_VERTEX **v;
; 348  : 	float squaredist, cone, dist;
; 349  : 	long mul;
; 350  : 	short i, j;
; 351  : 	long rgb[3];
; 352  : 	MODEL_RGB *col;
; 353  : 
; 354  : // loop thru polys
; 355  : 
; 356  : 	p = cube->Model.PolyPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _p$[ebp], ecx

; 357  : 	for (i = 0 ; i < cube->Model.PolyNum ; i++, p++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81403
$L81404:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _p$[ebp], ecx
$L81403:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cube$[ebp]
	movsx	edx, WORD PTR [ecx+72]
	cmp	eax, edx
	jge	$L81392

; 358  : 	{
; 359  : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _v$[ebp], eax

; 360  : 		col = (MODEL_RGB*)&p->rgb0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], eax

; 361  : 
; 362  : 		for (j = (p->Type & POLY_QUAD) ? 4 : 3 ; j ; j--, v++, col++)

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $L81407
$L81408:
	mov	ax, WORD PTR _j$[ebp]
	sub	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 4
	mov	DWORD PTR _col$[ebp], edx
$L81407:
	movsx	eax, WORD PTR _j$[ebp]
	test	eax, eax
	je	$L81409

; 363  : 		{
; 364  : 			LightDelta.v[X] = light->x - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 365  : 			LightDelta.v[Y] = light->y - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 366  : 			LightDelta.v[Z] = light->z - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 367  : 
; 368  : 			squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 369  : 			if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81410

; 370  : 			{
; 371  : 				dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 372  : 				cone = (-DotProduct(&light->DirMatrix.mv[Z], &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 373  : 				if (cone > 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81410

; 374  : 				{
; 375  : 					FTOL(((1 - squaredist / light->SquareReach) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81413[ebp]
	mov	eax, DWORD PTR __temp$81413[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 376  : 		
; 377  : 					rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 378  : 					rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 379  : 					rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 380  : 
; 381  : 					ModelAddGouraud(col, rgb, col);

	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	add	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81416[ebp], ecx
	cmp	DWORD PTR __i$81416[ebp], 255		; 000000ffH
	jle	SHORT $L81418
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH
	jmp	SHORT $L81419
$L81418:
	cmp	DWORD PTR __i$81416[ebp], 0
	jge	SHORT $L81420
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 0
	jmp	SHORT $L81419
$L81420:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81416[ebp]
	mov	BYTE PTR [eax+2], cl
$L81419:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	add	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81416[ebp], ecx
	cmp	DWORD PTR __i$81416[ebp], 255		; 000000ffH
	jle	SHORT $L81424
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
	jmp	SHORT $L81425
$L81424:
	cmp	DWORD PTR __i$81416[ebp], 0
	jge	SHORT $L81426
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 0
	jmp	SHORT $L81425
$L81426:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81416[ebp]
	mov	BYTE PTR [eax+1], cl
$L81425:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81416[ebp], ecx
	cmp	DWORD PTR __i$81416[ebp], 255		; 000000ffH
	jle	SHORT $L81430
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	jmp	SHORT $L81410
$L81430:
	cmp	DWORD PTR __i$81416[ebp], 0
	jge	SHORT $L81432
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 0
	jmp	SHORT $L81410
$L81432:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81416[ebp]
	mov	BYTE PTR [eax], cl
$L81410:

; 382  : 				}
; 383  : 			}
; 384  : 		}

	jmp	$L81408
$L81409:

; 385  : 	}

	jmp	$L81404
$L81392:

; 386  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightPermSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; AddCubeLightPermSpot
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddCubeLightPermSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__i$81467 = -60						; size = 4
__temp$81464 = -56					; size = 4
_col$ = -52						; size = 4
_rgb$ = -48						; size = 12
_j$ = -36						; size = 2
_i$ = -32						; size = 2
_mul$ = -28						; size = 4
_dist$ = -24						; size = 4
_cone$ = -20						; size = 4
_ang$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightPermSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightPermSpotNormal, COMDAT

; 393  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 394  : 	WORLD_POLY *p;
; 395  : 	WORLD_VERTEX **v;
; 396  : 	float squaredist, ang, cone, dist;
; 397  : 	long mul;
; 398  : 	short i, j;
; 399  : 	long rgb[3];
; 400  : 	MODEL_RGB *col;
; 401  : 
; 402  : // loop thru polys
; 403  : 
; 404  : 	p = cube->Model.PolyPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _p$[ebp], ecx

; 405  : 	for (i = 0 ; i < cube->Model.PolyNum ; i++, p++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81450
$L81451:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _p$[ebp], ecx
$L81450:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cube$[ebp]
	movsx	edx, WORD PTR [ecx+72]
	cmp	eax, edx
	jge	$L81438

; 406  : 	{
; 407  : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _v$[ebp], eax

; 408  : 		col = (MODEL_RGB*)&p->rgb0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], eax

; 409  : 
; 410  : 		for (j = (p->Type & POLY_QUAD) ? 4 : 3 ; j ; j--, v++, col++)

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $L81454
$L81455:
	mov	ax, WORD PTR _j$[ebp]
	sub	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 4
	mov	DWORD PTR _col$[ebp], edx
$L81454:
	movsx	eax, WORD PTR _j$[ebp]
	test	eax, eax
	je	$L81456

; 411  : 		{
; 412  : 			LightDelta.v[X] = light->x - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 413  : 			LightDelta.v[Y] = light->y - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 414  : 			LightDelta.v[Z] = light->z - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 415  : 
; 416  : 			ang = DotProduct(&LightDelta, (VEC*)&(*v)->nx);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 417  : 			if (ang > 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81460

; 418  : 			{
; 419  : 				squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 420  : 				if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81460

; 421  : 				{
; 422  : 					dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 423  : 					cone = (-DotProduct(&light->DirMatrix.mv[Z], &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 424  : 					if (cone > 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81460

; 425  : 					{
; 426  : 						FTOL(((1 - squaredist / light->SquareReach) * (ang / dist) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81464[ebp]
	mov	eax, DWORD PTR __temp$81464[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 427  : 		
; 428  : 						rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 429  : 						rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 430  : 						rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 431  : 
; 432  : 						ModelAddGouraud(col, rgb, col);

	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	add	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81467[ebp], ecx
	cmp	DWORD PTR __i$81467[ebp], 255		; 000000ffH
	jle	SHORT $L81469
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH
	jmp	SHORT $L81470
$L81469:
	cmp	DWORD PTR __i$81467[ebp], 0
	jge	SHORT $L81471
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+2], 0
	jmp	SHORT $L81470
$L81471:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81467[ebp]
	mov	BYTE PTR [eax+2], cl
$L81470:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	add	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81467[ebp], ecx
	cmp	DWORD PTR __i$81467[ebp], 255		; 000000ffH
	jle	SHORT $L81475
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
	jmp	SHORT $L81476
$L81475:
	cmp	DWORD PTR __i$81467[ebp], 0
	jge	SHORT $L81477
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax+1], 0
	jmp	SHORT $L81476
$L81477:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81467[ebp]
	mov	BYTE PTR [eax+1], cl
$L81476:
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81467[ebp], ecx
	cmp	DWORD PTR __i$81467[ebp], 255		; 000000ffH
	jle	SHORT $L81481
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	jmp	SHORT $L81460
$L81481:
	cmp	DWORD PTR __i$81467[ebp], 0
	jge	SHORT $L81483
	mov	eax, DWORD PTR _col$[ebp]
	mov	BYTE PTR [eax], 0
	jmp	SHORT $L81460
$L81483:
	mov	eax, DWORD PTR _col$[ebp]
	mov	cl, BYTE PTR __i$81467[ebp]
	mov	BYTE PTR [eax], cl
$L81460:

; 433  : 					}
; 434  : 				}
; 435  : 			}
; 436  : 		}

	jmp	$L81455
$L81456:

; 437  : 	}

	jmp	$L81451
$L81438:

; 438  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightPermSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; AddCubeLightPermSpotNormal
_TEXT	ENDS
PUBLIC	?CheckCubeLight@@YADPAUCUBE_HEADER@@@Z		; CheckCubeLight
PUBLIC	?SetCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightOmni
PUBLIC	?AddCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightOmni
PUBLIC	?SetCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightOmniNormal
PUBLIC	?AddCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightOmniNormal
PUBLIC	?SetCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightSpot
PUBLIC	?AddCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightSpot
PUBLIC	?SetCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightSpotNormal
PUBLIC	?AddCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightSpotNormal
; Function compile flags: /Odt /ZI
;	COMDAT ?CheckCubeLight@@YADPAUCUBE_HEADER@@@Z
_TEXT	SEGMENT
tv193 = -88						; size = 4
_l$ = -20						; size = 4
_conemul$ = -16						; size = 4
_cone$ = -12						; size = 4
_dist$ = -8						; size = 4
_flag$ = -2						; size = 1
_i$ = -1						; size = 1
_cube$ = 8						; size = 4
?CheckCubeLight@@YADPAUCUBE_HEADER@@@Z PROC NEAR	; CheckCubeLight, COMDAT

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 446  : 	char i, flag;
; 447  : 	float dist, cone, conemul;
; 448  : 	LIGHT *l;
; 449  : 
; 450  : // not if lights off
; 451  : 
; 452  : 	if (!RenderSettings.Light)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+88, 0
	jne	SHORT $L81495

; 453  : 		return FALSE;

	xor	al, al
	jmp	$L81488
$L81495:

; 454  : 
; 455  : // loop thru all fixed lights
; 456  : 
; 457  : 	flag = 0;

	mov	BYTE PTR _flag$[ebp], 0

; 458  : 
; 459  : 	for (i = 0 ; i < AffectFixedLightCount ; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L81496
$L81497:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L81496:
	movsx	eax, BYTE PTR _i$[ebp]
	movsx	ecx, WORD PTR _AffectFixedLightCount
	cmp	eax, ecx
	jge	$L81498

; 460  : 	{
; 461  : 		l = AffectFixedLights[i];

	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR _AffectFixedLights[eax*4]
	mov	DWORD PTR _l$[ebp], ecx

; 462  : 
; 463  : // bounding box test
; 464  : 
; 465  : 		if (cube->Xmin > l->Xmax || cube->Xmax < l->Xmin ||	cube->Ymin > l->Ymax || cube->Ymax < l->Ymin ||	cube->Zmin > l->Zmax || cube->Zmax < l->Zmin) continue;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81500
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+20]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81500
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+24]
	fcomp	DWORD PTR [ecx+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81500
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+28]
	fcomp	DWORD PTR [ecx+28]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81500
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+32]
	fcomp	DWORD PTR [ecx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81500
	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+36]
	fcomp	DWORD PTR [ecx+36]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81499
$L81500:
	jmp	$L81497
$L81499:

; 466  : 
; 467  : // radius test
; 468  : 
; 469  : 		LightDelta.v[X] = cube->CentreX - l->x;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 470  : 		LightDelta.v[Y] = cube->CentreY - l->y;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 471  : 		LightDelta.v[Z] = cube->CentreZ - l->z;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 472  : 
; 473  : 		dist = Length(&LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 474  : 		if (dist > l->Reach + cube->Radius) continue;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _cube$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+12]
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81502
	jmp	$L81497
$L81502:

; 475  : 
; 476  : // cone test if spot
; 477  : 
; 478  : 		if ((l->Type == LIGHT_SPOT || l->Type == LIGHT_SPOTNORMAL) && dist > cube->Radius)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L81504
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	$L81503
$L81504:
	mov	eax, DWORD PTR _cube$[ebp]
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR [eax+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81503

; 479  : 		{
; 480  : 			conemul = 1 / (cube->Radius / dist + l->Cone / 180);

	mov	eax, DWORD PTR _cube$[ebp]
	fld	DWORD PTR [eax+12]
	fdiv	DWORD PTR _dist$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [ecx+80]
	fdiv	DWORD PTR __real@43340000
	faddp	ST(1), ST(0)
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _conemul$[ebp]

; 481  : 			cone = (DotProduct(&l->DirMatrix.mv[Z], &LightDelta) / dist - 1) * conemul + 1;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	fmul	DWORD PTR _conemul$[ebp]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 482  : 			if (cone <= 0) continue;

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81503
	jmp	$L81497
$L81503:

; 483  : 		}
; 484  : 
; 485  : // yep, do it
; 486  : 
; 487  : 		switch (l->Type)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	mov	DWORD PTR tv193[ebp], ecx
	cmp	DWORD PTR tv193[ebp], 3
	ja	$L81507
	mov	edx, DWORD PTR tv193[ebp]
	jmp	DWORD PTR $L82622[edx*4]
$L81510:

; 488  : 		{
; 489  : 			case LIGHT_OMNI:
; 490  : 				if (flag) AddCubeLightOmni(cube, l);

	movsx	eax, BYTE PTR _flag$[ebp]
	test	eax, eax
	je	SHORT $L81511
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightOmni
	add	esp, 8

; 491  : 				else SetCubeLightOmni(cube, l);

	jmp	SHORT $L81512
$L81511:
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?SetCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightOmni
	add	esp, 8
$L81512:

; 492  : 			break;

	jmp	$L81507
$L81513:

; 493  : 			case LIGHT_OMNINORMAL:
; 494  : 				if (flag) AddCubeLightOmniNormal(cube, l);

	movsx	eax, BYTE PTR _flag$[ebp]
	test	eax, eax
	je	SHORT $L81514
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightOmniNormal
	add	esp, 8

; 495  : 				else SetCubeLightOmniNormal(cube, l);

	jmp	SHORT $L81515
$L81514:
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?SetCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightOmniNormal
	add	esp, 8
$L81515:

; 496  : 			break;

	jmp	SHORT $L81507
$L81516:

; 497  : 			case LIGHT_SPOT:
; 498  : 				if (flag) AddCubeLightSpot(cube, l);

	movsx	eax, BYTE PTR _flag$[ebp]
	test	eax, eax
	je	SHORT $L81517
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightSpot
	add	esp, 8

; 499  : 				else SetCubeLightSpot(cube, l);

	jmp	SHORT $L81518
$L81517:
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?SetCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightSpot
	add	esp, 8
$L81518:

; 500  : 			break;

	jmp	SHORT $L81507
$L81519:

; 501  : 			case LIGHT_SPOTNORMAL:
; 502  : 				if (flag) AddCubeLightSpotNormal(cube, l);

	movsx	eax, BYTE PTR _flag$[ebp]
	test	eax, eax
	je	SHORT $L81520
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?AddCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; AddCubeLightSpotNormal
	add	esp, 8

; 503  : 				else SetCubeLightSpotNormal(cube, l);

	jmp	SHORT $L81507
$L81520:
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cube$[ebp]
	push	ecx
	call	?SetCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ; SetCubeLightSpotNormal
	add	esp, 8
$L81507:

; 504  : 			break;
; 505  : 		}
; 506  : 		flag++;

	mov	al, BYTE PTR _flag$[ebp]
	add	al, 1
	mov	BYTE PTR _flag$[ebp], al

; 507  : 	}

	jmp	$L81497
$L81498:

; 508  : 
; 509  : // return result
; 510  : 
; 511  : 	return flag;

	mov	al, BYTE PTR _flag$[ebp]
$L81488:

; 512  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L82622:
	DD	$L81510
	DD	$L81513
	DD	$L81516
	DD	$L81519
?CheckCubeLight@@YADPAUCUBE_HEADER@@@Z ENDP		; CheckCubeLight
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81534 = -20					; size = 4
_i$ = -16						; size = 2
_mul$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?SetCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; SetCubeLightOmni, COMDAT

; 519  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 520  : 	WORLD_VERTEX *v;
; 521  : 	float squaredist;
; 522  : 	long mul;
; 523  : 	short i;
; 524  : 
; 525  : // loop thru verts
; 526  : 
; 527  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 528  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81530
$L81531:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81530:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81525

; 529  : 		{
; 530  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 531  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 532  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 533  : 
; 534  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 535  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81533

; 536  : 		{
; 537  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 538  : 			continue;

	jmp	$L81531
$L81533:

; 539  : 		}
; 540  : 
; 541  : 		FTOL((1 - squaredist / light->SquareReach) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81534[ebp]
	mov	eax, DWORD PTR __temp$81534[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 542  : 
; 543  : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 544  : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 545  : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 546  : 	}

	jmp	$L81531
$L81525:

; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP	; SetCubeLightOmni
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\light.cpp
_TEXT	ENDS
;	COMDAT ?AddCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81549 = -20					; size = 4
_i$ = -16						; size = 2
_mul$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightOmni, COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 555  : 	WORLD_VERTEX *v;
; 556  : 	float squaredist;
; 557  : 	long mul;
; 558  : 	short i;
; 559  : 
; 560  : // loop thru verts
; 561  : 
; 562  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 563  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81545
$L81546:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81545:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81540

; 564  : 	{
; 565  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 566  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 567  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 568  : 
; 569  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 570  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81548

; 571  : 			continue;

	jmp	$L81546
$L81548:

; 572  : 
; 573  : 		FTOL((1 - squaredist / light->SquareReach) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81549[ebp]
	mov	eax, DWORD PTR __temp$81549[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 574  : 		
; 575  : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 576  : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 577  : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 578  : 	}

	jmp	$L81546
$L81540:

; 579  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightOmni@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP	; AddCubeLightOmni
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81571 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_dist$ = -16						; size = 4
_ang$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?SetCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; SetCubeLightOmniNormal, COMDAT

; 586  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 587  : 	WORLD_VERTEX *v;
; 588  : 	float squaredist, ang, dist;
; 589  : 	long mul;
; 590  : 	short i;
; 591  : 
; 592  : // loop thru verts
; 593  : 
; 594  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 595  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81562
$L81563:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81562:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81555

; 596  : 	{
; 597  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 598  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 599  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 600  : 
; 601  : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 602  : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81568

; 603  : 		{
; 604  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 605  : 			continue;

	jmp	$L81563
$L81568:

; 606  : 		}
; 607  : 
; 608  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 609  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81569

; 610  : 		{
; 611  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 612  : 			continue;

	jmp	$L81563
$L81569:

; 613  : 		}
; 614  : 
; 615  : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 616  : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist)) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81571[ebp]
	mov	eax, DWORD PTR __temp$81571[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 617  : 
; 618  : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 619  : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 620  : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 621  : 	}

	jmp	$L81563
$L81555:

; 622  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; SetCubeLightOmniNormal
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81593 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_dist$ = -16						; size = 4
_ang$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightOmniNormal, COMDAT

; 629  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 630  : 	WORLD_VERTEX *v;
; 631  : 	float squaredist, ang, dist;
; 632  : 	long mul;
; 633  : 	short i;
; 634  : 
; 635  : // loop thru verts
; 636  : 
; 637  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 638  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81584
$L81585:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81584:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81577

; 639  : 	{
; 640  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 641  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 642  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 643  : 
; 644  : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 645  : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81590

; 646  : 			continue;

	jmp	$L81585
$L81590:

; 647  : 
; 648  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 649  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81591

; 650  : 			continue;

	jmp	$L81585
$L81591:

; 651  : 
; 652  : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 653  : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist)) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81593[ebp]
	mov	eax, DWORD PTR __temp$81593[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 654  : 
; 655  : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 656  : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 657  : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 658  : 	}

	jmp	$L81585
$L81577:

; 659  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightOmniNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; AddCubeLightOmniNormal
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81612 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_dist$ = -16						; size = 4
_cone$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?SetCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; SetCubeLightSpot, COMDAT

; 666  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 667  : 	WORLD_VERTEX *v;
; 668  : 	float squaredist, cone, dist;
; 669  : 	long mul;
; 670  : 	short i;
; 671  : 
; 672  : // loop thru verts
; 673  : 
; 674  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 675  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81606
$L81607:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81606:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81599

; 676  : 	{
; 677  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 678  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 679  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 680  : 
; 681  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 682  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81609

; 683  : 		{
; 684  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 685  : 			continue;

	jmp	$L81607
$L81609:

; 686  : 		}
; 687  : 
; 688  : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 689  : 
; 690  : 		cone = (-DotProduct(&light->DirMatrix.mv[Z], &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 691  : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81611

; 692  : 		{
; 693  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 694  : 			continue;

	jmp	$L81607
$L81611:

; 695  : 		}
; 696  : 
; 697  : 		FTOL(((1 - squaredist / light->SquareReach) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81612[ebp]
	mov	eax, DWORD PTR __temp$81612[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 698  : 
; 699  : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 700  : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 701  : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 702  : 	}

	jmp	$L81607
$L81599:

; 703  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP	; SetCubeLightSpot
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81631 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_dist$ = -16						; size = 4
_cone$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightSpot, COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 711  : 	WORLD_VERTEX *v;
; 712  : 	float squaredist, cone, dist;
; 713  : 	long mul;
; 714  : 	short i;
; 715  : 
; 716  : // loop thru verts
; 717  : 
; 718  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 719  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81625
$L81626:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81625:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81618

; 720  : 	{
; 721  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 722  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 723  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 724  : 
; 725  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 726  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81628

; 727  : 			continue;

	jmp	$L81626
$L81628:

; 728  : 
; 729  : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 730  : 
; 731  : 		cone = (-DotProduct(&light->DirMatrix.mv[Z], &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 732  : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81630

; 733  : 			continue;

	jmp	$L81626
$L81630:

; 734  : 
; 735  : 		FTOL(((1 - squaredist / light->SquareReach) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81631[ebp]
	mov	eax, DWORD PTR __temp$81631[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 736  : 
; 737  : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 738  : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 739  : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 740  : 	}

	jmp	$L81626
$L81618:

; 741  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightSpot@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP	; AddCubeLightSpot
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81655 = -32					; size = 4
_i$ = -28						; size = 2
_mul$ = -24						; size = 4
_dist$ = -20						; size = 4
_cone$ = -16						; size = 4
_ang$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?SetCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; SetCubeLightSpotNormal, COMDAT

; 748  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 749  : 	WORLD_VERTEX *v;
; 750  : 	float squaredist, ang, cone, dist;
; 751  : 	long mul;
; 752  : 	short i;
; 753  : 
; 754  : // loop thru verts
; 755  : 
; 756  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 757  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81645
$L81646:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81645:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81637

; 758  : 	{
; 759  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 760  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 761  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 762  : 
; 763  : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 764  : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81651

; 765  : 		{
; 766  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 767  : 			continue;

	jmp	$L81646
$L81651:

; 768  : 		}
; 769  : 
; 770  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 771  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81652

; 772  : 		{
; 773  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 774  : 			continue;

	jmp	$L81646
$L81652:

; 775  : 		}
; 776  : 
; 777  : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 778  : 
; 779  : 		cone = (-DotProduct(&light->DirMatrix.mv[Z], &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 780  : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81654

; 781  : 		{
; 782  : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 783  : 			continue;

	jmp	$L81646
$L81654:

; 784  : 		}
; 785  : 
; 786  : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81655[ebp]
	mov	eax, DWORD PTR __temp$81655[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 787  : 
; 788  : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 789  : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 790  : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 791  : 	}

	jmp	$L81646
$L81637:

; 792  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; SetCubeLightSpotNormal
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z
_TEXT	SEGMENT
__temp$81679 = -32					; size = 4
_i$ = -28						; size = 2
_mul$ = -24						; size = 4
_dist$ = -20						; size = 4
_cone$ = -16						; size = 4
_ang$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_cube$ = 8						; size = 4
_light$ = 12						; size = 4
?AddCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z PROC NEAR ; AddCubeLightSpotNormal, COMDAT

; 799  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 800  : 	WORLD_VERTEX *v;
; 801  : 	float squaredist, ang, cone, dist;
; 802  : 	long mul;
; 803  : 	short i;
; 804  : 
; 805  : // loop thru verts
; 806  : 
; 807  : 	v = cube->Model.VertPtr;

	mov	eax, DWORD PTR _cube$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _v$[ebp], ecx

; 808  : 	for (i = cube->Model.VertNum ; i ; i--, v++)

	mov	eax, DWORD PTR _cube$[ebp]
	mov	cx, WORD PTR [eax+74]
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $L81669
$L81670:
	mov	ax, WORD PTR _i$[ebp]
	sub	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _v$[ebp], ecx
$L81669:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	je	$L81661

; 809  : 	{
; 810  : 		LightDelta.v[X] = light->x - v->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 811  : 		LightDelta.v[Y] = light->y - v->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 812  : 		LightDelta.v[Z] = light->z - v->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 813  : 
; 814  : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 815  : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81675

; 816  : 			continue;

	jmp	$L81670
$L81675:

; 817  : 
; 818  : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 819  : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81676

; 820  : 			continue;

	jmp	$L81670
$L81676:

; 821  : 
; 822  : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 823  : 
; 824  : 		cone = (-DotProduct(&light->DirMatrix.mv[Z], &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _light$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 825  : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81678

; 826  : 			continue;

	jmp	$L81670
$L81678:

; 827  : 
; 828  : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81679[ebp]
	mov	eax, DWORD PTR __temp$81679[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 829  : 
; 830  : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 831  : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 832  : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 833  : 	}

	jmp	$L81670
$L81661:

; 834  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCubeLightSpotNormal@@YAXPAUCUBE_HEADER@@PAULIGHT@@@Z ENDP ; AddCubeLightSpotNormal
_TEXT	ENDS
PUBLIC	?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z ; CheckObjectLight
_BSS	SEGMENT
_AffectObjectLightCount DW 01H DUP (?)
	ALIGN	4

_AffectObjectLights DD 078H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z
_TEXT	SEGMENT
_conemul$ = -20						; size = 4
_cone$ = -16						; size = 4
_dist$ = -12						; size = 4
_l$ = -8						; size = 4
_i$ = -1						; size = 1
_pos$ = 8						; size = 4
_box$ = 12						; size = 4
_rad$ = 16						; size = 4
?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z PROC NEAR ; CheckObjectLight, COMDAT

; 841  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 842  : 	char i;
; 843  : 	LIGHT *l;
; 844  : 	float dist, cone, conemul;
; 845  : 
; 846  : // not if lights off
; 847  : 
; 848  : 	if (!RenderSettings.Light)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+88, 0
	jne	SHORT $L81692

; 849  : 		return FALSE;

	xor	ax, ax
	jmp	$L81686
$L81692:

; 850  : 
; 851  : // zero affecting lights list
; 852  : 
; 853  : 	AffectObjectLightCount = 0;

	mov	WORD PTR _AffectObjectLightCount, 0

; 854  : 
; 855  : // loop thru all active lights
; 856  : 
; 857  : 	for (i = 0 ; i < AffectMovingLightCount ; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L81693
$L81694:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L81693:
	movsx	eax, BYTE PTR _i$[ebp]
	movsx	ecx, WORD PTR _AffectMovingLightCount
	cmp	eax, ecx
	jge	$L81695

; 858  : 	{
; 859  : 		l = AffectMovingLights[i];

	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR _AffectMovingLights[eax*4]
	mov	DWORD PTR _l$[ebp], ecx

; 860  : 
; 861  : // bounding box test
; 862  : 
; 863  : 		if (box->Xmin > l->Xmax || box->Xmax < l->Xmin ||
; 864  : 			box->Ymin > l->Ymax || box->Ymax < l->Ymin ||
; 865  : 			box->Zmin > l->Zmax || box->Zmax < l->Zmin) continue;

	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81697
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81697
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR [ecx+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81697
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR [ecx+28]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81697
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR [ecx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81697
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+20]
	fcomp	DWORD PTR [ecx+36]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81696
$L81697:
	jmp	$L81694
$L81696:

; 866  : 
; 867  : // radius test
; 868  : 
; 869  : 		LightDelta.v[X] = pos->v[X] - l->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 870  : 		LightDelta.v[Y] = pos->v[Y] - l->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 871  : 		LightDelta.v[Z] = pos->v[Z] - l->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 872  : 		dist = Length(&LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 873  : 
; 874  : 		if (dist > l->Reach + rad) continue;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fadd	DWORD PTR [eax+12]
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81699
	jmp	$L81694
$L81699:

; 875  : 
; 876  : // cone test if spot
; 877  : 
; 878  : 		if ((l->Type == LIGHT_SPOT || l->Type == LIGHT_SPOTNORMAL) && dist > rad)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L81701
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	SHORT $L81700
$L81701:
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _rad$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81700

; 879  : 		{
; 880  : 			conemul = 1 / (rad / dist + l->Cone / 180);

	fld	DWORD PTR _rad$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+80]
	fdiv	DWORD PTR __real@43340000
	faddp	ST(1), ST(0)
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _conemul$[ebp]

; 881  : 			cone = (DotProduct(&l->DirMatrix.mv[Z], &LightDelta) / dist - 1) * conemul + 1;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	fmul	DWORD PTR _conemul$[ebp]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 882  : 			if (cone <= 0) continue;

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81700
	jmp	$L81694
$L81700:

; 883  : 		}
; 884  : 
; 885  : // ok, add light to list
; 886  : 
; 887  : 		AffectObjectLights[AffectObjectLightCount++] = l;

	movsx	eax, WORD PTR _AffectObjectLightCount
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _AffectObjectLights[eax*4], ecx
	mov	dx, WORD PTR _AffectObjectLightCount
	add	dx, 1
	mov	WORD PTR _AffectObjectLightCount, dx

; 888  : 	}

	jmp	$L81694
$L81695:

; 889  : 
; 890  : // return affecting count
; 891  : 
; 892  : 	return AffectObjectLightCount;

	mov	ax, WORD PTR _AffectObjectLightCount
$L81686:

; 893  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckObjectLight@@YAFPAUVectorStruct@@PAUBoundingBoxStruct@@M@Z ENDP ; CheckObjectLight
_TEXT	ENDS
PUBLIC	?CheckInstanceLight@@YAFPAUINSTANCE@@M@Z	; CheckInstanceLight
; Function compile flags: /Odt /ZI
;	COMDAT ?CheckInstanceLight@@YAFPAUINSTANCE@@M@Z
_TEXT	SEGMENT
_pos$ = -28						; size = 4
_box$ = -24						; size = 4
_conemul$ = -20						; size = 4
_cone$ = -16						; size = 4
_dist$ = -12						; size = 4
_l$ = -8						; size = 4
_i$ = -1						; size = 1
_inst$ = 8						; size = 4
_rad$ = 12						; size = 4
?CheckInstanceLight@@YAFPAUINSTANCE@@M@Z PROC NEAR	; CheckInstanceLight, COMDAT

; 900  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 901  : 	char i;
; 902  : 	LIGHT *l;
; 903  : 	float dist, cone, conemul;
; 904  : 	BOUNDING_BOX *box = &inst->Box;

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _box$[ebp], eax

; 905  : 	VEC *pos = &inst->WorldPos;

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pos$[ebp], eax

; 906  : 
; 907  : // not if lights off
; 908  : 
; 909  : 	if (!RenderSettings.Light)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+88, 0
	jne	SHORT $L81714

; 910  : 		return FALSE;

	xor	ax, ax
	jmp	$L81706
$L81714:

; 911  : 
; 912  : // zero affecting lights list
; 913  : 
; 914  : 	AffectObjectLightCount = 0;

	mov	WORD PTR _AffectObjectLightCount, 0

; 915  : 
; 916  : // loop thru 'affect fixed' lights
; 917  : 
; 918  : 	for (i = 0 ; i < AffectFixedLightCount ; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L81715
$L81716:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L81715:
	movsx	eax, BYTE PTR _i$[ebp]
	movsx	ecx, WORD PTR _AffectFixedLightCount
	cmp	eax, ecx
	jge	$L81717

; 919  : 	{
; 920  : 		l = AffectFixedLights[i];

	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR _AffectFixedLights[eax*4]
	mov	DWORD PTR _l$[ebp], ecx

; 921  : 
; 922  : // bounding box test
; 923  : 
; 924  : 		if (box->Xmin > l->Xmax || box->Xmax < l->Xmin ||
; 925  : 			box->Ymin > l->Ymax || box->Ymax < l->Ymin ||
; 926  : 			box->Zmin > l->Zmax || box->Zmax < l->Zmin) continue;

	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81719
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81719
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR [ecx+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81719
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR [ecx+28]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81719
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR [ecx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81719
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+20]
	fcomp	DWORD PTR [ecx+36]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81718
$L81719:
	jmp	$L81716
$L81718:

; 927  : 
; 928  : // radius test
; 929  : 
; 930  : 		LightDelta.v[X] = pos->v[X] - l->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 931  : 		LightDelta.v[Y] = pos->v[Y] - l->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 932  : 		LightDelta.v[Z] = pos->v[Z] - l->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 933  : 		dist = Length(&LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 934  : 
; 935  : 		if (dist > l->Reach + rad) continue;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fadd	DWORD PTR [eax+12]
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81721
	jmp	$L81716
$L81721:

; 936  : 
; 937  : // cone test if spot
; 938  : 
; 939  : 		if ((l->Type == LIGHT_SPOT || l->Type == LIGHT_SPOTNORMAL) && dist > rad)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L81723
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	SHORT $L81722
$L81723:
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _rad$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81722

; 940  : 		{
; 941  : 			conemul = 1 / (rad / dist + l->Cone / 180);

	fld	DWORD PTR _rad$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+80]
	fdiv	DWORD PTR __real@43340000
	faddp	ST(1), ST(0)
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _conemul$[ebp]

; 942  : 			cone = (DotProduct(&l->DirMatrix.mv[Z], &LightDelta) / dist - 1) * conemul + 1;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	fmul	DWORD PTR _conemul$[ebp]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 943  : 			if (cone <= 0) continue;

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81722
	jmp	$L81716
$L81722:

; 944  : 		}
; 945  : 
; 946  : // yep, add light to list
; 947  : 
; 948  : 		AffectObjectLights[AffectObjectLightCount++] = l;

	movsx	eax, WORD PTR _AffectObjectLightCount
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _AffectObjectLights[eax*4], ecx
	mov	dx, WORD PTR _AffectObjectLightCount
	add	dx, 1
	mov	WORD PTR _AffectObjectLightCount, dx

; 949  : 	}

	jmp	$L81716
$L81717:

; 950  : 
; 951  : // return affecting count
; 952  : 
; 953  : 	return AffectObjectLightCount;

	mov	ax, WORD PTR _AffectObjectLightCount
$L81706:

; 954  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckInstanceLight@@YAFPAUINSTANCE@@M@Z ENDP		; CheckInstanceLight
_TEXT	ENDS
PUBLIC	?CheckInstanceLightEdit@@YAFPAUINSTANCE@@M@Z	; CheckInstanceLightEdit
; Function compile flags: /Odt /ZI
;	COMDAT ?CheckInstanceLightEdit@@YAFPAUINSTANCE@@M@Z
_TEXT	SEGMENT
_pos$ = -28						; size = 4
_box$ = -24						; size = 4
_conemul$ = -20						; size = 4
_cone$ = -16						; size = 4
_dist$ = -12						; size = 4
_l$ = -8						; size = 4
_i$ = -1						; size = 1
_inst$ = 8						; size = 4
_rad$ = 12						; size = 4
?CheckInstanceLightEdit@@YAFPAUINSTANCE@@M@Z PROC NEAR	; CheckInstanceLightEdit, COMDAT

; 961  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 962  : 	char i;
; 963  : 	LIGHT *l;
; 964  : 	float dist, cone, conemul;
; 965  : 	BOUNDING_BOX *box = &inst->Box;

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _box$[ebp], eax

; 966  : 	VEC *pos = &inst->WorldPos;

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pos$[ebp], eax

; 967  : 
; 968  : // not if lights off
; 969  : 
; 970  : 	if (!RenderSettings.Light)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+88, 0
	jne	SHORT $L81736

; 971  : 		return FALSE;

	xor	ax, ax
	jmp	$L81728
$L81736:

; 972  : 
; 973  : // zero affecting lights list
; 974  : 
; 975  : 	AffectObjectLightCount = 0;

	mov	WORD PTR _AffectObjectLightCount, 0

; 976  : 
; 977  : // loop thru all lights
; 978  : 
; 979  : 	l = Light;

	mov	DWORD PTR _l$[ebp], OFFSET FLAT:?Light@@3PAULIGHT@@A ; Light

; 980  : 	for (i = 0 ; i < LIGHT_MAX ; i++, l++) if (l->Flag & ~LIGHT_OFF)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L81737
$L81738:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _l$[ebp], ecx
$L81737:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 120				; 00000078H
	jge	$L81739
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, -9					; fffffff7H
	je	$L81740

; 981  : 	{
; 982  : 
; 983  : // file light skip?
; 984  : 
; 985  : 		if ((inst->Flag & INSTANCE_NO_FILE_LIGHTS) && (l->Flag & LIGHT_FILE))

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 8
	je	SHORT $L81741
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 4
	je	SHORT $L81741

; 986  : 			continue;

	jmp	SHORT $L81738
$L81741:

; 987  : 
; 988  : // bounding box test
; 989  : 
; 990  : 		if (box->Xmin > l->Xmax || box->Xmax < l->Xmin ||
; 991  : 			box->Ymin > l->Ymax || box->Ymax < l->Ymin ||
; 992  : 			box->Zmin > l->Zmax || box->Zmax < l->Zmin) continue;

	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81743
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81743
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR [ecx+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81743
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR [ecx+28]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81743
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR [ecx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81743
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+20]
	fcomp	DWORD PTR [ecx+36]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81742
$L81743:
	jmp	$L81738
$L81742:

; 993  : 
; 994  : // radius test
; 995  : 
; 996  : 		LightDelta.v[X] = pos->v[X] - l->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 997  : 		LightDelta.v[Y] = pos->v[Y] - l->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 998  : 		LightDelta.v[Z] = pos->v[Z] - l->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 999  : 		dist = Length(&LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1000 : 
; 1001 : 		if (dist > l->Reach + rad) continue;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fadd	DWORD PTR [eax+12]
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81745
	jmp	$L81738
$L81745:

; 1002 : 
; 1003 : // cone test if spot
; 1004 : 
; 1005 : 		if ((l->Type == LIGHT_SPOT || l->Type == LIGHT_SPOTNORMAL) && dist > rad)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L81747
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	SHORT $L81746
$L81747:
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _rad$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81746

; 1006 : 		{
; 1007 : 			conemul = 1 / (rad / dist + l->Cone / 180);

	fld	DWORD PTR _rad$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR [eax+80]
	fdiv	DWORD PTR __real@43340000
	faddp	ST(1), ST(0)
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _conemul$[ebp]

; 1008 : 			cone = (DotProduct(&l->DirMatrix.mv[Z], &LightDelta) / dist - 1) * conemul + 1;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	fmul	DWORD PTR _conemul$[ebp]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1009 : 			if (cone <= 0) continue;

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81746
	jmp	$L81738
$L81746:

; 1010 : 		}
; 1011 : 
; 1012 : // yep, add light to list
; 1013 : 
; 1014 : 		AffectObjectLights[AffectObjectLightCount++] = l;

	movsx	eax, WORD PTR _AffectObjectLightCount
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _AffectObjectLights[eax*4], ecx
	mov	dx, WORD PTR _AffectObjectLightCount
	add	dx, 1
	mov	WORD PTR _AffectObjectLightCount, dx
$L81740:

; 1015 : 	}
; 1016 : 
; 1017 : // return affecting count
; 1018 : 
; 1019 : 	return AffectObjectLightCount;

	jmp	$L81738
$L81739:
	mov	ax, WORD PTR _AffectObjectLightCount
$L81728:

; 1020 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckInstanceLightEdit@@YAFPAUINSTANCE@@M@Z ENDP	; CheckInstanceLightEdit
_TEXT	ENDS
PUBLIC	?AddModelLightPermOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightPermOmni
; Function compile flags: /Odt /ZI
;	COMDAT ?AddModelLightPermOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
__i$81773 = -52						; size = 4
__temp$81770 = -48					; size = 4
_col$ = -44						; size = 4
_rgb$ = -40						; size = 12
_j$ = -28						; size = 2
_i$ = -24						; size = 2
_vcount$ = -20						; size = 4
_mul$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
?AddModelLightPermOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z PROC NEAR ; AddModelLightPermOmni, COMDAT

; 1027 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 1028 : 	MODEL_POLY *p;
; 1029 : 	MODEL_VERTEX **v;
; 1030 : 	float squaredist;
; 1031 : 	long mul, vcount;
; 1032 : 	short i, j;
; 1033 : 	long rgb[3];
; 1034 : 	POLY_RGB *col;
; 1035 : 
; 1036 : // loop thru polys
; 1037 : 
; 1038 : 	col = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _col$[ebp], ecx

; 1039 : 	p = model->PolyPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _p$[ebp], ecx

; 1040 : 
; 1041 : 	for (i = 0 ; i < model->PolyNum ; i++, p++, col++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81763
$L81764:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], edx
$L81763:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+32]
	cmp	eax, edx
	jge	$L81753

; 1042 : 	{
; 1043 : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _v$[ebp], eax

; 1044 : 
; 1045 : 		vcount = (p->Type & POLY_QUAD) ? 4 : 3;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	DWORD PTR _vcount$[ebp], ecx

; 1046 : 		for (j = 0 ; j < vcount ; j++, v++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L81766
$L81767:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
$L81766:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _vcount$[ebp]
	jge	$L81768

; 1047 : 		{
; 1048 : 			LightDelta.v[X] = pos->v[X] - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1049 : 			LightDelta.v[Y] = pos->v[Y] - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1050 : 			LightDelta.v[Z] = pos->v[Z] - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1051 : 
; 1052 : 			squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1053 : 			if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81769

; 1054 : 			{
; 1055 : 				FTOL((1 - squaredist / light->SquareReach) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81770[ebp]
	mov	eax, DWORD PTR __temp$81770[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1056 : 
; 1057 : 				rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 1058 : 				rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 1059 : 				rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 1060 : 
; 1061 : 				ModelAddGouraud(&col->rgb[j], rgb, &col->rgb[j]);

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+2]
	add	edx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81773[ebp], edx
	cmp	DWORD PTR __i$81773[ebp], 255		; 000000ffH
	jle	SHORT $L81775
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 255		; 000000ffH
	jmp	SHORT $L81776
$L81775:
	cmp	DWORD PTR __i$81773[ebp], 0
	jge	SHORT $L81777
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 0
	jmp	SHORT $L81776
$L81777:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81773[ebp]
	mov	BYTE PTR [ecx+eax*4+2], dl
$L81776:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+1]
	add	edx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81773[ebp], edx
	cmp	DWORD PTR __i$81773[ebp], 255		; 000000ffH
	jle	SHORT $L81781
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 255		; 000000ffH
	jmp	SHORT $L81782
$L81781:
	cmp	DWORD PTR __i$81773[ebp], 0
	jge	SHORT $L81783
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 0
	jmp	SHORT $L81782
$L81783:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81773[ebp]
	mov	BYTE PTR [ecx+eax*4+1], dl
$L81782:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4]
	add	edx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81773[ebp], edx
	cmp	DWORD PTR __i$81773[ebp], 255		; 000000ffH
	jle	SHORT $L81787
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 255		; 000000ffH
	jmp	SHORT $L81769
$L81787:
	cmp	DWORD PTR __i$81773[ebp], 0
	jge	SHORT $L81789
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 0
	jmp	SHORT $L81769
$L81789:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81773[ebp]
	mov	BYTE PTR [ecx+eax*4], dl
$L81769:

; 1062 : 			}
; 1063 : 		}

	jmp	$L81767
$L81768:

; 1064 : 	}

	jmp	$L81764
$L81753:

; 1065 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightPermOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ENDP ; AddModelLightPermOmni
_TEXT	ENDS
PUBLIC	?AddModelLightPermOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightPermOmniNormal
; Function compile flags: /Odt /ZI
;	COMDAT ?AddModelLightPermOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
__i$81823 = -60						; size = 4
__temp$81820 = -56					; size = 4
_col$ = -52						; size = 4
_rgb$ = -48						; size = 12
_j$ = -36						; size = 2
_i$ = -32						; size = 2
_vcount$ = -28						; size = 4
_mul$ = -24						; size = 4
_dist$ = -20						; size = 4
_ang$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
?AddModelLightPermOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z PROC NEAR ; AddModelLightPermOmniNormal, COMDAT

; 1072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 1073 : 	MODEL_POLY *p;
; 1074 : 	MODEL_VERTEX **v;
; 1075 : 	float squaredist, ang, dist;
; 1076 : 	long mul, vcount;
; 1077 : 	short i, j;
; 1078 : 	long rgb[3];
; 1079 : 	POLY_RGB *col;
; 1080 : 
; 1081 : // loop thru polys
; 1082 : 
; 1083 : 	col = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _col$[ebp], ecx

; 1084 : 	p = model->PolyPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _p$[ebp], ecx

; 1085 : 
; 1086 : 	for (i = 0 ; i < model->PolyNum ; i++, p++, col++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81808
$L81809:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], edx
$L81808:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+32]
	cmp	eax, edx
	jge	$L81796

; 1087 : 	{
; 1088 : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _v$[ebp], eax

; 1089 : 
; 1090 : 		vcount = (p->Type & POLY_QUAD) ? 4 : 3;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	DWORD PTR _vcount$[ebp], ecx

; 1091 : 		for (j = 0 ; j < vcount ; j++, v++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L81811
$L81812:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
$L81811:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _vcount$[ebp]
	jge	$L81813

; 1092 : 		{
; 1093 : 			LightDelta.v[X] = pos->v[X] - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1094 : 			LightDelta.v[Y] = pos->v[Y] - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1095 : 			LightDelta.v[Z] = pos->v[Z] - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1096 : 
; 1097 : 			ang = DotProduct(&LightDelta, (VEC*)&(*v)->nx);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 1098 : 			if (ang > 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81817

; 1099 : 			{
; 1100 : 				squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1101 : 				if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81817

; 1102 : 				{
; 1103 : 					dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1104 : 					FTOL(((1 - squaredist / light->SquareReach) * (ang / dist)) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81820[ebp]
	mov	eax, DWORD PTR __temp$81820[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1105 : 
; 1106 : 					rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 1107 : 					rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 1108 : 					rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 1109 : 
; 1110 : 					ModelAddGouraud(&col->rgb[j], rgb, &col->rgb[j]);

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+2]
	add	edx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81823[ebp], edx
	cmp	DWORD PTR __i$81823[ebp], 255		; 000000ffH
	jle	SHORT $L81825
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 255		; 000000ffH
	jmp	SHORT $L81826
$L81825:
	cmp	DWORD PTR __i$81823[ebp], 0
	jge	SHORT $L81827
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 0
	jmp	SHORT $L81826
$L81827:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81823[ebp]
	mov	BYTE PTR [ecx+eax*4+2], dl
$L81826:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+1]
	add	edx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81823[ebp], edx
	cmp	DWORD PTR __i$81823[ebp], 255		; 000000ffH
	jle	SHORT $L81831
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 255		; 000000ffH
	jmp	SHORT $L81832
$L81831:
	cmp	DWORD PTR __i$81823[ebp], 0
	jge	SHORT $L81833
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 0
	jmp	SHORT $L81832
$L81833:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81823[ebp]
	mov	BYTE PTR [ecx+eax*4+1], dl
$L81832:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4]
	add	edx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81823[ebp], edx
	cmp	DWORD PTR __i$81823[ebp], 255		; 000000ffH
	jle	SHORT $L81837
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 255		; 000000ffH
	jmp	SHORT $L81817
$L81837:
	cmp	DWORD PTR __i$81823[ebp], 0
	jge	SHORT $L81839
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 0
	jmp	SHORT $L81817
$L81839:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81823[ebp]
	mov	BYTE PTR [ecx+eax*4], dl
$L81817:

; 1111 : 				}
; 1112 : 			}
; 1113 : 		}

	jmp	$L81812
$L81813:

; 1114 : 	}

	jmp	$L81809
$L81796:

; 1115 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightPermOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ENDP ; AddModelLightPermOmniNormal
_TEXT	ENDS
PUBLIC	?AddModelLightPermSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightPermSpot
; Function compile flags: /Odt /ZI
;	COMDAT ?AddModelLightPermSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT
__i$81871 = -60						; size = 4
__temp$81868 = -56					; size = 4
_col$ = -52						; size = 4
_rgb$ = -48						; size = 12
_j$ = -36						; size = 2
_i$ = -32						; size = 2
_vcount$ = -28						; size = 4
_mul$ = -24						; size = 4
_cone$ = -20						; size = 4
_dist$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
_dir$ = 20						; size = 4
?AddModelLightPermSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z PROC NEAR ; AddModelLightPermSpot, COMDAT

; 1122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 1123 : 	MODEL_POLY *p;
; 1124 : 	MODEL_VERTEX **v;
; 1125 : 	float squaredist, dist, cone;
; 1126 : 	long mul, vcount;
; 1127 : 	short i, j;
; 1128 : 	long rgb[3];
; 1129 : 	POLY_RGB *col;
; 1130 : 
; 1131 : // loop thru polys
; 1132 : 
; 1133 : 	col = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _col$[ebp], ecx

; 1134 : 	p = model->PolyPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _p$[ebp], ecx

; 1135 : 
; 1136 : 	for (i = 0 ; i < model->PolyNum ; i++, p++, col++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81859
$L81860:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], edx
$L81859:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+32]
	cmp	eax, edx
	jge	$L81847

; 1137 : 	{
; 1138 : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _v$[ebp], eax

; 1139 : 
; 1140 : 		vcount = (p->Type & POLY_QUAD) ? 4 : 3;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	DWORD PTR _vcount$[ebp], ecx

; 1141 : 		for (j = 0 ; j < vcount ; j++, v++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L81862
$L81863:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
$L81862:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _vcount$[ebp]
	jge	$L81864

; 1142 : 		{
; 1143 : 			LightDelta.v[X] = pos->v[X] - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1144 : 			LightDelta.v[Y] = pos->v[Y] - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1145 : 			LightDelta.v[Z] = pos->v[Z] - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1146 : 
; 1147 : 			squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1148 : 			if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81865

; 1149 : 			{
; 1150 : 				dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1151 : 				cone = (-DotProduct(dir, &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1152 : 				if (cone > 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81865

; 1153 : 				{
; 1154 : 					FTOL(((1 - squaredist / light->SquareReach) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81868[ebp]
	mov	eax, DWORD PTR __temp$81868[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1155 : 
; 1156 : 					rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 1157 : 					rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 1158 : 					rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 1159 : 
; 1160 : 					ModelAddGouraud(&col->rgb[j], rgb, &col->rgb[j]);

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+2]
	add	edx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81871[ebp], edx
	cmp	DWORD PTR __i$81871[ebp], 255		; 000000ffH
	jle	SHORT $L81873
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 255		; 000000ffH
	jmp	SHORT $L81874
$L81873:
	cmp	DWORD PTR __i$81871[ebp], 0
	jge	SHORT $L81875
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 0
	jmp	SHORT $L81874
$L81875:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81871[ebp]
	mov	BYTE PTR [ecx+eax*4+2], dl
$L81874:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+1]
	add	edx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81871[ebp], edx
	cmp	DWORD PTR __i$81871[ebp], 255		; 000000ffH
	jle	SHORT $L81879
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 255		; 000000ffH
	jmp	SHORT $L81880
$L81879:
	cmp	DWORD PTR __i$81871[ebp], 0
	jge	SHORT $L81881
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 0
	jmp	SHORT $L81880
$L81881:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81871[ebp]
	mov	BYTE PTR [ecx+eax*4+1], dl
$L81880:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4]
	add	edx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81871[ebp], edx
	cmp	DWORD PTR __i$81871[ebp], 255		; 000000ffH
	jle	SHORT $L81885
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 255		; 000000ffH
	jmp	SHORT $L81865
$L81885:
	cmp	DWORD PTR __i$81871[ebp], 0
	jge	SHORT $L81887
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 0
	jmp	SHORT $L81865
$L81887:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81871[ebp]
	mov	BYTE PTR [ecx+eax*4], dl
$L81865:

; 1161 : 				}
; 1162 : 			}
; 1163 : 		}

	jmp	$L81863
$L81864:

; 1164 : 	}

	jmp	$L81860
$L81847:

; 1165 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightPermSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ENDP ; AddModelLightPermSpot
_TEXT	ENDS
PUBLIC	?AddModelLightPermSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightPermSpotNormal
; Function compile flags: /Odt /ZI
;	COMDAT ?AddModelLightPermSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT
__i$81924 = -64						; size = 4
__temp$81921 = -60					; size = 4
_col$ = -56						; size = 4
_rgb$ = -52						; size = 12
_j$ = -40						; size = 2
_i$ = -36						; size = 2
_vcount$ = -32						; size = 4
_mul$ = -28						; size = 4
_cone$ = -24						; size = 4
_dist$ = -20						; size = 4
_ang$ = -16						; size = 4
_squaredist$ = -12					; size = 4
_v$ = -8						; size = 4
_p$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
_dir$ = 20						; size = 4
?AddModelLightPermSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z PROC NEAR ; AddModelLightPermSpotNormal, COMDAT

; 1172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi

; 1173 : 	MODEL_POLY *p;
; 1174 : 	MODEL_VERTEX **v;
; 1175 : 	float squaredist, ang, dist, cone;
; 1176 : 	long mul, vcount;
; 1177 : 	short i, j;
; 1178 : 	long rgb[3];
; 1179 : 	POLY_RGB *col;
; 1180 : 
; 1181 : // loop thru polys
; 1182 : 
; 1183 : 	col = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _col$[ebp], ecx

; 1184 : 	p = model->PolyPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _p$[ebp], ecx

; 1185 : 
; 1186 : 	for (i = 0 ; i < model->PolyNum ; i++, p++, col++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81908
$L81909:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _col$[ebp], edx
$L81908:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+32]
	cmp	eax, edx
	jge	$L81895

; 1187 : 	{
; 1188 : 		v = &p->v0;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _v$[ebp], eax

; 1189 : 
; 1190 : 		vcount = (p->Type & POLY_QUAD) ? 4 : 3;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	DWORD PTR _vcount$[ebp], ecx

; 1191 : 		for (j = 0 ; j < vcount ; j++, v++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L81911
$L81912:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
$L81911:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _vcount$[ebp]
	jge	$L81913

; 1192 : 		{
; 1193 : 			LightDelta.v[X] = pos->v[X] - (*v)->x;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1194 : 			LightDelta.v[Y] = pos->v[Y] - (*v)->y;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1195 : 			LightDelta.v[Z] = pos->v[Z] - (*v)->z;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1196 : 
; 1197 : 			ang = DotProduct(&LightDelta, (VEC*)&(*v)->nx);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 1198 : 			if (ang > 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81917

; 1199 : 			{
; 1200 : 				squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1201 : 				if (squaredist < light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L81917

; 1202 : 				{
; 1203 : 					dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1204 : 					cone = (-DotProduct(dir, &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1205 : 					if (cone > 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81917

; 1206 : 					{
; 1207 : 						FTOL(((1 - squaredist / light->SquareReach) * (ang / dist) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81921[ebp]
	mov	eax, DWORD PTR __temp$81921[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1208 : 
; 1209 : 						rgb[0] = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp], ecx

; 1210 : 						rgb[1] = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+4], ecx

; 1211 : 						rgb[2] = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _rgb$[ebp+8], ecx

; 1212 : 
; 1213 : 						ModelAddGouraud(&col->rgb[j], rgb, &col->rgb[j]);

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+2]
	add	edx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR __i$81924[ebp], edx
	cmp	DWORD PTR __i$81924[ebp], 255		; 000000ffH
	jle	SHORT $L81926
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 255		; 000000ffH
	jmp	SHORT $L81927
$L81926:
	cmp	DWORD PTR __i$81924[ebp], 0
	jge	SHORT $L81928
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+2], 0
	jmp	SHORT $L81927
$L81928:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81924[ebp]
	mov	BYTE PTR [ecx+eax*4+2], dl
$L81927:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+1]
	add	edx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR __i$81924[ebp], edx
	cmp	DWORD PTR __i$81924[ebp], 255		; 000000ffH
	jle	SHORT $L81932
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 255		; 000000ffH
	jmp	SHORT $L81933
$L81932:
	cmp	DWORD PTR __i$81924[ebp], 0
	jge	SHORT $L81934
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4+1], 0
	jmp	SHORT $L81933
$L81934:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81924[ebp]
	mov	BYTE PTR [ecx+eax*4+1], dl
$L81933:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4]
	add	edx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR __i$81924[ebp], edx
	cmp	DWORD PTR __i$81924[ebp], 255		; 000000ffH
	jle	SHORT $L81938
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 255		; 000000ffH
	jmp	SHORT $L81917
$L81938:
	cmp	DWORD PTR __i$81924[ebp], 0
	jge	SHORT $L81940
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	BYTE PTR [ecx+eax*4], 0
	jmp	SHORT $L81917
$L81940:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	dl, BYTE PTR __i$81924[ebp]
	mov	BYTE PTR [ecx+eax*4], dl
$L81917:

; 1214 : 					}
; 1215 : 				}
; 1216 : 			}
; 1217 : 		}

	jmp	$L81912
$L81913:

; 1218 : 	}

	jmp	$L81909
$L81895:

; 1219 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightPermSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ENDP ; AddModelLightPermSpotNormal
_TEXT	ENDS
PUBLIC	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z ; AddModelLight
PUBLIC	?SetModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; SetModelLightOmni
PUBLIC	?AddModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightOmni
PUBLIC	?SetModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; SetModelLightOmniNormal
PUBLIC	?AddModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightOmniNormal
PUBLIC	?SetModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; SetModelLightSpot
PUBLIC	?AddModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightSpot
PUBLIC	?SetModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; SetModelLightSpotNormal
PUBLIC	?AddModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightSpotNormal
EXTRN	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z:NEAR ; TransposeRotVector
; Function compile flags: /Odt /ZI
;	COMDAT ?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
tv83 = -112						; size = 4
_dir$ = -44						; size = 12
_out$ = -32						; size = 12
_vec$ = -20						; size = 12
_l$ = -8						; size = 4
_i$ = -4						; size = 4
_model$ = 8						; size = 4
_pos$ = 12						; size = 4
_mat$ = 16						; size = 4
?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z PROC NEAR ; AddModelLight, COMDAT

; 1226 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 1227 : 	long i;
; 1228 : 	LIGHT *l;
; 1229 : 	VEC vec, out, dir;
; 1230 : 
; 1231 : // loop thru all affecting lights
; 1232 : 
; 1233 : 	l = Light;

	mov	DWORD PTR _l$[ebp], OFFSET FLAT:?Light@@3PAULIGHT@@A ; Light

; 1234 : 	for (i = 0 ; i < AffectObjectLightCount ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81953
$L81954:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81953:
	movsx	eax, WORD PTR _AffectObjectLightCount
	cmp	DWORD PTR _i$[ebp], eax
	jge	$L81947

; 1235 : 	{
; 1236 : 		l = AffectObjectLights[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _AffectObjectLights[eax*4]
	mov	DWORD PTR _l$[ebp], ecx

; 1237 : 
; 1238 : // get relative position
; 1239 : 
; 1240 : 		SubVector((VEC*)&l->x, pos, &vec);

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _vec$[ebp+8]

; 1241 : 		TransposeRotVector(mat, &vec, &out);

	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
	add	esp, 12					; 0000000cH

; 1242 : 
; 1243 : // set or add
; 1244 : 
; 1245 : 		switch (l->Type)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	mov	DWORD PTR tv83[ebp], ecx
	cmp	DWORD PTR tv83[ebp], 3
	ja	$L81960
	mov	edx, DWORD PTR tv83[ebp]
	jmp	DWORD PTR $L82659[edx*4]
$L81963:

; 1246 : 		{
; 1247 : 			case LIGHT_OMNI:
; 1248 : 				if (i) AddModelLightOmni(model, l, &out);

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L81964
	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?AddModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightOmni
	add	esp, 12					; 0000000cH

; 1249 : 				else SetModelLightOmni(model, l, &out);

	jmp	SHORT $L81965
$L81964:
	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?SetModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; SetModelLightOmni
	add	esp, 12					; 0000000cH
$L81965:

; 1250 : 			break;

	jmp	$L81960
$L81966:

; 1251 : 			case LIGHT_OMNINORMAL:
; 1252 : 				if (i) AddModelLightOmniNormal(model, l, &out);

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L81967
	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?AddModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightOmniNormal
	add	esp, 12					; 0000000cH

; 1253 : 				else SetModelLightOmniNormal(model, l, &out);

	jmp	SHORT $L81968
$L81967:
	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?SetModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; SetModelLightOmniNormal
	add	esp, 12					; 0000000cH
$L81968:

; 1254 : 			break;

	jmp	$L81960
$L81969:

; 1255 : 			case LIGHT_SPOT:
; 1256 : 				TransposeRotVector(mat, &l->DirMatrix.mv[Z], &dir);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
	add	esp, 12					; 0000000cH

; 1257 : 				if (i) AddModelLightSpot(model, l, &out, &dir);

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L81970
	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?AddModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightSpot
	add	esp, 16					; 00000010H

; 1258 : 				else SetModelLightSpot(model, l, &out, &dir);

	jmp	SHORT $L81971
$L81970:
	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?SetModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; SetModelLightSpot
	add	esp, 16					; 00000010H
$L81971:

; 1259 : 			break;

	jmp	SHORT $L81960
$L81972:

; 1260 : 			case LIGHT_SPOTNORMAL:
; 1261 : 				TransposeRotVector(mat, &l->DirMatrix.mv[Z], &dir);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
	add	esp, 12					; 0000000cH

; 1262 : 				if (i) AddModelLightSpotNormal(model, l, &out, &dir);

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L81973
	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?AddModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightSpotNormal
	add	esp, 16					; 00000010H

; 1263 : 				else SetModelLightSpotNormal(model, l, &out, &dir);

	jmp	SHORT $L81960
$L81973:
	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?SetModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; SetModelLightSpotNormal
	add	esp, 16					; 00000010H
$L81960:

; 1264 : 			break;
; 1265 : 		}
; 1266 : 	}

	jmp	$L81954
$L81947:

; 1267 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L82659:
	DD	$L81963
	DD	$L81966
	DD	$L81969
	DD	$L81972
?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z ENDP ; AddModelLight
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
__temp$81988 = -20					; size = 4
_i$ = -16						; size = 2
_mul$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
?SetModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z PROC NEAR ; SetModelLightOmni, COMDAT

; 1274 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1275 : 	MODEL_VERTEX *v;
; 1276 : 	float squaredist;
; 1277 : 	long mul;
; 1278 : 	short i;
; 1279 : 
; 1280 : // loop thru verts
; 1281 : 
; 1282 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1283 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81984
$L81985:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L81984:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L81979

; 1284 : 	{
; 1285 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1286 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1287 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1288 : 
; 1289 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1290 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81987

; 1291 : 		{
; 1292 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1293 : 			continue;

	jmp	$L81985
$L81987:

; 1294 : 		}
; 1295 : 
; 1296 : 		FTOL((1 - squaredist / light->SquareReach) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81988[ebp]
	mov	eax, DWORD PTR __temp$81988[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1297 : 
; 1298 : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 1299 : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 1300 : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 1301 : 	}

	jmp	$L81985
$L81979:

; 1302 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ENDP ; SetModelLightOmni
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
__temp$82004 = -20					; size = 4
_i$ = -16						; size = 2
_mul$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
?AddModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z PROC NEAR ; AddModelLightOmni, COMDAT

; 1309 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1310 : 	MODEL_VERTEX *v;
; 1311 : 	float squaredist;
; 1312 : 	long mul;
; 1313 : 	short i;
; 1314 : 
; 1315 : // loop thru verts
; 1316 : 
; 1317 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1318 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82000
$L82001:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82000:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L81995

; 1319 : 	{
; 1320 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1321 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1322 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1323 : 
; 1324 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1325 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82003

; 1326 : 			continue;

	jmp	$L82001
$L82003:

; 1327 : 
; 1328 : 		FTOL((1 - squaredist / light->SquareReach) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82004[ebp]
	mov	eax, DWORD PTR __temp$82004[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1329 : 
; 1330 : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 1331 : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1332 : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 1333 : 	}

	jmp	$L82001
$L81995:

; 1334 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ENDP ; AddModelLightOmni
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
__temp$82027 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_ang$ = -16						; size = 4
_dist$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
?SetModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z PROC NEAR ; SetModelLightOmniNormal, COMDAT

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1342 : 	MODEL_VERTEX *v;
; 1343 : 	float squaredist, dist, ang;
; 1344 : 	long mul;
; 1345 : 	short i;
; 1346 : 
; 1347 : // loop thru verts
; 1348 : 
; 1349 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1350 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82018
$L82019:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82018:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L82011

; 1351 : 	{
; 1352 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1353 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1354 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1355 : 
; 1356 : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 1357 : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82024

; 1358 : 		{
; 1359 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1360 : 			continue;

	jmp	$L82019
$L82024:

; 1361 : 		}
; 1362 : 
; 1363 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1364 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82025

; 1365 : 		{
; 1366 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1367 : 			continue;

	jmp	$L82019
$L82025:

; 1368 : 		}
; 1369 : 
; 1370 : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1371 : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist)) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82027[ebp]
	mov	eax, DWORD PTR __temp$82027[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1372 : 
; 1373 : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 1374 : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 1375 : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 1376 : 	}

	jmp	$L82019
$L82011:

; 1377 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ENDP ; SetModelLightOmniNormal
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
__temp$82050 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_ang$ = -16						; size = 4
_dist$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
?AddModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z PROC NEAR ; AddModelLightOmniNormal, COMDAT

; 1384 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1385 : 	MODEL_VERTEX *v;
; 1386 : 	float squaredist, dist, ang;
; 1387 : 	long mul;
; 1388 : 	short i;
; 1389 : 
; 1390 : // loop thru verts
; 1391 : 
; 1392 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1393 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82041
$L82042:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82041:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L82034

; 1394 : 	{
; 1395 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1396 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1397 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1398 : 
; 1399 : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 1400 : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82047

; 1401 : 			continue;

	jmp	$L82042
$L82047:

; 1402 : 
; 1403 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1404 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82048

; 1405 : 			continue;

	jmp	$L82042
$L82048:

; 1406 : 
; 1407 : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1408 : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist)) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82050[ebp]
	mov	eax, DWORD PTR __temp$82050[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1409 : 
; 1410 : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 1411 : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1412 : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 1413 : 	}

	jmp	$L82042
$L82034:

; 1414 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ENDP ; AddModelLightOmniNormal
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT
__temp$82071 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_cone$ = -16						; size = 4
_dist$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
_dir$ = 20						; size = 4
?SetModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z PROC NEAR ; SetModelLightSpot, COMDAT

; 1421 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1422 : 	MODEL_VERTEX *v;
; 1423 : 	float squaredist, dist, cone;
; 1424 : 	long mul;
; 1425 : 	short i;
; 1426 : 
; 1427 : // loop thru verts
; 1428 : 
; 1429 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1430 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82065
$L82066:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82065:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L82058

; 1431 : 	{
; 1432 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1433 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1434 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1435 : 
; 1436 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1437 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82068

; 1438 : 		{
; 1439 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1440 : 			continue;

	jmp	$L82066
$L82068:

; 1441 : 		}
; 1442 : 
; 1443 : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1444 : 
; 1445 : 		cone = (-DotProduct(dir, &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1446 : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82070

; 1447 : 		{
; 1448 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1449 : 			continue;

	jmp	$L82066
$L82070:

; 1450 : 		}
; 1451 : 
; 1452 : 		FTOL(((1 - squaredist / light->SquareReach) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82071[ebp]
	mov	eax, DWORD PTR __temp$82071[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1453 : 
; 1454 : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 1455 : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 1456 : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 1457 : 	}

	jmp	$L82066
$L82058:

; 1458 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ENDP ; SetModelLightSpot
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT
__temp$82092 = -28					; size = 4
_i$ = -24						; size = 2
_mul$ = -20						; size = 4
_cone$ = -16						; size = 4
_dist$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
_dir$ = 20						; size = 4
?AddModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z PROC NEAR ; AddModelLightSpot, COMDAT

; 1465 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1466 : 	MODEL_VERTEX *v;
; 1467 : 	float squaredist, dist, cone;
; 1468 : 	long mul;
; 1469 : 	short i;
; 1470 : 
; 1471 : // loop thru verts
; 1472 : 
; 1473 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1474 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82086
$L82087:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82086:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L82079

; 1475 : 	{
; 1476 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1477 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1478 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1479 : 
; 1480 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1481 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82089

; 1482 : 			continue;

	jmp	$L82087
$L82089:

; 1483 : 
; 1484 : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1485 : 
; 1486 : 		cone = (-DotProduct(dir, &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1487 : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82091

; 1488 : 			continue;

	jmp	$L82087
$L82091:

; 1489 : 
; 1490 : 		FTOL(((1 - squaredist / light->SquareReach) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82092[ebp]
	mov	eax, DWORD PTR __temp$82092[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1491 : 
; 1492 : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 1493 : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1494 : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 1495 : 	}

	jmp	$L82087
$L82079:

; 1496 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ENDP ; AddModelLightSpot
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT
__temp$82118 = -32					; size = 4
_i$ = -28						; size = 2
_mul$ = -24						; size = 4
_cone$ = -20						; size = 4
_ang$ = -16						; size = 4
_dist$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
_dir$ = 20						; size = 4
?SetModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z PROC NEAR ; SetModelLightSpotNormal, COMDAT

; 1503 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1504 : 	MODEL_VERTEX *v;
; 1505 : 	float squaredist, dist, ang, cone;
; 1506 : 	long mul;
; 1507 : 	short i;
; 1508 : 
; 1509 : // loop thru verts
; 1510 : 
; 1511 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1512 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82108
$L82109:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82108:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L82100

; 1513 : 	{
; 1514 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1515 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1516 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1517 : 
; 1518 : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 1519 : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82114

; 1520 : 		{
; 1521 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1522 : 			continue;

	jmp	$L82109
$L82114:

; 1523 : 		}
; 1524 : 
; 1525 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1526 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82115

; 1527 : 		{
; 1528 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1529 : 			continue;

	jmp	$L82109
$L82115:

; 1530 : 		}
; 1531 : 
; 1532 : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1533 : 
; 1534 : 		cone = (-DotProduct(dir, &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1535 : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82117

; 1536 : 		{
; 1537 : 			v->r = v->g = v->b = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+72], 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1538 : 			continue;

	jmp	$L82109
$L82117:

; 1539 : 		}
; 1540 : 
; 1541 : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82118[ebp]
	mov	eax, DWORD PTR __temp$82118[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1542 : 
; 1543 : 		v->r = (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 1544 : 		v->g = (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 1545 : 		v->b = (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 1546 : 	}

	jmp	$L82109
$L82100:

; 1547 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ENDP ; SetModelLightSpotNormal
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z
_TEXT	SEGMENT
__temp$82144 = -32					; size = 4
_i$ = -28						; size = 2
_mul$ = -24						; size = 4
_cone$ = -20						; size = 4
_ang$ = -16						; size = 4
_dist$ = -12						; size = 4
_squaredist$ = -8					; size = 4
_v$ = -4						; size = 4
_model$ = 8						; size = 4
_light$ = 12						; size = 4
_pos$ = 16						; size = 4
_dir$ = 20						; size = 4
?AddModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z PROC NEAR ; AddModelLightSpotNormal, COMDAT

; 1554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1555 : 	MODEL_VERTEX *v;
; 1556 : 	float squaredist, dist, ang, cone;
; 1557 : 	long mul;
; 1558 : 	short i;
; 1559 : 
; 1560 : // loop thru verts
; 1561 : 
; 1562 : 	v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1563 : 	for (i = 0 ; i < model->VertNum ; i++, v++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82134
$L82135:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82134:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	cmp	eax, edx
	jge	$L82126

; 1564 : 	{
; 1565 : 		LightDelta.v[X] = pos->v[X] - v->x;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1566 : 		LightDelta.v[Y] = pos->v[Y] - v->y;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1567 : 		LightDelta.v[Z] = pos->v[Z] - v->z;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1568 : 
; 1569 : 		ang = DotProduct(&LightDelta, (VEC*)&v->nx);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _ang$[ebp]

; 1570 : 		if (ang <= 0)

	fld	DWORD PTR _ang$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82140

; 1571 : 			continue;

	jmp	$L82135
$L82140:

; 1572 : 
; 1573 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1574 : 		if (squaredist >= light->SquareReach)

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82141

; 1575 : 			continue;

	jmp	$L82135
$L82141:

; 1576 : 
; 1577 : 		dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1578 : 
; 1579 : 		cone = (-DotProduct(dir, &LightDelta) / dist - 1) * light->ConeMul + 1;

	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _light$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1580 : 		if (cone <= 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82143

; 1581 : 			continue;

	jmp	$L82135
$L82143:

; 1582 : 
; 1583 : 		FTOL(((1 - squaredist / light->SquareReach) * (ang / dist) * cone) * 256, mul);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fld	DWORD PTR _ang$[ebp]
	fdiv	DWORD PTR _dist$[ebp]
	fmulp	ST(1), ST(0)
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82144[ebp]
	mov	eax, DWORD PTR __temp$82144[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1584 : 
; 1585 : 		v->r += (light->r * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 1586 : 		v->g += (light->g * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1587 : 		v->b += (light->b * mul) >> 8;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 1588 : 	}

	jmp	$L82135
$L82126:

; 1589 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ENDP ; AddModelLightSpotNormal
_TEXT	ENDS
PUBLIC	?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ; AddModelLightSimple
; Function compile flags: /Odt /ZI
;	COMDAT ?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
__temp$82174 = -52					; size = 4
__temp$82168 = -48					; size = 4
_v$ = -44						; size = 4
_b$ = -40						; size = 4
_g$ = -36						; size = 4
_r$ = -32						; size = 4
_cone$ = -28						; size = 4
_dist$ = -24						; size = 4
_squaredist$ = -20					; size = 4
_l$ = -16						; size = 4
_mul$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_model$ = 8						; size = 4
_pos$ = 12						; size = 4
?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z PROC NEAR ; AddModelLightSimple, COMDAT

; 1596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 1597 : 	long i, j, mul;
; 1598 : 	LIGHT *l;
; 1599 : 	float squaredist, dist, cone;
; 1600 : 	long r, g, b;
; 1601 : 	MODEL_VERTEX *v;
; 1602 : 
; 1603 : // loop thru all affecting lights
; 1604 : 
; 1605 : 	l = Light;

	mov	DWORD PTR _l$[ebp], OFFSET FLAT:?Light@@3PAULIGHT@@A ; Light

; 1606 : 	for (i = 0 ; i < AffectObjectLightCount ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82162
$L82163:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82162:
	movsx	eax, WORD PTR _AffectObjectLightCount
	cmp	DWORD PTR _i$[ebp], eax
	jge	$L82150

; 1607 : 	{
; 1608 : 		l = AffectObjectLights[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _AffectObjectLights[eax*4]
	mov	DWORD PTR _l$[ebp], ecx

; 1609 : 
; 1610 : // get light rgb
; 1611 : 
; 1612 : 		r = g = b = 0;

	mov	DWORD PTR _b$[ebp], 0
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _g$[ebp], eax
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR _r$[ebp], ecx

; 1613 : 
; 1614 : 		LightDelta.v[X] = l->x - pos->v[X];

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _LightDelta

; 1615 : 		LightDelta.v[Y] = l->y - pos->v[Y];

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _LightDelta+4

; 1616 : 		LightDelta.v[Z] = l->z - pos->v[Z];

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _LightDelta+8

; 1617 : 
; 1618 : 		squaredist = DotProduct(&LightDelta, &LightDelta);

	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR _LightDelta
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR _LightDelta+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR _LightDelta+8
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _squaredist$[ebp]

; 1619 : 		if (squaredist < l->SquareReach)

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fcomp	DWORD PTR [eax+16]
	fnstsw	ax
	test	ah, 5
	jp	$L82165

; 1620 : 		{
; 1621 : 			if (l->Type == LIGHT_OMNI || l->Type == LIGHT_OMNINORMAL)

	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	test	ecx, ecx
	je	SHORT $L82167
	mov	eax, DWORD PTR _l$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 1
	jne	SHORT $L82166
$L82167:

; 1622 : 			{
; 1623 : 				FTOL((1 - squaredist / l->SquareReach) * 256, mul);

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82168[ebp]
	mov	eax, DWORD PTR __temp$82168[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1624 : 
; 1625 : 				r = (l->r * mul) >> 8;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _r$[ebp], ecx

; 1626 : 				g = (l->g * mul) >> 8;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _g$[ebp], ecx

; 1627 : 				b = (l->b * mul) >> 8;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _b$[ebp], ecx

; 1628 : 			}
; 1629 : 			else

	jmp	$L82165
$L82166:

; 1630 : 			{
; 1631 : 				dist = (float)sqrt(squaredist);

	mov	eax, DWORD PTR _squaredist$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1632 : 
; 1633 : 				cone = (-DotProduct(&l->DirMatrix.mv[Z], &LightDelta) / dist - 1) * l->ConeMul + 1;

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+4
	fmul	DWORD PTR [ecx+72]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _l$[ebp]
	fld	DWORD PTR _LightDelta+8
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _l$[ebp]
	fmul	DWORD PTR [eax+84]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _cone$[ebp]

; 1634 : 				if (cone > 0)

	fld	DWORD PTR _cone$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82165

; 1635 : 				{
; 1636 : 					FTOL(((1 - squaredist / l->SquareReach) * cone) * 256, mul);

	mov	eax, DWORD PTR _l$[ebp]
	fld	DWORD PTR _squaredist$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _cone$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82174[ebp]
	mov	eax, DWORD PTR __temp$82174[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _mul$[ebp], eax

; 1637 : 
; 1638 : 					r = (l->r * mul) >> 8;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _r$[ebp], ecx

; 1639 : 					g = (l->g * mul) >> 8;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _g$[ebp], ecx

; 1640 : 					b = (l->b * mul) >> 8;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	imul	ecx, DWORD PTR _mul$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _b$[ebp], ecx
$L82165:

; 1641 : 				}
; 1642 : 			}
; 1643 : 		}
; 1644 : 
; 1645 : // set rgb
; 1646 : 
; 1647 : 		if (!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $L82177

; 1648 : 		{
; 1649 : 			v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1650 : 			for (j = 0 ; j < model->VertNum ; j++, v++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L82178
$L82179:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82178:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+34]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	SHORT $L82180

; 1651 : 			{
; 1652 : 				v->r = r;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 1653 : 				v->g = g;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1654 : 				v->b = b;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 1655 : 			}

	jmp	SHORT $L82179
$L82180:

; 1656 : 		}
; 1657 : 
; 1658 : // add to rgb
; 1659 : 
; 1660 : 		else if (r | g | b)

	jmp	SHORT $L82181
$L82177:
	mov	eax, DWORD PTR _r$[ebp]
	or	eax, DWORD PTR _g$[ebp]
	or	eax, DWORD PTR _b$[ebp]
	je	SHORT $L82181

; 1661 : 		{
; 1662 : 			v = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _v$[ebp], ecx

; 1663 : 			for (j = 0 ; j < model->VertNum ; j++, v++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L82183
$L82184:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _v$[ebp], ecx
$L82183:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+34]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	SHORT $L82181

; 1664 : 			{
; 1665 : 				v->r += r;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 1666 : 				v->g += g;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	add	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 1667 : 				v->b += b;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	add	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 1668 : 			}

	jmp	SHORT $L82184
$L82181:

; 1669 : 		}
; 1670 : 	}

	jmp	$L82163
$L82150:

; 1671 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddModelLightSimple@@YAXPAUMODEL@@PAUVectorStruct@@@Z ENDP ; AddModelLightSimple
_TEXT	ENDS
PUBLIC	?AddPermLightInstance@@YAXPAULIGHT@@@Z		; AddPermLightInstance
EXTRN	?InstanceNum@@3JA:DWORD				; InstanceNum
EXTRN	?Instances@@3PAUINSTANCE@@A:BYTE		; Instances
EXTRN	?InstanceModels@@3PAUINSTANCE_MODELS@@A:DWORD	; InstanceModels
; Function compile flags: /Odt /ZI
;	COMDAT ?AddPermLightInstance@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT
tv177 = -124						; size = 4
_savergb$ = -56						; size = 4
_model$ = -52						; size = 4
_dir$ = -48						; size = 12
_pos$ = -36						; size = 12
_vec$ = -24						; size = 12
_inst$ = -12						; size = 4
_j$ = -8						; size = 2
_i$ = -4						; size = 2
_light$ = 8						; size = 4
?AddPermLightInstance@@YAXPAULIGHT@@@Z PROC NEAR	; AddPermLightInstance, COMDAT

; 1678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 1679 : 	short i, j;
; 1680 : 	INSTANCE *inst;
; 1681 : 	VEC vec, pos, dir;
; 1682 : 	MODEL *model;
; 1683 : 	POLY_RGB *savergb;
; 1684 : 
; 1685 : // valid light?
; 1686 : 
; 1687 : 	if (!light->Flag) return;

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	test	ecx, ecx
	jne	SHORT $L82197
	jmp	$L82188
$L82197:

; 1688 : 
; 1689 : // make sure all vars up to date
; 1690 : 
; 1691 : 	ProcessOneLight(light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	call	?ProcessOneLight@@YAXPAULIGHT@@@Z	; ProcessOneLight
	add	esp, 4

; 1692 : 
; 1693 : // loop thru instances
; 1694 : 
; 1695 : 	inst = Instances;

	mov	DWORD PTR _inst$[ebp], OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances

; 1696 : 
; 1697 : 	for (i = 0 ; i < InstanceNum ; i++, inst++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82198
$L82199:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 136				; 00000088H
	mov	DWORD PTR _inst$[ebp], ecx
$L82198:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	$L82188

; 1698 : 	{
; 1699 : 
; 1700 : // skip if 'mirror hide' instance
; 1701 : 
; 1702 : 		if (inst->Flag & INSTANCE_HIDE)

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 2
	je	SHORT $L82201

; 1703 : 			continue;

	jmp	SHORT $L82199
$L82201:

; 1704 : 
; 1705 : // skip if not file lit
; 1706 : 
; 1707 : 		if (inst->Flag & INSTANCE_NO_FILE_LIGHTS)

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 8
	je	SHORT $L82202

; 1708 : 			continue;

	jmp	SHORT $L82199
$L82202:

; 1709 : 
; 1710 : // loop thru LOD's for instance
; 1711 : 
; 1712 : 		for (j = 0 ; j < InstanceModels[inst->Model].Count ; j++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L82203
$L82204:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$L82203:
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _inst$[ebp]
	movzx	edx, BYTE PTR [ecx]
	imul	edx, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	cmp	eax, DWORD PTR [ecx+edx]
	jge	$L82205

; 1713 : 		{
; 1714 : 
; 1715 : // bounding boxes qualify?
; 1716 : 
; 1717 : 			if (inst->Box.Xmin > light->Xmax || inst->Box.Xmax < light->Xmin || inst->Box.Ymin > light->Ymax || inst->Box.Ymax < light->Ymin || inst->Box.Zmin > light->Zmax || inst->Box.Zmax < light->Zmin)

	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+100]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82207
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+104]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82207
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+108]
	fcomp	DWORD PTR [ecx+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82207
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+112]
	fcomp	DWORD PTR [ecx+28]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82207
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+116]
	fcomp	DWORD PTR [ecx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82207
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+120]
	fcomp	DWORD PTR [ecx+36]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82206
$L82207:

; 1718 : 				continue;

	jmp	$L82204
$L82206:

; 1719 : 
; 1720 : // yep, go!
; 1721 : 
; 1722 : 			model = &InstanceModels[inst->Model].Models[j];

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	add	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	movsx	edx, WORD PTR _j$[ebp]
	imul	edx, 60					; 0000003cH
	lea	eax, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _model$[ebp], eax

; 1723 : 			savergb = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _savergb$[ebp], ecx

; 1724 : 			model->PolyRGB = inst->rgb[j];

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+80]
	mov	DWORD PTR [ecx+44], eax

; 1725 : 
; 1726 : 			SubVector((VEC*)&light->x, &inst->WorldPos, &vec);

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _inst$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+32]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _inst$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+36]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _inst$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+40]
	fstp	DWORD PTR _vec$[ebp+8]

; 1727 : 			TransposeRotVector(&inst->WorldMatrix, &vec, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
	add	esp, 12					; 0000000cH

; 1728 : 
; 1729 : 			switch (light->Type)

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	mov	DWORD PTR tv177[ebp], ecx
	cmp	DWORD PTR tv177[ebp], 3
	ja	$L82212
	mov	edx, DWORD PTR tv177[ebp]
	jmp	DWORD PTR $L82680[edx*4]
$L82215:

; 1730 : 			{
; 1731 : 				case LIGHT_OMNI:
; 1732 : 					AddModelLightPermOmni(model, light, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?AddModelLightPermOmni@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightPermOmni
	add	esp, 12					; 0000000cH

; 1733 : 					break;

	jmp	SHORT $L82212
$L82216:

; 1734 : 				case LIGHT_OMNINORMAL:
; 1735 : 					AddModelLightPermOmniNormal(model, light, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?AddModelLightPermOmniNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@@Z ; AddModelLightPermOmniNormal
	add	esp, 12					; 0000000cH

; 1736 : 					break;

	jmp	SHORT $L82212
$L82217:

; 1737 : 				case LIGHT_SPOT:
; 1738 : 					TransposeRotVector(&inst->WorldMatrix, &light->DirMatrix.mv[Z], &dir);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
	add	esp, 12					; 0000000cH

; 1739 : 					AddModelLightPermSpot(model, light, &pos, &dir);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _light$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?AddModelLightPermSpot@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightPermSpot
	add	esp, 16					; 00000010H

; 1740 : 					break;

	jmp	SHORT $L82212
$L82218:

; 1741 : 				case LIGHT_SPOTNORMAL:
; 1742 : 					TransposeRotVector(&inst->WorldMatrix, &light->DirMatrix.mv[Z], &dir);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
	add	esp, 12					; 0000000cH

; 1743 : 					AddModelLightPermSpotNormal(model, light, &pos, &dir);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _light$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?AddModelLightPermSpotNormal@@YAXPAUMODEL@@PAULIGHT@@PAUVectorStruct@@2@Z ; AddModelLightPermSpotNormal
	add	esp, 16					; 00000010H
$L82212:

; 1744 : 					break;
; 1745 : 			}
; 1746 : 			model->PolyRGB = savergb;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR _savergb$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1747 : 		}

	jmp	$L82204
$L82205:

; 1748 : 	}

	jmp	$L82199
$L82188:

; 1749 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L82680:
	DD	$L82215
	DD	$L82216
	DD	$L82217
	DD	$L82218
?AddPermLightInstance@@YAXPAULIGHT@@@Z ENDP		; AddPermLightInstance
_TEXT	ENDS
PUBLIC	?LoadLights@@YAXPAD@Z				; LoadLights
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	_fwrite:NEAR
EXTRN	?CopyMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; CopyMatrix
EXTRN	?EditMode@@3JA:DWORD				; EditMode
EXTRN	?EditScale@@3MA:DWORD				; EditScale
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadLights@@YAXPAD@Z
_TEXT	SEGMENT
_fl$ = -84						; size = 72
_light$ = -12						; size = 4
_fp$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?LoadLights@@YAXPAD@Z PROC NEAR				; LoadLights, COMDAT

; 1756 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 1757 : 	long i;
; 1758 : 	FILE *fp;
; 1759 : 	LIGHT *light;
; 1760 : 	FILELIGHT fl;
; 1761 : 
; 1762 : // open light file
; 1763 : 
; 1764 : 	fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1765 : 
; 1766 : // if not there create empty one
; 1767 : 
; 1768 : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L82227

; 1769 : 	{
; 1770 : 		fp = fopen(file, "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1771 : 		if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L82229
	jmp	$L82221
$L82229:

; 1772 : 		i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1773 : 		fwrite(&i, sizeof(i), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 1774 : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1775 : 		fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1776 : 		if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L82227
	jmp	$L82221
$L82227:

; 1777 : 	}
; 1778 : 
; 1779 : // loop thru all lights
; 1780 : 
; 1781 : 	fread(&i, sizeof(i), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 1782 : 
; 1783 : 	for ( ; i ; i--)

	jmp	SHORT $L82231
$L82232:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82231:
	cmp	DWORD PTR _i$[ebp], 0
	je	$L82233

; 1784 : 	{
; 1785 : 
; 1786 : // alloc light
; 1787 : 
; 1788 : 		light = AllocLight();

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	DWORD PTR _light$[ebp], eax

; 1789 : 		if (!light) break;

	cmp	DWORD PTR _light$[ebp], 0
	jne	SHORT $L82234
	jmp	$L82233
$L82234:

; 1790 : 
; 1791 : // setup from file
; 1792 : 
; 1793 : 		fread(&fl, sizeof(fl), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	72					; 00000048H
	lea	ecx, DWORD PTR _fl$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 1794 : 
; 1795 : 		if (EditMode == EDIT_LIGHTS)

	cmp	DWORD PTR ?EditMode@@3JA, 1		; EditMode
	jne	SHORT $L82235

; 1796 : 		{
; 1797 : 			VecMulScalar((VEC*)&fl.x, EditScale);

	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR ?EditScale@@3MA		; EditScale
	fstp	DWORD PTR _fl$[ebp]
	fld	DWORD PTR _fl$[ebp+4]
	fmul	DWORD PTR ?EditScale@@3MA		; EditScale
	fstp	DWORD PTR _fl$[ebp+4]
	fld	DWORD PTR _fl$[ebp+8]
	fmul	DWORD PTR ?EditScale@@3MA		; EditScale
	fstp	DWORD PTR _fl$[ebp+8]

; 1798 : 			fl.Reach *= EditScale;

	fld	DWORD PTR _fl$[ebp+12]
	fmul	DWORD PTR ?EditScale@@3MA		; EditScale
	fstp	DWORD PTR _fl$[ebp+12]
$L82235:

; 1799 : 		}
; 1800 : 
; 1801 : 		light->Flag = fl.Flag;

	mov	eax, DWORD PTR _light$[ebp]
	mov	cl, BYTE PTR _fl$[ebp+68]
	mov	BYTE PTR [eax+100], cl

; 1802 : 		light->Type = fl.Type;

	mov	eax, DWORD PTR _light$[ebp]
	mov	cl, BYTE PTR _fl$[ebp+69]
	mov	BYTE PTR [eax+101], cl

; 1803 : 		light->Speed = fl.Speed;

	mov	eax, DWORD PTR _light$[ebp]
	mov	cl, BYTE PTR _fl$[ebp+70]
	mov	BYTE PTR [eax+102], cl

; 1804 : 
; 1805 : 		light->x = fl.x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _fl$[ebp]
	mov	DWORD PTR [eax], ecx

; 1806 : 		light->y = fl.y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _fl$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 1807 : 		light->z = fl.z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _fl$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 1808 : 
; 1809 : 		light->Reach = fl.Reach;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _fl$[ebp+12]
	mov	DWORD PTR [eax+12], ecx

; 1810 : 
; 1811 : 		CopyMatrix(&fl.DirMatrix, &light->DirMatrix);

	mov	eax, DWORD PTR _light$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	lea	ecx, DWORD PTR _fl$[ebp+16]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 1812 : 
; 1813 : 		light->Cone = fl.Cone;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _fl$[ebp+52]
	mov	DWORD PTR [eax+80], ecx

; 1814 : 
; 1815 : 		light->r = (long)fl.r;

	fld	DWORD PTR _fl$[ebp+56]
	call	__ftol2
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 1816 : 		light->g = (long)fl.g;

	fld	DWORD PTR _fl$[ebp+60]
	call	__ftol2
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR [ecx+92], eax

; 1817 : 		light->b = (long)fl.b;

	fld	DWORD PTR _fl$[ebp+64]
	call	__ftol2
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR [ecx+96], eax

; 1818 : 
; 1819 : // do perm affect if not light or instance edit mode and not flickering
; 1820 : 
; 1821 : 		if (EditMode != EDIT_LIGHTS && EditMode != EDIT_INSTANCES && !(light->Flag & LIGHT_FLICKER))

	cmp	DWORD PTR ?EditMode@@3JA, 1		; EditMode
	je	SHORT $L82242
	cmp	DWORD PTR ?EditMode@@3JA, 4		; EditMode
	je	SHORT $L82242
	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 16					; 00000010H
	jne	SHORT $L82242

; 1822 : 		{
; 1823 : 
; 1824 : // affect world if LIGHT_FIXED flag set
; 1825 : 
; 1826 : 			if (light->Flag & LIGHT_FIXED)

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 1
	je	SHORT $L82243

; 1827 : 			{
; 1828 : 				AddPermLight(light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	call	?AddPermLight@@YAXPAULIGHT@@@Z		; AddPermLight
	add	esp, 4

; 1829 : 				light->Flag &= ~LIGHT_FIXED;

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _light$[ebp]
	mov	BYTE PTR [edx+100], cl
$L82243:

; 1830 : 			}
; 1831 : 
; 1832 : // always affect instances
; 1833 : 
; 1834 : 			AddPermLightInstance(light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	call	?AddPermLightInstance@@YAXPAULIGHT@@@Z	; AddPermLightInstance
	add	esp, 4

; 1835 : 
; 1836 : // then kill if not affecting moving objects
; 1837 : 
; 1838 : 			if (!(light->Flag & LIGHT_MOVING))

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 2
	jne	SHORT $L82242

; 1839 : 				FreeLight(light);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	call	?FreeLight@@YAXPAULIGHT@@@Z		; FreeLight
	add	esp, 4
$L82242:

; 1840 : 		}
; 1841 : 	}

	jmp	$L82232
$L82233:

; 1842 : 
; 1843 : // close light file
; 1844 : 
; 1845 : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L82221:

; 1846 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadLights@@YAXPAD@Z ENDP				; LoadLights
_TEXT	ENDS
PUBLIC	?SaveLights@@YAXPAD@Z				; SaveLights
PUBLIC	??_C@_03MIGHMCBI@li?9?$AA@			; `string'
PUBLIC	??_C@_0BC@LDPPJMHM@Saved?5Light?5File?3?$AA@	; `string'
EXTRN	_remove:NEAR
EXTRN	_rename:NEAR
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	_memcpy:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp__wsprintfA:NEAR
;	COMDAT ??_C@_03MIGHMCBI@li?9?$AA@
CONST	SEGMENT
??_C@_03MIGHMCBI@li?9?$AA@ DB 'li-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LDPPJMHM@Saved?5Light?5File?3?$AA@
CONST	SEGMENT
??_C@_0BC@LDPPJMHM@Saved?5Light?5File?3?$AA@ DB 'Saved Light File:', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SaveLights@@YAXPAD@Z
_TEXT	SEGMENT
_bak$ = -344						; size = 256
_fl$ = -88						; size = 72
_light$ = -16						; size = 4
_fp$ = -12						; size = 4
_i$ = -8						; size = 4
_num$ = -4						; size = 4
_file$ = 8						; size = 4
?SaveLights@@YAXPAD@Z PROC NEAR				; SaveLights, COMDAT

; 1853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi

; 1854 : 	long num, i;
; 1855 : 	FILE *fp;
; 1856 : 	LIGHT *light;
; 1857 : 	FILELIGHT fl;
; 1858 : 	char bak[256];
; 1859 : 
; 1860 : // backup old file
; 1861 : 
; 1862 : 	memcpy(bak, file, strlen(file) - 3);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, 3
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bak$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1863 : 	wsprintf(bak + strlen(file) - 3, "li-");

	push	OFFSET FLAT:??_C@_03MIGHMCBI@li?9?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _bak$[ebp+eax-3]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 1864 : 	remove(bak);

	lea	eax, DWORD PTR _bak$[ebp]
	push	eax
	call	_remove
	add	esp, 4

; 1865 : 	rename(file, bak);

	lea	eax, DWORD PTR _bak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_rename
	add	esp, 8

; 1866 : 
; 1867 : // open light file
; 1868 : 
; 1869 : 	fp = fopen(file, "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 1870 : 	if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L82255
	jmp	$L82247
$L82255:

; 1871 : 
; 1872 : // count num
; 1873 : 
; 1874 : 	for (i = num = 0 ; i < LIGHT_MAX ; i++) if (Light[i].Flag & LIGHT_FILE) num++;

	mov	DWORD PTR _num$[ebp], 0
	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L82256
$L82257:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82256:
	cmp	DWORD PTR _i$[ebp], 120			; 00000078H
	jge	SHORT $L82258
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	movzx	ecx, BYTE PTR ?Light@@3PAULIGHT@@A[eax+100]
	and	ecx, 4
	je	SHORT $L82259
	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	mov	DWORD PTR _num$[ebp], eax
$L82259:

; 1875 : 
; 1876 : // write num
; 1877 : 
; 1878 : 	fwrite(&num, sizeof(num), 1, fp);

	jmp	SHORT $L82257
$L82258:
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 1879 : 
; 1880 : // write out each file light
; 1881 : 
; 1882 : 	light = Light;

	mov	DWORD PTR _light$[ebp], OFFSET FLAT:?Light@@3PAULIGHT@@A ; Light

; 1883 : 	for (i = 0 ; i < LIGHT_MAX ; i++, light++) if (light->Flag & LIGHT_FILE)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82260
$L82261:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _light$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _light$[ebp], ecx
$L82260:
	cmp	DWORD PTR _i$[ebp], 120			; 00000078H
	jge	$L82262
	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 4
	je	$L82263

; 1884 : 	{
; 1885 : 
; 1886 : // set file light
; 1887 : 
; 1888 : 		fl.Flag = light->Flag & ~LIGHT_OFF;

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, -9					; fffffff7H
	mov	BYTE PTR _fl$[ebp+68], cl

; 1889 : 		fl.Type = light->Type;

	mov	eax, DWORD PTR _light$[ebp]
	mov	cl, BYTE PTR [eax+101]
	mov	BYTE PTR _fl$[ebp+69], cl

; 1890 : 		fl.Speed = light->Speed;

	mov	eax, DWORD PTR _light$[ebp]
	mov	cl, BYTE PTR [eax+102]
	mov	BYTE PTR _fl$[ebp+70], cl

; 1891 : 
; 1892 : 		fl.x = light->x;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fl$[ebp], ecx

; 1893 : 		fl.y = light->y;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _fl$[ebp+4], ecx

; 1894 : 		fl.z = light->z;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _fl$[ebp+8], ecx

; 1895 : 
; 1896 : 		fl.Reach = light->Reach;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _fl$[ebp+12], ecx

; 1897 : 
; 1898 : 		CopyMatrix(&light->DirMatrix, &fl.DirMatrix);

	lea	eax, DWORD PTR _fl$[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 1899 : 
; 1900 : 		fl.Cone = light->Cone;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _fl$[ebp+52], ecx

; 1901 : 
; 1902 : 		fl.r = (float)light->r;

	mov	eax, DWORD PTR _light$[ebp]
	fild	DWORD PTR [eax+88]
	fstp	DWORD PTR _fl$[ebp+56]

; 1903 : 		fl.g = (float)light->g;

	mov	eax, DWORD PTR _light$[ebp]
	fild	DWORD PTR [eax+92]
	fstp	DWORD PTR _fl$[ebp+60]

; 1904 : 		fl.b = (float)light->b;

	mov	eax, DWORD PTR _light$[ebp]
	fild	DWORD PTR [eax+96]
	fstp	DWORD PTR _fl$[ebp+64]

; 1905 : 
; 1906 : // write it
; 1907 : 
; 1908 : 		fwrite(&fl, sizeof(fl), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	72					; 00000048H
	lea	ecx, DWORD PTR _fl$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
$L82263:

; 1909 : 	}
; 1910 : 
; 1911 : // close file
; 1912 : 
; 1913 : 	Box("Saved Light File:", file, MB_OK);

	jmp	$L82261
$L82262:
	push	0
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BC@LDPPJMHM@Saved?5Light?5File?3?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 1914 : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L82247:

; 1915 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SaveLights@@YAXPAD@Z ENDP				; SaveLights
_TEXT	ENDS
PUBLIC	?DrawFileLights@@YAXXZ				; DrawFileLights
EXTRN	?CAM_MainCamera@@3PAUCameraStruct@@A:DWORD	; CAM_MainCamera
EXTRN	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z:NEAR ; DrawAxis
EXTRN	?DrawLine@@YAXPAUVectorStruct@@0JJ@Z:NEAR	; DrawLine
EXTRN	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z:NEAR ; DrawModel
EXTRN	?IdentityMatrix@@3TMatrixUnion@@A:BYTE		; IdentityMatrix
_BSS	SEGMENT
_LightOmniModel DB 03cH DUP (?)
_LightSpotModel DB 03cH DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?DrawFileLights@@YAXXZ
_TEXT	SEGMENT
_model$ = -32						; size = 4
_tempvec$ = -28						; size = 12
_lmat$ = -16						; size = 4
_light$ = -12						; size = 4
_col$ = -8						; size = 4
_i$ = -4						; size = 4
?DrawFileLights@@YAXXZ PROC NEAR			; DrawFileLights, COMDAT

; 1922 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1923 : 	long i, col;
; 1924 : 	LIGHT *light;
; 1925 : 	MAT *lmat;
; 1926 : 	VEC tempvec;
; 1927 : 	MODEL *model;
; 1928 : 
; 1929 : // loop thru all file lights
; 1930 : 
; 1931 : 	light = Light;

	mov	DWORD PTR _light$[ebp], OFFSET FLAT:?Light@@3PAULIGHT@@A ; Light

; 1932 : 	for (i = 0 ; i < LIGHT_MAX ; i++, light++) if (light->Flag & LIGHT_FILE)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82277
$L82278:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _light$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _light$[ebp], ecx
$L82277:
	cmp	DWORD PTR _i$[ebp], 120			; 00000078H
	jge	$L82270
	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 4
	je	$L82280

; 1933 : 	{
; 1934 : 
; 1935 : // draw
; 1936 : 
; 1937 : 		if (light->Type == LIGHT_SPOT || light->Type == LIGHT_SPOTNORMAL)

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L82282
	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	SHORT $L82281
$L82282:

; 1938 : 		{
; 1939 : 			model = &LightSpotModel;

	mov	DWORD PTR _model$[ebp], OFFSET FLAT:_LightSpotModel

; 1940 : 			lmat = &light->DirMatrix;

	mov	eax, DWORD PTR _light$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _lmat$[ebp], eax

; 1941 : 		}
; 1942 : 		else

	jmp	SHORT $L82283
$L82281:

; 1943 : 		{
; 1944 : 			model = &LightOmniModel;

	mov	DWORD PTR _model$[ebp], OFFSET FLAT:_LightOmniModel

; 1945 : 			lmat = &IdentityMatrix;

	mov	DWORD PTR _lmat$[ebp], OFFSET FLAT:?IdentityMatrix@@3TMatrixUnion@@A ; IdentityMatrix
$L82283:

; 1946 : 		}
; 1947 : 
; 1948 : 		DrawModel(model, lmat, (VEC*)&light->x, MODEL_PLAIN);

	push	0
	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lmat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H

; 1949 : 
; 1950 : // draw axis
; 1951 : 
; 1952 : 		if (light == CurrentEditLight)

	mov	eax, DWORD PTR _light$[ebp]
	cmp	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	jne	SHORT $L82285

; 1953 : 		{
; 1954 : 			if (LightAxisType)

	movsx	eax, BYTE PTR _LightAxisType
	test	eax, eax
	je	SHORT $L82286

; 1955 : 				DrawAxis(&IdentityMatrix, (VEC*)&light->x);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	push	OFFSET FLAT:?IdentityMatrix@@3TMatrixUnion@@A ; IdentityMatrix
	call	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ; DrawAxis
	add	esp, 8

; 1956 : 			else

	jmp	SHORT $L82285
$L82286:

; 1957 : 				DrawAxis(&CAM_MainCamera->WMatrix, (VEC*)&light->x);

	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	ecx, 16					; 00000010H
	push	ecx
	call	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ; DrawAxis
	add	esp, 8
$L82285:

; 1958 : 		}
; 1959 : 
; 1960 : // if spot, draw dir
; 1961 : 
; 1962 : 		if (light->Type == LIGHT_SPOT || light->Type == LIGHT_SPOTNORMAL)

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L82291
	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	SHORT $L82280
$L82291:

; 1963 : 		{
; 1964 : 			tempvec.v[X] = light->x + light->DirMatrix.m[LX] * light->Reach;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _light$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR _tempvec$[ebp]

; 1965 : 			tempvec.v[Y] = light->y + light->DirMatrix.m[LY] * light->Reach;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _light$[ebp]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR _tempvec$[ebp+4]

; 1966 : 			tempvec.v[Z] = light->z + light->DirMatrix.m[LZ] * light->Reach;

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _light$[ebp]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR _tempvec$[ebp+8]

; 1967 : 
; 1968 : 			col = (long)(light->r * 65536 + light->g * 256 + light->b);

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _light$[ebp]
	mov	eax, DWORD PTR [edx+92]
	shl	eax, 8
	add	ecx, eax
	mov	edx, DWORD PTR _light$[ebp]
	add	ecx, DWORD PTR [edx+96]
	mov	DWORD PTR _col$[ebp], ecx

; 1969 : 			DrawLine((VEC*)&light->x, &tempvec, col, 0);

	push	0
	mov	eax, DWORD PTR _col$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _light$[ebp]
	push	edx
	call	?DrawLine@@YAXPAUVectorStruct@@0JJ@Z	; DrawLine
	add	esp, 16					; 00000010H
$L82280:

; 1970 : 		}
; 1971 : 	}
; 1972 : }

	jmp	$L82278
$L82270:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawFileLights@@YAXXZ ENDP				; DrawFileLights
_TEXT	ENDS
PUBLIC	?EditFileLights@@YAXXZ				; EditFileLights
PUBLIC	??_C@_03KDBOCEAF@lit?$AA@			; `string'
PUBLIC	__real@43a00000
PUBLIC	__real@43700000
PUBLIC	__real@41c00000
PUBLIC	__real@46000000
PUBLIC	__real@41800000
PUBLIC	__real@44800000
EXTRN	?ViewMatrix@@3TMatrixUnion@@A:BYTE		; ViewMatrix
EXTRN	?ViewTrans@@3UVectorStruct@@A:BYTE		; ViewTrans
EXTRN	?MouseXpos@@3MA:DWORD				; MouseXpos
EXTRN	?MouseYpos@@3MA:DWORD				; MouseYpos
EXTRN	?MouseXrel@@3MA:DWORD				; MouseXrel
EXTRN	?MouseYrel@@3MA:DWORD				; MouseYrel
EXTRN	?CameraEditXrel@@3MA:DWORD			; CameraEditXrel
EXTRN	?CameraEditYrel@@3MA:DWORD			; CameraEditYrel
EXTRN	?CameraEditZrel@@3MA:DWORD			; CameraEditZrel
EXTRN	?MouseLeft@@3DA:BYTE				; MouseLeft
EXTRN	?MouseRight@@3DA:BYTE				; MouseRight
EXTRN	?MouseLastLeft@@3DA:BYTE			; MouseLastLeft
EXTRN	?Keys@@3PADA:BYTE				; Keys
EXTRN	?LastKeys@@3PADA:BYTE				; LastKeys
EXTRN	?GetLevelFilename@@YAPADPADJ@Z:NEAR		; GetLevelFilename
EXTRN	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z:NEAR	; RotMatrixZYX
EXTRN	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z:NEAR ; RotVector
EXTRN	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z:NEAR ; RotTransVector
;	COMDAT ??_C@_03KDBOCEAF@lit?$AA@
CONST	SEGMENT
??_C@_03KDBOCEAF@lit?$AA@ DB 'lit', 00H			; `string'
CONST	ENDS
;	COMDAT __real@43a00000
CONST	SEGMENT
__real@43a00000 DD 043a00000r			; 320
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?EditFileLights@@YAXXZ
_TEXT	SEGMENT
tv524 = -240						; size = 4
tv262 = -240						; size = 4
__mul$82391 = -172					; size = 4
__mul$82389 = -168					; size = 4
_light$ = -164						; size = 4
_mat$ = -160						; size = 36
_l2$ = -124						; size = 12
_u2$ = -112						; size = 12
_r2$ = -100						; size = 12
_l$ = -88						; size = 12
_u$ = -76						; size = 12
_r$ = -64						; size = 12
_vec2$ = -52						; size = 12
_vec$ = -40						; size = 12
_sy$ = -28						; size = 4
_sx$ = -24						; size = 4
_yrad$ = -20						; size = 4
_xrad$ = -16						; size = 4
_z$ = -12						; size = 4
_n$ = -8						; size = 2
_i$ = -4						; size = 2
?EditFileLights@@YAXXZ PROC NEAR			; EditFileLights, COMDAT

; 1979 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi

; 1980 : 	short i, n;
; 1981 : 	float z, xrad, yrad, sx, sy;
; 1982 : 	VEC vec, vec2;
; 1983 : 	VEC r, u, l, r2, u2, l2;
; 1984 : 	MAT mat;
; 1985 : 	LIGHT *light;
; 1986 : 
; 1987 : // quit if not in edit mode
; 1988 : 
; 1989 : 	if (CAM_MainCamera->Type != CAM_EDIT)

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	cmp	DWORD PTR [eax], 5
	je	SHORT $L82314

; 1990 : 	{
; 1991 : 		CurrentEditLight = NULL;

	mov	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, 0 ; CurrentEditLight

; 1992 : 		return;

	jmp	$L82296
$L82314:

; 1993 : 	}
; 1994 : 
; 1995 : // save lights?
; 1996 : 
; 1997 : 	if (Keys[DIK_LCONTROL] && Keys[DIK_F4] && !LastKeys[DIK_F4])

	movsx	eax, BYTE PTR ?Keys@@3PADA+29
	test	eax, eax
	je	SHORT $L82315
	movsx	eax, BYTE PTR ?Keys@@3PADA+62
	test	eax, eax
	je	SHORT $L82315
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+62
	test	eax, eax
	jne	SHORT $L82315

; 1998 : 	{
; 1999 : 		SaveLights(GetLevelFilename("lit", FILENAME_MAKE_BODY | FILENAME_GAME_SETTINGS));

	push	3
	push	OFFSET FLAT:??_C@_03KDBOCEAF@lit?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	?SaveLights@@YAXPAD@Z			; SaveLights
	add	esp, 4
$L82315:

; 2000 : 	}
; 2001 : 
; 2002 : // get a current light?
; 2003 : 
; 2004 : 	if (!CurrentEditLight && Keys[DIK_RETURN] && !LastKeys[DIK_RETURN])

	cmp	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, 0 ; CurrentEditLight
	jne	$L82317
	movsx	eax, BYTE PTR ?Keys@@3PADA+28
	test	eax, eax
	je	$L82317
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+28
	test	eax, eax
	jne	$L82317

; 2005 : 	{
; 2006 : 		n = -1;

	mov	WORD PTR _n$[ebp], -1

; 2007 : 		z = RenderSettings.FarClip;

	mov	eax, DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	mov	DWORD PTR _z$[ebp], eax

; 2008 : 
; 2009 : 		for (i = 0 ; i < LIGHT_MAX ; i++) if (Light[i].Flag & LIGHT_FILE)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L82318
$L82319:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L82318:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 120				; 00000078H
	jge	$L82320
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 104				; 00000068H
	movzx	ecx, BYTE PTR ?Light@@3PAULIGHT@@A[eax+100]
	and	ecx, 4
	je	$L82321

; 2010 : 		{
; 2011 : 			RotTransVector(&ViewMatrix, &ViewTrans, (VEC*)&Light[i].x, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 104				; 00000068H
	add	ecx, OFFSET FLAT:?Light@@3PAULIGHT@@A	; Light
	push	ecx
	push	OFFSET FLAT:?ViewTrans@@3UVectorStruct@@A ; ViewTrans
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 2012 : 
; 2013 : 			if (vec.v[Z] < RenderSettings.NearClip || vec.v[Z] >= RenderSettings.FarClip) continue;

	fld	DWORD PTR _vec$[ebp+8]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82324
	fld	DWORD PTR _vec$[ebp+8]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82323
$L82324:
	jmp	SHORT $L82319
$L82323:

; 2014 : 
; 2015 : 			sx = vec.v[X] * RenderSettings.GeomPers / vec.v[Z] + REAL_SCREEN_XHALF;

	fld	DWORD PTR _vec$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fdiv	DWORD PTR _vec$[ebp+8]
	fadd	DWORD PTR __real@43a00000
	fstp	DWORD PTR _sx$[ebp]

; 2016 : 			sy = vec.v[Y] * RenderSettings.GeomPers / vec.v[Z] + REAL_SCREEN_YHALF;

	fld	DWORD PTR _vec$[ebp+4]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fdiv	DWORD PTR _vec$[ebp+8]
	fadd	DWORD PTR __real@43700000
	fstp	DWORD PTR _sy$[ebp]

; 2017 : 
; 2018 : 			xrad = (24 * RenderSettings.GeomPers) / vec.v[Z];

	fld	DWORD PTR __real@41c00000
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fdiv	DWORD PTR _vec$[ebp+8]
	fstp	DWORD PTR _xrad$[ebp]

; 2019 : 			yrad = (24 * RenderSettings.GeomPers) / vec.v[Z];

	fld	DWORD PTR __real@41c00000
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fdiv	DWORD PTR _vec$[ebp+8]
	fstp	DWORD PTR _yrad$[ebp]

; 2020 : 
; 2021 : 			if (MouseXpos > sx - xrad && MouseXpos < sx + xrad && MouseYpos > sy - yrad && MouseYpos < sy + yrad)

	fld	DWORD PTR _sx$[ebp]
	fsub	DWORD PTR _xrad$[ebp]
	fcomp	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82321
	fld	DWORD PTR _sx$[ebp]
	fadd	DWORD PTR _xrad$[ebp]
	fcomp	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82321
	fld	DWORD PTR _sy$[ebp]
	fsub	DWORD PTR _yrad$[ebp]
	fcomp	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82321
	fld	DWORD PTR _sy$[ebp]
	fadd	DWORD PTR _yrad$[ebp]
	fcomp	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82321

; 2022 : 			{
; 2023 : 				if (vec.v[Z] < z)

	fld	DWORD PTR _vec$[ebp+8]
	fcomp	DWORD PTR _z$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82321

; 2024 : 				{
; 2025 : 					n = i;

	mov	ax, WORD PTR _i$[ebp]
	mov	WORD PTR _n$[ebp], ax

; 2026 : 					z = vec.v[Z];

	mov	eax, DWORD PTR _vec$[ebp+8]
	mov	DWORD PTR _z$[ebp], eax
$L82321:

; 2027 : 				}
; 2028 : 			}
; 2029 : 		}
; 2030 : 		if (n != -1)

	jmp	$L82319
$L82320:
	movsx	eax, WORD PTR _n$[ebp]
	cmp	eax, -1
	je	SHORT $L82317

; 2031 : 		{
; 2032 : 			CurrentEditLight = &Light[n];

	movsx	eax, WORD PTR _n$[ebp]
	imul	eax, 104				; 00000068H
	add	eax, OFFSET FLAT:?Light@@3PAULIGHT@@A	; Light
	mov	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, eax ; CurrentEditLight

; 2033 : 			return;

	jmp	$L82296
$L82317:

; 2034 : 		}
; 2035 : 	}
; 2036 : 
; 2037 : 
; 2038 : // new light?
; 2039 : 
; 2040 : 	if (Keys[DIK_INSERT] && !LastKeys[DIK_INSERT])

	movsx	eax, BYTE PTR ?Keys@@3PADA+210
	test	eax, eax
	je	$L82328
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+210
	test	eax, eax
	jne	$L82328

; 2041 : 	{
; 2042 : 		if ((light = AllocLight()))

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	DWORD PTR _light$[ebp], eax
	cmp	DWORD PTR _light$[ebp], 0
	je	$L82328

; 2043 : 		{
; 2044 : 			vec.v[X] = 0;

	mov	DWORD PTR _vec$[ebp], 0

; 2045 : 			vec.v[Y] = 0;

	mov	DWORD PTR _vec$[ebp+4], 0

; 2046 : 			vec.v[Z] = 256;

	mov	DWORD PTR _vec$[ebp+8], 1132462080	; 43800000H

; 2047 : 			RotVector(&CAM_MainCamera->WMatrix, &vec, &vec2);

	lea	eax, DWORD PTR _vec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2048 : 			light->x = CAM_MainCamera->WPos.v[X] + vec2.v[X];

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _vec2$[ebp]
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _light$[ebp]
	fstp	DWORD PTR [ecx]

; 2049 : 			light->y = CAM_MainCamera->WPos.v[Y] + vec2.v[Y];

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _vec2$[ebp+4]
	fadd	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _light$[ebp]
	fstp	DWORD PTR [ecx+4]

; 2050 : 			light->z = CAM_MainCamera->WPos.v[Z] + vec2.v[Z];

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _vec2$[ebp+8]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _light$[ebp]
	fstp	DWORD PTR [ecx+8]

; 2051 : 
; 2052 : 			light->Reach = 512;

	mov	eax, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax+12], 1140850688		; 44000000H

; 2053 : 
; 2054 : 			RotMatrixZYX(&light->DirMatrix, 0.25f, 0, 0);

	push	0
	push	0
	push	1048576000				; 3e800000H
	mov	eax, DWORD PTR _light$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 2055 : 
; 2056 : 			light->Cone = 90;

	mov	eax, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax+80], 1119092736		; 42b40000H

; 2057 : 
; 2058 : 			light->r = 0;

	mov	eax, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax+88], 0

; 2059 : 			light->g = 0;

	mov	eax, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax+92], 0

; 2060 : 			light->b = 0;

	mov	eax, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax+96], 0

; 2061 : 
; 2062 : 			light->Flag = LIGHT_FILE | LIGHT_FIXED | LIGHT_MOVING;

	mov	eax, DWORD PTR _light$[ebp]
	mov	BYTE PTR [eax+100], 7

; 2063 : 			light->Type = LIGHT_OMNI;

	mov	eax, DWORD PTR _light$[ebp]
	mov	BYTE PTR [eax+101], 0

; 2064 : 			light->Speed = 1;

	mov	eax, DWORD PTR _light$[ebp]
	mov	BYTE PTR [eax+102], 1

; 2065 : 
; 2066 : 			CurrentEditLight = light;

	mov	eax, DWORD PTR _light$[ebp]
	mov	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, eax ; CurrentEditLight
$L82328:

; 2067 : 		}
; 2068 : 	}
; 2069 : 
; 2070 : // quit now if no current light
; 2071 : 
; 2072 : 	if (!CurrentEditLight) return;

	cmp	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, 0 ; CurrentEditLight
	jne	SHORT $L82330
	jmp	$L82296
$L82330:

; 2073 : 
; 2074 : // exit current light edit?
; 2075 : 
; 2076 : 	if (Keys[DIK_RETURN] && !LastKeys[DIK_RETURN])

	movsx	eax, BYTE PTR ?Keys@@3PADA+28
	test	eax, eax
	je	SHORT $L82331
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+28
	test	eax, eax
	jne	SHORT $L82331

; 2077 : 	{
; 2078 : 		CurrentEditLight = NULL;

	mov	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, 0 ; CurrentEditLight

; 2079 : 		return;

	jmp	$L82296
$L82331:

; 2080 : 	}
; 2081 : 
; 2082 : // delete light?
; 2083 : 
; 2084 : 	if (Keys[DIK_DELETE] && !LastKeys[DIK_DELETE])

	movsx	eax, BYTE PTR ?Keys@@3PADA+211
	test	eax, eax
	je	SHORT $L82332
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+211
	test	eax, eax
	jne	SHORT $L82332

; 2085 : 	{
; 2086 : 		FreeLight(CurrentEditLight);

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	push	eax
	call	?FreeLight@@YAXPAULIGHT@@@Z		; FreeLight
	add	esp, 4

; 2087 : 		CurrentEditLight = NULL;

	mov	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, 0 ; CurrentEditLight

; 2088 : 		return;

	jmp	$L82296
$L82332:

; 2089 : 	}
; 2090 : 
; 2091 : // change light type?
; 2092 : 
; 2093 : 	if (Keys[DIK_SPACE] && !LastKeys[DIK_SPACE])

	movsx	eax, BYTE PTR ?Keys@@3PADA+57
	test	eax, eax
	je	SHORT $L82333
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+57
	test	eax, eax
	jne	SHORT $L82333

; 2094 : 	{
; 2095 : 		if (Keys[DIK_LSHIFT])

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L82334

; 2096 : 			CurrentEditLight->Type--;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	cl, BYTE PTR [eax+101]
	sub	cl, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+101], cl

; 2097 : 		else

	jmp	SHORT $L82335
$L82334:

; 2098 : 			CurrentEditLight->Type++;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	cl, BYTE PTR [eax+101]
	add	cl, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+101], cl
$L82335:

; 2099 : 
; 2100 : 		if (CurrentEditLight->Type > 4) CurrentEditLight->Type = 3;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 4
	jle	SHORT $L82336
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [eax+101], 3
$L82336:

; 2101 : 		if (CurrentEditLight->Type == 4) CurrentEditLight->Type = 0;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 4
	jne	SHORT $L82333
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [eax+101], 0
$L82333:

; 2102 : 	}
; 2103 : 
; 2104 : // change light flag?
; 2105 : 
; 2106 : 	if (Keys[DIK_NUMPADENTER] && !LastKeys[DIK_NUMPADENTER])

	movsx	eax, BYTE PTR ?Keys@@3PADA+156
	test	eax, eax
	je	$L82338
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+156
	test	eax, eax
	jne	$L82338

; 2107 : 	{
; 2108 : 		switch (CurrentEditLight->Flag & (LIGHT_FIXED | LIGHT_MOVING))

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 3
	mov	DWORD PTR tv262[ebp], ecx
	cmp	DWORD PTR tv262[ebp], 1
	je	SHORT $L82344
	cmp	DWORD PTR tv262[ebp], 2
	je	SHORT $L82345
	cmp	DWORD PTR tv262[ebp], 3
	je	SHORT $L82343
	jmp	SHORT $L82338
$L82343:

; 2109 : 		{
; 2110 : 			case LIGHT_FIXED | LIGHT_MOVING:
; 2111 : 				CurrentEditLight->Flag &= ~LIGHT_MOVING;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+100], cl

; 2112 : 				break;

	jmp	SHORT $L82338
$L82344:

; 2113 : 			case LIGHT_FIXED:
; 2114 : 				CurrentEditLight->Flag &= ~LIGHT_FIXED;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+100], cl

; 2115 : 				CurrentEditLight->Flag |= LIGHT_MOVING;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+100]
	or	ecx, 2
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+100], cl

; 2116 : 				break;

	jmp	SHORT $L82338
$L82345:

; 2117 : 			case LIGHT_MOVING:
; 2118 : 				CurrentEditLight->Flag |= LIGHT_FIXED;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+100]
	or	ecx, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+100], cl
$L82338:

; 2119 : 				break;
; 2120 : 		}
; 2121 : 	}
; 2122 : 
; 2123 : // change reach?
; 2124 : 
; 2125 : 	if (Keys[DIK_NUMPADPLUS] && CurrentEditLight->Reach < 8192) CurrentEditLight->Reach += 16;

	movsx	eax, BYTE PTR ?Keys@@3PADA+78
	test	eax, eax
	je	SHORT $L82346
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@46000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82346
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR __real@41800000
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+12]
$L82346:

; 2126 : 	if (Keys[DIK_NUMPADMINUS] && CurrentEditLight->Reach > 0) CurrentEditLight->Reach -= 16;

	movsx	eax, BYTE PTR ?Keys@@3PADA+74
	test	eax, eax
	je	SHORT $L82347
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82347
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR __real@41800000
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+12]
$L82347:

; 2127 : 
; 2128 : // change cone?
; 2129 : 
; 2130 : 	if (CurrentEditLight->Type == LIGHT_SPOT || CurrentEditLight->Type == LIGHT_SPOTNORMAL)

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L82349
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	SHORT $L82348
$L82349:

; 2131 : 	{
; 2132 : 		if (Keys[DIK_NUMPADSTAR] && CurrentEditLight->Cone < 180) CurrentEditLight->Cone++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+55
	test	eax, eax
	je	SHORT $L82350
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+80]
	fcomp	DWORD PTR __real@43340000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82350
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+80]
	fadd	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+80]
$L82350:

; 2133 : 		if (Keys[DIK_NUMPADSLASH] && CurrentEditLight->Cone > 1) CurrentEditLight->Cone--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+181
	test	eax, eax
	je	SHORT $L82348
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+80]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82348
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+80]
	fsub	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+80]
$L82348:

; 2134 : 	}
; 2135 : 
; 2136 : // change rgb?
; 2137 : 
; 2138 : 	if (Keys[DIK_LSHIFT]) LastKeys[DIK_NUMPAD4] = LastKeys[DIK_NUMPAD5] = LastKeys[DIK_NUMPAD6] = LastKeys[DIK_NUMPAD7] = LastKeys[DIK_NUMPAD8] = LastKeys[DIK_NUMPAD9] = 0;

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L82352
	mov	BYTE PTR ?LastKeys@@3PADA+73, 0
	mov	al, BYTE PTR ?LastKeys@@3PADA+73
	mov	BYTE PTR ?LastKeys@@3PADA+72, al
	mov	cl, BYTE PTR ?LastKeys@@3PADA+72
	mov	BYTE PTR ?LastKeys@@3PADA+71, cl
	mov	dl, BYTE PTR ?LastKeys@@3PADA+71
	mov	BYTE PTR ?LastKeys@@3PADA+77, dl
	mov	al, BYTE PTR ?LastKeys@@3PADA+77
	mov	BYTE PTR ?LastKeys@@3PADA+76, al
	mov	cl, BYTE PTR ?LastKeys@@3PADA+76
	mov	BYTE PTR ?LastKeys@@3PADA+75, cl
$L82352:

; 2139 : 
; 2140 : 	if (Keys[DIK_NUMPAD4] && !LastKeys[DIK_NUMPAD4] && CurrentEditLight->r > -1024) CurrentEditLight->r--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+75
	test	eax, eax
	je	SHORT $L82353
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+75
	test	eax, eax
	jne	SHORT $L82353
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	cmp	DWORD PTR [eax+88], -1024		; fffffc00H
	jle	SHORT $L82353
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR [eax+88]
	sub	ecx, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	DWORD PTR [edx+88], ecx
$L82353:

; 2141 : 	if (Keys[DIK_NUMPAD7] && !LastKeys[DIK_NUMPAD7] && CurrentEditLight->r < 1024) CurrentEditLight->r++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+71
	test	eax, eax
	je	SHORT $L82354
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+71
	test	eax, eax
	jne	SHORT $L82354
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	cmp	DWORD PTR [eax+88], 1024		; 00000400H
	jge	SHORT $L82354
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR [eax+88]
	add	ecx, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	DWORD PTR [edx+88], ecx
$L82354:

; 2142 : 
; 2143 : 	if (Keys[DIK_NUMPAD5] && !LastKeys[DIK_NUMPAD5] && CurrentEditLight->g > -1024) CurrentEditLight->g--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+76
	test	eax, eax
	je	SHORT $L82355
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+76
	test	eax, eax
	jne	SHORT $L82355
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	cmp	DWORD PTR [eax+92], -1024		; fffffc00H
	jle	SHORT $L82355
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR [eax+92]
	sub	ecx, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	DWORD PTR [edx+92], ecx
$L82355:

; 2144 : 	if (Keys[DIK_NUMPAD8] && !LastKeys[DIK_NUMPAD8] && CurrentEditLight->g < 1024) CurrentEditLight->g++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+72
	test	eax, eax
	je	SHORT $L82356
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+72
	test	eax, eax
	jne	SHORT $L82356
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	cmp	DWORD PTR [eax+92], 1024		; 00000400H
	jge	SHORT $L82356
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR [eax+92]
	add	ecx, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	DWORD PTR [edx+92], ecx
$L82356:

; 2145 : 
; 2146 : 	if (Keys[DIK_NUMPAD6] && !LastKeys[DIK_NUMPAD6] && CurrentEditLight->b > -1024) CurrentEditLight->b--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+77
	test	eax, eax
	je	SHORT $L82357
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+77
	test	eax, eax
	jne	SHORT $L82357
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	cmp	DWORD PTR [eax+96], -1024		; fffffc00H
	jle	SHORT $L82357
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR [eax+96]
	sub	ecx, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	DWORD PTR [edx+96], ecx
$L82357:

; 2147 : 	if (Keys[DIK_NUMPAD9] && !LastKeys[DIK_NUMPAD9] && CurrentEditLight->b < 1024) CurrentEditLight->b++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+73
	test	eax, eax
	je	SHORT $L82358
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+73
	test	eax, eax
	jne	SHORT $L82358
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	cmp	DWORD PTR [eax+96], 1024		; 00000400H
	jge	SHORT $L82358
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR [eax+96]
	add	ecx, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	DWORD PTR [edx+96], ecx
$L82358:

; 2148 : 
; 2149 : // change axis?
; 2150 : 
; 2151 : 	if (Keys[DIK_TAB] && !LastKeys[DIK_TAB])

	movsx	eax, BYTE PTR ?Keys@@3PADA+15
	test	eax, eax
	je	SHORT $L82359
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+15
	test	eax, eax
	jne	SHORT $L82359

; 2152 : 		{
; 2153 : 			if (Keys[DIK_LSHIFT]) LightAxis--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L82360
	mov	al, BYTE PTR _LightAxis
	sub	al, 1
	mov	BYTE PTR _LightAxis, al

; 2154 : 			else LightAxis++;

	jmp	SHORT $L82361
$L82360:
	mov	al, BYTE PTR _LightAxis
	add	al, 1
	mov	BYTE PTR _LightAxis, al
$L82361:

; 2155 : 			if (LightAxis == -1) LightAxis = 5;

	movsx	eax, BYTE PTR _LightAxis
	cmp	eax, -1
	jne	SHORT $L82362
	mov	BYTE PTR _LightAxis, 5
$L82362:

; 2156 : 			if (LightAxis == 6) LightAxis = 0;

	movsx	eax, BYTE PTR _LightAxis
	cmp	eax, 6
	jne	SHORT $L82359
	mov	BYTE PTR _LightAxis, 0
$L82359:

; 2157 : 		}
; 2158 : 
; 2159 : // change axis type?
; 2160 : 
; 2161 : 	if (Keys[DIK_LALT] && !LastKeys[DIK_LALT])

	movsx	eax, BYTE PTR ?Keys@@3PADA+56
	test	eax, eax
	je	SHORT $L82364
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+56
	test	eax, eax
	jne	SHORT $L82364

; 2162 : 		LightAxisType ^= 1;

	movsx	eax, BYTE PTR _LightAxisType
	xor	eax, 1
	mov	BYTE PTR _LightAxisType, al
$L82364:

; 2163 : 
; 2164 : // toggle off / on
; 2165 : 
; 2166 : 	if (Keys[DIK_O] && !LastKeys[DIK_O])

	movsx	eax, BYTE PTR ?Keys@@3PADA+24
	test	eax, eax
	je	SHORT $L82365
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+24
	test	eax, eax
	jne	SHORT $L82365

; 2167 : 		CurrentEditLight->Flag ^= LIGHT_OFF;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+100]
	xor	ecx, 8
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+100], cl
$L82365:

; 2168 : 
; 2169 : // toggle flicker off / on
; 2170 : 
; 2171 : 	if (Keys[DIK_F] && !LastKeys[DIK_F])

	movsx	eax, BYTE PTR ?Keys@@3PADA+33
	test	eax, eax
	je	SHORT $L82366
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+33
	test	eax, eax
	jne	SHORT $L82366

; 2172 : 		CurrentEditLight->Flag ^= LIGHT_FLICKER;

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+100]
	xor	ecx, 16					; 00000010H
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+100], cl
$L82366:

; 2173 : 
; 2174 : // change flicker speed
; 2175 : 
; 2176 : 	if (Keys[DIK_EQUALS] && CurrentEditLight->Speed < 255) CurrentEditLight->Speed++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+13
	test	eax, eax
	je	SHORT $L82367
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+102]
	cmp	ecx, 255				; 000000ffH
	jge	SHORT $L82367
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	cl, BYTE PTR [eax+102]
	add	cl, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+102], cl
$L82367:

; 2177 : 	if (Keys[DIK_MINUS] && CurrentEditLight->Speed > 1) CurrentEditLight->Speed--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+12
	test	eax, eax
	je	SHORT $L82368
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+102]
	cmp	ecx, 1
	jle	SHORT $L82368
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	cl, BYTE PTR [eax+102]
	sub	cl, 1
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	BYTE PTR [edx+102], cl
$L82368:

; 2178 : 
; 2179 : // copy light?
; 2180 : 
; 2181 : 	if (MouseLeft && !MouseLastLeft && Keys[DIK_LSHIFT])

	movsx	eax, BYTE PTR ?MouseLeft@@3DA		; MouseLeft
	test	eax, eax
	je	SHORT $L82369
	movsx	eax, BYTE PTR ?MouseLastLeft@@3DA	; MouseLastLeft
	test	eax, eax
	jne	SHORT $L82369
	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L82369

; 2182 : 	{
; 2183 : 		if ((light = AllocLight()))

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	DWORD PTR _light$[ebp], eax
	cmp	DWORD PTR _light$[ebp], 0
	je	SHORT $L82369

; 2184 : 		{
; 2185 : 			memcpy(light, CurrentEditLight, sizeof(LIGHT));

	push	104					; 00000068H
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2186 : 			CurrentEditLight = light;

	mov	eax, DWORD PTR _light$[ebp]
	mov	DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A, eax ; CurrentEditLight

; 2187 : 			return;

	jmp	$L82296
$L82369:

; 2188 : 		}
; 2189 : 	}
; 2190 : 
; 2191 : // move light?
; 2192 : 
; 2193 : 	if (MouseLeft)

	movsx	eax, BYTE PTR ?MouseLeft@@3DA		; MouseLeft
	test	eax, eax
	je	$L82372

; 2194 : 	{
; 2195 : 		RotTransVector(&ViewMatrix, &ViewTrans, (VEC*)&CurrentEditLight->x, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	push	ecx
	push	OFFSET FLAT:?ViewTrans@@3UVectorStruct@@A ; ViewTrans
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 2196 : 
; 2197 : 		switch (LightAxis)

	movsx	eax, BYTE PTR _LightAxis
	mov	DWORD PTR tv524[ebp], eax
	cmp	DWORD PTR tv524[ebp], 5
	ja	$L82375
	mov	ecx, DWORD PTR tv524[ebp]
	jmp	DWORD PTR $L82701[ecx*4]
$L82378:

; 2198 : 		{
; 2199 : 			case LIGHT_AXIS_XY:
; 2200 : 				vec.v[X] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditXrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditXrel@@3MA		; CameraEditXrel
	fstp	DWORD PTR _vec$[ebp]

; 2201 : 				vec.v[Y] = MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditYrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditYrel@@3MA		; CameraEditYrel
	fstp	DWORD PTR _vec$[ebp+4]

; 2202 : 				vec.v[Z] = CameraEditZrel;

	mov	eax, DWORD PTR ?CameraEditZrel@@3MA
	mov	DWORD PTR _vec$[ebp+8], eax

; 2203 : 				break;

	jmp	$L82375
$L82379:

; 2204 : 			case LIGHT_AXIS_XZ:
; 2205 : 				vec.v[X] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditXrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditXrel@@3MA		; CameraEditXrel
	fstp	DWORD PTR _vec$[ebp]

; 2206 : 				vec.v[Y] = CameraEditYrel;

	mov	eax, DWORD PTR ?CameraEditYrel@@3MA
	mov	DWORD PTR _vec$[ebp+4], eax

; 2207 : 				vec.v[Z] = -MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditZrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fchs
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditZrel@@3MA		; CameraEditZrel
	fstp	DWORD PTR _vec$[ebp+8]

; 2208 : 				break;

	jmp	$L82375
$L82380:

; 2209 : 			case LIGHT_AXIS_ZY:
; 2210 : 				vec.v[X] = CameraEditXrel;

	mov	eax, DWORD PTR ?CameraEditXrel@@3MA
	mov	DWORD PTR _vec$[ebp], eax

; 2211 : 				vec.v[Y] = MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditYrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditYrel@@3MA		; CameraEditYrel
	fstp	DWORD PTR _vec$[ebp+4]

; 2212 : 				vec.v[Z] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditZrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditZrel@@3MA		; CameraEditZrel
	fstp	DWORD PTR _vec$[ebp+8]

; 2213 : 				break;

	jmp	SHORT $L82375
$L82381:

; 2214 : 			case LIGHT_AXIS_X:
; 2215 : 				vec.v[X] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditXrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditXrel@@3MA		; CameraEditXrel
	fstp	DWORD PTR _vec$[ebp]

; 2216 : 				vec.v[Y] = CameraEditYrel;

	mov	eax, DWORD PTR ?CameraEditYrel@@3MA
	mov	DWORD PTR _vec$[ebp+4], eax

; 2217 : 				vec.v[Z] = CameraEditZrel;

	mov	eax, DWORD PTR ?CameraEditZrel@@3MA
	mov	DWORD PTR _vec$[ebp+8], eax

; 2218 : 				break;

	jmp	SHORT $L82375
$L82382:

; 2219 : 			case LIGHT_AXIS_Y:
; 2220 : 				vec.v[X] = CameraEditXrel;

	mov	eax, DWORD PTR ?CameraEditXrel@@3MA
	mov	DWORD PTR _vec$[ebp], eax

; 2221 : 				vec.v[Y] = MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditYrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditYrel@@3MA		; CameraEditYrel
	fstp	DWORD PTR _vec$[ebp+4]

; 2222 : 				vec.v[Z] = CameraEditZrel;

	mov	eax, DWORD PTR ?CameraEditZrel@@3MA
	mov	DWORD PTR _vec$[ebp+8], eax

; 2223 : 				break;

	jmp	SHORT $L82375
$L82383:

; 2224 : 			case LIGHT_AXIS_Z:
; 2225 : 				vec.v[X] = CameraEditXrel;

	mov	eax, DWORD PTR ?CameraEditXrel@@3MA
	mov	DWORD PTR _vec$[ebp], eax

; 2226 : 				vec.v[Y] = CameraEditYrel;

	mov	eax, DWORD PTR ?CameraEditYrel@@3MA
	mov	DWORD PTR _vec$[ebp+4], eax

; 2227 : 				vec.v[Z] = -MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditZrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fchs
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditZrel@@3MA		; CameraEditZrel
	fstp	DWORD PTR _vec$[ebp+8]
$L82375:

; 2228 : 				break;
; 2229 : 		}
; 2230 : 
; 2231 : 		if (LightAxisType == 1)

	movsx	eax, BYTE PTR _LightAxisType
	cmp	eax, 1
	jne	SHORT $L82384

; 2232 : 		{
; 2233 : 			SetVector(&vec2, vec.v[X], vec.v[Y], vec.v[Z]);

	mov	eax, DWORD PTR _vec$[ebp]
	mov	DWORD PTR _vec2$[ebp], eax
	mov	eax, DWORD PTR _vec$[ebp+4]
	mov	DWORD PTR _vec2$[ebp+4], eax
	mov	eax, DWORD PTR _vec$[ebp+8]
	mov	DWORD PTR _vec2$[ebp+8], eax

; 2234 : 		}
; 2235 : 		else

	jmp	SHORT $L82385
$L82384:

; 2236 : 		{
; 2237 : 			RotVector(&CAM_MainCamera->WMatrix, &vec, &vec2);

	lea	eax, DWORD PTR _vec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH
$L82385:

; 2238 : 		}
; 2239 : 
; 2240 : 		CurrentEditLight->x += vec2.v[X];

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR _vec2$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx]

; 2241 : 		CurrentEditLight->y += vec2.v[Y];

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR _vec2$[ebp+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+4]

; 2242 : 		CurrentEditLight->z += vec2.v[Z];

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR _vec2$[ebp+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+8]
$L82372:

; 2243 : 	}
; 2244 : 
; 2245 : // rotate light?
; 2246 : 
; 2247 : 	if (MouseRight) if (CurrentEditLight->Type == LIGHT_SPOT || CurrentEditLight->Type == LIGHT_SPOTNORMAL)

	movsx	eax, BYTE PTR ?MouseRight@@3DA		; MouseRight
	test	eax, eax
	je	$L82296
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L82388
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	$L82296
$L82388:

; 2248 : 	{
; 2249 : 		RotVector(&ViewMatrix, &CurrentEditLight->DirMatrix.mv[X], &r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	add	ecx, 44					; 0000002cH
	push	ecx
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2250 : 		RotVector(&ViewMatrix, &CurrentEditLight->DirMatrix.mv[Y], &u);

	lea	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	add	ecx, 56					; 00000038H
	push	ecx
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2251 : 		RotVector(&ViewMatrix, &CurrentEditLight->DirMatrix.mv[Z], &l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	add	ecx, 68					; 00000044H
	push	ecx
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2252 : 
; 2253 : 		RotMatrixZYX(&mat, MouseYrel / 1024, -MouseXrel / 1024, 0);

	push	0
	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fchs
	fdiv	DWORD PTR __real@44800000
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fdiv	DWORD PTR __real@44800000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 2254 : 
; 2255 : 		RotVector(&mat, &r, &r2);

	lea	eax, DWORD PTR _r2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2256 : 		RotVector(&mat, &u, &u2);

	lea	eax, DWORD PTR _u2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _u$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2257 : 		RotVector(&mat, &l, &l2);

	lea	eax, DWORD PTR _l2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2258 : 
; 2259 : 		RotVector(&CAM_MainCamera->WMatrix, &r2, &CurrentEditLight->DirMatrix.mv[X]);

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	add	eax, 44					; 0000002cH
	push	eax
	lea	ecx, DWORD PTR _r2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2260 : 		RotVector(&CAM_MainCamera->WMatrix, &u2, &CurrentEditLight->DirMatrix.mv[Y]);

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	add	eax, 56					; 00000038H
	push	eax
	lea	ecx, DWORD PTR _u2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2261 : 		RotVector(&CAM_MainCamera->WMatrix, &l2, &CurrentEditLight->DirMatrix.mv[Z]);

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _l2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 2262 : 
; 2263 : 		NormalizeMatrix(&CurrentEditLight->DirMatrix);

	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+60]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR [edx+64]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82389[ebp]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR __mul$82389[ebp]
	fmul	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR __mul$82389[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR __mul$82389[ebp]
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [ecx+76]
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82391[ebp]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR __mul$82391[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR __mul$82391[ebp]
	fmul	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR __mul$82391[ebp]
	fmul	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+76]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+76]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+72]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+56]
	fmul	DWORD PTR [eax+76]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+68]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+76]
	fmul	DWORD PTR [eax+48]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [eax+52]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	mov	eax, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+44]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentEditLight@@3PAULIGHT@@A ; CurrentEditLight
	fstp	DWORD PTR [ecx+64]
$L82296:

; 2264 : 	}
; 2265 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L82701:
	DD	$L82378
	DD	$L82379
	DD	$L82380
	DD	$L82381
	DD	$L82382
	DD	$L82383
?EditFileLights@@YAXXZ ENDP				; EditFileLights
_TEXT	ENDS
PUBLIC	?DisplayLightInfo@@YAXPAULIGHT@@@Z		; DisplayLightInfo
PUBLIC	??_C@_0BA@OGNLDANN@RGB?5?$CFld?5?$CFld?5?$CFld?$AA@ ; `string'
PUBLIC	??_C@_08EIJPKPMB@Reach?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0L@HMGNNLP@Flicker?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BB@LDIGKJBL@Flicker?5Speed?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_07LMDIMKBF@Cone?5?$CFd?$AA@		; `string'
EXTRN	?DumpText@@YAXFFFFJPAD@Z:NEAR			; DumpText
;	COMDAT ??_C@_0BA@OGNLDANN@RGB?5?$CFld?5?$CFld?5?$CFld?$AA@
CONST	SEGMENT
??_C@_0BA@OGNLDANN@RGB?5?$CFld?5?$CFld?5?$CFld?$AA@ DB 'RGB %ld %ld %ld', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EIJPKPMB@Reach?5?$CFd?$AA@
CONST	SEGMENT
??_C@_08EIJPKPMB@Reach?5?$CFd?$AA@ DB 'Reach %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HMGNNLP@Flicker?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@HMGNNLP@Flicker?5?$CFs?$AA@ DB 'Flicker %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LDIGKJBL@Flicker?5Speed?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LDIGKJBL@Flicker?5Speed?5?$CFd?$AA@ DB 'Flicker Speed %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@ DB 'Axis %s - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LMDIMKBF@Cone?5?$CFd?$AA@
CONST	SEGMENT
??_C@_07LMDIMKBF@Cone?5?$CFd?$AA@ DB 'Cone %d', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DisplayLightInfo@@YAXPAULIGHT@@@Z
_TEXT	SEGMENT
_buf$ = -128						; size = 128
_light$ = 8						; size = 4
?DisplayLightInfo@@YAXPAULIGHT@@@Z PROC NEAR		; DisplayLightInfo, COMDAT

; 2272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 2273 : 	char buf[128];
; 2274 : 
; 2275 : // type
; 2276 : 
; 2277 : 	DumpText(450, 0, 8, 16, 0xffff00, LightNames[light->Type]);

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	mov	edx, DWORD PTR _LightNames[ecx*4]
	push	edx
	push	16776960				; 00ffff00H
	push	16					; 00000010H
	push	8
	push	0
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 2278 : 
; 2279 : // flag
; 2280 : 
; 2281 : 	DumpText(450, 24, 8, 16, 0x00ffff, LightFlags[(light->Flag & (LIGHT_FIXED | LIGHT_MOVING)) - 1]);

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 3
	mov	edx, DWORD PTR _LightFlags[ecx*4-4]
	push	edx
	push	65535					; 0000ffffH
	push	16					; 00000010H
	push	8
	push	24					; 00000018H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 2282 : 
; 2283 : // rgb
; 2284 : 
; 2285 : 	wsprintf(buf, "RGB %ld %ld %ld", light->r, light->g, light->b);

	mov	eax, DWORD PTR _light$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	mov	edx, DWORD PTR _light$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@OGNLDANN@RGB?5?$CFld?5?$CFld?5?$CFld?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 2286 : 	DumpText(450, 48, 8, 16, 0x00ff00, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	65280					; 0000ff00H
	push	16					; 00000010H
	push	8
	push	48					; 00000030H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 2287 : 
; 2288 : // reach
; 2289 : 
; 2290 : 	wsprintf(buf, "Reach %d", (short)light->Reach);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+12]
	call	__ftol2
	movsx	ecx, ax
	push	ecx
	push	OFFSET FLAT:??_C@_08EIJPKPMB@Reach?5?$CFd?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 2291 : 	DumpText(450, 72, 8, 16, 0xff0000, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	push	72					; 00000048H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 2292 : 
; 2293 : // flicker
; 2294 : 
; 2295 : 	wsprintf(buf, "Flicker %s", LightFlickerNames[(light->Flag & LIGHT_FLICKER) != 0]);

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+100]
	and	ecx, 16					; 00000010H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	edx, DWORD PTR _LightFlickerNames[ecx*4]
	push	edx
	push	OFFSET FLAT:??_C@_0L@HMGNNLP@Flicker?5?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 2296 : 	DumpText(450, 96, 8, 16, 0xff00ff, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16711935				; 00ff00ffH
	push	16					; 00000010H
	push	8
	push	96					; 00000060H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 2297 : 
; 2298 : // flicker speed
; 2299 : 
; 2300 : 	wsprintf(buf, "Flicker Speed %d", light->Speed);

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+102]
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@LDIGKJBL@Flicker?5Speed?5?$CFd?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 2301 : 	DumpText(450, 120, 8, 16, 0x0000ff, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	255					; 000000ffH
	push	16					; 00000010H
	push	8
	push	120					; 00000078H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 2302 : 
; 2303 : // axis
; 2304 : 
; 2305 : 	wsprintf(buf, "Axis %s - %s", LightAxisNames[LightAxis], LightAxisTypeNames[LightAxisType]);

	movsx	eax, BYTE PTR _LightAxisType
	mov	ecx, DWORD PTR _LightAxisTypeNames[eax*4]
	push	ecx
	movsx	edx, BYTE PTR _LightAxis
	mov	eax, DWORD PTR _LightAxisNames[edx*4]
	push	eax
	push	OFFSET FLAT:??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 2306 : 	DumpText(450, 144, 8, 16, 0xffff00, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16776960				; 00ffff00H
	push	16					; 00000010H
	push	8
	push	144					; 00000090H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 2307 : 
; 2308 : // cone
; 2309 : 
; 2310 : 	if (light->Type == LIGHT_SPOT || light->Type == LIGHT_SPOTNORMAL)

	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 2
	je	SHORT $L82404
	mov	eax, DWORD PTR _light$[ebp]
	movzx	ecx, BYTE PTR [eax+101]
	cmp	ecx, 3
	jne	SHORT $L82395
$L82404:

; 2311 : 	{
; 2312 : 		wsprintf(buf, "Cone %d", (short)light->Cone);

	mov	eax, DWORD PTR _light$[ebp]
	fld	DWORD PTR [eax+80]
	call	__ftol2
	movsx	ecx, ax
	push	ecx
	push	OFFSET FLAT:??_C@_07LMDIMKBF@Cone?5?$CFd?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 2313 : 		DumpText(450, 168, 8, 16, 0x00ffff, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	65535					; 0000ffffH
	push	16					; 00000010H
	push	8
	push	168					; 000000a8H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H
$L82395:

; 2314 : 	}
; 2315 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayLightInfo@@YAXPAULIGHT@@@Z ENDP			; DisplayLightInfo
_TEXT	ENDS
PUBLIC	?LoadEditLightModels@@YAXXZ			; LoadEditLightModels
PUBLIC	??_C@_0M@BNNKLDPF@edit?2omni?4m?$AA@		; `string'
PUBLIC	??_C@_0M@JNPPPCPI@edit?2spot?4m?$AA@		; `string'
EXTRN	?LoadModel@@YAJPADPAUMODEL@@DDDJ@Z:NEAR		; LoadModel
;	COMDAT ??_C@_0M@BNNKLDPF@edit?2omni?4m?$AA@
CONST	SEGMENT
??_C@_0M@BNNKLDPF@edit?2omni?4m?$AA@ DB 'edit\omni.m', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JNPPPCPI@edit?2spot?4m?$AA@
CONST	SEGMENT
??_C@_0M@JNPPPCPI@edit?2spot?4m?$AA@ DB 'edit\spot.m', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadEditLightModels@@YAXXZ
_TEXT	SEGMENT
?LoadEditLightModels@@YAXXZ PROC NEAR			; LoadEditLightModels, COMDAT

; 2322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2323 : 	LoadModel("edit\\omni.m", &LightOmniModel, -1, 1, LOADMODEL_FORCE_TPAGE, 100);

	push	100					; 00000064H
	push	1
	push	1
	push	-1
	push	OFFSET FLAT:_LightOmniModel
	push	OFFSET FLAT:??_C@_0M@BNNKLDPF@edit?2omni?4m?$AA@
	call	?LoadModel@@YAJPADPAUMODEL@@DDDJ@Z	; LoadModel
	add	esp, 24					; 00000018H

; 2324 : 	LoadModel("edit\\spot.m", &LightSpotModel, -1, 1, LOADMODEL_FORCE_TPAGE, 100);

	push	100					; 00000064H
	push	1
	push	1
	push	-1
	push	OFFSET FLAT:_LightSpotModel
	push	OFFSET FLAT:??_C@_0M@JNPPPCPI@edit?2spot?4m?$AA@
	call	?LoadModel@@YAJPADPAUMODEL@@DDDJ@Z	; LoadModel
	add	esp, 24					; 00000018H

; 2325 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadEditLightModels@@YAXXZ ENDP			; LoadEditLightModels
_TEXT	ENDS
PUBLIC	?FreeEditLightModels@@YAXXZ			; FreeEditLightModels
EXTRN	?FreeModel@@YAXPAUMODEL@@J@Z:NEAR		; FreeModel
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeEditLightModels@@YAXXZ
_TEXT	SEGMENT
?FreeEditLightModels@@YAXXZ PROC NEAR			; FreeEditLightModels, COMDAT

; 2332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2333 : 	FreeModel(&LightOmniModel, 1);

	push	1
	push	OFFSET FLAT:_LightOmniModel
	call	?FreeModel@@YAXPAUMODEL@@J@Z		; FreeModel
	add	esp, 8

; 2334 : 	FreeModel(&LightSpotModel, 1);

	push	1
	push	OFFSET FLAT:_LightSpotModel
	call	?FreeModel@@YAXPAUMODEL@@J@Z		; FreeModel
	add	esp, 8

; 2335 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeEditLightModels@@YAXXZ ENDP			; FreeEditLightModels
_TEXT	ENDS
END
