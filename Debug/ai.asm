; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\ai.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_ProcessAllAIs@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_CarAiHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_RemoteAiHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_GhostCarAiHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCarFinishDist@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCarSfx@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCarMisc@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_BarrelHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_PlanetHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_PlaneHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_CopterHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TurnCopter@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlyCopter@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopterWait@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewCopterDest@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_DragonHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_WaterHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_BoatHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_RadarHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_BalloonHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_HorseRipper@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_TrainHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_StrobeHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SparkGenHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_SpacemanHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_PickupHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_DissolveModelHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_LaserHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_SplashHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AI_SpeedupAIHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeedupImpulse@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?AI_Testing@@3JA				; AI_Testing
PUBLIC	?SfxScrapeList@@3PAJA				; SfxScrapeList
_BSS	SEGMENT
?AI_Testing@@3JA DD 01H DUP (?)				; AI_Testing
_BSS	ENDS
_DATA	SEGMENT
_PlanePropOff DD 000000000r			; 0
	DD	0c2f00000r			; -120
	DD	042dc0000r			; 110
_CopterBlade1Off DD 000000000r			; 0
	DD	0c3aa0000r			; -340
	DD	042840000r			; 66
_CopterBlade2Off DD 041e00000r			; 28
	DD	0c37c0000r			; -252
	DD	0c3480000r			; -200
_TrainSteamOffset DD 000000000r			; 0
	DD	0c4098000r			; -550
	DD	0c3440000r			; -196
_TrainSteamDir DD 000000000r			; 0
	DD	0c3af0000r			; -350
	DD	000000000r			; 0
_BoatSteamOffset DD 000000000r			; 0
	DD	0c3af0000r			; -350
	DD	000000000r			; 0
_BoatSteamVel DD 000000000r			; 0
	DD	0c3fa0000r			; -500
	DD	0c2c80000r			; -100
_TrainWheelOffsets DD 042c40000r		; 98
	DD	0c3080000r			; -136
	DD	043a50000r			; 330
	DD	0c2c40000r			; -98
	DD	0c3080000r			; -136
	DD	043a50000r			; 330
	DD	042c40000r			; 98
	DD	0c2b80000r			; -92
	DD	0c34c0000r			; -204
	DD	0c2c40000r			; -98
	DD	0c2b80000r			; -92
	DD	0c34c0000r			; -204
	ORG $+4
?SfxScrapeList@@3PAJA DD 02H				; SfxScrapeList
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
?pickup@?1??UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z@4JA DD 0ffffffffH ; `UpdatePlayerPickup'::`2'::pickup
_DATA	ENDS
PUBLIC	?AI_ProcessAllAIs@@YAXXZ			; AI_ProcessAllAIs
EXTRN	?OBJ_ObjectHead@@3PAUobject_def@@A:DWORD	; OBJ_ObjectHead
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\ai.cpp
;	COMDAT ?AI_ProcessAllAIs@@YAXXZ
_TEXT	SEGMENT
_next$ = -8						; size = 4
_obj$ = -4						; size = 4
?AI_ProcessAllAIs@@YAXXZ PROC NEAR			; AI_ProcessAllAIs, COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 132  : 	OBJECT	*obj, *next;
; 133  : 
; 134  : 	for (obj = OBJ_ObjectHead ; obj ; )

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj$[ebp], eax
$L82428:
	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $L82424

; 135  : 	{
; 136  : 		next = obj->next;	// get next now in case object frees itself!

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _next$[ebp], ecx

; 137  : 		if (obj->aihandler)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+696], 0
	je	SHORT $L82430

; 138  : 		{
; 139  : 			obj->aihandler(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	call	DWORD PTR [ecx+696]
	add	esp, 4
$L82430:

; 140  : 		}
; 141  : 		obj = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _obj$[ebp], eax

; 142  : 	}	

	jmp	SHORT $L82428
$L82424:

; 143  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_ProcessAllAIs@@YAXXZ ENDP				; AI_ProcessAllAIs
_TEXT	ENDS
PUBLIC	?AI_CarAiHandler@@YAXPAUobject_def@@@Z		; AI_CarAiHandler
EXTRN	?CAI_CarHelper@@YAXPAUPlayerStruct@@@Z:NEAR	; CAI_CarHelper
EXTRN	?CarAccTimings@@YAXPAUCarStruct@@@Z:NEAR	; CarAccTimings
EXTRN	__fltused:NEAR
EXTRN	?AIN_GetForwardNode@@YAPAU_AINODE@@PAUPlayerStruct@@MPAM@Z:NEAR ; AIN_GetForwardNode
; Function compile flags: /Odt /ZI
;	COMDAT ?AI_CarAiHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?AI_CarAiHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_CarAiHandler, COMDAT

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 154  : 	obj->player->LastValidRailCamNode = obj->player->ValidRailCamNode;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	ecx, DWORD PTR [ecx+10312]
	mov	DWORD PTR [eax+10316], ecx

; 155  : 	obj->player->ValidRailCamNode = -1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+10312], -1

; 156  : #ifndef _PSX
; 157  : 	CAI_CarHelper(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?CAI_CarHelper@@YAXPAUPlayerStruct@@@Z	; CAI_CarHelper
	add	esp, 4

; 158  : 	UpdateCarFinishDist(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?UpdateCarFinishDist@@YAXPAUPlayerStruct@@@Z ; UpdateCarFinishDist
	add	esp, 4

; 159  : #endif
; 160  : #ifdef _PC
; 161  : 	CarAccTimings(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?CarAccTimings@@YAXPAUCarStruct@@@Z	; CarAccTimings
	add	esp, 4

; 162  : 	UpdateCarSfx(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?UpdateCarSfx@@YAXPAUCarStruct@@@Z	; UpdateCarSfx
	add	esp, 4

; 163  : 	UpdatePlayerPickup(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z ; UpdatePlayerPickup
	add	esp, 4

; 164  : #endif
; 165  : 	UpdateCarMisc(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?UpdateCarMisc@@YAXPAUCarStruct@@@Z	; UpdateCarMisc
	add	esp, 4

; 166  : 
; 167  : #ifndef _PSX
; 168  : 	if (AI_Testing)

	cmp	DWORD PTR ?AI_Testing@@3JA, 0		; AI_Testing
	je	SHORT $L82433

; 169  : 	{
; 170  : 		obj->player->CarAI.CurNode = AIN_GetForwardNode(obj->player, 200, (REAL *)&obj->player->CarAI.NodeDist);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 10144				; 000027a0H
	push	ecx
	push	1128792064				; 43480000H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	push	eax
	call	?AIN_GetForwardNode@@YAPAU_AINODE@@PAUPlayerStruct@@MPAM@Z ; AIN_GetForwardNode
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	mov	DWORD PTR [edx+10136], eax
$L82433:

; 171  : 	}
; 172  : #endif
; 173  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_CarAiHandler@@YAXPAUobject_def@@@Z ENDP		; AI_CarAiHandler
_TEXT	ENDS
PUBLIC	?AI_RemoteAiHandler@@YAXPAUobject_def@@@Z	; AI_RemoteAiHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?AI_RemoteAiHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?AI_RemoteAiHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_RemoteAiHandler, COMDAT

; 176  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 177  : 	obj->player->LastValidRailCamNode = obj->player->ValidRailCamNode;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	ecx, DWORD PTR [ecx+10312]
	mov	DWORD PTR [eax+10316], ecx

; 178  : 	obj->player->ValidRailCamNode = -1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+10312], -1

; 179  : #ifdef _PC
; 180  : //	UpdateRemotePlayer(obj->player);
; 181  : 	UpdateCarFinishDist(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?UpdateCarFinishDist@@YAXPAUPlayerStruct@@@Z ; UpdateCarFinishDist
	add	esp, 4

; 182  : 	UpdateCarSfx(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?UpdateCarSfx@@YAXPAUCarStruct@@@Z	; UpdateCarSfx
	add	esp, 4

; 183  : 	UpdateCarMisc(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?UpdateCarMisc@@YAXPAUCarStruct@@@Z	; UpdateCarMisc
	add	esp, 4

; 184  : 	UpdatePlayerPickup(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z ; UpdatePlayerPickup
	add	esp, 4

; 185  : #endif
; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_RemoteAiHandler@@YAXPAUobject_def@@@Z ENDP		; AI_RemoteAiHandler
_TEXT	ENDS
PUBLIC	?AI_GhostCarAiHandler@@YAXPAUobject_def@@@Z	; AI_GhostCarAiHandler
EXTRN	?MOV_MoveGhost@@YAXPAUobject_def@@@Z:NEAR	; MOV_MoveGhost
; Function compile flags: /Odt /ZI
;	COMDAT ?AI_GhostCarAiHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?AI_GhostCarAiHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_GhostCarAiHandler, COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 190  : 	obj->player->LastValidRailCamNode = obj->player->ValidRailCamNode;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	ecx, DWORD PTR [ecx+10312]
	mov	DWORD PTR [eax+10316], ecx

; 191  : 	obj->player->ValidRailCamNode = -1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+10312], -1

; 192  : #ifdef _PC
; 193  : 	MOV_MoveGhost(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?MOV_MoveGhost@@YAXPAUobject_def@@@Z	; MOV_MoveGhost
	add	esp, 4

; 194  : 	UpdateCarFinishDist(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?UpdateCarFinishDist@@YAXPAUPlayerStruct@@@Z ; UpdateCarFinishDist
	add	esp, 4

; 195  : 	UpdateCarSfx(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?UpdateCarSfx@@YAXPAUCarStruct@@@Z	; UpdateCarSfx
	add	esp, 4

; 196  : 	UpdateCarMisc(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?UpdateCarMisc@@YAXPAUCarStruct@@@Z	; UpdateCarMisc
	add	esp, 4

; 197  : 	UpdatePlayerPickup(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z ; UpdatePlayerPickup
	add	esp, 4

; 198  : #endif
; 199  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_GhostCarAiHandler@@YAXPAUobject_def@@@Z ENDP	; AI_GhostCarAiHandler
_TEXT	ENDS
PUBLIC	__real@3f333333
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@bf000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@00000000
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?AiNode@@3PAU_AINODE@@A:DWORD			; AiNode
EXTRN	?AiNodeNum@@3JA:DWORD				; AiNodeNum
EXTRN	?AiNodeTotalDist@@3MA:DWORD			; AiNodeTotalDist
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateCarFinishDist@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
tv343 = -124						; size = 4
_i$ = -56						; size = 4
_norm$ = -52						; size = 12
_vec$ = -40						; size = 12
_max$ = -28						; size = 4
_add$ = -24						; size = 4
_dist$ = -20						; size = 4
_ndist$ = -16						; size = 4
_cdist$ = -12						; size = 4
_nnode$ = -8						; size = 4
_cnode$ = -4						; size = 4
_player$ = 8						; size = 4
?UpdateCarFinishDist@@YAXPAUPlayerStruct@@@Z PROC NEAR	; UpdateCarFinishDist, COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 207  : #ifndef _PSX
; 208  : 
; 209  : 	AINODE *cnode, *nnode;
; 210  : 	REAL cdist, ndist, dist, add, max;
; 211  : 	VEC vec, norm;
; 212  : 	long i;
; 213  : 
; 214  : // not if no nodes
; 215  : 
; 216  : 	if (!AiNodeNum)

	cmp	DWORD PTR ?AiNodeNum@@3JA, 0		; AiNodeNum
	jne	SHORT $L82455

; 217  : 		return;

	jmp	$L82444
$L82455:

; 218  : 
; 219  : // get dist to current node
; 220  : 
; 221  : 	cnode = &AiNode[player->CarAI.FinishDistNode];

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+10196]
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	mov	DWORD PTR _cnode$[ebp], ecx

; 222  : 	SubVector(&cnode->Centre, &player->car.Body->Centre.Pos, &vec);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _cnode$[ebp]
	fld	DWORD PTR [edx+72]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _cnode$[ebp]
	fld	DWORD PTR [edx+76]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _cnode$[ebp]
	fld	DWORD PTR [edx+80]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _vec$[ebp+8]

; 223  : 	cdist = vec.v[X] * vec.v[X] + vec.v[Y] * vec.v[Y] + vec.v[Z] * vec.v[Z];

	fld	DWORD PTR _vec$[ebp]
	fmul	DWORD PTR _vec$[ebp]
	fld	DWORD PTR _vec$[ebp+4]
	fmul	DWORD PTR _vec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vec$[ebp+8]
	fmul	DWORD PTR _vec$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _cdist$[ebp]

; 224  : 
; 225  : 	ndist = FLT_MAX;

	mov	DWORD PTR _ndist$[ebp], 2139095039	; 7f7fffffH

; 226  : 
; 227  : // look for nearest forward or backward node
; 228  : 
; 229  : 	for (i = 0 ; i < MAX_AINODE_LINKS ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82456
$L82457:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82456:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$L82458

; 230  : 	{
; 231  : 		if (cnode->Prev[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	cmp	DWORD PTR [ecx+eax*4+20], 0
	je	$L82459

; 232  : 		{
; 233  : 			SubVector(&cnode->Prev[i]->Centre, &player->car.Body->Centre.Pos, &vec);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR [edx+72]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR [edx+76]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR [edx+80]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _vec$[ebp+8]

; 234  : 			dist = vec.v[X] * vec.v[X] + vec.v[Y] * vec.v[Y] + vec.v[Z] * vec.v[Z];

	fld	DWORD PTR _vec$[ebp]
	fmul	DWORD PTR _vec$[ebp]
	fld	DWORD PTR _vec$[ebp+4]
	fmul	DWORD PTR _vec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vec$[ebp+8]
	fmul	DWORD PTR _vec$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dist$[ebp]

; 235  : 
; 236  : 			if (dist < ndist)

	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _ndist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82459

; 237  : 			{
; 238  : 				ndist = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _ndist$[ebp], eax

; 239  : 				nnode = cnode->Prev[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	mov	DWORD PTR _nnode$[ebp], edx
$L82459:

; 240  : 			}
; 241  : 		}
; 242  : 
; 243  : 		if (cnode->Next[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	cmp	DWORD PTR [ecx+eax*4+28], 0
	je	$L82461

; 244  : 		{
; 245  : 			SubVector(&cnode->Next[i]->Centre, &player->car.Body->Centre.Pos, &vec);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR [edx+72]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR [edx+76]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR [edx+80]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _vec$[ebp+8]

; 246  : 			dist = vec.v[X] * vec.v[X] + vec.v[Y] * vec.v[Y] + vec.v[Z] * vec.v[Z];

	fld	DWORD PTR _vec$[ebp]
	fmul	DWORD PTR _vec$[ebp]
	fld	DWORD PTR _vec$[ebp+4]
	fmul	DWORD PTR _vec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vec$[ebp+8]
	fmul	DWORD PTR _vec$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dist$[ebp]

; 247  : 
; 248  : 			if (dist < ndist)

	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _ndist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82461

; 249  : 			{
; 250  : 				ndist = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _ndist$[ebp], eax

; 251  : 				nnode = cnode->Next[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cnode$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	DWORD PTR _nnode$[ebp], edx
$L82461:

; 252  : 			}
; 253  : 		}
; 254  : 	}

	jmp	$L82457
$L82458:

; 255  : 
; 256  : // update current node?
; 257  : 
; 258  : 	if (ndist < cdist)

	fld	DWORD PTR _ndist$[ebp]
	fcomp	DWORD PTR _cdist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82463

; 259  : 	{
; 260  : 		player->CarAI.FinishDistNode = (long)(nnode - AiNode);

	mov	eax, DWORD PTR _nnode$[ebp]
	sub	eax, DWORD PTR ?AiNode@@3PAU_AINODE@@A	; AiNode
	cdq
	mov	ecx, 104				; 00000068H
	idiv	ecx
	mov	edx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [edx+10196], eax
$L82463:

; 261  : 	}
; 262  : 
; 263  : // update finish dist
; 264  : 
; 265  : 	SetVector(&norm, -cnode->RVec.v[Z], cnode->RVec.v[Y], cnode->RVec.v[X]);

	mov	eax, DWORD PTR _cnode$[ebp]
	fld	DWORD PTR [eax+92]
	fchs
	fstp	DWORD PTR _norm$[ebp]
	mov	eax, DWORD PTR _cnode$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _norm$[ebp+4], ecx
	mov	eax, DWORD PTR _cnode$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _norm$[ebp+8], ecx

; 266  : 	SubVector(&player->car.Body->Centre.Pos, &cnode->Centre, &vec);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _cnode$[ebp]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR [edx+72]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _cnode$[ebp]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR [edx+76]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _cnode$[ebp]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR [edx+80]
	fstp	DWORD PTR _vec$[ebp+8]

; 267  : 	player->CarAI.FinishDist = cnode->FinishDist + DotProduct(&norm, &vec);

	fld	DWORD PTR _norm$[ebp]
	fmul	DWORD PTR _vec$[ebp]
	fld	DWORD PTR _norm$[ebp+4]
	fmul	DWORD PTR _vec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _norm$[ebp+8]
	fmul	DWORD PTR _vec$[ebp+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _cnode$[ebp]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [ecx+10200]

; 268  : 
; 269  : // update 'wrong way' flag
; 270  : 
; 271  : 	player->CarAI.WrongWay = (DotProduct(&norm, &player->car.Body->Centre.WMatrix.mv[L]) > 0.7f);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	fld	DWORD PTR _norm$[ebp]
	fmul	DWORD PTR [ecx+124]
	mov	edx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx+900]
	fld	DWORD PTR _norm$[ebp+4]
	fmul	DWORD PTR [eax+128]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	fld	DWORD PTR _norm$[ebp+8]
	fmul	DWORD PTR [edx+132]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@3f333333
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83321
	mov	DWORD PTR tv343[ebp], 1
	jmp	SHORT $L83322
$L83321:
	mov	DWORD PTR tv343[ebp], 0
$L83322:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR tv343[ebp]
	mov	DWORD PTR [eax+10192], ecx

; 272  : 
; 273  : // update panel finish dist
; 274  : 
; 275  : 	dist = player->CarAI.FinishDist / AiNodeTotalDist;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10200]
	fdiv	DWORD PTR ?AiNodeTotalDist@@3MA		; AiNodeTotalDist
	fstp	DWORD PTR _dist$[ebp]

; 276  : 	add = dist - player->CarAI.FinishDistPanel;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR [eax+10204]
	fstp	DWORD PTR _add$[ebp]

; 277  : 
; 278  : 	if (add > 0.5f) add -= 1.0f;

	fld	DWORD PTR _add$[ebp]
	fcomp	DWORD PTR __real@3f000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82465
	fld	DWORD PTR _add$[ebp]
	fsub	DWORD PTR __real@3f800000
	fstp	DWORD PTR _add$[ebp]

; 279  : 	else if (add < -0.5f) add += 1.0f;

	jmp	SHORT $L82466
$L82465:
	fld	DWORD PTR _add$[ebp]
	fcomp	DWORD PTR __real@bf000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82466
	fld	DWORD PTR _add$[ebp]
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _add$[ebp]
$L82466:

; 280  : 
; 281  : 	max = 0.1f * TimeStep;

	fld	DWORD PTR __real@3dcccccd
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _max$[ebp]

; 282  : 	if (add > max) add = max;

	fld	DWORD PTR _add$[ebp]
	fcomp	DWORD PTR _max$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82468
	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR _add$[ebp], eax

; 283  : 	else if (add < -max) add = -max;

	jmp	SHORT $L82469
$L82468:
	fld	DWORD PTR _max$[ebp]
	fchs
	fcomp	DWORD PTR _add$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82469
	fld	DWORD PTR _max$[ebp]
	fchs
	fstp	DWORD PTR _add$[ebp]
$L82469:

; 284  : 
; 285  : 	player->CarAI.FinishDistPanel += add;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR _add$[ebp]
	fadd	DWORD PTR [eax+10204]
	mov	ecx, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [ecx+10204]

; 286  : 	if (player->CarAI.FinishDistPanel >= 1.0f) player->CarAI.FinishDistPanel -= 1.0f;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10204]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82471
	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10204]
	fsub	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [ecx+10204]

; 287  : 	else if (player->CarAI.FinishDistPanel < 0.0f) player->CarAI.FinishDistPanel += 1.0f;

	jmp	SHORT $L82444
$L82471:
	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10204]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82444
	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10204]
	fadd	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [ecx+10204]
$L82444:

; 288  : 
; 289  : #endif
; 290  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCarFinishDist@@YAXPAUPlayerStruct@@@Z ENDP	; UpdateCarFinishDist
_TEXT	ENDS
PUBLIC	__real@41100000
EXTRN	?LastKeys@@3PADA:BYTE				; LastKeys
EXTRN	?PLR_LocalPlayer@@3PAUPlayerStruct@@A:DWORD	; PLR_LocalPlayer
EXTRN	?WeaponTarget@@YAPAUobject_def@@PAU1@@Z:NEAR	; WeaponTarget
EXTRN	__ftol2:NEAR
EXTRN	?Keys@@3PADA:BYTE				; Keys
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
tv187 = -72						; size = 4
_f$ = -4						; size = 4
_player$ = 8						; size = 4
?UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z PROC NEAR	; UpdatePlayerPickup, COMDAT

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 298  : 	REAL f;
; 299  : 
; 300  : // tempy pickup select
; 301  : 
; 302  : 	static long pickup = PICKUP_NONE;
; 303  : #ifdef _PC
; 304  : 	if (Keys[DIK_RSHIFT] && !LastKeys[DIK_RSHIFT] && player == PLR_LocalPlayer)

	movsx	eax, BYTE PTR ?Keys@@3PADA+54
	test	eax, eax
	je	SHORT $L82480
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+54
	test	eax, eax
	jne	SHORT $L82480
	mov	eax, DWORD PTR _player$[ebp]
	cmp	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	jne	SHORT $L82480

; 305  : #endif
; 306  : #ifdef _N64
; 307  : 	if ((player == PLR_LocalPlayer) && (player->controls.digital & CTRL_SELWEAPON))
; 308  : #endif
; 309  : 	{
; 310  : 		pickup = (pickup + 1) % PICKUP_NUM;

	mov	eax, DWORD PTR ?pickup@?1??UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z@4JA
	add	eax, 1
	cdq
	mov	ecx, 9
	idiv	ecx
	mov	DWORD PTR ?pickup@?1??UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z@4JA, edx

; 311  : 		player->PickupType = pickup;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR ?pickup@?1??UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z@4JA
	mov	DWORD PTR [eax+10228], ecx

; 312  : 		player->PickupNum = 1000000;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10232], 1000000		; 000f4240H
$L82480:

; 313  : 	}
; 314  : 
; 315  : // only if no cycling pickup
; 316  : 
; 317  : 	if (player->PickupCycleSpeed) {

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [eax+10224]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$L82481

; 318  : 
; 319  : // dec cycle speed
; 320  : 
; 321  : 		player->PickupCycleSpeed -= TimeStep;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10224]
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [ecx+10224]

; 322  : 
; 323  : // inc cycle type
; 324  : 
; 325  : 		player->PickupCycleType += player->PickupCycleSpeed * TimeStep * 2.0f;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+10224]
	fadd	ST(0), ST(0)
	mov	ecx, DWORD PTR _player$[ebp]
	fadd	DWORD PTR [ecx+10220]
	mov	edx, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [edx+10220]

; 326  : 		if (player->PickupCycleType > PICKUP_NUM)

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10220]
	fcomp	DWORD PTR __real@41100000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82482

; 327  : 			player->PickupCycleType -= PICKUP_NUM;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10220]
	fsub	DWORD PTR __real@41100000
	mov	ecx, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [ecx+10220]
$L82482:

; 328  : 
; 329  : // give to player?
; 330  : 
; 331  : 		f = 1.0f - (player->PickupCycleType - (float)(long)player->PickupCycleType);

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10220]
	call	__ftol2
	mov	DWORD PTR tv187[ebp], eax
	fild	DWORD PTR tv187[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	fsubr	DWORD PTR [ecx+10220]
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _f$[ebp]

; 332  : 		if (player->PickupCycleSpeed < f)

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10224]
	fcomp	DWORD PTR _f$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82481

; 333  : 		{
; 334  : 
; 335  : // yep
; 336  : 
; 337  : 			player->PickupCycleSpeed = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10224], 0

; 338  : 			player->PickupType = (long)(player->PickupCycleType + 0.5f) % PICKUP_NUM;

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR [eax+10220]
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	cdq
	mov	ecx, 9
	idiv	ecx
	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10228], edx

; 339  : 			player->PickupTarget = NULL;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10236], 0

; 340  : 
; 341  : 			if (player->PickupType == PICKUP_FIREWORKPACK)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+10228], 2
	jne	SHORT $L82487

; 342  : 				player->PickupNum = 3;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10232], 3

; 343  : 			else

	jmp	SHORT $L82481
$L82487:

; 344  : 				player->PickupNum = 1;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+10232], 1
$L82481:

; 345  : 		}
; 346  : 
; 347  : 	}
; 348  : 
; 349  : // Select weapon target if the weapon type requires it
; 350  : 	if ((player->PickupType == PICKUP_FIREWORK) || (player->PickupType == PICKUP_FIREWORKPACK)) {

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+10228], 1
	je	SHORT $L82490
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+10228], 2
	jne	SHORT $L82476
$L82490:

; 351  : 		player->PickupTarget = WeaponTarget(player->ownobj);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	?WeaponTarget@@YAPAUobject_def@@PAU1@@Z	; WeaponTarget
	add	esp, 4
	mov	edx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [edx+10236], eax
$L82476:

; 352  : 	}
; 353  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdatePlayerPickup@@YAXPAUPlayerStruct@@@Z ENDP	; UpdatePlayerPickup
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	__real@4b000000
PUBLIC	__real@44160000
EXTRN	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z:NEAR ; CreateSfx3D
EXTRN	?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z:NEAR		; FreeSfx3D
EXTRN	?ChangeSfxSample3D@@YAXPAUSAMPLE_3D@@J@Z:NEAR	; ChangeSfxSample3D
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateCarSfx@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
tv72 = -112						; size = 4
__temp$82531 = -44					; size = 4
__temp$82515 = -40					; size = 4
__temp$82504 = -36					; size = 4
__temp$82501 = -32					; size = 4
_screech$ = -28						; size = 4
_sfx$ = -24						; size = 4
_time$ = -20						; size = 4
_maxvol$ = -16						; size = 4
_vel$ = -12						; size = 4
_revs$ = -8						; size = 4
_i$ = -4						; size = 4
_car$ = 8						; size = 4
?UpdateCarSfx@@YAXPAUCarStruct@@@Z PROC NEAR		; UpdateCarSfx, COMDAT

; 361  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 362  : 	long i, revs, vel, maxvol, time, sfx, screech;
; 363  : 
; 364  : // get car revs, velocity
; 365  : 
; 366  : 	FTOL(abs(car->Revs), revs);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3504]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83344
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+3504]
	fstp	DWORD PTR tv72[ebp]
	jmp	SHORT $L83345
$L83344:
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+3504]
	fchs
	fstp	DWORD PTR tv72[ebp]
$L83345:
	fld	DWORD PTR tv72[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82501[ebp]
	mov	eax, DWORD PTR __temp$82501[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _revs$[ebp], eax

; 367  : 	FTOL(Length(&car->Body->Centre.Vel), vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+36]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+40]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82504[ebp]
	mov	eax, DWORD PTR __temp$82504[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _vel$[ebp], eax

; 368  : 
; 369  : // update engine
; 370  : 
; 371  : 	if (car->SfxEngine)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3592], 0
	je	$L82508

; 372  : 	{
; 373  : 		car->SfxEngine->Freq = 10000 + revs * 80;

	mov	eax, DWORD PTR _revs$[ebp]
	imul	eax, 80					; 00000050H
	add	eax, 10000				; 00002710H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3592]
	mov	DWORD PTR [edx+12], eax

; 374  : 
; 375  : 		car->SfxEngine->Vol = revs / 2;

	mov	eax, DWORD PTR _revs$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3592]
	mov	DWORD PTR [edx+8], eax

; 376  : 		if (car->SfxEngine->Vol > SFX_MAX_VOL) car->SfxEngine->Vol = SFX_MAX_VOL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3592]
	cmp	DWORD PTR [ecx+8], 127			; 0000007fH
	jle	SHORT $L82509
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3592]
	mov	DWORD PTR [ecx+8], 127			; 0000007fH
$L82509:

; 377  : 
; 378  : 		CopyVec(&car->Body->Centre.Pos, &car->SfxEngine->Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3592]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+28], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3592]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3592]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+36], ecx
$L82508:

; 379  : 	}
; 380  : 
; 381  : // update scrape
; 382  : 
; 383  : 	if (car->Body->ScrapeMaterial == MATERIAL_NONE)

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	cmp	DWORD PTR [ecx+536], -1
	jne	SHORT $L82510

; 384  : 	{
; 385  : 		if (car->SfxScrape)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3596], 0
	je	SHORT $L82511

; 386  : 		{
; 387  : 			FreeSfx3D(car->SfxScrape);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3596]
	push	ecx
	call	?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z		; FreeSfx3D
	add	esp, 4

; 388  : 			car->SfxScrape = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3596], 0
$L82511:

; 389  : 		}
; 390  : 	}
; 391  : 	else

	jmp	$L82512
$L82510:

; 392  : 	{
; 393  : 		sfx = SfxScrapeList[car->Body->ScrapeMaterial];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+536]
	mov	eax, DWORD PTR ?SfxScrapeList@@3PAJA[edx*4]
	mov	DWORD PTR _sfx$[ebp], eax

; 394  : 
; 395  : 		if (!car->SfxScrape)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3596], 0
	jne	SHORT $L82513

; 396  : 		{
; 397  : 			car->SfxScrape = CreateSfx3D(sfx, 0, 0, TRUE, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	push	1
	push	0
	push	0
	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	call	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ; CreateSfx3D
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+3596], eax

; 398  : 			car->ScrapeMaterial = car->Body->ScrapeMaterial;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+536]
	mov	DWORD PTR [edx+3604], eax
$L82513:

; 399  : 		}
; 400  : 
; 401  : 		if (car->SfxScrape)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3596], 0
	je	$L82512

; 402  : 		{
; 403  : 			car->SfxScrape->Freq = 20000 + vel * 5;

	mov	eax, DWORD PTR _vel$[ebp]
	imul	eax, 5
	add	eax, 20000				; 00004e20H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3596]
	mov	DWORD PTR [edx+12], eax

; 404  : 
; 405  : 			FTOL(TimeStep * 600.0f, time);

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@44160000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82515[ebp]
	mov	eax, DWORD PTR __temp$82515[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _time$[ebp], eax

; 406  : 			if (!time) time = 1;

	jne	SHORT $L82518
	mov	DWORD PTR _time$[ebp], 1
$L82518:

; 407  : 			maxvol = car->SfxScrape->Vol + time;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3596]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _time$[ebp]
	mov	DWORD PTR _maxvol$[ebp], edx

; 408  : 			if (maxvol > SFX_MAX_VOL) maxvol = SFX_MAX_VOL;

	cmp	DWORD PTR _maxvol$[ebp], 127		; 0000007fH
	jle	SHORT $L82519
	mov	DWORD PTR _maxvol$[ebp], 127		; 0000007fH
$L82519:

; 409  : 
; 410  : 			car->SfxScrape->Vol = vel / 10;

	mov	eax, DWORD PTR _vel$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [edx+3596]
	mov	DWORD PTR [ecx+8], eax

; 411  : 			if (car->SfxScrape->Vol > maxvol) car->SfxScrape->Vol = maxvol;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3596]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _maxvol$[ebp]
	jle	SHORT $L82520
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3596]
	mov	edx, DWORD PTR _maxvol$[ebp]
	mov	DWORD PTR [ecx+8], edx
$L82520:

; 412  : 
; 413  : 			CopyVec(&car->Body->Centre.Pos, &car->SfxScrape->Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3596]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+28], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3596]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3596]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+36], ecx

; 414  : 
; 415  : 			if (car->ScrapeMaterial != car->Body->ScrapeMaterial)

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3604]
	cmp	eax, DWORD PTR [ecx+536]
	je	SHORT $L82512

; 416  : 			{
; 417  : 				ChangeSfxSample3D(car->SfxScrape, sfx);

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3596]
	push	edx
	call	?ChangeSfxSample3D@@YAXPAUSAMPLE_3D@@J@Z ; ChangeSfxSample3D
	add	esp, 8

; 418  : 				car->ScrapeMaterial = car->Body->ScrapeMaterial;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+536]
	mov	DWORD PTR [edx+3604], eax
$L82512:

; 419  : 			}
; 420  : 		}
; 421  : 	}
; 422  : 
; 423  : // update screech
; 424  : 
; 425  : 	screech = FALSE;

	mov	DWORD PTR _screech$[ebp], 0

; 426  : 	for (i = 0 ; i < CAR_NWHEELS ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82522
$L82523:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82522:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L82524

; 427  : 	{
; 428  : 		if (IsWheelPresent(&car->Wheel[i]) && IsWheelSkidding(&car->Wheel[i]) && IsWheelInContact(&car->Wheel[i]))

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 1
	je	SHORT $L82525
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 48					; 00000030H
	je	SHORT $L82525
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 8
	je	SHORT $L82525

; 429  : 		{
; 430  : 			screech = TRUE;

	mov	DWORD PTR _screech$[ebp], 1

; 431  : 			break;

	jmp	SHORT $L82524
$L82525:

; 432  : 		}
; 433  : 	}

	jmp	SHORT $L82523
$L82524:

; 434  : 
; 435  : 	if (!screech)

	cmp	DWORD PTR _screech$[ebp], 0
	jne	SHORT $L82526

; 436  : 	{
; 437  : 		if (car->SfxScreech)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3600], 0
	je	SHORT $L82527

; 438  : 		{
; 439  : 			FreeSfx3D(car->SfxScreech);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3600]
	push	ecx
	call	?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z		; FreeSfx3D
	add	esp, 4

; 440  : 			car->SfxScreech = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3600], 0
$L82527:

; 441  : 		}
; 442  : 	}
; 443  : 	else

	jmp	$L82493
$L82526:

; 444  : 	{
; 445  : 		if (!car->SfxScreech)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3600], 0
	jne	SHORT $L82529

; 446  : 		{
; 447  : 			car->SfxScreech = CreateSfx3D(SFX_SCREECH, 0, 0, TRUE, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	push	1
	push	0
	push	0
	push	3
	call	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ; CreateSfx3D
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3600], eax
$L82529:

; 448  : 		}
; 449  : 
; 450  : 		if (car->SfxScreech)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3600], 0
	je	$L82493

; 451  : 		{
; 452  : 			car->SfxScreech->Freq = 15000 + vel * 2;

	mov	eax, DWORD PTR _vel$[ebp]
	lea	ecx, DWORD PTR [eax+eax+15000]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3600]
	mov	DWORD PTR [eax+12], ecx

; 453  : 
; 454  : 			FTOL(TimeStep * 600.0f, time);

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@44160000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82531[ebp]
	mov	eax, DWORD PTR __temp$82531[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _time$[ebp], eax

; 455  : 			if (!time) time = 1;

	jne	SHORT $L82534
	mov	DWORD PTR _time$[ebp], 1
$L82534:

; 456  : 			maxvol = car->SfxScreech->Vol + time;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3600]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _time$[ebp]
	mov	DWORD PTR _maxvol$[ebp], edx

; 457  : 			if (maxvol > SFX_MAX_VOL) maxvol = SFX_MAX_VOL;

	cmp	DWORD PTR _maxvol$[ebp], 127		; 0000007fH
	jle	SHORT $L82535
	mov	DWORD PTR _maxvol$[ebp], 127		; 0000007fH
$L82535:

; 458  : 
; 459  : 			car->SfxScreech->Vol = vel / 10;

	mov	eax, DWORD PTR _vel$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [edx+3600]
	mov	DWORD PTR [ecx+8], eax

; 460  : 			if (car->SfxScreech->Vol > maxvol) car->SfxScreech->Vol = maxvol;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3600]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _maxvol$[ebp]
	jle	SHORT $L82536
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3600]
	mov	edx, DWORD PTR _maxvol$[ebp]
	mov	DWORD PTR [ecx+8], edx
$L82536:

; 461  : 
; 462  : 			CopyVec(&car->Body->Centre.Pos, &car->SfxScreech->Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3600]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+28], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3600]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+3600]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+36], ecx
$L82493:

; 463  : 		}
; 464  : 	}
; 465  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCarSfx@@YAXPAUCarStruct@@@Z ENDP			; UpdateCarSfx
_TEXT	ENDS
PUBLIC	__real@45c00000
PUBLIC	__real@447a0000
PUBLIC	__real@43960000
EXTRN	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z:NEAR	; RotMatrixZYX
EXTRN	?MulMatrix@@YAXPATMatrixUnion@@00@Z:NEAR	; MulMatrix
EXTRN	?CopyMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; CopyMatrix
EXTRN	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z:NEAR	; PlaySfx3D
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
;	COMDAT __real@45c00000
CONST	SEGMENT
__real@45c00000 DD 045c00000r			; 6144
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateCarMisc@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_freq$82557 = -92					; size = 4
_vol$82556 = -88					; size = 4
_mat2$ = -84						; size = 36
_mat1$ = -48						; size = 36
_vec$ = -12						; size = 12
_car$ = 8						; size = 4
?UpdateCarMisc@@YAXPAUCarStruct@@@Z PROC NEAR		; UpdateCarMisc, COMDAT

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi

; 473  : 	VEC vec;
; 474  : 	MAT mat1, mat2;
; 475  : 
; 476  : // env matrix
; 477  : 
; 478  : #ifdef _PC
; 479  : 	if (RenderSettings.Env)

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+76, 0
	je	$L82543

; 480  : 	{
; 481  : 		SubVector(&car->Body->Centre.Pos, &car->Body->Centre.OldPos, &vec);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR [eax+12]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR [eax+16]
	fstp	DWORD PTR _vec$[ebp+8]

; 482  : 		RotMatrixZYX(&mat1, vec.v[X] / 6144, 0, vec.v[Z] / 6144);

	fld	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR __real@45c00000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	fld	DWORD PTR _vec$[ebp]
	fdiv	DWORD PTR __real@45c00000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat1$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 483  : 		MulMatrix(&car->EnvMatrix, &mat1, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	add	edx, 784				; 00000310H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 484  : 		CopyMatrix(&mat2, &car->EnvMatrix);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 784				; 00000310H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8
$L82543:

; 485  : 	}
; 486  : #endif
; 487  : 
; 488  : // electropulsed power timer?
; 489  : 
; 490  : 	if (car->PowerTimer)

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [eax+3512]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L82544

; 491  : 	{	
; 492  : 		car->PowerTimer -= TimeStep;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3512]
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+3512]

; 493  : 		if (car->PowerTimer < 0.0f)

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3512]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82544

; 494  : 			car->PowerTimer = 0.0f;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3512], 0
$L82544:

; 495  : 	}
; 496  : 
; 497  : // zero AddLit
; 498  : 
; 499  : #ifdef _PC
; 500  : 	if (car->AddLit > 0)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3516], 0
	jle	SHORT $L82546

; 501  : 	{
; 502  : 		car->AddLit -= (long)(TimeStep * 1000);

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@447a0000
	call	__ftol2
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3516]
	sub	edx, eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3516], edx

; 503  : 		if (car->AddLit < 0) car->AddLit = 0;

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3516], 0
	jge	SHORT $L82548
	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3516], 0
$L82548:

; 504  : 	}
; 505  : 	else if (car->AddLit < 0)

	jmp	SHORT $L82549
$L82546:
	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3516], 0
	jge	SHORT $L82549

; 506  : 	{
; 507  : 		car->AddLit += (long)(TimeStep * 1000);

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@447a0000
	call	__ftol2
	mov	ecx, DWORD PTR _car$[ebp]
	add	eax, DWORD PTR [ecx+3516]
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3516], eax

; 508  : 		if (car->AddLit > 0) car->AddLit = 0;

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3516], 0
	jle	SHORT $L82549
	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3516], 0
$L82549:

; 509  : 	}
; 510  : #endif
; 511  : 
; 512  : // bomb return timer
; 513  : 	if (car->NoReturnTimer > ZERO) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3532]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82553

; 514  : 		car->NoReturnTimer -= TimeStep;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3532]
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+3532]
$L82553:

; 515  : 	}
; 516  : 
; 517  : // Bang storing
; 518  : #ifdef _PC
; 519  : 	if (car->Body->BangMag > TO_VEL(Real(300))) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+548]
	fcomp	DWORD PTR __real@43960000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82555

; 520  : 		long vol, freq;
; 521  : 
; 522  : 		//vol = SFX_MIN_VOL + (SFX_MAX_VOL - SFX_MIN_VOL) * obj->body.BangMag / 1000;
; 523  : 		//if (vol > SFX_MAX_VOL) vol = SFX_MAX_VOL;
; 524  : 		vol = SFX_MAX_VOL;

	mov	DWORD PTR _vol$82556[ebp], 127		; 0000007fH

; 525  : 
; 526  : 		freq = 22050;

	mov	DWORD PTR _freq$82557[ebp], 22050	; 00005622H

; 527  : 
; 528  : 		PlaySfx3D(SFX_CHROMEBALL_HIT, vol, freq, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _freq$82557[ebp]
	push	edx
	mov	eax, DWORD PTR _vol$82556[ebp]
	push	eax
	push	12					; 0000000cH
	call	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z	; PlaySfx3D
	add	esp, 16					; 00000010H
$L82555:

; 529  : 	}
; 530  : #endif
; 531  : 	car->Body->Banged = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	BYTE PTR [ecx+544], 0

; 532  : 	car->Body->BangMag = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+548], 0

; 533  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCarMisc@@YAXPAUCarStruct@@@Z ENDP		; UpdateCarMisc
_TEXT	ENDS
PUBLIC	?AI_BarrelHandler@@YAXPAUobject_def@@@Z		; AI_BarrelHandler
EXTRN	?RotMatrixX@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixX
EXTRN	?TimeFactor@@3MA:DWORD				; TimeFactor
; Function compile flags: /Odt /ZI
;	COMDAT ?AI_BarrelHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
__mul$82568 = -84					; size = 4
__mul$82566 = -80					; size = 4
_barrel$ = -76						; size = 4
_mat2$ = -72						; size = 36
_mat$ = -36						; size = 36
_obj$ = 8						; size = 4
?AI_BarrelHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_BarrelHandler, COMDAT

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 542  : 	MAT mat, mat2;
; 543  : 	BARREL_OBJ *barrel = (BARREL_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _barrel$[ebp], ecx

; 544  : 
; 545  : // quit if not visible
; 546  : 
; 547  : 	if (!obj->renderflag.visible)

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L82565

; 548  : 		return;

	jmp	$L82560
$L82565:

; 549  : 
; 550  : // spin
; 551  : 
; 552  : 	RotMatrixX(&mat, barrel->SpinSpeed * TimeFactor);

	mov	eax, DWORD PTR _barrel$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixX@@YAXPATMatrixUnion@@M@Z	; RotMatrixX
	add	esp, 8

; 553  : 	MulMatrix(&obj->body.Centre.WMatrix, &mat, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 554  : 	NormalizeMatrix(&mat2);

	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+20]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82566[ebp]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR __mul$82566[ebp]
	fstp	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR __mul$82566[ebp]
	fstp	DWORD PTR _mat2$[ebp+16]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR __mul$82566[ebp]
	fstp	DWORD PTR _mat2$[ebp+20]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82568[ebp]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR __mul$82568[ebp]
	fstp	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR __mul$82568[ebp]
	fstp	DWORD PTR _mat2$[ebp+28]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR __mul$82568[ebp]
	fstp	DWORD PTR _mat2$[ebp+32]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+32]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+28]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+4]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+28]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+24]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+8]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp+8]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+16]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+4]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+20]

; 555  : 	CopyMatrix(&mat2, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8
$L82560:

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_BarrelHandler@@YAXPAUobject_def@@@Z ENDP		; AI_BarrelHandler
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?AI_PlanetHandler@@YAXPAUobject_def@@@Z		; AI_PlanetHandler
EXTRN	?RotMatrixY@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixY
EXTRN	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixZ
EXTRN	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z:NEAR ; RotTransVector
EXTRN	?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z:NEAR ; BuildLookMatrixForward
EXTRN	_rand:NEAR
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\ai.cpp
;	COMDAT ?AI_PlanetHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
__mul$82608 = -128					; size = 4
__mul$82606 = -124					; size = 4
__mul$82603 = -120					; size = 4
__mul$82601 = -116					; size = 4
_sun$ = -112						; size = 4
_findplanet$ = -108					; size = 4
_planet$ = -104						; size = 4
_len$ = -100						; size = 4
_findsun$ = -96						; size = 4
_findobj$ = -92						; size = 4
_vec$ = -88						; size = 12
_mat2$ = -76						; size = 36
_mat$ = -40						; size = 36
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_PlanetHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_PlanetHandler, COMDAT

; 564  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 565  : 	long i;
; 566  : 	MAT mat, mat2;
; 567  : 	VEC vec;
; 568  : 	OBJECT *findobj, *findsun;
; 569  : 	REAL len;
; 570  : 	PLANET_OBJ *planet = (PLANET_OBJ*)obj->Data, *findplanet;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _planet$[ebp], ecx

; 571  : 	SUN_OBJ *sun = (SUN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _sun$[ebp], ecx

; 572  : 
; 573  : // get orbit object?
; 574  : 
; 575  : 	if (!obj->objref)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+592], 0
	jne	$L82585

; 576  : 	{
; 577  : 		for (findobj = OBJ_ObjectHead ; findobj ; findobj = findobj->next)

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _findobj$[ebp], eax
	jmp	SHORT $L82586
$L82587:
	mov	eax, DWORD PTR _findobj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _findobj$[ebp], ecx
$L82586:
	cmp	DWORD PTR _findobj$[ebp], 0
	je	$L82588

; 578  : 		{
; 579  : 			findplanet = (PLANET_OBJ*)findobj->Data;

	mov	eax, DWORD PTR _findobj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _findplanet$[ebp], ecx

; 580  : 			if (findobj->Type == OBJECT_TYPE_PLANET && findplanet->OwnPlanet == planet->OrbitPlanet)

	mov	eax, DWORD PTR _findobj$[ebp]
	cmp	DWORD PTR [eax+568], 2
	jne	SHORT $L82590
	mov	eax, DWORD PTR _findplanet$[ebp]
	mov	ecx, DWORD PTR _planet$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $L82590

; 581  : 			{
; 582  : 				obj->objref = findobj;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _findobj$[ebp]
	mov	DWORD PTR [eax+592], ecx

; 583  : 
; 584  : 				for (findsun = OBJ_ObjectHead ; findsun ; findsun = findsun->next)

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _findsun$[ebp], eax
	jmp	SHORT $L82591
$L82592:
	mov	eax, DWORD PTR _findsun$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _findsun$[ebp], ecx
$L82591:
	cmp	DWORD PTR _findsun$[ebp], 0
	je	SHORT $L82593

; 585  : 					if (findsun->Type == OBJECT_TYPE_PLANET && ((PLANET_OBJ*)findsun->Data)->OwnPlanet == PLANET_SUN)

	mov	eax, DWORD PTR _findsun$[ebp]
	cmp	DWORD PTR [eax+568], 2
	jne	SHORT $L82595
	mov	eax, DWORD PTR _findsun$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	cmp	DWORD PTR [ecx], 11			; 0000000bH
	jne	SHORT $L82595

; 586  : 						planet->VisiMask = ((SUN_OBJ*)(findsun->Data))->VisiMask;

	mov	eax, DWORD PTR _findsun$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	edx, DWORD PTR _planet$[ebp]
	mov	eax, DWORD PTR [ecx+82088]
	mov	DWORD PTR [edx+64], eax
	mov	ecx, DWORD PTR [ecx+82092]
	mov	DWORD PTR [edx+68], ecx
$L82595:

; 587  : 
; 588  : 				break;

	jmp	SHORT $L82592
$L82593:
	jmp	SHORT $L82588
$L82590:

; 589  : 			}
; 590  : 		}

	jmp	$L82587
$L82588:

; 591  : 
; 592  : 		if (!obj->objref)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+592], 0
	jne	SHORT $L82597

; 593  : 			return;

	jmp	$L82572
$L82597:

; 594  : 
; 595  : 		if (planet->OwnPlanet != PLANET_SUN)

	mov	eax, DWORD PTR _planet$[ebp]
	cmp	DWORD PTR [eax], 11			; 0000000bH
	je	$L82585

; 596  : 		{
; 597  : // setup orbit info
; 598  : 			SubVector(&obj->body.Centre.Pos, &obj->objref->body.Centre.Pos, &vec);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+24]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+28]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _vec$[ebp+8]

; 599  : 			len = Length(&vec);

	fld	DWORD PTR _vec$[ebp]
	fmul	DWORD PTR _vec$[ebp]
	fld	DWORD PTR _vec$[ebp+4]
	fmul	DWORD PTR _vec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vec$[ebp+8]
	fmul	DWORD PTR _vec$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _len$[ebp]

; 600  : 			SetVector(&planet->OrbitOffset, 0, 0, len);

	mov	eax, DWORD PTR _planet$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR _planet$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	eax, DWORD PTR _planet$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 601  : 
; 602  : 			BuildLookMatrixForward(&obj->objref->body.Centre.Pos, &obj->body.Centre.Pos, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+592]
	add	eax, 20					; 00000014H
	push	eax
	call	?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ; BuildLookMatrixForward
	add	esp, 12					; 0000000cH

; 603  : //			RotMatrixZ(&mat, ((float)rand() / RAND_MAX - 0.5f) / 3.0f);
; 604  : 			RotMatrixZ(&mat, 0.1f);

	push	1036831949				; 3dcccccdH
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 605  : 			MulMatrix(&mat2, &mat, &planet->OrbitMatrix);

	mov	eax, DWORD PTR _planet$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat2$[ebp]
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH
$L82585:

; 606  : 		}
; 607  : 	}
; 608  : 
; 609  : // rotate on orbit
; 610  : 	if (planet->OwnPlanet != planet->OrbitPlanet)

	mov	eax, DWORD PTR _planet$[ebp]
	mov	ecx, DWORD PTR _planet$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	je	$L82600

; 611  : 	{
; 612  : 		RotMatrixX(&mat, planet->OrbitSpeed * TimeFactor);

	mov	eax, DWORD PTR _planet$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixX@@YAXPATMatrixUnion@@M@Z	; RotMatrixX
	add	esp, 8

; 613  : 		MulMatrix(&planet->OrbitMatrix, &mat, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _planet$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 614  : 		NormalizeMatrix(&mat2);

	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+20]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82601[ebp]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR __mul$82601[ebp]
	fstp	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR __mul$82601[ebp]
	fstp	DWORD PTR _mat2$[ebp+16]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR __mul$82601[ebp]
	fstp	DWORD PTR _mat2$[ebp+20]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82603[ebp]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR __mul$82603[ebp]
	fstp	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR __mul$82603[ebp]
	fstp	DWORD PTR _mat2$[ebp+28]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR __mul$82603[ebp]
	fstp	DWORD PTR _mat2$[ebp+32]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+32]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+28]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+4]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+28]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+24]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+8]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp+8]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+16]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+4]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+20]

; 615  : 		CopyMatrix(&mat2, &planet->OrbitMatrix);

	mov	eax, DWORD PTR _planet$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 616  : 		RotTransVector(&planet->OrbitMatrix, &obj->objref->body.Centre.Pos, &planet->OrbitOffset, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _planet$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+592]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _planet$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H
$L82600:

; 617  : 	}
; 618  : 
; 619  : // quit if not visible
; 620  : 
; 621  : //	if (planet->OwnPlanet != PLANET_SUN && !obj->renderflag.visible)
; 622  : 	if (!obj->renderflag.visible)

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L82605

; 623  : 		return;

	jmp	$L82572
$L82605:

; 624  : 
; 625  : // spin on local Y axis
; 626  : 
; 627  : 	RotMatrixY(&mat, planet->SpinSpeed * TimeFactor);

	mov	eax, DWORD PTR _planet$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+12]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 628  : 	MulMatrix(&obj->body.Centre.WMatrix, &mat, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 629  : 	NormalizeMatrix(&mat2);

	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+20]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82606[ebp]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR __mul$82606[ebp]
	fstp	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR __mul$82606[ebp]
	fstp	DWORD PTR _mat2$[ebp+16]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR __mul$82606[ebp]
	fstp	DWORD PTR _mat2$[ebp+20]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82608[ebp]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR __mul$82608[ebp]
	fstp	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR __mul$82608[ebp]
	fstp	DWORD PTR _mat2$[ebp+28]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR __mul$82608[ebp]
	fstp	DWORD PTR _mat2$[ebp+32]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+32]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+28]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp]
	fld	DWORD PTR _mat2$[ebp+20]
	fmul	DWORD PTR _mat2$[ebp+24]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+4]
	fld	DWORD PTR _mat2$[ebp+12]
	fmul	DWORD PTR _mat2$[ebp+28]
	fld	DWORD PTR _mat2$[ebp+16]
	fmul	DWORD PTR _mat2$[ebp+24]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+8]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp+8]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+12]
	fld	DWORD PTR _mat2$[ebp+32]
	fmul	DWORD PTR _mat2$[ebp]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+16]
	fld	DWORD PTR _mat2$[ebp+24]
	fmul	DWORD PTR _mat2$[ebp+4]
	fld	DWORD PTR _mat2$[ebp+28]
	fmul	DWORD PTR _mat2$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat2$[ebp+20]

; 630  : 	CopyMatrix(&mat2, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 631  : 
; 632  : // sun?
; 633  : 
; 634  : 	if (planet->OwnPlanet != PLANET_SUN)

	mov	eax, DWORD PTR _planet$[ebp]
	cmp	DWORD PTR [eax], 11			; 0000000bH
	je	SHORT $L82610

; 635  : 		return;

	jmp	$L82572
$L82610:

; 636  : 
; 637  : // maintain overlays
; 638  : 
; 639  : 	for (i = 0 ; i < SUN_OVERLAY_NUM ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82611
$L82612:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82611:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$L82572

; 640  : 	{
; 641  : //		sun->Overlay[i].RotVel += frand(0.0001f) - 0.00005f;
; 642  : //		if (sun->Overlay[i].RotVel < -0.001f) sun->Overlay[i].RotVel = -0.001f;
; 643  : //		else if (sun->Overlay[i].RotVel > 0.001f) sun->Overlay[i].RotVel = 0.001f;
; 644  : 
; 645  : 		sun->Overlay[i].Rot += sun->Overlay[i].RotVel * TimeFactor;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _sun$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [edx+ecx+92]
	mov	ecx, DWORD PTR _sun$[ebp]
	fadd	DWORD PTR [ecx+eax+88]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _sun$[ebp]
	fstp	DWORD PTR [eax+edx+88]

; 646  : 
; 647  : 		sun->Overlay[i].r += (rand() % 5) - 2;

	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	eax, DWORD PTR _sun$[ebp]
	mov	ecx, DWORD PTR [eax+esi+72]
	lea	edx, DWORD PTR [edx+ecx-2]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+72], edx

; 648  : 		if (sun->Overlay[i].r > 128) sun->Overlay[i].r = 128;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	cmp	DWORD PTR [ecx+eax+72], 128		; 00000080H
	jle	SHORT $L82614
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+72], 128		; 00000080H

; 649  : 		else if (sun->Overlay[i].r < 96) sun->Overlay[i].r = 96;

	jmp	SHORT $L82615
$L82614:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	cmp	DWORD PTR [ecx+eax+72], 96		; 00000060H
	jge	SHORT $L82615
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+72], 96		; 00000060H
$L82615:

; 650  : 
; 651  : 		sun->Overlay[i].g += (rand() % 5) - 2;

	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	eax, DWORD PTR _sun$[ebp]
	mov	ecx, DWORD PTR [eax+esi+76]
	lea	edx, DWORD PTR [edx+ecx-2]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+76], edx

; 652  : 		if (sun->Overlay[i].g > 128) sun->Overlay[i].g = 128;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	cmp	DWORD PTR [ecx+eax+76], 128		; 00000080H
	jle	SHORT $L82617
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+76], 128		; 00000080H

; 653  : 		else if (sun->Overlay[i].g < 96) sun->Overlay[i].g = 96;

	jmp	SHORT $L82618
$L82617:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	cmp	DWORD PTR [ecx+eax+76], 96		; 00000060H
	jge	SHORT $L82618
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+76], 96		; 00000060H
$L82618:

; 654  : 
; 655  : 		sun->Overlay[i].b += (rand() % 5) - 2;

	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	eax, DWORD PTR _sun$[ebp]
	mov	ecx, DWORD PTR [eax+esi+80]
	lea	edx, DWORD PTR [edx+ecx-2]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+80], edx

; 656  : 		if (sun->Overlay[i].b > 96) sun->Overlay[i].b = 96;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	cmp	DWORD PTR [ecx+eax+80], 96		; 00000060H
	jle	SHORT $L82620
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+80], 96		; 00000060H

; 657  : 		else if (sun->Overlay[i].b < 64) sun->Overlay[i].b = 64;

	jmp	SHORT $L82621
$L82620:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	cmp	DWORD PTR [ecx+eax+80], 64		; 00000040H
	jge	SHORT $L82621
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+80], 64		; 00000040H
$L82621:

; 658  : 
; 659  : 		sun->Overlay[i].rgb = (sun->Overlay[i].r << 16) | (sun->Overlay[i].g << 8) | sun->Overlay[i].b;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	edx, DWORD PTR [ecx+eax+72]
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	eax, DWORD PTR [ecx+eax+76]
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	eax, DWORD PTR _sun$[ebp]
	or	edx, DWORD PTR [eax+ecx+80]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	eax, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [eax+ecx+84], edx

; 660  : 	}

	jmp	$L82612
$L82572:

; 661  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_PlanetHandler@@YAXPAUobject_def@@@Z ENDP		; AI_PlanetHandler
_TEXT	ENDS
PUBLIC	?AI_PlaneHandler@@YAXPAUobject_def@@@Z		; AI_PlaneHandler
PUBLIC	__real@43fa0000
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?TimerFreq@@3KA:DWORD				; TimerFreq
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_PlaneHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv188 = -120						; size = 8
tv181 = -112						; size = 8
_plane$ = -40						; size = 4
_mat$ = -36						; size = 36
_obj$ = 8						; size = 4
?AI_PlaneHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_PlaneHandler, COMDAT

; 669  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 670  : 	MAT mat;
; 671  : 	PLANE_OBJ *plane = (PLANE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _plane$[ebp], ecx

; 672  : 
; 673  : // get world mat / pos
; 674  : 
; 675  : 	plane->Rot += plane->Speed * TimeFactor;

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [edx+4]

; 676  : 	RotMatrixY(&mat, plane->Rot);

	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 677  : 	MulMatrix(&mat, &plane->BankMatrix, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _plane$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 678  : 	RotTransVector(&mat, &plane->GenPos, &plane->Offset, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _plane$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _plane$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 679  : 
; 680  : // set propellor world pos / mat
; 681  : 
; 682  : 	RotMatrixZ(&mat, (float)TIME2MS(CurrentTimer()) / 500.0f);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR tv181[ebp], eax
	mov	DWORD PTR tv181[ebp+4], 0
	fild	QWORD PTR tv181[ebp]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR tv188[ebp], eax
	mov	DWORD PTR tv188[ebp+4], 0
	fild	QWORD PTR tv188[ebp]
	fdivp	ST(1), ST(0)
	fdiv	DWORD PTR __real@43fa0000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 683  : 	MulMatrix(&obj->body.Centre.WMatrix, &mat, &plane->PropMatrix);

	mov	eax, DWORD PTR _plane$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 684  : 	RotTransVector(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &PlanePropOff, &plane->PropPos);

	mov	eax, DWORD PTR _plane$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET FLAT:_PlanePropOff
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 685  : 
; 686  : // update sfx pos
; 687  : 
; 688  : #ifdef _PC
; 689  : 	if (obj->Sfx3D)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+680], 0
	je	SHORT $L82625

; 690  : 	{
; 691  : 		CopyVec(&obj->body.Centre.Pos, &obj->Sfx3D->Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+36], eax
$L82625:

; 692  : 	}
; 693  : #endif
; 694  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_PlaneHandler@@YAXPAUobject_def@@@Z ENDP		; AI_PlaneHandler
_TEXT	ENDS
PUBLIC	?AI_CopterHandler@@YAXPAUobject_def@@@Z		; AI_CopterHandler
PUBLIC	__real@43c80000
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_CopterHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv205 = -120						; size = 8
tv186 = -120						; size = 8
tv198 = -112						; size = 8
tv179 = -112						; size = 8
tv66 = -108						; size = 4
_copter$ = -40						; size = 4
_mat$ = -36						; size = 36
_obj$ = 8						; size = 4
?AI_CopterHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_CopterHandler, COMDAT

; 700  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 701  : 	MAT mat;
; 702  : 	COPTER_OBJ *copter = (COPTER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _copter$[ebp], ecx

; 703  : 
; 704  : // move the copter
; 705  : 	switch (copter->State) {

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $L82643
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $L82642
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $L82641
	jmp	SHORT $L82638
$L82641:

; 706  : 	case COPTER_WAIT:
; 707  : 		CopterWait(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?CopterWait@@YAXPAUobject_def@@@Z	; CopterWait
	add	esp, 4

; 708  : 		break;

	jmp	SHORT $L82638
$L82642:

; 709  : 	case COPTER_TURNING:
; 710  : 		TurnCopter(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?TurnCopter@@YAXPAUobject_def@@@Z	; TurnCopter
	add	esp, 4

; 711  : 		break;

	jmp	SHORT $L82638
$L82643:

; 712  : 	case COPTER_FLYING:
; 713  : 		FlyCopter(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?FlyCopter@@YAXPAUobject_def@@@Z	; FlyCopter
	add	esp, 4
$L82638:

; 714  : 		break;
; 715  : 	default:
; 716  : 		break;
; 717  : 	}
; 718  : 
; 719  : 
; 720  : // set blade world pos / mat
; 721  : 
; 722  : 	RotMatrixY(&mat, (float)TIME2MS(CurrentTimer()) / 500.0f);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR tv179[ebp], eax
	mov	DWORD PTR tv179[ebp+4], 0
	fild	QWORD PTR tv179[ebp]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR tv186[ebp], eax
	mov	DWORD PTR tv186[ebp+4], 0
	fild	QWORD PTR tv186[ebp]
	fdivp	ST(1), ST(0)
	fdiv	DWORD PTR __real@43fa0000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 723  : 	MulMatrix(&obj->body.Centre.WMatrix, &mat, &copter->BladeMatrix1);

	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 724  : 	RotTransVector(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &CopterBlade1Off, &copter->BladePos1);

	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET FLAT:_CopterBlade1Off
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 725  : 
; 726  : 	RotMatrixX(&mat, (float)TIME2MS(CurrentTimer()) / 400.0f);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR tv198[ebp], eax
	mov	DWORD PTR tv198[ebp+4], 0
	fild	QWORD PTR tv198[ebp]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR tv205[ebp], eax
	mov	DWORD PTR tv205[ebp+4], 0
	fild	QWORD PTR tv205[ebp]
	fdivp	ST(1), ST(0)
	fdiv	DWORD PTR __real@43c80000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotMatrixX@@YAXPATMatrixUnion@@M@Z	; RotMatrixX
	add	esp, 8

; 727  : 	MulMatrix(&obj->body.Centre.WMatrix, &mat, &copter->BladeMatrix2);

	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 728  : 	RotTransVector(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &CopterBlade2Off, &copter->BladePos2);

	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET FLAT:_CopterBlade2Off
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 729  : 
; 730  : // update sfx pos
; 731  : #ifdef _PC
; 732  : 	if (obj->Sfx3D)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+680], 0
	je	SHORT $L82633

; 733  : 	{
; 734  : 		CopyVec(&obj->body.Centre.Pos, &obj->Sfx3D->Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+36], eax
$L82633:

; 735  : 	}
; 736  : #endif
; 737  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_CopterHandler@@YAXPAUobject_def@@@Z ENDP		; AI_CopterHandler
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?TurnCopter@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_copter$ = -4						; size = 4
_obj$ = 8						; size = 4
?TurnCopter@@YAXPAUobject_def@@@Z PROC NEAR		; TurnCopter, COMDAT

; 741  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 742  : 	COPTER_OBJ *copter = (COPTER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _copter$[ebp], ecx

; 743  : 
; 744  : 	//if (copter->TurnTime >= 5) {
; 745  : 	//	NewCopterDest(obj);
; 746  : 		copter->State = COPTER_FLYING;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+104], 0

; 747  : 		return;
; 748  : 	//}
; 749  : 
; 750  : 	// Interpolate to new destination quaternion
; 751  : 	SLerpQuat(&copter->OldInitialQuat, &copter->InitialQuat, copter->TurnTime / 5, &copter->CurrentUpQuat);
; 752  : 	NormalizeQuat(&copter->CurrentUpQuat);
; 753  : 	CopyQuat(&copter->CurrentUpQuat, &obj->body.Centre.Quat);
; 754  : 	copter->TurnTime += TimeStep;
; 755  : 
; 756  : 	// Set the copters matrix
; 757  : 	QuatToMat(&obj->body.Centre.Quat, &obj->body.Centre.WMatrix);
; 758  : 
; 759  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnCopter@@YAXPAUobject_def@@@Z ENDP			; TurnCopter
_TEXT	ENDS
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?NewCopterDest@@YAXPAUobject_def@@@Z		; NewCopterDest
PUBLIC	__real@40a00000
PUBLIC	__real@3727c5ac
PUBLIC	__real@41200000
PUBLIC	__real@40200000
PUBLIC	__real@40490fdb
PUBLIC	__real@be19999a
EXTRN	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z:NEAR ; QuatToMat
EXTRN	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z:NEAR	; SLerpQuat
EXTRN	?UpVec@@3UVectorStruct@@A:BYTE			; UpVec
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@be19999a
CONST	SEGMENT
__real@be19999a DD 0be19999ar			; -0.15
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?FlyCopter@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_qLen$82682 = -72					; size = 4
_qLen$82678 = -68					; size = 4
_copter$ = -64						; size = 4
_dQuat$ = -60						; size = 16
_axis$ = -44						; size = 12
_dR$ = -32						; size = 12
_t$ = -20						; size = 4
_vel$ = -16						; size = 4
_velDest$ = -12						; size = 4
_dRLen$ = -8						; size = 4
_reachedDest$ = -1					; size = 1
_obj$ = 8						; size = 4
?FlyCopter@@YAXPAUobject_def@@@Z PROC NEAR		; FlyCopter, COMDAT

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 764  : 	bool reachedDest;
; 765  : 	REAL dRLen, velDest, vel, t;
; 766  : 	VEC dR, axis;
; 767  : 	QUATERNION dQuat;
; 768  : 	COPTER_OBJ *copter = (COPTER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _copter$[ebp], ecx

; 769  : 
; 770  : 	reachedDest = FALSE;

	mov	BYTE PTR _reachedDest$[ebp], 0

; 771  : 
; 772  : 	// Get distance from destination
; 773  : 	VecMinusVec(&obj->body.Centre.Pos, &copter->Destination, &dR);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+184]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+188]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR [ecx+192]
	fstp	DWORD PTR _dR$[ebp+8]

; 774  : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 775  : 
; 776  : 	// If have reached destination, choose a new one
; 777  : 	if (dRLen < 10) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@41200000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82670

; 778  : 		reachedDest = TRUE;

	mov	BYTE PTR _reachedDest$[ebp], 1
$L82670:

; 779  : 	}
; 780  : 
; 781  : 	// accelerate/ decelerate towards destination
; 782  : 	velDest = (dRLen);

	mov	eax, DWORD PTR _dRLen$[ebp]
	mov	DWORD PTR _velDest$[ebp], eax

; 783  : 	if (velDest > copter->MaxVel) velDest = copter->MaxVel;

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _velDest$[ebp]
	fcomp	DWORD PTR [eax+208]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82671
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR _velDest$[ebp], ecx
$L82671:

; 784  : 
; 785  : 	vel = VecLen(&obj->body.Centre.Vel);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [eax+36]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR [edx+40]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _vel$[ebp]

; 786  : 	if (vel < velDest) {

	fld	DWORD PTR _vel$[ebp]
	fcomp	DWORD PTR _velDest$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82673

; 787  : 		vel += copter->Acc * TimeStep;

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+212]
	fadd	DWORD PTR _vel$[ebp]
	fstp	DWORD PTR _vel$[ebp]

; 788  : 	} else if (vel > velDest) {

	jmp	SHORT $L82674
$L82673:
	fld	DWORD PTR _vel$[ebp]
	fcomp	DWORD PTR _velDest$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82674

; 789  : 		vel = velDest;

	mov	eax, DWORD PTR _velDest$[ebp]
	mov	DWORD PTR _vel$[ebp], eax
$L82674:

; 790  : 	}
; 791  : 	if (vel < ZERO) {

	fld	DWORD PTR _vel$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82676

; 792  : 		vel = ZERO;

	mov	DWORD PTR _vel$[ebp], 0

; 793  : 		reachedDest = TRUE;

	mov	BYTE PTR _reachedDest$[ebp], 1
$L82676:

; 794  : 	}
; 795  : 
; 796  : 	// Move the copter
; 797  : 	VecEqScalarVec(&obj->body.Centre.Vel, vel, &copter->Direction);

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+40]

; 798  : 	VecPlusEqScalarVec(&obj->body.Centre.Pos, TimeStep, &obj->body.Centre.Vel);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [edx+28]

; 799  : 
; 800  : 
; 801  : 	// Interpolate to new destination quaternion
; 802  : 	t = HALF * ((float)sin(((copter->TurnTime - 2.5f) / 5) * PI) + ONE);

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+156]
	fsub	DWORD PTR __real@40200000
	fdiv	DWORD PTR __real@40a00000
	fmul	DWORD PTR __real@40490fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fadd	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@3f000000
	fstp	DWORD PTR _t$[ebp]

; 803  : 	SLerpQuat(&copter->OldInitialQuat, &copter->InitialQuat, t, &copter->CurrentUpQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _copter$[ebp]
	add	edx, 124				; 0000007cH
	push	edx
	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	call	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ; SLerpQuat
	add	esp, 16					; 00000010H

; 804  : 	NormalizeQuat(&copter->CurrentUpQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+140]
	fmul	DWORD PTR [ecx+140]
	mov	edx, DWORD PTR _copter$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [edx+144]
	fmul	DWORD PTR [eax+144]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [ecx+148]
	fmul	DWORD PTR [edx+148]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+152]
	fmul	DWORD PTR [ecx+152]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$82678[ebp]
	fld	DWORD PTR _qLen$82678[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82680
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$82678[ebp]
	fstp	DWORD PTR _qLen$82678[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _qLen$82678[ebp]
	fmul	DWORD PTR [eax+140]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _qLen$82678[ebp]
	fmul	DWORD PTR [eax+144]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _qLen$82678[ebp]
	fmul	DWORD PTR [eax+148]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+148]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _qLen$82678[ebp]
	fmul	DWORD PTR [eax+152]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+152]
$L82680:

; 805  : 	copter->TurnTime += TimeStep;

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+156]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+156]

; 806  : 	if (copter->TurnTime >= 5) copter->TurnTime = 5;

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+156]
	fcomp	DWORD PTR __real@40a00000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82681
	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+156], 1084227584		; 40a00000H
$L82681:

; 807  : 
; 808  : 
; 809  : 	VecCrossVec(&copter->Direction, &UpVec, &axis);

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+204]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _axis$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [ecx+196]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _axis$[ebp+4]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fmul	DWORD PTR [ecx+200]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _axis$[ebp+8]

; 810  : 	VecMulScalar(&axis, -0.15f * vel / copter->MaxVel);

	fld	DWORD PTR __real@be19999a
	fmul	DWORD PTR _vel$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fdiv	DWORD PTR [eax+208]
	fmul	DWORD PTR _axis$[ebp]
	fstp	DWORD PTR _axis$[ebp]
	fld	DWORD PTR __real@be19999a
	fmul	DWORD PTR _vel$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fdiv	DWORD PTR [eax+208]
	fmul	DWORD PTR _axis$[ebp+4]
	fstp	DWORD PTR _axis$[ebp+4]
	fld	DWORD PTR __real@be19999a
	fmul	DWORD PTR _vel$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fdiv	DWORD PTR [eax+208]
	fmul	DWORD PTR _axis$[ebp+8]
	fstp	DWORD PTR _axis$[ebp+8]

; 811  : 	//VecMulQuat(&axis, &copter->InitialQuat, &dQuat);
; 812  : 	//QuatPlusQuat(&copter->InitialQuat, &dQuat, &obj->body.Centre.Quat);
; 813  : 	VecMulQuat(&axis, &copter->CurrentUpQuat, &dQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp]
	fmul	DWORD PTR [eax+152]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+4]
	fmul	DWORD PTR [ecx+148]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+8]
	fmul	DWORD PTR [edx+144]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _dQuat$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+4]
	fmul	DWORD PTR [eax+152]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+8]
	fmul	DWORD PTR [ecx+140]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp]
	fmul	DWORD PTR [edx+148]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _dQuat$[ebp+4]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+8]
	fmul	DWORD PTR [eax+152]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp]
	fmul	DWORD PTR [ecx+144]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+4]
	fmul	DWORD PTR [edx+140]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _dQuat$[ebp+8]
	fld	DWORD PTR _axis$[ebp]
	fchs
	mov	eax, DWORD PTR _copter$[ebp]
	fmul	DWORD PTR [eax+140]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+4]
	fmul	DWORD PTR [ecx+144]
	fsubp	ST(1), ST(0)
	mov	edx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _axis$[ebp+8]
	fmul	DWORD PTR [edx+148]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _dQuat$[ebp+12]

; 814  : 	QuatPlusQuat(&copter->CurrentUpQuat, &dQuat, &obj->body.Centre.Quat);

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _dQuat$[ebp]
	fadd	DWORD PTR [eax+140]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _dQuat$[ebp+4]
	fadd	DWORD PTR [eax+144]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _dQuat$[ebp+8]
	fadd	DWORD PTR [eax+148]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR _dQuat$[ebp+12]
	fadd	DWORD PTR [eax+152]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+80]

; 815  : 	NormalizeQuat(&obj->body.Centre.Quat);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+76]
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+80]
	fmul	DWORD PTR [ecx+80]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$82682[ebp]
	fld	DWORD PTR _qLen$82682[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82684
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$82682[ebp]
	fstp	DWORD PTR _qLen$82682[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _qLen$82682[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _qLen$82682[ebp]
	fmul	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _qLen$82682[ebp]
	fmul	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _qLen$82682[ebp]
	fmul	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+80]
$L82684:

; 816  : 	QuatToMat(&obj->body.Centre.Quat, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	call	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z ; QuatToMat
	add	esp, 8

; 817  : 
; 818  : 	if (reachedDest) {	

	movzx	eax, BYTE PTR _reachedDest$[ebp]
	test	eax, eax
	je	SHORT $L82658

; 819  : 		NewCopterDest(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?NewCopterDest@@YAXPAUobject_def@@@Z	; NewCopterDest
	add	esp, 4

; 820  : 		copter->State = COPTER_TURNING;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+104], 1
$L82658:

; 821  : 	}
; 822  : 
; 823  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlyCopter@@YAXPAUobject_def@@@Z ENDP			; FlyCopter
_TEXT	ENDS
PUBLIC	_sinf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC NEAR					; sin, COMDAT

; 575  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sinf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
EXTRN	_sin:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sinf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sinf	PROC NEAR					; COMDAT

; 466  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
PUBLIC	__real@40000000
;	COMDAT __real@40000000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\ai.cpp
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CopterWait@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_copter$ = -8						; size = 4
_dPosLen$ = -4						; size = 4
_obj$ = 8						; size = 4
?CopterWait@@YAXPAUobject_def@@@Z PROC NEAR		; CopterWait, COMDAT

; 826  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 827  : 	REAL dPosLen;
; 828  : 	COPTER_OBJ *copter = (COPTER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _copter$[ebp], ecx

; 829  : 
; 830  : 	// wait for 2 seconds
; 831  : 	copter->TurnTime += TimeStep;

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+156]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+156]

; 832  : 	if (copter->TurnTime > 2) {

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+156]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82688

; 833  : 
; 834  : 		// Choose new destination
; 835  : 		SetVec(&copter->Destination,
; 836  : 			obj->body.Centre.Pos.v[X] - 600 * obj->body.Centre.WMatrix.mv[L].v[X],
; 837  : 			copter->FlyBox.YMin,
; 838  : 			obj->body.Centre.Pos.v[Z] - 600 * obj->body.Centre.WMatrix.mv[L].v[Z]);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@44160000
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _obj$[ebp]
	fsubr	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+184]
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [eax+188], edx
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@44160000
	fmul	DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _obj$[ebp]
	fsubr	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+192]

; 839  : 		VecMinusVec(&copter->Destination, &obj->body.Centre.Pos, &copter->Direction);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+184]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+196]
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+188]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+200]
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+192]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+204]

; 840  : 		dPosLen = VecLen(&copter->Direction);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+196]
	fmul	DWORD PTR [ecx+196]
	mov	edx, DWORD PTR _copter$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [edx+200]
	fmul	DWORD PTR [eax+200]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [ecx+204]
	fmul	DWORD PTR [edx+204]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dPosLen$[ebp]

; 841  : 		VecDivScalar(&copter->Direction, dPosLen);

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+196]
	fdiv	DWORD PTR _dPosLen$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+196]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+200]
	fdiv	DWORD PTR _dPosLen$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+200]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+204]
	fdiv	DWORD PTR _dPosLen$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+204]

; 842  : 		CopyQuat(&copter->CurrentUpQuat, &copter->OldInitialQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+112], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+116], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+120], edx

; 843  : 		copter->State = COPTER_FLYING;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+104], 0
$L82688:

; 844  : 	}
; 845  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopterWait@@YAXPAUobject_def@@@Z ENDP			; CopterWait
_TEXT	ENDS
PUBLIC	__real@46fffe00
PUBLIC	__real@3e4ccccd
EXTRN	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z:NEAR ; MatToQuat
EXTRN	?DownVec@@3UVectorStruct@@A:BYTE		; DownVec
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewCopterDest@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv414 = -132						; size = 4
tv371 = -132						; size = 4
tv364 = -132						; size = 4
tv357 = -132						; size = 4
_copter$ = -64						; size = 4
_look$ = -60						; size = 12
_lookLen$ = -48						; size = 4
_dPosLen$ = -44						; size = 4
_newMat$ = -40						; size = 36
_its$ = -4						; size = 4
_obj$ = 8						; size = 4
?NewCopterDest@@YAXPAUobject_def@@@Z PROC NEAR		; NewCopterDest, COMDAT

; 849  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 850  : 	int its;
; 851  : 	MAT newMat;
; 852  : 	REAL dPosLen, lookLen;
; 853  : 	VEC look;
; 854  : 	COPTER_OBJ *copter = (COPTER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _copter$[ebp], ecx

; 855  : 
; 856  : 	SetVecZero(&obj->body.Centre.Vel);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+40], 0

; 857  : 	CopyQuat(&copter->CurrentUpQuat, &copter->OldInitialQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+112], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+116], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+120], edx

; 858  : 	copter->TurnTime = ZERO;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+156], 0

; 859  : 
; 860  : 	// Choose a new destination
; 861  : 	its = 0;

	mov	DWORD PTR _its$[ebp], 0
$L82704:

; 862  : 	do {
; 863  : 		SetVec(&copter->Destination, 
; 864  : 			copter->FlyBox.XMin + frand(ONE) * (copter->FlyBox.XMax - copter->FlyBox.XMin),
; 865  : 			copter->FlyBox.YMin + frand(ONE) * (copter->FlyBox.YMax - copter->FlyBox.YMin),
; 866  : 			copter->FlyBox.ZMin + frand(ONE) * (copter->FlyBox.ZMax - copter->FlyBox.ZMin));

	call	_rand
	mov	DWORD PTR tv357[ebp], eax
	fild	DWORD PTR tv357[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+164]
	fsub	DWORD PTR [ecx+160]
	fmulp	ST(1), ST(0)
	mov	edx, DWORD PTR _copter$[ebp]
	fadd	DWORD PTR [edx+160]
	mov	eax, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [eax+184]
	call	_rand
	mov	DWORD PTR tv364[ebp], eax
	fild	DWORD PTR tv364[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+172]
	fsub	DWORD PTR [ecx+168]
	fmulp	ST(1), ST(0)
	mov	edx, DWORD PTR _copter$[ebp]
	fadd	DWORD PTR [edx+168]
	mov	eax, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [eax+188]
	call	_rand
	mov	DWORD PTR tv371[ebp], eax
	fild	DWORD PTR tv371[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+180]
	fsub	DWORD PTR [ecx+176]
	fmulp	ST(1), ST(0)
	mov	edx, DWORD PTR _copter$[ebp]
	fadd	DWORD PTR [edx+176]
	mov	eax, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [eax+192]

; 867  : 		VecMinusVec(&copter->Destination, &obj->body.Centre.Pos, &copter->Direction);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+184]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+196]
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+188]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+200]
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+192]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+204]

; 868  : 		dPosLen = VecLen(&copter->Direction);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+196]
	fmul	DWORD PTR [ecx+196]
	mov	edx, DWORD PTR _copter$[ebp]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [edx+200]
	fmul	DWORD PTR [eax+200]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [ecx+204]
	fmul	DWORD PTR [edx+204]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dPosLen$[ebp]

; 869  : 	} while (dPosLen < Real(1000) && ++its < 10);

	fld	DWORD PTR _dPosLen$[ebp]
	fcomp	DWORD PTR __real@447a0000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82706
	mov	eax, DWORD PTR _its$[ebp]
	add	eax, 1
	mov	DWORD PTR _its$[ebp], eax
	cmp	DWORD PTR _its$[ebp], 10		; 0000000aH
	jl	$L82704
$L82706:

; 870  : 	VecDivScalar(&copter->Direction, dPosLen);

	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+196]
	fdiv	DWORD PTR _dPosLen$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+196]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+200]
	fdiv	DWORD PTR _dPosLen$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+200]
	mov	eax, DWORD PTR _copter$[ebp]
	fld	DWORD PTR [eax+204]
	fdiv	DWORD PTR _dPosLen$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [ecx+204]

; 871  : 
; 872  : 	// Choose a new default orientation
; 873  : 	if (frand(ONE) > Real(0.2)) {

	call	_rand
	mov	DWORD PTR tv414[ebp], eax
	fild	DWORD PTR tv414[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	fcomp	DWORD PTR __real@3e4ccccd
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82715

; 874  : 		SetVec(&look, copter->Direction.v[X], ZERO, copter->Direction.v[Z]);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	DWORD PTR _look$[ebp], ecx
	mov	DWORD PTR _look$[ebp+4], 0
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	DWORD PTR _look$[ebp+8], ecx

; 875  : 		lookLen = VecLen(&look);

	fld	DWORD PTR _look$[ebp]
	fmul	DWORD PTR _look$[ebp]
	fld	DWORD PTR _look$[ebp+4]
	fmul	DWORD PTR _look$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _look$[ebp+8]
	fmul	DWORD PTR _look$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _lookLen$[ebp]

; 876  : 		if (lookLen > SMALL_REAL) {

	fld	DWORD PTR _lookLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82715

; 877  : 			VecDivScalar(&look, lookLen);

	fld	DWORD PTR _look$[ebp]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _look$[ebp]
	fld	DWORD PTR _look$[ebp+4]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _look$[ebp+4]
	fld	DWORD PTR _look$[ebp+8]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _look$[ebp+8]

; 878  : 			CopyVec(&look, &newMat.mv[L]);

	mov	eax, DWORD PTR _look$[ebp]
	mov	DWORD PTR _newMat$[ebp+24], eax
	mov	eax, DWORD PTR _look$[ebp+4]
	mov	DWORD PTR _newMat$[ebp+28], eax
	mov	eax, DWORD PTR _look$[ebp+8]
	mov	DWORD PTR _newMat$[ebp+32], eax

; 879  : 			CopyVec(&DownVec, &newMat.mv[U]);

	mov	eax, DWORD PTR ?DownVec@@3UVectorStruct@@A
	mov	DWORD PTR _newMat$[ebp+12], eax
	mov	eax, DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	mov	DWORD PTR _newMat$[ebp+16], eax
	mov	eax, DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	mov	DWORD PTR _newMat$[ebp+20], eax

; 880  : 			VecCrossVec(&DownVec, &look, &newMat.mv[R]);

	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR _look$[ebp+8]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR _look$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _newMat$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR _look$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR _look$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _newMat$[ebp+4]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR _look$[ebp+4]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR _look$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _newMat$[ebp+8]

; 881  : 			MatToQuat(&newMat, &copter->InitialQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	lea	ecx, DWORD PTR _newMat$[ebp]
	push	ecx
	call	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z ; MatToQuat
	add	esp, 8
$L82715:

; 882  : 		}
; 883  : 	}
; 884  : 
; 885  : 	copter->State = COPTER_FLYING;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+104], 0

; 886  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NewCopterDest@@YAXPAUobject_def@@@Z ENDP		; NewCopterDest
_TEXT	ENDS
PUBLIC	?AI_DragonHandler@@YAXPAUobject_def@@@Z		; AI_DragonHandler
PUBLIC	__real@40c00000
PUBLIC	__real@41000000
PUBLIC	__real@40800000
PUBLIC	__real@400ccccd
PUBLIC	__real@40c90fdb
PUBLIC	__real@3cf5c28f
PUBLIC	__real@40c66666
PUBLIC	__real@43e00000
PUBLIC	__real@42000000
PUBLIC	__real@3e800000
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3c23d70a
PUBLIC	__real@40900000
PUBLIC	__real@43ff8000
EXTRN	?AllocLight@@YAPAULIGHT@@XZ:NEAR		; AllocLight
EXTRN	?FreeLight@@YAXPAULIGHT@@@Z:NEAR		; FreeLight
EXTRN	?SetModelMorph@@YAXPAUMODEL@@JJM@Z:NEAR		; SetModelMorph
EXTRN	?LevelModel@@3PAULEVEL_MODEL@@A:BYTE		; LevelModel
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@400ccccd
CONST	SEGMENT
__real@400ccccd DD 0400ccccdr			; 2.2
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@40c66666
CONST	SEGMENT
__real@40c66666 DD 040c66666r			; 6.2
CONST	ENDS
;	COMDAT __real@43e00000
CONST	SEGMENT
__real@43e00000 DD 043e00000r			; 448
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@40900000
CONST	SEGMENT
__real@40900000 DD 040900000r			; 4.5
CONST	ENDS
;	COMDAT __real@43ff8000
CONST	SEGMENT
__real@43ff8000 DD 043ff8000r			; 511
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_DragonHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv651 = -152						; size = 4
tv672 = -148						; size = 4
tv668 = -148						; size = 4
tv664 = -148						; size = 4
tv649 = -148						; size = 4
tv647 = -148						; size = 4
__temp$82786 = -80					; size = 4
__temp$82776 = -76					; size = 4
__temp$82754 = -72					; size = 4
_dragon$ = -68						; size = 4
_mat$ = -64						; size = 36
_vec$ = -28						; size = 12
_model$ = -16						; size = 4
_col$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_DragonHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_DragonHandler, COMDAT

; 894  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi

; 895  : 	long i, j, col;
; 896  : 	MODEL *model;
; 897  : 	VEC vec;
; 898  : 	MAT mat;
; 899  : 	DRAGON_OBJ *dragon = (DRAGON_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _dragon$[ebp], ecx

; 900  : 
; 901  : // quit if not visible and waiting
; 902  : 
; 903  : 	if (!obj->renderflag.visible && dragon->Count > 6.0f)

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L82729
	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40c00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82729

; 904  : 		return;

	jmp	$L82720
$L82729:

; 905  : 
; 906  : // get morph model
; 907  : 
; 908  : 	if (dragon->HeadModel)

	mov	eax, DWORD PTR _dragon$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L82730

; 909  : 		model = &LevelModel[dragon->HeadModel].Model;

	mov	eax, DWORD PTR _dragon$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	add	ecx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	mov	DWORD PTR _model$[ebp], ecx

; 910  : 	else

	jmp	SHORT $L82731
$L82730:

; 911  : 		model = NULL;

	mov	DWORD PTR _model$[ebp], 0
$L82731:

; 912  : 
; 913  : // inc anim count
; 914  : 
; 915  : 	dragon->Count += TimeStep;

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+12]

; 916  : 	if (dragon->Count > 8.0f) dragon->Count -= 8.0f;

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@41000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82732
	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR __real@41000000
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+12]
$L82732:

; 917  : 
; 918  : // handle morphs
; 919  : 
; 920  : 	if (model)

	cmp	DWORD PTR _model$[ebp], 0
	je	$L82733

; 921  : 	{
; 922  : 		if (dragon->Count <= 2.0f)

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82734

; 923  : 		{
; 924  : 			SetModelMorph(model, 0, 1, dragon->Count / 2.0f);

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fdiv	DWORD PTR __real@40000000
	push	ecx
	fstp	DWORD PTR [esp]
	push	1
	push	0
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	?SetModelMorph@@YAXPAUMODEL@@JJM@Z	; SetModelMorph
	add	esp, 16					; 00000010H

; 925  : 		}
; 926  : 
; 927  : 		else if (dragon->Count <= 4.0f)

	jmp	$L82733
$L82734:
	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82736

; 928  : 		{
; 929  : 			if (dragon->Count < 2.2f)

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@400ccccd
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82737

; 930  : 				SetModelMorph(model, 0, 1, (float)sin((dragon->Count - 2.0f) * 2.5f * RAD) * 0.03f + 1.0f);

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR __real@40000000
	fmul	DWORD PTR __real@40200000
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fmul	DWORD PTR __real@3cf5c28f
	fadd	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	push	1
	push	0
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	?SetModelMorph@@YAXPAUMODEL@@JJM@Z	; SetModelMorph
	add	esp, 16					; 00000010H

; 931  : 			else

	jmp	SHORT $L82739
$L82737:

; 932  : 				SetModelMorph(model, 1, 0, 0);

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?SetModelMorph@@YAXPAUMODEL@@JJM@Z	; SetModelMorph
	add	esp, 16					; 00000010H
$L82739:

; 933  : 		}
; 934  : 
; 935  : 		else if (dragon->Count <= 6.0f)

	jmp	$L82733
$L82736:
	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40c00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82741

; 936  : 		{
; 937  : 			SetModelMorph(model, 0, 1, (6.0f - dragon->Count) / 2.0f);

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR __real@40c00000
	fsub	DWORD PTR [eax+12]
	fdiv	DWORD PTR __real@40000000
	push	ecx
	fstp	DWORD PTR [esp]
	push	1
	push	0
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	?SetModelMorph@@YAXPAUMODEL@@JJM@Z	; SetModelMorph
	add	esp, 16					; 00000010H

; 938  : 		}
; 939  : 
; 940  : 		else

	jmp	SHORT $L82733
$L82741:

; 941  : 		{
; 942  : 			if (dragon->Count < 6.2f)

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40c66666
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82743

; 943  : 				SetModelMorph(model, 1, 0, (float)sin((dragon->Count - 6.0f) * 2.5f * RAD) * 0.03f + 1.0f);

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR __real@40c00000
	fmul	DWORD PTR __real@40200000
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fmul	DWORD PTR __real@3cf5c28f
	fadd	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	push	1
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	?SetModelMorph@@YAXPAUMODEL@@JJM@Z	; SetModelMorph
	add	esp, 16					; 00000010H

; 944  : 			else

	jmp	SHORT $L82733
$L82743:

; 945  : 				SetModelMorph(model, 0, 0, 0);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?SetModelMorph@@YAXPAUMODEL@@JJM@Z	; SetModelMorph
	add	esp, 16					; 00000010H
$L82733:

; 946  : 		}
; 947  : 	}
; 948  : 
; 949  : // firestarter?
; 950  : 
; 951  : 	if (dragon->Count > 2.0f && dragon->Count < 4.0f)

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82746
	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40800000
	fnstsw	ax
	test	ah, 5
	jp	$L82746

; 952  : 	{
; 953  : 
; 954  : // yep, gen light?
; 955  : 
; 956  : 		if (!obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	jne	$L82747

; 957  : 		{
; 958  : 			obj->Light = AllocLight();

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 959  : 			if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	$L82747

; 960  : 			{
; 961  : 				CopyVec(&dragon->FireGenPoint, (VEC*)&obj->Light->x);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _dragon$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _dragon$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _dragon$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+8], eax

; 962  : 				obj->Light->Reach = 1024;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+12], 1149239296		; 44800000H

; 963  : 				obj->Light->Flag = LIGHT_FIXED | LIGHT_MOVING;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+100], 3

; 964  : 				obj->Light->Type= LIGHT_OMNINORMAL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+101], 1

; 965  : 				obj->Light->r = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+88], 0

; 966  : 				obj->Light->g = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+92], 0

; 967  : 				obj->Light->b = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+96], 0

; 968  : 
; 969  : 				obj->Sfx3D = CreateSfx3D(SFX_TOY_DRAGON, SFX_MAX_VOL, 22050, FALSE, &dragon->FireGenPoint);

	mov	eax, DWORD PTR _dragon$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	0
	push	22050					; 00005622H
	push	127					; 0000007fH
	push	20					; 00000014H
	call	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ; CreateSfx3D
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+680], eax
$L82747:

; 970  : 			}
; 971  : 		}		
; 972  : 
; 973  : // flicker light?
; 974  : 
; 975  : 		if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	$L82752

; 976  : 		{
; 977  : 			if (dragon->Count < 2.5f)

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40200000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82753

; 978  : 			{
; 979  : 				FTOL((dragon->Count - 2.0f) * 448, obj->Light->r);

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR __real@40000000
	fmul	DWORD PTR __real@43e00000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82754[ebp]
	mov	eax, DWORD PTR __temp$82754[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+88], eax

; 980  : 				obj->Light->r += rand() & 31;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	esi, DWORD PTR [eax+672]
	call	_rand
	and	eax, 31					; 0000001fH
	add	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+88], eax

; 981  : 			}
; 982  : 			else

	jmp	SHORT $L82757
$L82753:

; 983  : 			{
; 984  : 				obj->Light->r = (rand() & 31) + 224;

	call	_rand
	and	eax, 31					; 0000001fH
	add	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+88], eax
$L82757:

; 985  : 			}
; 986  : 
; 987  : 			obj->Light->g = obj->Light->r >> 1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR [ecx+88]
	sar	edx, 1
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+92], edx
$L82752:

; 988  : 		}
; 989  : 
; 990  : // new fire?
; 991  : 
; 992  : 		if ((long)(CurrentTimer() - dragon->FireGenTime) >= 0)

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, DWORD PTR _dragon$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	js	$L82759

; 993  : 		{
; 994  : 			
; 995  : 			for (j = 0 ; j < 2 ; j++) for (i = 0 ; i < DRAGON_FIRE_NUM ; i++) if (!dragon->Fire[i].Time)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L82760
$L82761:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L82760:
	cmp	DWORD PTR _j$[ebp], 2
	jge	$L82759
	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82763
$L82764:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82763:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	$L82765
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [ecx+eax+44]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$L82766

; 996  : 			{
; 997  : 				SetVector(&vec, 0, 0, frand(32));

	mov	DWORD PTR _vec$[ebp], 0
	mov	DWORD PTR _vec$[ebp+4], 0
	call	_rand
	mov	DWORD PTR tv647[ebp], eax
	fild	DWORD PTR tv647[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fstp	DWORD PTR _vec$[ebp+8]

; 998  : 				RotMatrixZYX(&mat, 0, frand(1.0f), frand(0.5f) - 0.25f);

	call	_rand
	mov	DWORD PTR tv649[ebp], eax
	fild	DWORD PTR tv649[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f000000
	fsub	DWORD PTR __real@3e800000
	push	ecx
	fstp	DWORD PTR [esp]
	call	_rand
	mov	DWORD PTR tv651[ebp], eax
	fild	DWORD PTR tv651[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 999  : 				RotTransVector(&mat, &dragon->FireGenPoint, &vec, &dragon->Fire[i].Pos);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	lea	edx, DWORD PTR [ecx+eax+64]
	push	edx
	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dragon$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1000 : 
; 1001 : 				dragon->Fire[i].Time = 0.5f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [ecx+eax+44], 1056964608	; 3f000000H

; 1002 : 				dragon->Fire[i].MinSize = frand(8) + 8;

	call	_rand
	mov	DWORD PTR tv664[ebp], eax
	fild	DWORD PTR tv664[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@41000000
	fadd	DWORD PTR __real@41000000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+eax+48]

; 1003 : 				dragon->Fire[i].Spin = frand(1);

	call	_rand
	mov	DWORD PTR tv668[ebp], eax
	fild	DWORD PTR tv668[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+eax+56]

; 1004 : 				dragon->Fire[i].SpinSpeed = frand(0.02f) - 0.01f;

	call	_rand
	mov	DWORD PTR tv672[ebp], eax
	fild	DWORD PTR tv672[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3ca3d70a
	fsub	DWORD PTR __real@3c23d70a
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+eax+60]

; 1005 : 
; 1006 : 				dragon->FireGenTime = CurrentTimer() + MS2TIME(20);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	imul	eax, 20					; 00000014H
	add	ecx, eax
	mov	edx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1007 : 				break;

	jmp	SHORT $L82765
$L82766:

; 1008 : 			}
; 1009 : 		}

	jmp	$L82764
$L82765:
	jmp	$L82761
$L82759:

; 1010 : 	}
; 1011 : 
; 1012 : // kill light + sfx?
; 1013 : 
; 1014 : 	else

	jmp	$L82773
$L82746:

; 1015 : 	{
; 1016 : 		if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	$L82773

; 1017 : 		{
; 1018 : 			if (dragon->Count < 4.5f)

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@40900000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82775

; 1019 : 			{
; 1020 : 				FTOL((4.5f - dragon->Count) * 448, obj->Light->r);

	mov	eax, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR __real@40900000
	fsub	DWORD PTR [eax+12]
	fmul	DWORD PTR __real@43e00000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82776[ebp]
	mov	eax, DWORD PTR __temp$82776[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+88], eax

; 1021 : 				obj->Light->r += rand() & 31;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	esi, DWORD PTR [eax+672]
	call	_rand
	and	eax, 31					; 0000001fH
	add	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+88], eax

; 1022 : 				obj->Light->g = obj->Light->r >> 1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR [ecx+88]
	sar	edx, 1
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+92], edx

; 1023 : 			}
; 1024 : 			else

	jmp	SHORT $L82773
$L82775:

; 1025 : 			{
; 1026 : 				FreeLight(obj->Light);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	push	ecx
	call	?FreeLight@@YAXPAULIGHT@@@Z		; FreeLight
	add	esp, 4

; 1027 : 				obj->Light = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+672], 0

; 1028 : 
; 1029 : 				if (obj->Sfx3D) if (!obj->Sfx3D->Sample)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+680], 0
	je	SHORT $L82773
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $L82773

; 1030 : 				{
; 1031 : 					FreeSfx3D(obj->Sfx3D);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	push	ecx
	call	?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z		; FreeSfx3D
	add	esp, 4

; 1032 : 					obj->Sfx3D = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+680], 0
$L82773:

; 1033 : 				}
; 1034 : 			}
; 1035 : 		}
; 1036 : 	}
; 1037 : 
; 1038 : // maintain existing fire
; 1039 : 
; 1040 : 	for (i = 0 ; i < DRAGON_FIRE_NUM ; i++) if (dragon->Fire[i].Time)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82782
$L82783:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82782:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	$L82720
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [ecx+eax+44]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$L82785

; 1041 : 	{
; 1042 : 		dragon->Fire[i].Pos.v[X] += dragon->FireGenDir.v[X] * TimeFactor;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _dragon$[ebp]
	fadd	DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+eax+64]

; 1043 : 		dragon->Fire[i].Pos.v[Y] += dragon->FireGenDir.v[Y] * TimeFactor;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _dragon$[ebp]
	fadd	DWORD PTR [edx+eax+68]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+eax+68]

; 1044 : 		dragon->Fire[i].Pos.v[Z] += dragon->FireGenDir.v[Z] * TimeFactor;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _dragon$[ebp]
	fadd	DWORD PTR [edx+eax+72]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [ecx+eax+72]

; 1045 : 
; 1046 : 		dragon->Fire[i].Size = dragon->Fire[i].Time * 32 + dragon->Fire[i].MinSize;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [ecx+eax+44]
	fmul	DWORD PTR __real@42000000
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 72					; 00000048H
	mov	eax, DWORD PTR _dragon$[ebp]
	fadd	DWORD PTR [eax+edx+48]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 72					; 00000048H
	mov	edx, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [edx+ecx+52]

; 1047 : 
; 1048 : 		dragon->Fire[i].Spin += dragon->Fire[i].SpinSpeed * TimeFactor;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 72					; 00000048H
	mov	edx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR [edx+ecx+60]
	mov	ecx, DWORD PTR _dragon$[ebp]
	fadd	DWORD PTR [ecx+eax+56]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 72					; 00000048H
	mov	eax, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [eax+edx+56]

; 1049 : 		RotMatrixZ(&dragon->Fire[i].Matrix, dragon->Fire[i].Spin);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	edx, DWORD PTR [ecx+eax+56]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	lea	edx, DWORD PTR [ecx+eax+76]
	push	edx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 1050 : 
; 1051 : 		FTOL(dragon->Fire[i].Time * 511, col);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [ecx+eax+44]
	fmul	DWORD PTR __real@43ff8000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82786[ebp]
	mov	eax, DWORD PTR __temp$82786[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _col$[ebp], eax

; 1052 : 		dragon->Fire[i].rgb = col | (col << 8) | (col << 16);

	mov	eax, DWORD PTR _col$[ebp]
	shl	eax, 8
	or	eax, DWORD PTR _col$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [ecx+edx+40], eax

; 1053 : 
; 1054 : 		dragon->Fire[i].Time -= TimeStep;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [ecx+eax+44]
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 72					; 00000048H
	mov	eax, DWORD PTR _dragon$[ebp]
	fstp	DWORD PTR [eax+edx+44]

; 1055 : 		if (dragon->Fire[i].Time < 0) dragon->Fire[i].Time = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	fld	DWORD PTR [ecx+eax+44]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82785
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [ecx+eax+44], 0
$L82785:

; 1056 : 	}
; 1057 : }

	jmp	$L82783
$L82720:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_DragonHandler@@YAXPAUobject_def@@@Z ENDP		; AI_DragonHandler
_TEXT	ENDS
PUBLIC	?AI_WaterHandler@@YAXPAUobject_def@@@Z		; AI_WaterHandler
PUBLIC	__real@462be000
PUBLIC	__real@43400000
;	COMDAT __real@462be000
CONST	SEGMENT
__real@462be000 DD 0462be000r			; 11000
CONST	ENDS
;	COMDAT __real@43400000
CONST	SEGMENT
__real@43400000 DD 043400000r			; 192
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_WaterHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
__temp$82850 = -72					; size = 4
__mul$82827 = -68					; size = 4
_norm$ = -64						; size = 12
_vec2$ = -52						; size = 12
_vec1$ = -40						; size = 12
_mrgb$ = -28						; size = 4
_mp$ = -24						; size = 4
_mv$ = -20						; size = 4
_wv$ = -16						; size = 4
_model$ = -12						; size = 4
_water$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_WaterHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_WaterHandler, COMDAT

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 1066 : 	long i;
; 1067 : 	WATER_OBJ *water = (WATER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _water$[ebp], ecx

; 1068 : 	MODEL *model = &LevelModel[obj->DefaultModel].Model;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	add	ecx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	mov	DWORD PTR _model$[ebp], ecx

; 1069 : 	WATER_VERTEX *wv;
; 1070 : 	MODEL_VERTEX *mv;
; 1071 : 	MODEL_POLY *mp;
; 1072 : 	POLY_RGB *mrgb;
; 1073 : 	VEC vec1, vec2, norm;
; 1074 : 
; 1075 : // quit if not visible
; 1076 : 
; 1077 : 	if (!obj->renderflag.visible)

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L82804

; 1078 : 		return;

	jmp	$L82792
$L82804:

; 1079 : 
; 1080 : // move verts
; 1081 : 
; 1082 : 	wv = water->Vert;

	mov	eax, DWORD PTR _water$[ebp]
	add	eax, 8
	mov	DWORD PTR _wv$[ebp], eax

; 1083 : 	mv = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _mv$[ebp], ecx

; 1084 : 
; 1085 : 	for (i = 0 ; i < water->VertNum ; i++, wv++, mv++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82805
$L82806:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _wv$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _wv$[ebp], ecx
	mov	edx, DWORD PTR _mv$[ebp]
	add	edx, 88					; 00000058H
	mov	DWORD PTR _mv$[ebp], edx
$L82805:
	mov	eax, DWORD PTR _water$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$L82807

; 1086 : 	{
; 1087 : 		wv->Time += TimeStep;

	mov	eax, DWORD PTR _wv$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _wv$[ebp]
	fstp	DWORD PTR [ecx+4]
$L82809:

; 1088 : 		while (wv->Time >= wv->TotalTime) wv->Time -= wv->TotalTime;

	mov	eax, DWORD PTR _wv$[ebp]
	mov	ecx, DWORD PTR _wv$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82810
	mov	eax, DWORD PTR _wv$[ebp]
	mov	ecx, DWORD PTR _wv$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _wv$[ebp]
	fstp	DWORD PTR [edx+4]
	jmp	SHORT $L82809
$L82810:

; 1089 : 		mv->y = wv->Height + (float)sin(wv->Time / wv->TotalTime * RAD) * water->Scale;

	mov	eax, DWORD PTR _wv$[ebp]
	mov	ecx, DWORD PTR _wv$[ebp]
	fld	DWORD PTR [eax+4]
	fdiv	DWORD PTR [ecx+8]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	mov	edx, DWORD PTR _water$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _wv$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _mv$[ebp]
	fstp	DWORD PTR [ecx+4]

; 1090 : 
; 1091 : 		mv->nx = mv->ny = mv->nz = 0;

	mov	eax, DWORD PTR _mv$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	ecx, DWORD PTR _mv$[ebp]
	mov	DWORD PTR [ecx+28], 0
	mov	edx, DWORD PTR _mv$[ebp]
	mov	DWORD PTR [edx+24], 0

; 1092 : 		mv->a = 0;

	mov	eax, DWORD PTR _mv$[ebp]
	mov	DWORD PTR [eax+80], 0

; 1093 : 	}

	jmp	$L82806
$L82807:

; 1094 : 
; 1095 : // calc vert normals + uv's
; 1096 : 
; 1097 : 	mp = model->PolyPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _mp$[ebp], ecx

; 1098 : 
; 1099 : 	for (i = model->PolyNum ; i ; i--, mp++)

	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+32]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $L82812
$L82813:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mp$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _mp$[ebp], ecx
$L82812:
	cmp	DWORD PTR _i$[ebp], 0
	je	$L82814

; 1100 : 	{
; 1101 : 		SubVector((VEC*)&mp->v1->x, (VEC*)&mp->v0->x, &vec1);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _vec1$[ebp]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _vec1$[ebp+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR _vec1$[ebp+8]

; 1102 : 		SubVector((VEC*)&mp->v2->x, (VEC*)&mp->v0->x, &vec2);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _vec2$[ebp]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _vec2$[ebp+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR _vec2$[ebp+8]

; 1103 : 		CrossProduct(&vec2, &vec1, &norm);

	fld	DWORD PTR _vec2$[ebp+4]
	fmul	DWORD PTR _vec1$[ebp+8]
	fld	DWORD PTR _vec2$[ebp+8]
	fmul	DWORD PTR _vec1$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _norm$[ebp]
	fld	DWORD PTR _vec2$[ebp+8]
	fmul	DWORD PTR _vec1$[ebp]
	fld	DWORD PTR _vec2$[ebp]
	fmul	DWORD PTR _vec1$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _norm$[ebp+4]
	fld	DWORD PTR _vec2$[ebp]
	fmul	DWORD PTR _vec1$[ebp+4]
	fld	DWORD PTR _vec2$[ebp+4]
	fmul	DWORD PTR _vec1$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _norm$[ebp+8]

; 1104 : 		NormalizeVector(&norm);

	fld	DWORD PTR _norm$[ebp]
	fmul	DWORD PTR _norm$[ebp]
	fld	DWORD PTR _norm$[ebp+4]
	fmul	DWORD PTR _norm$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _norm$[ebp+8]
	fmul	DWORD PTR _norm$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$82827[ebp]
	fld	DWORD PTR _norm$[ebp]
	fmul	DWORD PTR __mul$82827[ebp]
	fstp	DWORD PTR _norm$[ebp]
	fld	DWORD PTR _norm$[ebp+4]
	fmul	DWORD PTR __mul$82827[ebp]
	fstp	DWORD PTR _norm$[ebp+4]
	fld	DWORD PTR _norm$[ebp+8]
	fmul	DWORD PTR __mul$82827[ebp]
	fstp	DWORD PTR _norm$[ebp+8]

; 1105 : 
; 1106 : 		AddVector((VEC*)&mp->v0->nx, &norm, (VEC*)&mp->v0->nx);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fld	DWORD PTR _norm$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fld	DWORD PTR _norm$[ebp+4]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fld	DWORD PTR _norm$[ebp+8]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fstp	DWORD PTR [eax+32]

; 1107 : 		mp->v0->a++;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+80]
	add	edx, 1
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+80], edx

; 1108 : 
; 1109 : 		AddVector((VEC*)&mp->v1->nx, &norm, (VEC*)&mp->v1->nx);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR _norm$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR _norm$[ebp+4]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR _norm$[ebp+8]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fstp	DWORD PTR [eax+32]

; 1110 : 		mp->v1->a++;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+80]
	add	edx, 1
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [ecx+80], edx

; 1111 : 
; 1112 : 		AddVector((VEC*)&mp->v2->nx, &norm, (VEC*)&mp->v2->nx);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fld	DWORD PTR _norm$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+44]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fld	DWORD PTR _norm$[ebp+4]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+44]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fld	DWORD PTR _norm$[ebp+8]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+44]
	fstp	DWORD PTR [eax+32]

; 1113 : 		mp->v2->a++;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+80]
	add	edx, 1
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+80], edx

; 1114 : 	}

	jmp	$L82813
$L82814:

; 1115 : 
; 1116 : 	mv = model->VertPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _mv$[ebp], ecx

; 1117 : 
; 1118 : 	for (i = 0 ; i < water->VertNum ; i++, mv++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82847
$L82848:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mv$[ebp], ecx
$L82847:
	mov	eax, DWORD PTR _water$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$L82849

; 1119 : 	{
; 1120 : 		mv->nx /= mv->a;

	mov	eax, DWORD PTR _mv$[ebp]
	fild	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _mv$[ebp]
	fdivr	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mv$[ebp]
	fstp	DWORD PTR [edx+24]

; 1121 : 		mv->ny /= mv->a;

	mov	eax, DWORD PTR _mv$[ebp]
	fild	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _mv$[ebp]
	fdivr	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _mv$[ebp]
	fstp	DWORD PTR [edx+28]

; 1122 : 		mv->nz /= mv->a;

	mov	eax, DWORD PTR _mv$[ebp]
	fild	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _mv$[ebp]
	fdivr	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _mv$[ebp]
	fstp	DWORD PTR [edx+32]

; 1123 : 
; 1124 : 		mv->tu = mv->nx * 6.0f + 0.5f;

	mov	eax, DWORD PTR _mv$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR __real@40c00000
	fadd	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _mv$[ebp]
	fstp	DWORD PTR [ecx+60]

; 1125 : 		mv->tv = mv->nz * 6.0f + 0.5f;

	mov	eax, DWORD PTR _mv$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR __real@40c00000
	fadd	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _mv$[ebp]
	fstp	DWORD PTR [ecx+64]

; 1126 : 
; 1127 : 		FTOL((mv->ny + 1.0f) * 11000.0f + 192.0f, mv->a);

	mov	eax, DWORD PTR _mv$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@462be000
	fadd	DWORD PTR __real@43400000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$82850[ebp]
	mov	eax, DWORD PTR __temp$82850[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR _mv$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 1128 : 	}

	jmp	$L82848
$L82849:

; 1129 : 
; 1130 : // give vert uv's to poly uv's
; 1131 : 
; 1132 : 	mp = model->PolyPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _mp$[ebp], ecx

; 1133 : 	mrgb = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _mrgb$[ebp], ecx

; 1134 : 
; 1135 : 	for (i = model->PolyNum ; i ; i--, mp++, mrgb++)

	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+32]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $L82853
$L82854:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mp$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _mp$[ebp], ecx
	mov	edx, DWORD PTR _mrgb$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _mrgb$[ebp], edx
$L82853:
	cmp	DWORD PTR _i$[ebp], 0
	je	$L82792

; 1136 : 	{
; 1137 : 		mp->tu0 = mp->v0->tu;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [edx+4], eax

; 1138 : 		mp->tv0 = mp->v0->tv;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR [edx+8], eax

; 1139 : 
; 1140 : 		mp->tu1 = mp->v1->tu;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [edx+12], eax

; 1141 : 		mp->tv1 = mp->v1->tv;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR [edx+16], eax

; 1142 : 
; 1143 : 		mp->tu2 = mp->v2->tu;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [edx+20], eax

; 1144 : 		mp->tv2 = mp->v2->tv;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR [edx+24], eax

; 1145 : 
; 1146 : 		mrgb->rgb[0].a = (unsigned char)mp->v0->a;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mrgb$[ebp]
	mov	al, BYTE PTR [ecx+80]
	mov	BYTE PTR [edx+3], al

; 1147 : 		mrgb->rgb[1].a = (unsigned char)mp->v1->a;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _mrgb$[ebp]
	mov	al, BYTE PTR [ecx+80]
	mov	BYTE PTR [edx+7], al

; 1148 : 		mrgb->rgb[2].a = (unsigned char)mp->v2->a;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _mrgb$[ebp]
	mov	al, BYTE PTR [ecx+80]
	mov	BYTE PTR [edx+11], al

; 1149 : 	}	

	jmp	$L82854
$L82792:

; 1150 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_WaterHandler@@YAXPAUobject_def@@@Z ENDP		; AI_WaterHandler
_TEXT	ENDS
PUBLIC	?AI_BoatHandler@@YAXPAUobject_def@@@Z		; AI_BoatHandler
PUBLIC	__real@41700000
PUBLIC	__real@42b40000
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_BoatHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_mat$ = -40						; size = 36
_boat$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_BoatHandler@@YAXPAUobject_def@@@Z PROC NEAR		; AI_BoatHandler, COMDAT

; 1187 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 1188 : 	BOAT_OBJ *boat = (BOAT_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _boat$[ebp], ecx

; 1189 : 	//VEC vec, vec2;
; 1190 : 	MAT mat;
; 1191 : 
; 1192 : // quit if not visible
; 1193 : 
; 1194 : 	if (!obj->renderflag.visible)

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L82865

; 1195 : 		return;

	jmp	$L82861
$L82865:

; 1196 : 
; 1197 : // update times
; 1198 : 
; 1199 : 	boat->TimeX += TimeStep;

	mov	eax, DWORD PTR _boat$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [ecx+4]
$L82867:

; 1200 : 	while (boat->TimeX >= boat->TotalTimeX) boat->TimeX -= boat->TotalTimeX;

	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82868
	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [edx+4]
	jmp	SHORT $L82867
$L82868:

; 1201 : 
; 1202 : 	boat->TimeHeight += TimeStep;

	mov	eax, DWORD PTR _boat$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [ecx+12]
$L82870:

; 1203 : 	while (boat->TimeHeight >= boat->TotalTimeHeight) boat->TimeHeight -= boat->TotalTimeHeight;

	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82871
	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [edx+12]
	jmp	SHORT $L82870
$L82871:

; 1204 : 
; 1205 : 	boat->TimeZ += TimeStep;

	mov	eax, DWORD PTR _boat$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [ecx+20]
$L82873:

; 1206 : 	while (boat->TimeZ >= boat->TotalTimeZ) boat->TimeZ -= boat->TotalTimeZ;

	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+20]
	fcomp	DWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82874
	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [edx+20]
	jmp	SHORT $L82873
$L82874:

; 1207 : 
; 1208 : // set height
; 1209 : 
; 1210 : 	obj->body.Centre.Pos.v[Y] = boat->Height + (float)sin(boat->TimeHeight / boat->TotalTimeHeight * RAD) * 15.0f;

	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+12]
	fdiv	DWORD PTR [ecx+16]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fmul	DWORD PTR __real@41700000
	mov	edx, DWORD PTR _boat$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [eax+24]

; 1211 : 
; 1212 : // set ori
; 1213 : 
; 1214 : 	RotMatrixZYX(&mat, (float)sin(boat->TimeZ / boat->TotalTimeZ * RAD) / 90.0f, 0, (float)sin(boat->TimeX / boat->TotalTimeX * RAD) / 90.0f);

	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [eax+4]
	fdiv	DWORD PTR [ecx+8]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fdiv	DWORD PTR __real@42b40000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	mov	edx, DWORD PTR _boat$[ebp]
	mov	eax, DWORD PTR _boat$[ebp]
	fld	DWORD PTR [edx+20]
	fdiv	DWORD PTR [eax+24]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fdiv	DWORD PTR __real@42b40000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 1215 : 	MulMatrix(&boat->Ori, &mat, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _boat$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH
$L82861:

; 1216 : 
; 1217 : // steam?
; 1218 : 
; 1219 : /*	boat->SteamTime += TimeStep;
; 1220 : 	if (boat->SteamTime > Real(0.1f))
; 1221 : 	{
; 1222 : 		boat->SteamTime -= Real(0.1f);
; 1223 : 		VecMulMat(&BoatSteamOffset, &obj->body.Centre.WMatrix, &vec);
; 1224 : 		VecPlusEqVec(&vec, &obj->body.Centre.Pos);
; 1225 : 		VecMulMat(&BoatSteamVel, &obj->body.Centre.WMatrix, &vec2);
; 1226 : 		CreateSpark(SPARK_SMOKE2, &vec, &vec2, ZERO);
; 1227 : 	}
; 1228 : */
; 1229 : 
; 1230 : 
; 1231 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_BoatHandler@@YAXPAUobject_def@@@Z ENDP		; AI_BoatHandler
_TEXT	ENDS
PUBLIC	?AI_RadarHandler@@YAXPAUobject_def@@@Z		; AI_RadarHandler
PUBLIC	__real@3f400000
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_RadarHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_radar$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_RadarHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_RadarHandler, COMDAT

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1241 : 	RADAR_OBJ *radar = (RADAR_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _radar$[ebp], ecx

; 1242 : 
; 1243 : // set matrix
; 1244 : 
; 1245 : 	radar->Time += TimeStep;

	mov	eax, DWORD PTR _radar$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$[ebp]
	fstp	DWORD PTR [ecx]

; 1246 : 	RotMatrixY(&obj->body.Centre.WMatrix, radar->Time * 0.75f);

	mov	eax, DWORD PTR _radar$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR __real@3f400000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 1247 : 
; 1248 : // set light dirs
; 1249 : 
; 1250 : 	if (radar->Light2)

	mov	eax, DWORD PTR _radar$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L82883

; 1251 : 		CopyVec(&obj->body.Centre.WMatrix.mv[R], &radar->Light2->DirMatrix.mv[L]);

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR [ecx+68], eax
	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR [ecx+72], eax
	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+76], eax
$L82883:

; 1252 : 	
; 1253 : 	if (radar->Light1)

	mov	eax, DWORD PTR _radar$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L82880

; 1254 : 		SetVector(&radar->Light1->DirMatrix.mv[L], -obj->body.Centre.WMatrix.m[RX], -obj->body.Centre.WMatrix.m[RY], -obj->body.Centre.WMatrix.m[RZ]);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+100]
	fchs
	mov	ecx, DWORD PTR _radar$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+68]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+104]
	fchs
	mov	ecx, DWORD PTR _radar$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+72]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+108]
	fchs
	mov	ecx, DWORD PTR _radar$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+76]
$L82880:

; 1255 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_RadarHandler@@YAXPAUobject_def@@@Z ENDP		; AI_RadarHandler
_TEXT	ENDS
PUBLIC	?AI_BalloonHandler@@YAXPAUobject_def@@@Z	; AI_BalloonHandler
PUBLIC	__real@41800000
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_BalloonHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_balloon$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_BalloonHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_BalloonHandler, COMDAT

; 1264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1265 : 	BALLOON_OBJ *balloon = (BALLOON_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _balloon$[ebp], ecx

; 1266 : 
; 1267 : // quit if not visible
; 1268 : 
; 1269 : 	if (!obj->renderflag.visible)

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L82890

; 1270 : 		return;

	jmp	SHORT $L82887
$L82890:

; 1271 : 
; 1272 : // bob
; 1273 : 
; 1274 : 	balloon->Time += TimeStep;

	mov	eax, DWORD PTR _balloon$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _balloon$[ebp]
	fstp	DWORD PTR [ecx]

; 1275 : 	obj->body.Centre.Pos.v[Y] = balloon->Height + (float)sin(balloon->Time) * 16;

	mov	eax, DWORD PTR _balloon$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fmul	DWORD PTR __real@41800000
	mov	edx, DWORD PTR _balloon$[ebp]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [eax+24]
$L82887:

; 1276 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_BalloonHandler@@YAXPAUobject_def@@@Z ENDP		; AI_BalloonHandler
_TEXT	ENDS
PUBLIC	?AI_HorseRipper@@YAXPAUobject_def@@@Z		; AI_HorseRipper
PUBLIC	__real@42480000
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_HorseRipper@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_rock$ = -44						; size = 4
_mat$ = -40						; size = 36
_horse$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_HorseRipper@@YAXPAUobject_def@@@Z PROC NEAR		; AI_HorseRipper, COMDAT

; 1285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1286 : 	HORSE_OBJ *horse = (HORSE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _horse$[ebp], ecx

; 1287 : 	MAT mat;
; 1288 : 	REAL rock;
; 1289 : 
; 1290 : // get rock num
; 1291 : 
; 1292 : 	horse->Time += TimeStep * 4.0f;

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@40800000
	mov	eax, DWORD PTR _horse$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _horse$[ebp]
	fstp	DWORD PTR [ecx+4]

; 1293 : 	rock = (float)sin(horse->Time);

	mov	eax, DWORD PTR _horse$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _rock$[ebp]

; 1294 : 
; 1295 : // creak?
; 1296 : 
; 1297 : 	if (horse->CreakFlag > 0)

	mov	eax, DWORD PTR _horse$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82900

; 1298 : 	{
; 1299 : 		if (rock > horse->CreakFlag)

	mov	eax, DWORD PTR _horse$[ebp]
	fld	DWORD PTR _rock$[ebp]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82901

; 1300 : 		{
; 1301 : 			horse->CreakFlag = -horse->CreakFlag;

	mov	eax, DWORD PTR _horse$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _horse$[ebp]
	fstp	DWORD PTR [ecx]

; 1302 : 			PlaySfx3D(SFX_TOY_CREAK, SFX_MAX_VOL, 20000, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	20000					; 00004e20H
	push	127					; 0000007fH
	push	21					; 00000015H
	call	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z	; PlaySfx3D
	add	esp, 16					; 00000010H
$L82901:

; 1303 : 		}
; 1304 : 	}
; 1305 : 	else

	jmp	SHORT $L82902
$L82900:

; 1306 : 	{
; 1307 : 		if (rock < horse->CreakFlag)

	mov	eax, DWORD PTR _horse$[ebp]
	fld	DWORD PTR _rock$[ebp]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82902

; 1308 : 		{
; 1309 : 			horse->CreakFlag = -horse->CreakFlag;

	mov	eax, DWORD PTR _horse$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _horse$[ebp]
	fstp	DWORD PTR [ecx]

; 1310 : 			PlaySfx3D(SFX_TOY_CREAK, SFX_MAX_VOL, 17000, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	17000					; 00004268H
	push	127					; 0000007fH
	push	21					; 00000015H
	call	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z	; PlaySfx3D
	add	esp, 16					; 00000010H
$L82902:

; 1311 : 		}
; 1312 : 	}
; 1313 : 
; 1314 : // quit if not visible
; 1315 : 
; 1316 : 	if (!obj->renderflag.visible)

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L82904

; 1317 : 		return;

	jmp	SHORT $L82894
$L82904:

; 1318 : 
; 1319 : // rock
; 1320 : 
; 1321 : 	RotMatrixX(&mat, rock / 50.0f);

	fld	DWORD PTR _rock$[ebp]
	fdiv	DWORD PTR __real@42480000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixX@@YAXPATMatrixUnion@@M@Z	; RotMatrixX
	add	esp, 8

; 1322 : 	MulMatrix(&horse->Mat, &mat, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _horse$[ebp]
	add	edx, 8
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH
$L82894:

; 1323 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_HorseRipper@@YAXPAUobject_def@@@Z ENDP		; AI_HorseRipper
_TEXT	ENDS
PUBLIC	?AI_TrainHandler@@YAXPAUobject_def@@@Z		; AI_TrainHandler
PUBLIC	__real@3e99999a
PUBLIC	__real@c3c80000
PUBLIC	__real@44480000
EXTRN	?PLR_PlayerHead@@3PAUPlayerStruct@@A:DWORD	; PLR_PlayerHead
EXTRN	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z:NEAR ; CreateSpark
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@c3c80000
CONST	SEGMENT
__real@c3c80000 DD 0c3c80000r			; -400
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_TrainHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv220 = -108						; size = 4
_player$ = -40						; size = 4
_vec2$ = -36						; size = 12
_vec$ = -24						; size = 12
_train$ = -12						; size = 4
_flag$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_TrainHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_TrainHandler, COMDAT

; 1332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1333 : 	long i, flag;
; 1334 : 	TRAIN_OBJ *train = (TRAIN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _train$[ebp], ecx

; 1335 : 	VEC vec, vec2;
; 1336 : 	PLAYER *player;
; 1337 : 
; 1338 : // rot wheels
; 1339 : 
; 1340 : 	train->TimeFront -= TimeStep * 0.5f;

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _train$[ebp]
	fsubr	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _train$[ebp]
	fstp	DWORD PTR [ecx+60]

; 1341 : 	train->TimeBack -= TimeStep * 0.3f;

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@3e99999a
	mov	eax, DWORD PTR _train$[ebp]
	fsubr	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _train$[ebp]
	fstp	DWORD PTR [ecx+64]

; 1342 : 
; 1343 : // set wheel positions
; 1344 : 
; 1345 : 	for (i = 0 ; i < 4 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82915
$L82916:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82915:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L82917

; 1346 : 	{
; 1347 : 		AddVector(&obj->body.Centre.Pos, &TrainWheelOffsets[i], &train->WheelPos[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+20]
	fadd	DWORD PTR _TrainWheelOffsets[eax]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _train$[ebp]
	fstp	DWORD PTR [eax+edx]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+24]
	fadd	DWORD PTR _TrainWheelOffsets[eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _train$[ebp]
	fstp	DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+28]
	fadd	DWORD PTR _TrainWheelOffsets[eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _train$[ebp]
	fstp	DWORD PTR [eax+edx+8]

; 1348 : 	}

	jmp	SHORT $L82916
$L82917:

; 1349 : 
; 1350 : // update sfx pos
; 1351 : 
; 1352 : 	if (obj->Sfx3D)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+680], 0
	je	SHORT $L82918

; 1353 : 	{
; 1354 : 		CopyVec(&obj->body.Centre.Pos, &obj->Sfx3D->Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+36], eax
$L82918:

; 1355 : 	}
; 1356 : 
; 1357 : // steam?
; 1358 : 
; 1359 : 	AddVector(&obj->body.Centre.Pos, &TrainSteamOffset, &vec);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _TrainSteamOffset
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _TrainSteamOffset+4
	fadd	DWORD PTR [eax+24]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _TrainSteamOffset+8
	fadd	DWORD PTR [eax+28]
	fstp	DWORD PTR _vec$[ebp+8]

; 1360 : 
; 1361 : 	train->SteamTime += TimeStep;

	mov	eax, DWORD PTR _train$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _train$[ebp]
	fstp	DWORD PTR [ecx+68]

; 1362 : 	if (train->SteamTime > 0.1f)

	mov	eax, DWORD PTR _train$[ebp]
	fld	DWORD PTR [eax+68]
	fcomp	DWORD PTR __real@3dcccccd
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82919

; 1363 : 	{
; 1364 : 		train->SteamTime -= 0.1f;

	mov	eax, DWORD PTR _train$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _train$[ebp]
	fstp	DWORD PTR [ecx+68]

; 1365 : 		CreateSpark(SPARK_SMOKE2, &vec, &TrainSteamDir, ZERO, 0);

	push	0
	push	0
	push	0
	push	OFFSET FLAT:_TrainSteamDir
	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	push	11					; 0000000bH
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H
$L82919:

; 1366 : 	}
; 1367 : 
; 1368 : // whistle?
; 1369 : 
; 1370 : 	flag = FALSE;

	mov	DWORD PTR _flag$[ebp], 0

; 1371 : 
; 1372 : 	for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L82920
$L82921:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L82920:
	cmp	DWORD PTR _player$[ebp], 0
	je	$L82922

; 1373 : 	{
; 1374 : 		SubVector(&obj->body.Centre.Pos, &player->car.Body->Centre.Pos, &vec2);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _vec2$[ebp]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+24]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _vec2$[ebp+4]
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+28]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _vec2$[ebp+8]

; 1375 : 		if (abs(vec2.v[X]) < 400 && vec2.v[Z] > -400 && vec2.v[Z] < 800)

	fld	DWORD PTR _vec2$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83458
	mov	eax, DWORD PTR _vec2$[ebp]
	mov	DWORD PTR tv220[ebp], eax
	jmp	SHORT $L83459
$L83458:
	fld	DWORD PTR _vec2$[ebp]
	fchs
	fstp	DWORD PTR tv220[ebp]
$L83459:
	fld	DWORD PTR tv220[ebp]
	fcomp	DWORD PTR __real@43c80000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82923
	fld	DWORD PTR _vec2$[ebp+8]
	fcomp	DWORD PTR __real@c3c80000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82923
	fld	DWORD PTR _vec2$[ebp+8]
	fcomp	DWORD PTR __real@44480000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82923

; 1376 : 		{
; 1377 : 			flag = TRUE;

	mov	DWORD PTR _flag$[ebp], 1

; 1378 : 			break;

	jmp	SHORT $L82922
$L82923:

; 1379 : 		}
; 1380 : 	}

	jmp	$L82921
$L82922:

; 1381 : 
; 1382 : 	if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $L82924

; 1383 : 	{
; 1384 : 		if (train->WhistleFlag)

	mov	eax, DWORD PTR _train$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $L82925

; 1385 : 		{
; 1386 : 			train->WhistleFlag = FALSE;

	mov	eax, DWORD PTR _train$[ebp]
	mov	DWORD PTR [eax+56], 0

; 1387 : 			PlaySfx3D(SFX_TOY_WHISTLE, SFX_MAX_VOL, 22050, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	push	22050					; 00005622H
	push	127					; 0000007fH
	push	23					; 00000017H
	call	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z	; PlaySfx3D
	add	esp, 16					; 00000010H
$L82925:

; 1388 : 		}
; 1389 : 	}
; 1390 : 	else

	jmp	SHORT $L82907
$L82924:

; 1391 : 	{
; 1392 : 	 	train->WhistleFlag = TRUE;

	mov	eax, DWORD PTR _train$[ebp]
	mov	DWORD PTR [eax+56], 1
$L82907:

; 1393 : 	}
; 1394 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_TrainHandler@@YAXPAUobject_def@@@Z ENDP		; AI_TrainHandler
_TEXT	ENDS
PUBLIC	?AI_StrobeHandler@@YAXPAUobject_def@@@Z		; AI_StrobeHandler
PUBLIC	__real@42c80000
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_StrobeHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_strobe$ = -20						; size = 4
_col$ = -16						; size = 4
_per$ = -12						; size = 4
_diff$ = -8						; size = 4
_num$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_StrobeHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_StrobeHandler, COMDAT

; 1403 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1404 : 	long num, diff, per, col;
; 1405 : 	STROBE_OBJ *strobe = (STROBE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _strobe$[ebp], ecx

; 1406 : 
; 1407 : // get brightness
; 1408 : 
; 1409 : 	num = (TIME2MS(CurrentTimer()) / 20) % strobe->StrobeCount;

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	xor	edx, edx
	mov	ecx, 20					; 00000014H
	div	ecx
	mov	ecx, DWORD PTR _strobe$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	DWORD PTR _num$[ebp], edx

; 1410 : 	diff = num - strobe->StrobeNum;

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _diff$[ebp], ecx

; 1411 : 	if (diff < -strobe->StrobeCount / 2) diff += strobe->StrobeCount;

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [eax]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _diff$[ebp], eax
	jge	SHORT $L82936
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR _diff$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _diff$[ebp], ecx
$L82936:

; 1412 : 	if (diff > strobe->StrobeCount / 2) diff -= strobe->StrobeCount;

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _diff$[ebp], eax
	jle	SHORT $L82937
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR _diff$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _diff$[ebp], ecx
$L82937:

; 1413 : 
; 1414 : // off
; 1415 : 
; 1416 : 	if (diff < -strobe->FadeUp || diff > strobe->FadeDown)

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	neg	ecx
	cmp	DWORD PTR _diff$[ebp], ecx
	jl	SHORT $L82939
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR _diff$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jle	SHORT $L82938
$L82939:

; 1417 : 	{
; 1418 : 		if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $L82940

; 1419 : 		{
; 1420 : 			FreeLight(obj->Light);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	push	ecx
	call	?FreeLight@@YAXPAULIGHT@@@Z		; FreeLight
	add	esp, 4

; 1421 : 			obj->Light = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+672], 0
$L82940:

; 1422 : 		}
; 1423 : 		strobe->Glow = 0;

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1424 : 	}
; 1425 : 
; 1426 : // on
; 1427 : 
; 1428 : 	else

	jmp	$L82929
$L82938:

; 1429 : 	{
; 1430 : 		if (!obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	jne	SHORT $L82942

; 1431 : 		{
; 1432 : 			obj->Light = AllocLight();

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 1433 : 			if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $L82942

; 1434 : 			{
; 1435 : 				obj->Light->x = strobe->LightPos.v[X];

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx], eax

; 1436 : 				obj->Light->y = strobe->LightPos.v[Y];

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+4], eax

; 1437 : 				obj->Light->z = strobe->LightPos.v[Z];

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+8], eax

; 1438 : 				obj->Light->Reach = strobe->Range;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+12], eax

; 1439 : 				obj->Light->Flag = LIGHT_FIXED | LIGHT_MOVING;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+100], 3

; 1440 : 				obj->Light->Type= LIGHT_OMNI;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+101], 0
$L82942:

; 1441 : 			}
; 1442 : 		}
; 1443 : 
; 1444 : 		if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	$L82944

; 1445 : 		{
; 1446 : 			if (diff < 0) per = (diff + strobe->FadeUp) * (100 / strobe->FadeUp);

	cmp	DWORD PTR _diff$[ebp], 0
	jge	SHORT $L82945
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR _diff$[ebp]
	add	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR _strobe$[ebp]
	mov	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR [esi+8]
	imul	ecx, eax
	mov	DWORD PTR _per$[ebp], ecx

; 1447 : 			else per = (strobe->FadeDown - diff) * (100 / strobe->FadeDown);

	jmp	SHORT $L82946
$L82945:
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _diff$[ebp]
	mov	esi, DWORD PTR _strobe$[ebp]
	mov	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR [esi+12]
	imul	ecx, eax
	mov	DWORD PTR _per$[ebp], ecx
$L82946:

; 1448 : 
; 1449 : 			obj->Light->r = strobe->r * per / 100;

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [eax+16]
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+672]
	mov	DWORD PTR [ecx+88], eax

; 1450 : 			obj->Light->g = strobe->g * per / 100;

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [eax+20]
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+672]
	mov	DWORD PTR [ecx+92], eax

; 1451 : 			obj->Light->b = strobe->b * per / 100;

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR [eax+24]
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+672]
	mov	DWORD PTR [ecx+96], eax

; 1452 : 
; 1453 : 			col = (obj->Light->r << 16) | (obj->Light->g << 8) | obj->Light->b;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR [ecx+88]
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	eax, DWORD PTR [ecx+92]
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [ecx+672]
	or	edx, DWORD PTR [eax+96]
	mov	DWORD PTR _col$[ebp], edx
$L82944:

; 1454 : 		}
; 1455 : 		strobe->Glow = (float)per / 100.0f;

	fild	DWORD PTR _per$[ebp]
	fdiv	DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _strobe$[ebp]
	fstp	DWORD PTR [eax+32]
$L82929:

; 1456 : 	}
; 1457 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_StrobeHandler@@YAXPAUobject_def@@@Z ENDP		; AI_StrobeHandler
_TEXT	ENDS
PUBLIC	?SparkGenHandler@@YAXPAUobject_def@@@Z		; SparkGenHandler
EXTRN	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z:NEAR ; VecMulMat
EXTRN	?CamVisiMask@@3_KA:QWORD			; CamVisiMask
; Function compile flags: /Odt /ZI
;	COMDAT ?SparkGenHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv186 = -108						; size = 8
tv199 = -104						; size = 4
_sparkGen$ = -36					; size = 4
_vel$ = -32						; size = 12
_pos$ = -20						; size = 12
_nTries$ = -8						; size = 4
_ii$ = -4						; size = 4
_obj$ = 8						; size = 4
?SparkGenHandler@@YAXPAUobject_def@@@Z PROC NEAR	; SparkGenHandler, COMDAT

; 1468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1469 : 	int ii, nTries;
; 1470 : 	VEC pos, vel;
; 1471 : 	SPARK_GEN *sparkGen = (SPARK_GEN *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _sparkGen$[ebp], ecx

; 1472 : 
; 1473 : 	// update time for this generator
; 1474 : 	sparkGen->Time += TimeStep;

	mov	eax, DWORD PTR _sparkGen$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	fstp	DWORD PTR [ecx+36]

; 1475 : 
; 1476 : 	// make sure it is visible
; 1477 : 	if (CamVisiMask & sparkGen->VisiMask) return;

	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR ?CamVisiMask@@3_KA
	and	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	and	edx, DWORD PTR [eax+12]
	mov	DWORD PTR tv186[ebp], ecx
	mov	DWORD PTR tv186[ebp+4], edx
	mov	eax, DWORD PTR tv186[ebp]
	or	eax, DWORD PTR tv186[ebp+4]
	je	SHORT $L82957
	jmp	$L82950
$L82957:

; 1478 : 
; 1479 : 	nTries = 1 + (int)(TimeStep / sparkGen->MaxTime);

	mov	eax, DWORD PTR _sparkGen$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR [eax+40]
	call	__ftol2
	add	eax, 1
	mov	DWORD PTR _nTries$[ebp], eax

; 1480 : 	if (nTries > 5) nTries = 5;

	cmp	DWORD PTR _nTries$[ebp], 5
	jle	SHORT $L82959
	mov	DWORD PTR _nTries$[ebp], 5
$L82959:

; 1481 : 	for (ii = 0; ii < nTries; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82960
$L82961:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82960:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _nTries$[ebp]
	jge	$L82950

; 1482 : 		
; 1483 : 		// See if a new spark should be generated
; 1484 : 		if (frand(ONE) > sparkGen->Time / sparkGen->MaxTime) continue;

	call	_rand
	mov	DWORD PTR tv199[ebp], eax
	fild	DWORD PTR tv199[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	fld	DWORD PTR [eax+36]
	fdiv	DWORD PTR [ecx+40]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82964
	jmp	SHORT $L82961
$L82964:

; 1485 : 		sparkGen->Time = ZERO;

	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	DWORD PTR [eax+36], 0

; 1486 : 
; 1487 : 		if (sparkGen->Parent != NULL) {

	mov	eax, DWORD PTR _sparkGen$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$L82965

; 1488 : 			// Calculate average spark velocity and start position
; 1489 : 			VecMulMat(&obj->body.Centre.Pos, &sparkGen->Parent->body.Centre.WMatrix, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1490 : 			VecPlusEqVec(&pos, &sparkGen->Parent->body.Centre.Pos);

	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fld	DWORD PTR _pos$[ebp]
	fadd	DWORD PTR [ecx+20]
	fstp	DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fld	DWORD PTR _pos$[ebp+4]
	fadd	DWORD PTR [ecx+24]
	fstp	DWORD PTR _pos$[ebp+4]
	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fld	DWORD PTR _pos$[ebp+8]
	fadd	DWORD PTR [ecx+28]
	fstp	DWORD PTR _pos$[ebp+8]

; 1491 : 			VecMulMat(&sparkGen->SparkVel, &sparkGen->Parent->body.Centre.WMatrix, &vel);

	lea	eax, DWORD PTR _vel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _sparkGen$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1492 : 	
; 1493 : 			// Generate the object-relative spark
; 1494 : 			CreateSpark(sparkGen->Type, &pos, &vel, sparkGen->SparkVelVar, sparkGen->VisiMask);

	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	lea	edx, DWORD PTR _vel$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H

; 1495 : 		} else {

	jmp	SHORT $L82966
$L82965:

; 1496 : 			// Generate the spark
; 1497 : 			CreateSpark(sparkGen->Type, &obj->body.Centre.Pos, &sparkGen->SparkVel, sparkGen->SparkVelVar, sparkGen->VisiMask);

	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _sparkGen$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H
$L82966:

; 1498 : 		}
; 1499 : 	}

	jmp	$L82961
$L82950:

; 1500 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SparkGenHandler@@YAXPAUobject_def@@@Z ENDP		; SparkGenHandler
_TEXT	ENDS
PUBLIC	?AI_SpacemanHandler@@YAXPAUobject_def@@@Z	; AI_SpacemanHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?AI_SpacemanHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_spaceman$ = -76					; size = 4
_mat2$ = -72						; size = 36
_mat1$ = -36						; size = 36
_obj$ = 8						; size = 4
?AI_SpacemanHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_SpacemanHandler, COMDAT

; 1509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 1510 : 	MAT mat1, mat2;
; 1511 : 	SPACEMAN_OBJ *spaceman = (SPACEMAN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _spaceman$[ebp], ecx

; 1512 : 
; 1513 : 	RotMatrixZYX(&mat1, 0.001f, 0.001f, 0);

	push	0
	push	981668463				; 3a83126fH
	push	981668463				; 3a83126fH
	lea	eax, DWORD PTR _mat1$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 1514 : 	MulMatrix(&obj->body.Centre.WMatrix, &mat1, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 1515 : 	CopyMatrix(&mat2, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 1516 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_SpacemanHandler@@YAXPAUobject_def@@@Z ENDP		; AI_SpacemanHandler
_TEXT	ENDS
PUBLIC	?AI_PickupHandler@@YAXPAUobject_def@@@Z		; AI_PickupHandler
PUBLIC	__real@44fa0000
PUBLIC	__real@3fcccccd
PUBLIC	__real@3fc00000
PUBLIC	__real@3faccccd
PUBLIC	__real@4036db62
PUBLIC	__real@41400000
PUBLIC	__real@43aa0000
PUBLIC	__real@437f0000
EXTRN	?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z:NEAR ; DetectCarBodyColls
EXTRN	?COL_NBodyColls@@3HA:DWORD			; COL_NBodyColls
EXTRN	?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z:NEAR ; CreateObject
EXTRN	?GHO_GhostPlayer@@3PAUPlayerStruct@@A:DWORD	; GHO_GhostPlayer
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@3fcccccd
CONST	SEGMENT
__real@3fcccccd DD 03fcccccdr			; 1.6
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3faccccd
CONST	SEGMENT
__real@3faccccd DD 03faccccdr			; 1.35
CONST	ENDS
;	COMDAT __real@4036db62
CONST	SEGMENT
__real@4036db62 DD 04036db62r			; 2.85714
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@43aa0000
CONST	SEGMENT
__real@43aa0000 DD 043aa0000r			; 340
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_PickupHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv623 = -108						; size = 8
tv482 = -108						; size = 8
tv599 = -104						; size = 4
tv596 = -104						; size = 4
tv507 = -104						; size = 4
tv65 = -104						; size = 4
__temp$83028 = -36					; size = 4
__temp$83009 = -32					; size = 4
_bomb$ = -28						; size = 4
_bombobj$ = -24						; size = 4
_player$ = -20						; size = 4
_pickup$ = -16						; size = 4
_mul$ = -12						; size = 4
_flag$ = -8						; size = 4
_col$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_PickupHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_PickupHandler, COMDAT

; 1525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1526 : 	long col, flag;
; 1527 : 	REAL mul;
; 1528 : 	PICKUP_OBJ *pickup = (PICKUP_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _pickup$[ebp], ecx

; 1529 : 	PLAYER *player;
; 1530 : 	OBJECT *bombobj;
; 1531 : 	PUTTYBOMB_OBJ *bomb;
; 1532 : 
; 1533 : // act on mode
; 1534 : 
; 1535 : 	switch (pickup->Mode)

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $L82989
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $L82991
	cmp	DWORD PTR tv65[ebp], 2
	je	$L83027
	jmp	$L82976
$L82989:

; 1536 : 	{
; 1537 : 
; 1538 : // waiting to generate?
; 1539 : 
; 1540 : 		case 0:
; 1541 : 
; 1542 : 			pickup->Timer -= TimeStep;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _pickup$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1543 : 			if (pickup->Timer <= 0)

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L82990

; 1544 : 			{
; 1545 : 				pickup->Mode = 1;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax], 1

; 1546 : 				pickup->Timer = 0.0f;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1547 : 				pickup->Clone = (!(rand() & 7));

	call	_rand
	and	eax, 7
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	ecx, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1548 : 
; 1549 : 				obj->EnvRGB = 0xffff80;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+652], 16777088		; 00ffff80H
$L82990:

; 1550 : 			}
; 1551 : 
; 1552 : 		break;

	jmp	$L82976
$L82991:

; 1553 : 
; 1554 : // waiting to be picked up
; 1555 : 
; 1556 : 		case 1:
; 1557 : 
; 1558 : // inc age
; 1559 : 
; 1560 : 			pickup->Timer += TimeStep;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pickup$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1561 : 
; 1562 : // spin
; 1563 : 
; 1564 : 			RotMatrixY(&obj->body.Centre.WMatrix, TIME2MS(CurrentTimer()) / 2000.0f);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	DWORD PTR tv482[ebp], eax
	mov	DWORD PTR tv482[ebp+4], 0
	fild	QWORD PTR tv482[ebp]
	fdiv	DWORD PTR __real@44fa0000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 1565 : 			if (pickup->Timer < 1.6f)

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3fcccccd
	fnstsw	ax
	test	ah, 5
	jp	$L82992

; 1566 : 			{
; 1567 : 				if (pickup->Timer < 0.5f)

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3f000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82993

; 1568 : 					mul = 0;

	mov	DWORD PTR _mul$[ebp], 0

; 1569 : 				else if (pickup->Timer < 1.0f)

	jmp	$L82994
$L82993:
	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82995

; 1570 : 					mul = (pickup->Timer - 0.5f) * 2.0f + (float)sin((pickup->Timer - 0.5f) * RAD) / 1.5f;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR __real@3f000000
	fadd	ST(0), ST(0)
	fstp	DWORD PTR tv507[ebp]
	mov	ecx, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR __real@3f000000
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fdiv	DWORD PTR __real@3fc00000
	fadd	DWORD PTR tv507[ebp]
	fstp	DWORD PTR _mul$[ebp]

; 1571 : 				else if (pickup->Timer < 1.35f)

	jmp	SHORT $L82994
$L82995:
	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3faccccd
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82998

; 1572 : 					mul = 1.0f - (float)sin((pickup->Timer - 1.0f) * 2.85714f * PI) / 6.0f;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@4036db62
	fmul	DWORD PTR __real@40490fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fdiv	DWORD PTR __real@40c00000
	fsubr	DWORD PTR __real@3f800000
	fstp	DWORD PTR _mul$[ebp]

; 1573 : 				else

	jmp	SHORT $L82994
$L82998:

; 1574 : 					mul = 1.0f + (float)sin((pickup->Timer - 1.35f) * 4.0f * PI) / 12.0f;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR __real@3faccccd
	fmul	DWORD PTR __real@40800000
	fmul	DWORD PTR __real@40490fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fdiv	DWORD PTR __real@41400000
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _mul$[ebp]
$L82994:

; 1575 : 
; 1576 : 				obj->body.Centre.WMatrix.m[XX] *= mul;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _mul$[ebp]
	fmul	DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1577 : 				obj->body.Centre.WMatrix.m[YY] *= mul;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _mul$[ebp]
	fmul	DWORD PTR [eax+116]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+116]

; 1578 : 				obj->body.Centre.WMatrix.m[ZZ] *= mul;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _mul$[ebp]
	fmul	DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+132]
$L82992:

; 1579 : 			}
; 1580 : 
; 1581 : // need a light source?
; 1582 : 
; 1583 : 			if (!obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	jne	SHORT $L83002

; 1584 : 			{
; 1585 : 				obj->Light = AllocLight();

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 1586 : 				if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $L83002

; 1587 : 				{
; 1588 : 					CopyVec(&obj->body.Centre.Pos, (VEC*)&obj->Light->x);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+8], eax

; 1589 : 					obj->Light->Reach = 512;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+12], 1140850688		; 44000000H

; 1590 : 					obj->Light->Flag = LIGHT_FIXED | LIGHT_MOVING;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+100], 3

; 1591 : 					obj->Light->Type = LIGHT_OMNI;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+101], 0
$L83002:

; 1592 : 				}
; 1593 : 			}
; 1594 : 
; 1595 : // maintain light
; 1596 : 
; 1597 : 			if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	$L83007

; 1598 : 			{
; 1599 : 				if (pickup->Timer < 0.75f)

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3f400000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83008

; 1600 : 				{
; 1601 : 					FTOL(pickup->Timer * 340.0f, col);

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR __real@43aa0000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$83009[ebp]
	mov	eax, DWORD PTR __temp$83009[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _col$[ebp], eax

; 1602 : 				}
; 1603 : 				else

	jmp	SHORT $L83012
$L83008:

; 1604 : 				{
; 1605 : 					col = 255;

	mov	DWORD PTR _col$[ebp], 255		; 000000ffH
$L83012:

; 1606 : 				}
; 1607 : 
; 1608 : 				if (!pickup->Clone)

	mov	eax, DWORD PTR _pickup$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L83013

; 1609 : 				{
; 1610 : 					obj->Light->r = col;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [ecx+88], edx

; 1611 : 					obj->Light->g = col * 3 / 4;

	mov	eax, DWORD PTR _col$[ebp]
	imul	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+92], eax

; 1612 : 					obj->Light->b = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+96], 0

; 1613 : 				}
; 1614 : 				else

	jmp	SHORT $L83007
$L83013:

; 1615 : 				{
; 1616 : 					obj->Light->r = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+88], 0

; 1617 : 					obj->Light->g = -col;

	mov	eax, DWORD PTR _col$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+92], eax

; 1618 : 					obj->Light->b = -col;

	mov	eax, DWORD PTR _col$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+96], eax
$L83007:

; 1619 : 				}
; 1620 : 			}
; 1621 : 
; 1622 : // look for car collision
; 1623 : 
; 1624 : 			obj->CollType = COLL_TYPE_BODY;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 1

; 1625 : 
; 1626 : 			for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L83015
$L83016:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L83015:
	cmp	DWORD PTR _player$[ebp], 0
	je	$L83017

; 1627 : 			{
; 1628 : 				if (player != GHO_GhostPlayer && !player->PickupNum && !player->PickupCycleSpeed)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	eax, DWORD PTR ?GHO_GhostPlayer@@3PAUPlayerStruct@@A ; GHO_GhostPlayer
	je	$L83018
	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+10232], 0
	jne	$L83018
	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [eax+10224]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$L83018

; 1629 : 				{
; 1630 : 					COL_NBodyColls = 0;

	mov	DWORD PTR ?COL_NBodyColls@@3HA, 0	; COL_NBodyColls

; 1631 : 					DetectCarBodyColls(&player->car, &obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectCarBodyColls
	add	esp, 8

; 1632 : 					if (COL_NBodyColls)

	cmp	DWORD PTR ?COL_NBodyColls@@3HA, 0	; COL_NBodyColls
	je	$L83018

; 1633 : 					{
; 1634 : 						pickup->Mode = 2;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax], 2

; 1635 : 						pickup->Timer = 0.0f;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1636 : 
; 1637 : 						SetVector(&pickup->Vel, player->ownobj->body.Centre.Vel.v[X] / 2.0f, -64.0f, player->ownobj->body.Centre.Vel.v[Z] / 2.0f);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR [ecx+32]
	fdiv	DWORD PTR __real@40000000
	mov	edx, DWORD PTR _pickup$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax+28], -1031798784		; c2800000H
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR [ecx+40]
	fdiv	DWORD PTR __real@40000000
	mov	edx, DWORD PTR _pickup$[ebp]
	fstp	DWORD PTR [edx+32]

; 1638 : 
; 1639 : 						if (!pickup->Clone)

	mov	eax, DWORD PTR _pickup$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L83020

; 1640 : 						{
; 1641 : 							PlaySfx3D(SFX_PICKUP, SFX_MAX_VOL, 22050, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	22050					; 00005622H
	push	127					; 0000007fH
	push	5
	call	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z	; PlaySfx3D
	add	esp, 16					; 00000010H

; 1642 : 
; 1643 : 							player->PickupCycleType = frand(PICKUP_NUM);

	call	_rand
	mov	DWORD PTR tv596[ebp], eax
	fild	DWORD PTR tv596[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@41100000
	mov	eax, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [eax+10220]

; 1644 : 							player->PickupCycleSpeed = frand(1.0f) + 4.0f;

	call	_rand
	mov	DWORD PTR tv599[ebp], eax
	fild	DWORD PTR tv599[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	fadd	DWORD PTR __real@40800000
	mov	eax, DWORD PTR _player$[ebp]
	fstp	DWORD PTR [eax+10224]

; 1645 : 						}
; 1646 : 						else

	jmp	SHORT $L83023
$L83020:

; 1647 : 						{
; 1648 : 							PlaySfx3D(SFX_PICKUP_CLONE, SFX_MAX_VOL, 22050, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	22050					; 00005622H
	push	127					; 0000007fH
	push	6
	call	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z	; PlaySfx3D
	add	esp, 16					; 00000010H

; 1649 : 
; 1650 : 							flag = (long)player;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR _flag$[ebp], eax

; 1651 : 					 		bombobj = CreateObject(&player->car.Body->Centre.Pos, &player->car.Body->Centre.WMatrix, OBJECT_TYPE_PUTTYBOMB, &flag);

	lea	eax, DWORD PTR _flag$[ebp]
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z ; CreateObject
	add	esp, 16					; 00000010H
	mov	DWORD PTR _bombobj$[ebp], eax

; 1652 : 							if (bombobj)

	cmp	DWORD PTR _bombobj$[ebp], 0
	je	SHORT $L83023

; 1653 : 							{
; 1654 : 								bomb = (PUTTYBOMB_OBJ*)bombobj->Data;

	mov	eax, DWORD PTR _bombobj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _bomb$[ebp], ecx

; 1655 : 								bomb->Timer = 0.0f;

	mov	eax, DWORD PTR _bomb$[ebp]
	mov	DWORD PTR [eax], 0

; 1656 : 								player->car.WillDetonate = TRUE;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+3572], 1
$L83023:

; 1657 : 							}
; 1658 : 						}
; 1659 : 
; 1660 : 						break;

	jmp	SHORT $L83017
$L83018:

; 1661 : 					}
; 1662 : 				}
; 1663 : 			}

	jmp	$L83016
$L83017:

; 1664 : 
; 1665 : 			obj->CollType = COLL_TYPE_NONE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 0

; 1666 : 
; 1667 : 		break;

	jmp	$L82976
$L83027:

; 1668 : 
; 1669 : // dissappearing
; 1670 : 
; 1671 : 		case 2:
; 1672 : 
; 1673 : // inc age
; 1674 : 
; 1675 : 			pickup->Timer += TimeStep;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pickup$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1676 : 
; 1677 : // spin
; 1678 : 
; 1679 : 			RotMatrixY(&obj->body.Centre.WMatrix, TIME2MS(CurrentTimer()) / 2000.0f);

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	DWORD PTR tv623[ebp], eax
	mov	DWORD PTR tv623[ebp+4], 0
	fild	QWORD PTR tv623[ebp]
	fdiv	DWORD PTR __real@44fa0000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 1680 : 
; 1681 : 			mul = pickup->Timer * 2.0f + 1.0f;

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@3f800000
	fstp	DWORD PTR _mul$[ebp]

; 1682 : 
; 1683 : 			obj->body.Centre.WMatrix.m[XX] *= mul;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _mul$[ebp]
	fmul	DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1684 : 			obj->body.Centre.WMatrix.m[YY] *= mul;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _mul$[ebp]
	fmul	DWORD PTR [eax+116]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+116]

; 1685 : 			obj->body.Centre.WMatrix.m[ZZ] *= mul;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR _mul$[ebp]
	fmul	DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+132]

; 1686 : 
; 1687 : // set env rgb
; 1688 : 
; 1689 : 			FTOL(-pickup->Timer * 255.0f + 255.0f, col);

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	fmul	DWORD PTR __real@437f0000
	fadd	DWORD PTR __real@437f0000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$83028[ebp]
	mov	eax, DWORD PTR __temp$83028[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _col$[ebp], eax

; 1690 : 
; 1691 : 			obj->EnvRGB = col >> 1 | col << 8 | col << 16;

	mov	eax, DWORD PTR _col$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _col$[ebp]
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _col$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+652], eax

; 1692 : 
; 1693 : // maintain light
; 1694 : 
; 1695 : 			if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $L83031

; 1696 : 			{
; 1697 : 				if (!pickup->Clone)

	mov	eax, DWORD PTR _pickup$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L83032

; 1698 : 				{
; 1699 : 					obj->Light->r = col;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [ecx+88], edx

; 1700 : 					obj->Light->g = col * 3 / 4;

	mov	eax, DWORD PTR _col$[ebp]
	imul	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+92], eax

; 1701 : 					obj->Light->b = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+96], 0

; 1702 : 				}
; 1703 : 				else

	jmp	SHORT $L83031
$L83032:

; 1704 : 				{
; 1705 : 					obj->Light->r = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+88], 0

; 1706 : 					obj->Light->g = -col;

	mov	eax, DWORD PTR _col$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+92], eax

; 1707 : 					obj->Light->b = -col;

	mov	eax, DWORD PTR _col$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [edx+96], eax
$L83031:

; 1708 : 				}
; 1709 : 			}
; 1710 : 
; 1711 : // set pos
; 1712 : 
; 1713 : 			VecPlusScalarVec(&pickup->Pos, pickup->Timer, &pickup->Vel, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pickup$[ebp]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _pickup$[ebp]
	fadd	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [eax+20]
	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pickup$[ebp]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _pickup$[ebp]
	fadd	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pickup$[ebp]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _pickup$[ebp]
	fadd	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [eax+28]

; 1714 : 
; 1715 : // done?
; 1716 : 
; 1717 : 			if (pickup->Timer > 1.0f)

	mov	eax, DWORD PTR _pickup$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82976

; 1718 : 			{
; 1719 : 				pickup->Mode = 0;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax], 0

; 1720 : 				pickup->Timer = PICKUP_GEN_TIME;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax+8], 1092616192		; 41200000H

; 1721 : 
; 1722 : 				CopyVec(&pickup->Pos, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _pickup$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _pickup$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _pickup$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+28], edx

; 1723 : 
; 1724 : 				if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $L82976

; 1725 : 				{
; 1726 : 					FreeLight(obj->Light);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	push	ecx
	call	?FreeLight@@YAXPAULIGHT@@@Z		; FreeLight
	add	esp, 4

; 1727 : 					obj->Light = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+672], 0
$L82976:

; 1728 : 				}
; 1729 : 			}
; 1730 : 
; 1731 : 		break;
; 1732 : 	}
; 1733 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_PickupHandler@@YAXPAUobject_def@@@Z ENDP		; AI_PickupHandler
_TEXT	ENDS
PUBLIC	?AI_DissolveModelHandler@@YAXPAUobject_def@@@Z	; AI_DissolveModelHandler
PUBLIC	__real@42fe0000
EXTRN	?OBJ_FreeObject@@YAJPAUobject_def@@@Z:NEAR	; OBJ_FreeObject
;	COMDAT __real@42fe0000
CONST	SEGMENT
__real@42fe0000 DD 042fe0000r			; 127
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_DissolveModelHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
__temp$83101 = -132					; size = 4
__temp$83051 = -128					; size = 4
_mat$ = -124						; size = 36
_delta$ = -88						; size = 48
_centre$ = -40						; size = 12
_particle$ = -28					; size = 4
_dissolve$ = -24					; size = 4
_mrgb$ = -20						; size = 4
_mp$ = -16						; size = 4
_col$ = -12						; size = 4
_alpha$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_DissolveModelHandler@@YAXPAUobject_def@@@Z PROC NEAR ; AI_DissolveModelHandler, COMDAT

; 1742 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 1743 : 	long i, alpha, col;
; 1744 : 	MODEL_POLY *mp;
; 1745 : 	POLY_RGB *mrgb;
; 1746 : 	DISSOLVE_OBJ *dissolve = (DISSOLVE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _dissolve$[ebp], ecx

; 1747 : 	DISSOLVE_PARTICLE *particle = (DISSOLVE_PARTICLE*)(dissolve->Model.VertPtr + dissolve->Model.VertNum);

	mov	eax, DWORD PTR _dissolve$[ebp]
	movsx	ecx, WORD PTR [eax+38]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _dissolve$[ebp]
	add	ecx, DWORD PTR [edx+56]
	mov	DWORD PTR _particle$[ebp], ecx

; 1748 : 	VEC centre, delta[4];
; 1749 : 	MAT mat;
; 1750 : 
; 1751 : // loop thru polys
; 1752 : 
; 1753 : 	FTOL(255.0f - dissolve->Age * 127, alpha);

	mov	eax, DWORD PTR _dissolve$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR __real@42fe0000
	fsubr	DWORD PTR __real@437f0000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$83051[ebp]
	mov	eax, DWORD PTR __temp$83051[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _alpha$[ebp], eax

; 1754 : 	mp = dissolve->Model.PolyPtr;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _mp$[ebp], ecx

; 1755 : 	mrgb = dissolve->Model.PolyRGB;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _mrgb$[ebp], ecx

; 1756 : 
; 1757 : 	for (i = 0 ; i < dissolve->Model.PolyNum ; i++, mp++, mrgb++, particle++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83054
$L83055:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mp$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _mp$[ebp], ecx
	mov	edx, DWORD PTR _mrgb$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _mrgb$[ebp], edx
	mov	eax, DWORD PTR _particle$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _particle$[ebp], eax
$L83054:
	mov	eax, DWORD PTR _dissolve$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$L83056

; 1758 : 	{
; 1759 : 
; 1760 : // set alpha
; 1761 : 
; 1762 : 		mrgb->rgb[0].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _mrgb$[ebp]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [eax+3], cl

; 1763 : 		mrgb->rgb[1].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _mrgb$[ebp]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [eax+7], cl

; 1764 : 		mrgb->rgb[2].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _mrgb$[ebp]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [eax+11], cl

; 1765 : 		mrgb->rgb[3].a = (unsigned char)alpha;

	mov	eax, DWORD PTR _mrgb$[ebp]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [eax+15], cl

; 1766 : 
; 1767 : // get centre + vector offsets
; 1768 : 
; 1769 : 		centre.v[X] = (mp->v0->x + mp->v1->x + mp->v2->x + mp->v3->x) / 4.0f;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _mp$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx]
	fdiv	DWORD PTR __real@40800000
	fstp	DWORD PTR _centre$[ebp]

; 1770 : 		centre.v[Y] = (mp->v0->y + mp->v1->y + mp->v2->y + mp->v3->y) / 4.0f;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fld	DWORD PTR [ecx+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _mp$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+4]
	fdiv	DWORD PTR __real@40800000
	fstp	DWORD PTR _centre$[ebp+4]

; 1771 : 		centre.v[Z] = (mp->v0->z + mp->v1->z + mp->v2->z + mp->v3->z) / 4.0f;

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fld	DWORD PTR [ecx+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _mp$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+8]
	fdiv	DWORD PTR __real@40800000
	fstp	DWORD PTR _centre$[ebp+8]

; 1772 : 
; 1773 : 		SubVector((VEC*)&mp->v0->x, &centre, &delta[0]);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _centre$[ebp]
	fstp	DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _centre$[ebp+4]
	fstp	DWORD PTR _delta$[ebp+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _centre$[ebp+8]
	fstp	DWORD PTR _delta$[ebp+8]

; 1774 : 		SubVector((VEC*)&mp->v1->x, &centre, &delta[1]);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _centre$[ebp]
	fstp	DWORD PTR _delta$[ebp+12]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _centre$[ebp+4]
	fstp	DWORD PTR _delta$[ebp+16]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _centre$[ebp+8]
	fstp	DWORD PTR _delta$[ebp+20]

; 1775 : 		SubVector((VEC*)&mp->v2->x, &centre, &delta[2]);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _centre$[ebp]
	fstp	DWORD PTR _delta$[ebp+24]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _centre$[ebp+4]
	fstp	DWORD PTR _delta$[ebp+28]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _centre$[ebp+8]
	fstp	DWORD PTR _delta$[ebp+32]

; 1776 : 		SubVector((VEC*)&mp->v3->x, &centre, &delta[3]);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _centre$[ebp]
	fstp	DWORD PTR _delta$[ebp+36]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _centre$[ebp+4]
	fstp	DWORD PTR _delta$[ebp+40]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _centre$[ebp+8]
	fstp	DWORD PTR _delta$[ebp+44]

; 1777 : 
; 1778 : // spin points + add back centre
; 1779 : 
; 1780 : 		RotMatrixZYX(&mat, particle->Rot.v[X] * TimeStep, particle->Rot.v[Y] * TimeStep, particle->Rot.v[Z] * TimeStep);

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+20]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [ecx+16]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+12]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 1781 : 
; 1782 : 		RotTransVector(&mat, &centre, &delta[0], (VEC*)&mp->v0->x);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	lea	edx, DWORD PTR _delta$[ebp]
	push	edx
	lea	eax, DWORD PTR _centre$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1783 : 		RotTransVector(&mat, &centre, &delta[1], (VEC*)&mp->v1->x);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	lea	edx, DWORD PTR _delta$[ebp+12]
	push	edx
	lea	eax, DWORD PTR _centre$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1784 : 		RotTransVector(&mat, &centre, &delta[2], (VEC*)&mp->v2->x);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	lea	edx, DWORD PTR _delta$[ebp+24]
	push	edx
	lea	eax, DWORD PTR _centre$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1785 : 		RotTransVector(&mat, &centre, &delta[3], (VEC*)&mp->v3->x);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	lea	edx, DWORD PTR _delta$[ebp+36]
	push	edx
	lea	eax, DWORD PTR _centre$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1786 : 
; 1787 : // add velocity
; 1788 : 
; 1789 : 		particle->Vel.v[Y] += 192.0f * TimeStep;

	fld	DWORD PTR __real@43400000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	eax, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [ecx+4]

; 1790 : 
; 1791 : 		VecPlusEqScalarVec((VEC*)&mp->v0->x, TimeStep, &particle->Vel);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx]
	fadd	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+4]
	fadd	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+8]
	fadd	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	fstp	DWORD PTR [ecx+8]

; 1792 : 		VecPlusEqScalarVec((VEC*)&mp->v1->x, TimeStep, &particle->Vel);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx]
	fadd	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+4]
	fadd	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+8]
	fadd	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	fstp	DWORD PTR [ecx+8]

; 1793 : 		VecPlusEqScalarVec((VEC*)&mp->v2->x, TimeStep, &particle->Vel);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx]
	fadd	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+4]
	fadd	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+8]
	fadd	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	fstp	DWORD PTR [ecx+8]

; 1794 : 		VecPlusEqScalarVec((VEC*)&mp->v3->x, TimeStep, &particle->Vel);

	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx]
	fadd	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+4]
	fadd	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [edx+8]
	fadd	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fstp	DWORD PTR [ecx+8]

; 1795 : 	}

	jmp	$L83055
$L83056:

; 1796 : 
; 1797 : // set env rgb
; 1798 : 
; 1799 : 	FTOL(255.0f - dissolve->Age * 127, col);

	mov	eax, DWORD PTR _dissolve$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR __real@42fe0000
	fsubr	DWORD PTR __real@437f0000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$83101[ebp]
	mov	eax, DWORD PTR __temp$83101[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _col$[ebp], eax

; 1800 : 	((MODEL_RGB*)&dissolve->EnvRGB)->r = ((MODEL_RGB*)&obj->EnvRGB)->r * col / 256;

	mov	eax, DWORD PTR _obj$[ebp]
	movzx	eax, BYTE PTR [eax+654]
	imul	eax, DWORD PTR _col$[ebp]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _dissolve$[ebp]
	mov	BYTE PTR [ecx+66], al

; 1801 : 	((MODEL_RGB*)&dissolve->EnvRGB)->g = ((MODEL_RGB*)&obj->EnvRGB)->g * col / 256;

	mov	eax, DWORD PTR _obj$[ebp]
	movzx	eax, BYTE PTR [eax+653]
	imul	eax, DWORD PTR _col$[ebp]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _dissolve$[ebp]
	mov	BYTE PTR [ecx+65], al

; 1802 : 	((MODEL_RGB*)&dissolve->EnvRGB)->b = ((MODEL_RGB*)&obj->EnvRGB)->b * col / 256;

	mov	eax, DWORD PTR _obj$[ebp]
	movzx	eax, BYTE PTR [eax+652]
	imul	eax, DWORD PTR _col$[ebp]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _dissolve$[ebp]
	mov	BYTE PTR [ecx+64], al

; 1803 : 
; 1804 : // inc age
; 1805 : 
; 1806 : 	dissolve->Age += TimeStep;

	mov	eax, DWORD PTR _dissolve$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _dissolve$[ebp]
	fstp	DWORD PTR [ecx]

; 1807 : 	if (dissolve->Age > 2.0f)

	mov	eax, DWORD PTR _dissolve$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83038

; 1808 : 		OBJ_FreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?OBJ_FreeObject@@YAJPAUobject_def@@@Z	; OBJ_FreeObject
	add	esp, 4
$L83038:

; 1809 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_DissolveModelHandler@@YAXPAUobject_def@@@Z ENDP	; AI_DissolveModelHandler
_TEXT	ENDS
PUBLIC	?AI_LaserHandler@@YAXPAUobject_def@@@Z		; AI_LaserHandler
PUBLIC	__real@c2c80000
EXTRN	?LineOfSightObj@@YA_NPAUVectorStruct@@0PAM@Z:NEAR ; LineOfSightObj
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_LaserHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_laser$ = -28						; size = 4
_pos$ = -24						; size = 12
_vel$ = -12						; size = 12
_obj$ = 8						; size = 4
?AI_LaserHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_LaserHandler, COMDAT

; 1818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1819 : 	VEC vel, pos;
; 1820 : 	LASER_OBJ *laser = (LASER_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _laser$[ebp], ecx

; 1821 : 
; 1822 : 	// make sure it is visible
; 1823 : 	if (!obj->renderflag.visible) return;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $L83118
	jmp	$L83113
$L83118:

; 1824 : 
; 1825 : 	// Find the fractional distance from the laser source to intersection point with objects
; 1826 : 	if (laser->ObjectCollide) {

	mov	eax, DWORD PTR _laser$[ebp]
	movzx	ecx, BYTE PTR [eax+44]
	test	ecx, ecx
	je	SHORT $L83119

; 1827 : 		LineOfSightObj(&obj->body.Centre.Pos, &laser->Dest, &laser->Dist);

	mov	eax, DWORD PTR _laser$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _laser$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?LineOfSightObj@@YA_NPAUVectorStruct@@0PAM@Z ; LineOfSightObj
	add	esp, 12					; 0000000cH

; 1828 : 	} else {

	jmp	SHORT $L83120
$L83119:

; 1829 : 		laser->Dist = ONE;

	mov	eax, DWORD PTR _laser$[ebp]
	mov	DWORD PTR [eax+24], 1065353216		; 3f800000H
$L83120:

; 1830 : 	}
; 1831 : 
; 1832 : 	// Create sparks at the contact point
; 1833 : 	if (laser->Dist < ONE) {

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+24]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	$L83113

; 1834 : 		VecEqScalarVec(&vel, -100, &obj->body.Centre.WMatrix.mv[L]);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@c2c80000
	fmul	DWORD PTR [eax+124]
	fstp	DWORD PTR _vel$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@c2c80000
	fmul	DWORD PTR [eax+128]
	fstp	DWORD PTR _vel$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@c2c80000
	fmul	DWORD PTR [eax+132]
	fstp	DWORD PTR _vel$[ebp+8]

; 1835 : 		VecPlusScalarVec(&obj->body.Centre.Pos, laser->Dist, &laser->Delta, &pos)

	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _laser$[ebp]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [edx+20]
	fstp	DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _laser$[ebp]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [edx+24]
	fstp	DWORD PTR _pos$[ebp+4]
	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _laser$[ebp]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [edx+28]
	fstp	DWORD PTR _pos$[ebp+8]

; 1836 : 		CreateSpark(SPARK_SPARK, &pos, &vel, 200, laser->VisiMask);

	mov	eax, DWORD PTR _laser$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	push	1128792064				; 43480000H
	lea	eax, DWORD PTR _vel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H
$L83113:

; 1837 : 	}
; 1838 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_LaserHandler@@YAXPAUobject_def@@@Z ENDP		; AI_LaserHandler
_TEXT	ENDS
PUBLIC	?AI_SplashHandler@@YAXPAUobject_def@@@Z		; AI_SplashHandler
PUBLIC	__real@43c00000
;	COMDAT __real@43c00000
CONST	SEGMENT
__real@43c00000 DD 043c00000r			; 384
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AI_SplashHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_grav$ = -16						; size = 4
_spoly$ = -12						; size = 4
_splash$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_SplashHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_SplashHandler, COMDAT

; 1847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1848 : 	long i;
; 1849 : 	SPLASH_OBJ *splash = (SPLASH_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _splash$[ebp], ecx

; 1850 : 	SPLASH_POLY *spoly;
; 1851 : 	REAL grav;
; 1852 : 
; 1853 : // process each poly
; 1854 : 
; 1855 : 	spoly = splash->Poly;

	mov	eax, DWORD PTR _splash$[ebp]
	add	eax, 4
	mov	DWORD PTR _spoly$[ebp], eax

; 1856 : 	for (i = 0 ; i < SPLASH_POLY_NUM ; i++, spoly++) if (spoly->Frame < 16.0f)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83130
$L83131:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _spoly$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _spoly$[ebp], ecx
$L83130:
	cmp	DWORD PTR _i$[ebp], 150			; 00000096H
	jge	$L83132
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR [eax+96]
	fcomp	DWORD PTR __real@41800000
	fnstsw	ax
	test	ah, 5
	jp	$L83133

; 1857 : 	{
; 1858 : 		spoly->Frame += spoly->FrameAdd * TimeStep;

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+96]

; 1859 : 		if (spoly->Frame >= 16.0f)

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR [eax+96]
	fcomp	DWORD PTR __real@41800000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L83134

; 1860 : 		{
; 1861 : 			splash->Count--;

	mov	eax, DWORD PTR _splash$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _splash$[ebp]
	mov	DWORD PTR [edx], ecx

; 1862 : 			continue;

	jmp	SHORT $L83131
$L83134:

; 1863 : 		}
; 1864 : 
; 1865 : 		grav = 384.0f * TimeStep;

	fld	DWORD PTR __real@43c00000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _grav$[ebp]

; 1866 : 		spoly->Vel[0].v[Y] += grav;

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR _grav$[ebp]
	fadd	DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [ecx+52]

; 1867 : 		spoly->Vel[1].v[Y] += grav;

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR _grav$[ebp]
	fadd	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [ecx+64]

; 1868 : 		spoly->Vel[2].v[Y] += grav;

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR _grav$[ebp]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [ecx+76]

; 1869 : 		spoly->Vel[3].v[Y] += grav;

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR _grav$[ebp]
	fadd	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [ecx+88]

; 1870 : 
; 1871 : 		VecPlusEqScalarVec(&spoly->Pos[0], TimeStep, &spoly->Vel[0]);

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+8]

; 1872 : 		VecPlusEqScalarVec(&spoly->Pos[1], TimeStep, &spoly->Vel[1]);

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+20]

; 1873 : 		VecPlusEqScalarVec(&spoly->Pos[2], TimeStep, &spoly->Vel[2]);

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+32]

; 1874 : 		VecPlusEqScalarVec(&spoly->Pos[3], TimeStep, &spoly->Vel[3]);

	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+84]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR [eax+92]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fadd	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [edx+44]
$L83133:

; 1875 : 	}
; 1876 : 
; 1877 : // kill?
; 1878 : 
; 1879 : 	if (!splash->Count)

	jmp	$L83131
$L83132:
	mov	eax, DWORD PTR _splash$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L83124

; 1880 : 	{
; 1881 : 		OBJ_FreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?OBJ_FreeObject@@YAJPAUobject_def@@@Z	; OBJ_FreeObject
	add	esp, 4
$L83124:

; 1882 : 	}
; 1883 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_SplashHandler@@YAXPAUobject_def@@@Z ENDP		; AI_SplashHandler
_TEXT	ENDS
PUBLIC	?AI_SpeedupAIHandler@@YAXPAUobject_def@@@Z	; AI_SpeedupAIHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?AI_SpeedupAIHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_speedup$ = -4						; size = 4
_obj$ = 8						; size = 4
?AI_SpeedupAIHandler@@YAXPAUobject_def@@@Z PROC NEAR	; AI_SpeedupAIHandler, COMDAT

; 1896 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1897 : 	SPEEDUP_OBJ *speedup = (SPEEDUP_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _speedup$[ebp], ecx

; 1898 : 
; 1899 : 	// does this speedup change state?
; 1900 : 	if (speedup->ChangeTime == ZERO) return;

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [eax+20]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L83141
	jmp	SHORT $L83138
$L83141:

; 1901 : 
; 1902 : 	// Is it time to change?
; 1903 : 	speedup->Time += TimeStep;

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+24]

; 1904 : 	if (speedup->Time > speedup->ChangeTime) {

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+24]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83138

; 1905 : 		if (speedup->Speed == speedup->LoSpeed) {

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [eax+16]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L83143

; 1906 : 			speedup->Speed = speedup->HiSpeed;

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _speedup$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+16], edx

; 1907 : 		} else {

	jmp	SHORT $L83144
$L83143:

; 1908 : 			speedup->Speed = speedup->LoSpeed;

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _speedup$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+16], edx
$L83144:

; 1909 : 		}
; 1910 : 		speedup->Time = ZERO;

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	DWORD PTR [eax+24], 0
$L83138:

; 1911 : 	}
; 1912 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AI_SpeedupAIHandler@@YAXPAUobject_def@@@Z ENDP		; AI_SpeedupAIHandler
_TEXT	ENDS
PUBLIC	?SpeedupImpulse@@YAXPAUCarStruct@@@Z		; SpeedupImpulse
PUBLIC	__real@c0000000
EXTRN	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z:NEAR ; PointInCollPolyBounds
EXTRN	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z:NEAR ; LinePlaneIntersect
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SpeedupImpulse@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
tv283 = -144						; size = 4
tv258 = -144						; size = 4
tv238 = -144						; size = 4
tv218 = -144						; size = 4
tv198 = -144						; size = 4
tv178 = -144						; size = 4
tv158 = -144						; size = 4
tv137 = -144						; size = 4
_speedup$ = -76						; size = 4
_obj$ = -72						; size = 4
_bBox$ = -68						; size = 24
_wPos$ = -44						; size = 12
_dPos$ = -32						; size = 12
_impMag$ = -20						; size = 4
_vel$ = -16						; size = 4
_velDotNorm$ = -12					; size = 4
_depth$ = -8						; size = 4
_time$ = -4						; size = 4
_car$ = 8						; size = 4
?SpeedupImpulse@@YAXPAUCarStruct@@@Z PROC NEAR		; SpeedupImpulse, COMDAT

; 1916 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 1917 : 	REAL time, depth, velDotNorm, vel, impMag;
; 1918 : 	VEC dPos, wPos;
; 1919 : 	BBOX bBox;
; 1920 : 	OBJECT *obj;
; 1921 : 	SPEEDUP_OBJ *speedup;
; 1922 : 
; 1923 : 	// loop over objects checking for speedups
; 1924 : 	for (obj = OBJ_ObjectHead; obj != NULL; obj = obj->next) {

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj$[ebp], eax
	jmp	SHORT $L83158
$L83159:
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj$[ebp], ecx
$L83158:
	cmp	DWORD PTR _obj$[ebp], 0
	je	$L83147

; 1925 : 
; 1926 : 		if (obj->Type != OBJECT_TYPE_SPEEDUP) continue;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+568], 9
	je	SHORT $L83161
	jmp	SHORT $L83159
$L83161:

; 1927 : 		speedup = (SPEEDUP_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _speedup$[ebp], ecx

; 1928 : 
; 1929 : 		// Check for collision between speedup and car
; 1930 : 		if (!BBTestXZY(&speedup->CollPoly.BBox, &car->BBox)) continue;

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+116]
	fcomp	DWORD PTR [ecx+3152]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L83508
	mov	edx, DWORD PTR _speedup$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+120]
	fcomp	DWORD PTR [eax+3148]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83508
	mov	ecx, DWORD PTR _speedup$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+132]
	fcomp	DWORD PTR [edx+3168]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83508
	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+136]
	fcomp	DWORD PTR [ecx+3164]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83508
	mov	edx, DWORD PTR _speedup$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+124]
	fcomp	DWORD PTR [eax+3160]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83508
	mov	ecx, DWORD PTR _speedup$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+128]
	fcomp	DWORD PTR [edx+3156]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83508
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $L83509
$L83508:
	mov	DWORD PTR tv137[ebp], 0
$L83509:
	cmp	DWORD PTR tv137[ebp], 0
	jne	SHORT $L83163
	jmp	$L83159
$L83163:

; 1931 : 
; 1932 : 		// Quick bounding-box test
; 1933 : 		SetBBox(&bBox, 
; 1934 : 			Min(car->Body->Centre.Pos.v[X], car->Body->Centre.OldPos.v[X]),
; 1935 : 			Max(car->Body->Centre.Pos.v[X], car->Body->Centre.OldPos.v[X]),
; 1936 : 			Min(car->Body->Centre.Pos.v[Y], car->Body->Centre.OldPos.v[Y]),
; 1937 : 			Max(car->Body->Centre.Pos.v[Y], car->Body->Centre.OldPos.v[Y]),
; 1938 : 			Min(car->Body->Centre.Pos.v[Z], car->Body->Centre.OldPos.v[Z]),
; 1939 : 			Max(car->Body->Centre.Pos.v[Z], car->Body->Centre.OldPos.v[Z]));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83510
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv158[ebp], eax
	jmp	SHORT $L83511
$L83510:
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv158[ebp], eax
$L83511:
	mov	ecx, DWORD PTR tv158[ebp]
	mov	DWORD PTR _bBox$[ebp], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83512
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv178[ebp], eax
	jmp	SHORT $L83513
$L83512:
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv178[ebp], eax
$L83513:
	mov	ecx, DWORD PTR tv178[ebp]
	mov	DWORD PTR _bBox$[ebp+4], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83514
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv198[ebp], eax
	jmp	SHORT $L83515
$L83514:
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv198[ebp], eax
$L83515:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR _bBox$[ebp+8], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83516
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv218[ebp], eax
	jmp	SHORT $L83517
$L83516:
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv218[ebp], eax
$L83517:
	mov	ecx, DWORD PTR tv218[ebp]
	mov	DWORD PTR _bBox$[ebp+12], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [eax+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83518
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv238[ebp], eax
	jmp	SHORT $L83519
$L83518:
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv238[ebp], eax
$L83519:
	mov	ecx, DWORD PTR tv238[ebp]
	mov	DWORD PTR _bBox$[ebp+16], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [eax+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83520
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv258[ebp], eax
	jmp	SHORT $L83521
$L83520:
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv258[ebp], eax
$L83521:
	mov	ecx, DWORD PTR tv258[ebp]
	mov	DWORD PTR _bBox$[ebp+20], ecx

; 1940 : 		if(!BBTestYXZ(&bBox, &speedup->CollPoly.BBox)) continue;

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _bBox$[ebp+8]
	fcomp	DWORD PTR [eax+128]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83522
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _bBox$[ebp+12]
	fcomp	DWORD PTR [ecx+124]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83522
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _bBox$[ebp]
	fcomp	DWORD PTR [edx+120]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83522
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _bBox$[ebp+4]
	fcomp	DWORD PTR [eax+116]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83522
	mov	ecx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _bBox$[ebp+16]
	fcomp	DWORD PTR [ecx+136]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83522
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR _bBox$[ebp+20]
	fcomp	DWORD PTR [edx+132]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83522
	mov	DWORD PTR tv283[ebp], 1
	jmp	SHORT $L83523
$L83522:
	mov	DWORD PTR tv283[ebp], 0
$L83523:
	cmp	DWORD PTR tv283[ebp], 0
	jne	SHORT $L83164
	jmp	$L83159
$L83164:

; 1941 : 
; 1942 : 		// Check for point passing through collision polygon
; 1943 : 		if (!LinePlaneIntersect(&car->Body->Centre.OldPos, &car->Body->Centre.Pos, &speedup->CollPoly.Plane, &time, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _speedup$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 8
	push	eax
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L83165

; 1944 : 			continue;

	jmp	$L83159
$L83165:

; 1945 : 		}
; 1946 : 
; 1947 : 		// Calculate the intersection point
; 1948 : 		VecMinusVec(&car->Body->Centre.Pos, &car->Body->Centre.OldPos, &dPos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR _dPos$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR [eax+12]
	fstp	DWORD PTR _dPos$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR [eax+16]
	fstp	DWORD PTR _dPos$[ebp+8]

; 1949 : 		VecPlusScalarVec(&car->Body->Centre.OldPos, time, &dPos, &wPos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR _wPos$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+4]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR _wPos$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+8]
	fadd	DWORD PTR [ecx+16]
	fstp	DWORD PTR _wPos$[ebp+8]

; 1950 : 
; 1951 : 		// Check intersection point is within the polygon boundary
; 1952 : 		if (!PointInCollPolyBounds(&wPos, &speedup->CollPoly)) {

	mov	eax, DWORD PTR _speedup$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR _wPos$[ebp]
	push	ecx
	call	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ; PointInCollPolyBounds
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L83166

; 1953 : 			continue;

	jmp	$L83159
$L83166:

; 1954 : 		}
; 1955 : 
; 1956 : 		// Make sure the particle is travelling towards the poly
; 1957 : 		velDotNorm = VecDotVec(&car->Body->Centre.Vel, PlaneNormal(&speedup->CollPoly.Plane));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+36]
	fmul	DWORD PTR [edx+40]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR [edx+44]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 1958 : 		if (velDotNorm > ZERO) {

	fld	DWORD PTR _velDotNorm$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L83170

; 1959 : 			vel = VecDotVec(&car->Body->Centre.Vel, &car->Body->Centre.WMatrix.mv[L]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+128]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+132]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vel$[ebp]

; 1960 : 			if (vel > ZERO) {

	fld	DWORD PTR _vel$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83171

; 1961 : 				impMag = car->Body->Centre.Mass * (speedup->Speed - vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _impMag$[ebp]

; 1962 : 			} else {

	jmp	SHORT $L83172
$L83171:

; 1963 : 				impMag = car->Body->Centre.Mass * (-speedup->Speed - vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [edx+16]
	fchs
	fsub	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _impMag$[ebp]
$L83172:

; 1964 : 			}
; 1965 : 		} else {

	jmp	$L83173
$L83170:

; 1966 : 			vel = VecDotVec(&car->Body->Centre.Vel, &car->Body->Centre.WMatrix.mv[L]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+128]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+132]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vel$[ebp]

; 1967 : 			if (vel > ZERO) {

	fld	DWORD PTR _vel$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83174

; 1968 : 				impMag = car->Body->Centre.Mass * (-speedup->LoSpeed - vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [edx+8]
	fchs
	fsub	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _impMag$[ebp]

; 1969 : 			} else {

	jmp	SHORT $L83173
$L83174:

; 1970 : 				impMag = car->Body->Centre.Mass * (speedup->LoSpeed - vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _impMag$[ebp]
$L83173:

; 1971 : 			}
; 1972 : 		}
; 1973 : 
; 1974 : 		if (depth < ZERO) {

	fld	DWORD PTR _depth$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	$L83176

; 1975 : 			VecPlusEqScalarVec(&car->Body->Centre.Shift, -2 * (depth - COLL_EPSILON), &speedup->CollPoly.Plane);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _depth$[ebp]
	fsub	DWORD PTR __real@40000000
	fmul	DWORD PTR __real@c0000000
	mov	edx, DWORD PTR _speedup$[ebp]
	fmul	DWORD PTR [edx+36]
	fadd	DWORD PTR [ecx+200]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fstp	DWORD PTR [ecx+200]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _depth$[ebp]
	fsub	DWORD PTR __real@40000000
	fmul	DWORD PTR __real@c0000000
	mov	edx, DWORD PTR _speedup$[ebp]
	fmul	DWORD PTR [edx+40]
	fadd	DWORD PTR [ecx+204]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fstp	DWORD PTR [ecx+204]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _depth$[ebp]
	fsub	DWORD PTR __real@40000000
	fmul	DWORD PTR __real@c0000000
	mov	edx, DWORD PTR _speedup$[ebp]
	fmul	DWORD PTR [edx+44]
	fadd	DWORD PTR [ecx+208]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fstp	DWORD PTR [ecx+208]
$L83176:

; 1976 : 		}
; 1977 : 
; 1978 : 
; 1979 : 		// Apply impulse to the car
; 1980 : 		VecPlusEqScalarVec(&car->Body->Centre.Impulse, impMag, &car->Body->Centre.WMatrix.mv[L]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _impMag$[ebp]
	fmul	DWORD PTR [eax+124]
	fadd	DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+56]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _impMag$[ebp]
	fmul	DWORD PTR [eax+128]
	fadd	DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+60]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _impMag$[ebp]
	fmul	DWORD PTR [eax+132]
	fadd	DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+64]

; 1981 : 
; 1982 : 	}

	jmp	$L83159
$L83147:

; 1983 : 
; 1984 : 
; 1985 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpeedupImpulse@@YAXPAUCarStruct@@@Z ENDP		; SpeedupImpulse
_TEXT	ENDS
END
