; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\ReadInit.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BJ@IPJEKABE@Could?5not?5find?5file?5name?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OKGDLNCL@NONE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@KDDNJEHJ@Could?5not?5read?5integer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HCDDPBNL@TRUE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IPHJCBHH@YES?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MAJJAKPI@FALSE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02NFLNFON@NO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFDLKPNA@Could?5not?5read?5vector?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MNAHJMBI@Could?5not?5read?5Matrix?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@DCLKCFFC@Could?5not?5open?5CarInit?5file?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KGLEMGGD@NUMCARS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IN@BPKIBILN@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KOMPAPBB@CAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DAGGNFD@Car?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@GJMPDGPA@Error?5in?5CarInit?5file?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BJLDAIDO@MODEL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NFIJOKEG@Model?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DKECMECL@TPAGE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CADPFKMD@ENVRGB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MALFBGLN@COLL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GJALCMIF@COM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06GANGLKEK@WEAPON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MEHDIIKB@BODY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LBGCJCLG@WHEEL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HNFIHAMO@Wheel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FGCBKJHB@AERIAL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BNNDCJEI@SPRING?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NGEFMOAG@Spring?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KGHJJBLC@AXLE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KLICFMMO@Axle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EAHPLIF@PIN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KJMOJJMH@Pin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CICCNPHL@SPINNER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NACABLMM@STEERRATE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OJNPGGI@STEERMOD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PDFEHAIB@ENGINERATE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BJKHBKGK@TOPSPEED?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07DNFKGLMM@MAXREVS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GILDKIMA@DOWNFORCEMOD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04IPKHEEB@NAME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NDAOGOPN@BESTTIME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@BGJAAOOG@SELECTABLE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OACPFCKA@MODELNUM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KPFMBGLO@OFFSET?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EFHKDFDM@MASS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HHDLKAPO@INERTIA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JIEIIHJI@GRAVITY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NGNOIIA@HARDNESS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NFJMCNIC@RESISTANCE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NJKNDHJM@ANGRES?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HAFCDGMH@RESMOD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NCOGJENF@STATICFRICTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKHKGPBI@KINETICFRICTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HHPKKAIJ@GRIP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OKCLMFCP@OFFSET1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MBAGJGOM@OFFSET2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KCFDAKCE@RADIUS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KKHFKCDD@MAXPOS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@NCEBIKPJ@AXLEFRICTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OMPJAECO@STEERRATIO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OELHENGI@ENGINERATIO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HIDOAEMD@ISTURNABLE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NALINNHD@ISPOWERED?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PMFGHDFJ@ISPRESENT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JHAMDBMI@SKIDWIDTH?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MLIGBJO@LENGTH?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BNIFBKBF@STIFFNESS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HNIDCKIK@DAMPING?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NFADOHD@RESTITUTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LMCKOGIO@AXIS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JLJFKOFF@ANGVEL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OEIEABJD@SECMODELNUM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LOCKIKHD@TOPMODELNUM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EPFKIFGC@DIRECTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@BNOGOCOE@?$CC?$CFs?$CC?6?6Continue?$DP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GOKDACMG@Unrecognised?5word?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@MAOHNJL@Initialisation?5Error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@EABDAOBM@Invalid?5variable?5for?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@GHAKLHEF@Invalid?5number?5list?5for?6?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadWord@@YA_NPADPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadFileName@@YA_NPADPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadInt@@YA_NPAHPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadBool@@YA_NPA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadReal@@YA_NPAMPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadMat@@YA_NPATMatrixUnion@@PAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringToUpper@@YA_NPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compare@@YA_NPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadAllCarInfo@@YA_NPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadCarInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadBodyInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadWheelInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadSpringInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadAxleInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadPinInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadSpinnerInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadAerialInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnknownWordMessage@@YAHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowErrorMessage@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidNumberList@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??ReadAllCarInfo@@YA_NPAD@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?CarList@@3PAHA					; CarList
PUBLIC	?CarListSize@@3HA				; CarListSize
PUBLIC	?WheelList@@3PAHA				; WheelList
PUBLIC	?WheelListSize@@3HA				; WheelListSize
PUBLIC	?SpringList@@3PAHA				; SpringList
PUBLIC	?SpringListSize@@3HA				; SpringListSize
PUBLIC	?AxleList@@3PAHA				; AxleList
PUBLIC	?AxleListSize@@3HA				; AxleListSize
PUBLIC	?PinList@@3PAHA					; PinList
PUBLIC	?PinListSize@@3HA				; PinListSize
PUBLIC	?ModelList@@3PAHA				; ModelList
PUBLIC	?ModelListSize@@3HA				; ModelListSize
_BSS	SEGMENT
?CarList@@3PAHA DD 01H DUP (?)				; CarList
?CarListSize@@3HA DD 01H DUP (?)			; CarListSize
?WheelList@@3PAHA DD 04H DUP (?)			; WheelList
?WheelListSize@@3HA DD 01H DUP (?)			; WheelListSize
?SpringList@@3PAHA DD 04H DUP (?)			; SpringList
?SpringListSize@@3HA DD 01H DUP (?)			; SpringListSize
?AxleList@@3PAHA DD 04H DUP (?)				; AxleList
?AxleListSize@@3HA DD 01H DUP (?)			; AxleListSize
?PinList@@3PAHA DD 04H DUP (?)				; PinList
?PinListSize@@3HA DD 01H DUP (?)			; PinListSize
?ModelList@@3PAHA DD 013H DUP (?)			; ModelList
?ModelListSize@@3HA DD 01H DUP (?)			; ModelListSize
_BSS	ENDS
PUBLIC	?StringToUpper@@YA_NPAD@Z			; StringToUpper
EXTRN	_toupper:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\readinit.cpp
;	COMDAT ?StringToUpper@@YA_NPAD@Z
_TEXT	SEGMENT
_sLen$ = -8						; size = 4
_iChar$ = -4						; size = 4
_string$ = 8						; size = 4
?StringToUpper@@YA_NPAD@Z PROC NEAR			; StringToUpper, COMDAT

; 276  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 277  : 	int iChar;
; 278  : 	int sLen = strlen(string);

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sLen$[ebp], eax

; 279  : 
; 280  : 	if (sLen > READ_MAX_WORDLEN) return FALSE;

	cmp	DWORD PTR _sLen$[ebp], 256		; 00000100H
	jle	SHORT $L80333
	xor	al, al
	jmp	SHORT $L80330
$L80333:

; 281  : 	
; 282  : 	for (iChar = 0; iChar < sLen; ++iChar) {

	mov	DWORD PTR _iChar$[ebp], 0
	jmp	SHORT $L80334
$L80335:
	mov	eax, DWORD PTR _iChar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iChar$[ebp], eax
$L80334:
	mov	eax, DWORD PTR _iChar$[ebp]
	cmp	eax, DWORD PTR _sLen$[ebp]
	jge	SHORT $L80336

; 283  : 		string[iChar] = toupper(string[iChar]);

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, DWORD PTR _iChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_toupper
	add	esp, 4
	mov	edx, DWORD PTR _string$[ebp]
	add	edx, DWORD PTR _iChar$[ebp]
	mov	BYTE PTR [edx], al

; 284  : 	}

	jmp	SHORT $L80335
$L80336:

; 285  : 	return TRUE;

	mov	al, 1
$L80330:

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StringToUpper@@YA_NPAD@Z ENDP				; StringToUpper
_TEXT	ENDS
PUBLIC	?ReadAllCarInfo@@YA_NPAD@Z			; ReadAllCarInfo
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0BM@DCLKCFFC@Could?5not?5open?5CarInit?5file?$AA@ ; `string'
PUBLIC	??_C@_07KGLEMGGD@NUMCARS?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??ReadAllCarInfo@@YA_NPAD@Z@4JA	; `ReadAllCarInfo'::`2'::__LINE__Var
PUBLIC	??_C@_0IN@BPKIBILN@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	??_C@_03KOMPAPBB@CAR?$AA@			; `string'
PUBLIC	??_C@_03DAGGNFD@Car?$AA@			; `string'
PUBLIC	??_C@_0BG@GJMPDGPA@Error?5in?5CarInit?5file?$AA@ ; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
EXTRN	?CreateCarInfo@@YAPAUCAR_INFO@@J@Z:NEAR		; CreateCarInfo
EXTRN	?CarInfo@@3PAUCAR_INFO@@A:DWORD			; CarInfo
EXTRN	?NCarTypes@@3JA:DWORD				; NCarTypes
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DCLKCFFC@Could?5not?5open?5CarInit?5file?$AA@
CONST	SEGMENT
??_C@_0BM@DCLKCFFC@Could?5not?5open?5CarInit?5file?$AA@ DB 'Could not ope'
	DB	'n CarInit file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGLEMGGD@NUMCARS?$AA@
CONST	SEGMENT
??_C@_07KGLEMGGD@NUMCARS?$AA@ DB 'NUMCARS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IN@BPKIBILN@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IN@BPKIBILN@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\readi'
	DB	'nit.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ReadAllCarInfo@@YA_NPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ReadAllCarInfo@@YA_NPAD@Z@4JA DD 01a0H	; `ReadAllCarInfo'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03KOMPAPBB@CAR?$AA@
CONST	SEGMENT
??_C@_03KOMPAPBB@CAR?$AA@ DB 'CAR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAGGNFD@Car?$AA@
CONST	SEGMENT
??_C@_03DAGGNFD@Car?$AA@ DB 'Car', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GJMPDGPA@Error?5in?5CarInit?5file?$AA@
CONST	SEGMENT
??_C@_0BG@GJMPDGPA@Error?5in?5CarInit?5file?$AA@ DB 'Error in CarInit fil'
	DB	'e', 00H					; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadAllCarInfo@@YA_NPAD@Z
_TEXT	SEGMENT
_tInt$ = -264						; size = 4
_fp$ = -260						; size = 4
_word$ = -256						; size = 256
_fileName$ = 8						; size = 4
?ReadAllCarInfo@@YA_NPAD@Z PROC NEAR			; ReadAllCarInfo, COMDAT

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi

; 417  : 	char word[READ_MAX_WORDLEN];
; 418  : 	FILE *fp;
; 419  : 
; 420  : 	int tInt;
; 421  : 
; 422  : 	// Open the file
; 423  : 	if ((fp = fopen(fileName, "r")) == NULL) {

	push	OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
	mov	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L80397

; 424  : 		ShowErrorMessage("Could not open CarInit file");

	push	OFFSET FLAT:??_C@_0BM@DCLKCFFC@Could?5not?5open?5CarInit?5file?$AA@
	call	?ShowErrorMessage@@YAXPAD@Z		; ShowErrorMessage
	add	esp, 4

; 425  : 		return FALSE;

	xor	al, al
	jmp	$L80389
$L80397:

; 426  : 	}
; 427  : 
; 428  : 	// Read in keywords and act on them
; 429  : 	while (ReadWord(word, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80398

; 430  : 
; 431  : 		// NCARS
; 432  : 		if (Compare(word, "NUMCARS")) {

	push	OFFSET FLAT:??_C@_07KGLEMGGD@NUMCARS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80399

; 433  : 			// read in the number of cars
; 434  : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 435  : 			NCarTypes = tInt;

	mov	eax, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR ?NCarTypes@@3JA, eax		; NCarTypes

; 436  : 			if (CarInfo == NULL) {

	cmp	DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A, 0	; CarInfo
	jne	SHORT $L80401

; 437  : 				CarInfo = CreateCarInfo(NCarTypes);

	mov	eax, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	push	eax
	call	?CreateCarInfo@@YAPAUCAR_INFO@@J@Z	; CreateCarInfo
	add	esp, 4
	mov	DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A, eax ; CarInfo
$L80401:

; 438  : 			}
; 439  : 			CarList = (int *)malloc(sizeof(int) * NCarTypes);

	push	OFFSET FLAT:??_C@_0IN@BPKIBILN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??ReadAllCarInfo@@YA_NPAD@Z@4JA
	add	eax, 23					; 00000017H
	push	eax
	mov	ecx, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	shl	ecx, 2
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?CarList@@3PAHA, eax		; CarList

; 440  : 		}
; 441  : 
; 442  : 		// CAR
; 443  : 		else if (Compare(word, "CAR")) {

	jmp	$L80406
$L80399:
	push	OFFSET FLAT:??_C@_03KOMPAPBB@CAR?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80407

; 444  : 			if ((CarListSize = ReadNumberList(CarList, NCarTypes, fp)) < 0) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	push	ecx
	mov	edx, DWORD PTR ?CarList@@3PAHA		; CarList
	push	edx
	call	?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z	; ReadNumberList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?CarListSize@@3HA, eax	; CarListSize
	cmp	DWORD PTR ?CarListSize@@3HA, 0		; CarListSize
	jge	SHORT $L80409

; 445  : 				InvalidNumberList("Car");

	push	OFFSET FLAT:??_C@_03DAGGNFD@Car?$AA@
	call	?InvalidNumberList@@YAXPAD@Z		; InvalidNumberList
	add	esp, 4

; 446  : 				fclose(fp); 

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 447  : 				return FALSE;

	xor	al, al
	jmp	$L80389
$L80409:

; 448  : 			}
; 449  : 			if (!ReadCarInfo(fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadCarInfo@@YA_NPAU_iobuf@@@Z		; ReadCarInfo
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80411

; 450  : 				ShowErrorMessage("Error in CarInit file");

	push	OFFSET FLAT:??_C@_0BG@GJMPDGPA@Error?5in?5CarInit?5file?$AA@
	call	?ShowErrorMessage@@YAXPAD@Z		; ShowErrorMessage
	add	esp, 4

; 451  : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 452  : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80389
$L80411:

; 453  : 			}
; 454  : 		}
; 455  : 
; 456  : 		// DEFAULT
; 457  : 		else {

	jmp	SHORT $L80406
$L80407:

; 458  : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L80406

; 459  : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 460  : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80389
$L80406:

; 461  : 			}
; 462  : 		}
; 463  : 	}

	jmp	$L80397
$L80398:

; 464  : 
; 465  : 	free(CarList);

	push	OFFSET FLAT:??_C@_0IN@BPKIBILN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??ReadAllCarInfo@@YA_NPAD@Z@4JA
	add	eax, 49					; 00000031H
	push	eax
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 466  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 467  : 
; 468  : 	return TRUE;

	mov	al, 1
$L80389:

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadAllCarInfo@@YA_NPAD@Z ENDP				; ReadAllCarInfo
_TEXT	ENDS
EXTRN	_fgetc:NEAR
EXTRN	_ungetc:NEAR
EXTRN	_isspace:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?ReadWord@@YA_NPADPAU_iobuf@@@Z
_TEXT	SEGMENT
_pChar$ = -4						; size = 4
_buf$ = 8						; size = 4
_fp$ = 12						; size = 4
?ReadWord@@YA_NPADPAU_iobuf@@@Z PROC NEAR		; ReadWord, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 35   : 	char *pChar = buf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pChar$[ebp], eax
$L80230:

; 36   : 
; 37   : 	// Skip white space and commas
; 38   : 	while (isspace(*pChar = fgetc(fp)) || (*pChar == ',')) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	ecx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pChar$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $L80232
	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $L80234
$L80232:

; 39   : 	}

	jmp	SHORT $L80230
$L80234:

; 40   : 
; 41   : 	// Check for comments
; 42   : 	while (*pChar == READ_COMMENT_CHAR) {

	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $L80235
$L80237:

; 43   : 		// Go to next line
; 44   : 		while ((*pChar = fgetc(fp)) != '\n' && (*pChar != EOF)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	ecx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pChar$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $L80238
	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	je	SHORT $L80238

; 45   : 			NULL;
; 46   : 		}

	jmp	SHORT $L80237
$L80238:

; 47   : 
; 48   : 		// Skip the white space again
; 49   : 		if (*pChar != EOF) {

	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	je	SHORT $L80239
$L80241:

; 50   : 			while (isspace(*pChar = fgetc(fp))) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	ecx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pChar$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80239

; 51   : 			}

	jmp	SHORT $L80241
$L80239:

; 52   : 		}
; 53   : 	}

	jmp	SHORT $L80234
$L80235:

; 54   : 
; 55   : 	// Check for EOF
; 56   : 	if (*pChar == EOF) {

	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	jne	SHORT $L80245

; 57   : 		buf[0] = NULL;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	BYTE PTR [eax], 0

; 58   : 		return FALSE;

	xor	al, al
	jmp	SHORT $L80227
$L80245:

; 59   : 	}
; 60   : 
; 61   : 	// Read in chars up to next white space, brace or comma
; 62   : 	while (!isspace(*++pChar = fgetc(fp)) && 
; 63   : 		(*pChar != EOF) && 
; 64   : 		(*pChar != '{') &&
; 65   : 		(*pChar != '}') &&
; 66   : 		(*pChar != ',')) 

	mov	eax, DWORD PTR _pChar$[ebp]
	add	eax, 1
	mov	DWORD PTR _pChar$[ebp], eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fgetc
	add	esp, 4
	mov	edx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $L80246
	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	je	SHORT $L80246
	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $L80246
	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 125				; 0000007dH
	je	SHORT $L80246
	mov	eax, DWORD PTR _pChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $L80246

; 67   : 	{
; 68   : 		NULL;
; 69   : 	}

	jmp	SHORT $L80245
$L80246:

; 70   : 	ungetc(*pChar, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChar$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	_ungetc
	add	esp, 8

; 71   : 	*pChar = '\0';

	mov	eax, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [eax], 0

; 72   : 
; 73   : 	return TRUE;

	mov	al, 1
$L80227:

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadWord@@YA_NPADPAU_iobuf@@@Z ENDP			; ReadWord
_TEXT	ENDS
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0BH@KDDNJEHJ@Could?5not?5read?5integer?$AA@ ; `string'
EXTRN	_fscanf:NEAR
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KDDNJEHJ@Could?5not?5read?5integer?$AA@
CONST	SEGMENT
??_C@_0BH@KDDNJEHJ@Could?5not?5read?5integer?$AA@ DB 'Could not read inte'
	DB	'ger', 00H					; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadInt@@YA_NPAHPAU_iobuf@@@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_fp$ = 12						; size = 4
?ReadInt@@YA_NPAHPAU_iobuf@@@Z PROC NEAR		; ReadInt, COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 137  : 	if (fscanf(fp, "%d", n) == EOF) {

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fscanf
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $L80279

; 138  : 		ShowErrorMessage("Could not read integer");

	push	OFFSET FLAT:??_C@_0BH@KDDNJEHJ@Could?5not?5read?5integer?$AA@
	call	?ShowErrorMessage@@YAXPAD@Z		; ShowErrorMessage
	add	esp, 4

; 139  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L80278
$L80279:

; 140  : 	} else {
; 141  : 		return TRUE;

	mov	al, 1
$L80278:

; 142  : 	}
; 143  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadInt@@YA_NPAHPAU_iobuf@@@Z ENDP			; ReadInt
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?Compare@@YA_NPAD0@Z
_TEXT	SEGMENT
_iChar$ = -8						; size = 4
_wordLen$ = -4						; size = 4
_word$ = 8						; size = 4
_token$ = 12						; size = 4
?Compare@@YA_NPAD0@Z PROC NEAR				; Compare, COMDAT

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 311  : 	unsigned int wordLen;
; 312  : 	unsigned int iChar;
; 313  : 
; 314  : 	wordLen = strlen(word);

	mov	eax, DWORD PTR _word$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _wordLen$[ebp], eax

; 315  : 
; 316  : 	if (wordLen != strlen(token)) return FALSE;

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _wordLen$[ebp], eax
	je	SHORT $L80343
	xor	al, al
	jmp	SHORT $L80340
$L80343:

; 317  : 
; 318  : 	for (iChar = 0; iChar < wordLen; iChar++) {

	mov	DWORD PTR _iChar$[ebp], 0
	jmp	SHORT $L80344
$L80345:
	mov	eax, DWORD PTR _iChar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iChar$[ebp], eax
$L80344:
	mov	eax, DWORD PTR _iChar$[ebp]
	cmp	eax, DWORD PTR _wordLen$[ebp]
	jae	SHORT $L80346

; 319  : 		if (toupper(word[iChar]) != toupper(token[iChar])) {

	mov	eax, DWORD PTR _word$[ebp]
	add	eax, DWORD PTR _iChar$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_toupper
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _token$[ebp]
	add	edx, DWORD PTR _iChar$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_toupper
	add	esp, 4
	cmp	esi, eax
	je	SHORT $L80347

; 320  : 			return FALSE;

	xor	al, al
	jmp	SHORT $L80340
$L80347:

; 321  : 		}
; 322  : 	}

	jmp	SHORT $L80345
$L80346:

; 323  : 
; 324  : 	return TRUE;

	mov	al, 1
$L80340:

; 325  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Compare@@YA_NPAD0@Z ENDP				; Compare
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z
_TEXT	SEGMENT
tv133 = -88						; size = 4
tv95 = -88						; size = 4
tv79 = -88						; size = 4
_ch$ = -18						; size = 1
_doneList$ = -17					; size = 1
_tmpNum$ = -16						; size = 4
_endNum$ = -12						; size = 4
_startNum$ = -8						; size = 4
_iN$ = -4						; size = 4
_numList$ = 8						; size = 4
_maxNum$ = 12						; size = 4
_fp$ = 16						; size = 4
?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z PROC NEAR		; ReadNumberList, COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 335  : 	int iN = 0;

	mov	DWORD PTR _iN$[ebp], 0
$L80360:

; 336  : 	int startNum, endNum, tmpNum;
; 337  : 	bool doneList;
; 338  : 	char ch;
; 339  : 
; 340  : 	// Skip white space
; 341  : 	while (isspace(ch = fgetc(fp))) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80361

; 342  : 		NULL;
; 343  : 	}

	jmp	SHORT $L80360
$L80361:

; 344  : 	ungetc(ch, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_ungetc
	add	esp, 8

; 345  : 
; 346  : 	// Read the first number
; 347  : 	if ((!ReadInt(&numList[iN++], fp))) {

	mov	eax, DWORD PTR _iN$[ebp]
	mov	ecx, DWORD PTR _numList$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8
	movzx	edx, al
	mov	eax, DWORD PTR _iN$[ebp]
	add	eax, 1
	mov	DWORD PTR _iN$[ebp], eax
	test	edx, edx
	jne	SHORT $L80362

; 348  : 		return 0;

	xor	eax, eax
	jmp	$L80352
$L80362:

; 349  : 	}
; 350  : 
; 351  : 	if (numList[0] < 0) {

	mov	eax, DWORD PTR _numList$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $L80363

; 352  : 		return -1;

	or	eax, -1
	jmp	$L80352
$L80363:

; 353  : 	}
; 354  : 
; 355  : 	// Read in the rest of the numbers
; 356  : 	doneList = FALSE;

	mov	BYTE PTR _doneList$[ebp], 0
$L80365:

; 357  : 	while (!doneList) {

	movzx	eax, BYTE PTR _doneList$[ebp]
	test	eax, eax
	jne	$L80366

; 358  : 
; 359  : 		// Make sure there is no overflow
; 360  : 		if (iN > maxNum) {

	mov	eax, DWORD PTR _iN$[ebp]
	cmp	eax, DWORD PTR _maxNum$[ebp]
	jle	SHORT $L80369

; 361  : 			return -1;

	or	eax, -1
	jmp	$L80352
$L80369:

; 362  : 		}
; 363  : 
; 364  : 		// skip white space
; 365  : 		while (isspace(ch = fgetc(fp))){

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80370

; 366  : 			NULL;
; 367  : 		}

	jmp	SHORT $L80369
$L80370:

; 368  : 
; 369  : 		// parse the list
; 370  : 		switch (ch) {

	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR tv95[ebp], al
	cmp	BYTE PTR tv95[ebp], 44			; 0000002cH
	je	SHORT $L80375
	cmp	BYTE PTR tv95[ebp], 45			; 0000002dH
	je	SHORT $L80377
	jmp	$L80386
$L80375:

; 371  : 
; 372  : 		// comma separated list
; 373  : 		case ',':
; 374  : 			if (!ReadInt(&numList[iN++], fp)) {

	mov	eax, DWORD PTR _iN$[ebp]
	mov	ecx, DWORD PTR _numList$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv133[ebp], edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv133[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8
	movzx	edx, al
	mov	eax, DWORD PTR _iN$[ebp]
	add	eax, 1
	mov	DWORD PTR _iN$[ebp], eax
	test	edx, edx
	jne	SHORT $L80376

; 375  : 				return iN - 1;

	mov	eax, DWORD PTR _iN$[ebp]
	sub	eax, 1
	jmp	$L80352
$L80376:

; 376  : 			}
; 377  : 			break;

	jmp	$L80372
$L80377:

; 378  : 
; 379  : 		// dash separated list
; 380  : 		case '-':
; 381  : 			if (!ReadInt(&endNum, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _endNum$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L80378

; 382  : 				return -1;

	or	eax, -1
	jmp	$L80352
$L80378:

; 383  : 			} else {
; 384  : 				if (endNum < 0 || endNum >= maxNum) return -1;

	cmp	DWORD PTR _endNum$[ebp], 0
	jl	SHORT $L80381
	mov	eax, DWORD PTR _endNum$[ebp]
	cmp	eax, DWORD PTR _maxNum$[ebp]
	jl	SHORT $L80380
$L80381:
	or	eax, -1
	jmp	SHORT $L80352
$L80380:

; 385  : 				startNum = numList[--iN];

	mov	eax, DWORD PTR _iN$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iN$[ebp], eax
	mov	ecx, DWORD PTR _iN$[ebp]
	mov	edx, DWORD PTR _numList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _startNum$[ebp], eax

; 386  : 				if (endNum < startNum) {

	mov	eax, DWORD PTR _endNum$[ebp]
	cmp	eax, DWORD PTR _startNum$[ebp]
	jge	SHORT $L80384

; 387  : 					tmpNum = startNum;

	mov	eax, DWORD PTR _startNum$[ebp]
	mov	DWORD PTR _tmpNum$[ebp], eax

; 388  : 					startNum = endNum;

	mov	eax, DWORD PTR _endNum$[ebp]
	mov	DWORD PTR _startNum$[ebp], eax

; 389  : 					endNum = tmpNum;

	mov	eax, DWORD PTR _tmpNum$[ebp]
	mov	DWORD PTR _endNum$[ebp], eax
$L80384:

; 390  : 				}
; 391  : 				while(startNum <= endNum) {

	mov	eax, DWORD PTR _startNum$[ebp]
	cmp	eax, DWORD PTR _endNum$[ebp]
	jg	SHORT $L80379

; 392  : 					numList[iN++] = startNum++;

	mov	eax, DWORD PTR _iN$[ebp]
	mov	ecx, DWORD PTR _numList$[ebp]
	mov	edx, DWORD PTR _startNum$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _iN$[ebp]
	add	eax, 1
	mov	DWORD PTR _iN$[ebp], eax
	mov	ecx, DWORD PTR _startNum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _startNum$[ebp], ecx

; 393  : 				}

	jmp	SHORT $L80384
$L80379:

; 394  : 			}
; 395  : 			break;

	jmp	SHORT $L80372
$L80386:

; 396  : 		
; 397  : 		// end of list
; 398  : 		default:
; 399  : 			ungetc(ch, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_ungetc
	add	esp, 8

; 400  : 			doneList = TRUE;

	mov	BYTE PTR _doneList$[ebp], 1
$L80372:

; 401  : 			break;
; 402  : 		
; 403  : 		}
; 404  : 	}

	jmp	$L80365
$L80366:

; 405  : 	return iN;

	mov	eax, DWORD PTR _iN$[ebp]
$L80352:

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z ENDP		; ReadNumberList
_TEXT	ENDS
PUBLIC	__real@42b2e410
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_05BJLDAIDO@MODEL?$AA@			; `string'
PUBLIC	??_C@_05NFIJOKEG@Model?$AA@			; `string'
PUBLIC	??_C@_05DKECMECL@TPAGE?$AA@			; `string'
PUBLIC	??_C@_06CADPFKMD@ENVRGB?$AA@			; `string'
PUBLIC	??_C@_04MALFBGLN@COLL?$AA@			; `string'
PUBLIC	??_C@_03GJALCMIF@COM?$AA@			; `string'
PUBLIC	??_C@_06GANGLKEK@WEAPON?$AA@			; `string'
PUBLIC	??_C@_04MEHDIIKB@BODY?$AA@			; `string'
PUBLIC	??_C@_05LBGCJCLG@WHEEL?$AA@			; `string'
PUBLIC	??_C@_05HNFIHAMO@Wheel?$AA@			; `string'
PUBLIC	??_C@_06FGCBKJHB@AERIAL?$AA@			; `string'
PUBLIC	??_C@_06BNNDCJEI@SPRING?$AA@			; `string'
PUBLIC	??_C@_06NGEFMOAG@Spring?$AA@			; `string'
PUBLIC	??_C@_04KGHJJBLC@AXLE?$AA@			; `string'
PUBLIC	??_C@_04KLICFMMO@Axle?$AA@			; `string'
PUBLIC	??_C@_03EAHPLIF@PIN?$AA@			; `string'
PUBLIC	??_C@_03KJMOJJMH@Pin?$AA@			; `string'
PUBLIC	??_C@_07CICCNPHL@SPINNER?$AA@			; `string'
PUBLIC	??_C@_09NACABLMM@STEERRATE?$AA@			; `string'
PUBLIC	??_C@_08OJNPGGI@STEERMOD?$AA@			; `string'
PUBLIC	??_C@_0L@PDFEHAIB@ENGINERATE?$AA@		; `string'
PUBLIC	??_C@_08BJKHBKGK@TOPSPEED?$AA@			; `string'
PUBLIC	??_C@_07DNFKGLMM@MAXREVS?$AA@			; `string'
PUBLIC	??_C@_0N@GILDKIMA@DOWNFORCEMOD?$AA@		; `string'
PUBLIC	??_C@_04IPKHEEB@NAME?$AA@			; `string'
PUBLIC	??_C@_08NDAOGOPN@BESTTIME?$AA@			; `string'
PUBLIC	??_C@_0L@BGJAAOOG@SELECTABLE?$AA@		; `string'
EXTRN	__fltused:NEAR
EXTRN	_strncpy:NEAR
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BJLDAIDO@MODEL?$AA@
CONST	SEGMENT
??_C@_05BJLDAIDO@MODEL?$AA@ DB 'MODEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFIJOKEG@Model?$AA@
CONST	SEGMENT
??_C@_05NFIJOKEG@Model?$AA@ DB 'Model', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKECMECL@TPAGE?$AA@
CONST	SEGMENT
??_C@_05DKECMECL@TPAGE?$AA@ DB 'TPAGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CADPFKMD@ENVRGB?$AA@
CONST	SEGMENT
??_C@_06CADPFKMD@ENVRGB?$AA@ DB 'ENVRGB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MALFBGLN@COLL?$AA@
CONST	SEGMENT
??_C@_04MALFBGLN@COLL?$AA@ DB 'COLL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJALCMIF@COM?$AA@
CONST	SEGMENT
??_C@_03GJALCMIF@COM?$AA@ DB 'COM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GANGLKEK@WEAPON?$AA@
CONST	SEGMENT
??_C@_06GANGLKEK@WEAPON?$AA@ DB 'WEAPON', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEHDIIKB@BODY?$AA@
CONST	SEGMENT
??_C@_04MEHDIIKB@BODY?$AA@ DB 'BODY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBGCJCLG@WHEEL?$AA@
CONST	SEGMENT
??_C@_05LBGCJCLG@WHEEL?$AA@ DB 'WHEEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNFIHAMO@Wheel?$AA@
CONST	SEGMENT
??_C@_05HNFIHAMO@Wheel?$AA@ DB 'Wheel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FGCBKJHB@AERIAL?$AA@
CONST	SEGMENT
??_C@_06FGCBKJHB@AERIAL?$AA@ DB 'AERIAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNNDCJEI@SPRING?$AA@
CONST	SEGMENT
??_C@_06BNNDCJEI@SPRING?$AA@ DB 'SPRING', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGEFMOAG@Spring?$AA@
CONST	SEGMENT
??_C@_06NGEFMOAG@Spring?$AA@ DB 'Spring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KGHJJBLC@AXLE?$AA@
CONST	SEGMENT
??_C@_04KGHJJBLC@AXLE?$AA@ DB 'AXLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLICFMMO@Axle?$AA@
CONST	SEGMENT
??_C@_04KLICFMMO@Axle?$AA@ DB 'Axle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EAHPLIF@PIN?$AA@
CONST	SEGMENT
??_C@_03EAHPLIF@PIN?$AA@ DB 'PIN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KJMOJJMH@Pin?$AA@
CONST	SEGMENT
??_C@_03KJMOJJMH@Pin?$AA@ DB 'Pin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CICCNPHL@SPINNER?$AA@
CONST	SEGMENT
??_C@_07CICCNPHL@SPINNER?$AA@ DB 'SPINNER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NACABLMM@STEERRATE?$AA@
CONST	SEGMENT
??_C@_09NACABLMM@STEERRATE?$AA@ DB 'STEERRATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJNPGGI@STEERMOD?$AA@
CONST	SEGMENT
??_C@_08OJNPGGI@STEERMOD?$AA@ DB 'STEERMOD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDFEHAIB@ENGINERATE?$AA@
CONST	SEGMENT
??_C@_0L@PDFEHAIB@ENGINERATE?$AA@ DB 'ENGINERATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJKHBKGK@TOPSPEED?$AA@
CONST	SEGMENT
??_C@_08BJKHBKGK@TOPSPEED?$AA@ DB 'TOPSPEED', 00H	; `string'
CONST	ENDS
;	COMDAT __real@42b2e410
CONST	SEGMENT
__real@42b2e410 DD 042b2e410r			; 89.4454
CONST	ENDS
;	COMDAT ??_C@_07DNFKGLMM@MAXREVS?$AA@
CONST	SEGMENT
??_C@_07DNFKGLMM@MAXREVS?$AA@ DB 'MAXREVS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GILDKIMA@DOWNFORCEMOD?$AA@
CONST	SEGMENT
??_C@_0N@GILDKIMA@DOWNFORCEMOD?$AA@ DB 'DOWNFORCEMOD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPKHEEB@NAME?$AA@
CONST	SEGMENT
??_C@_04IPKHEEB@NAME?$AA@ DB 'NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NDAOGOPN@BESTTIME?$AA@
CONST	SEGMENT
??_C@_08NDAOGOPN@BESTTIME?$AA@ DB 'BESTTIME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BGJAAOOG@SELECTABLE?$AA@
CONST	SEGMENT
??_C@_0L@BGJAAOOG@SELECTABLE?$AA@ DB 'SELECTABLE', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadCarInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tVec$ = -300						; size = 12
_tInt3$ = -288						; size = 4
_tInt2$ = -284						; size = 4
_tInt$ = -280						; size = 4
_tReal$ = -276						; size = 4
_tBool$ = -269						; size = 1
_iModel$ = -268						; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadCarInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadCarInfo, COMDAT

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	push	ebx
	push	esi
	push	edi
$L80429:

; 480  : 	char ch;
; 481  : 	char word[READ_MAX_WORDLEN];
; 482  : 	int iCar, iModel;
; 483  : 	bool tBool;
; 484  : 	//char *fileName;
; 485  : 
; 486  : 	REAL tReal;
; 487  : 	int tInt, tInt2, tInt3;
; 488  : 	VEC tVec;
; 489  : 
; 490  : 	// Find the opening braces
; 491  : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80434
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80434

; 492  : 		if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80432
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L80431
$L80432:

; 493  : 			return FALSE;

	xor	al, al
	jmp	$L80417
$L80431:

; 494  : 		}
; 495  : 	}

	jmp	SHORT $L80429
$L80434:

; 496  : 
; 497  : 	// Read in keywords and act on them
; 498  : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80435
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L80435

; 499  : 
; 500  : 		// MODEL FILE
; 501  : 		if (Compare(word, "MODEL")) {

	push	OFFSET FLAT:??_C@_05BJLDAIDO@MODEL?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80437

; 502  : 			if ((ModelListSize = ReadNumberList(ModelList, MAX_CAR_MODEL_TYPES, fp)) < 0) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	19					; 00000013H
	push	OFFSET FLAT:?ModelList@@3PAHA		; ModelList
	call	?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z	; ReadNumberList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?ModelListSize@@3HA, eax	; ModelListSize
	cmp	DWORD PTR ?ModelListSize@@3HA, 0	; ModelListSize
	jge	SHORT $L80439

; 503  : 				InvalidNumberList("Model");

	push	OFFSET FLAT:??_C@_05NFIJOKEG@Model?$AA@
	call	?InvalidNumberList@@YAXPAD@Z		; InvalidNumberList
	add	esp, 4

; 504  : 				return FALSE;

	xor	al, al
	jmp	$L80417
$L80439:

; 505  : 			}
; 506  : 			ReadFileName(word, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadFileName@@YA_NPADPAU_iobuf@@@Z	; ReadFileName
	add	esp, 8

; 507  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80441
$L80442:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80441:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	$L80443

; 508  : 				for (iModel = 0; iModel < ModelListSize; iModel++) {

	mov	DWORD PTR _iModel$[ebp], 0
	jmp	SHORT $L80444
$L80445:
	mov	eax, DWORD PTR _iModel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iModel$[ebp], eax
$L80444:
	mov	eax, DWORD PTR _iModel$[ebp]
	cmp	eax, DWORD PTR ?ModelListSize@@3HA	; ModelListSize
	jge	SHORT $L80446

; 509  : 					if (ModelList[iModel] >= MAX_CAR_MODEL_TYPES) {

	mov	eax, DWORD PTR _iModel$[ebp]
	cmp	DWORD PTR ?ModelList@@3PAHA[eax*4], 19	; 00000013H
	jl	SHORT $L80447

; 510  : 						return FALSE;

	xor	al, al
	jmp	$L80417
$L80447:

; 511  : 					}
; 512  : 					strncpy(CarInfo[CarList[iCar]].ModelFile[ModelList[iModel]], word, MAX_CAR_FILENAME);

	push	64					; 00000040H
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCar$[ebp]
	mov	edx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	eax, DWORD PTR [edx+ecx*4]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _iModel$[ebp]
	mov	edx, DWORD PTR ?ModelList@@3PAHA[ecx*4]
	shl	edx, 6
	add	eax, edx
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 513  : 				}

	jmp	SHORT $L80445
$L80446:

; 514  : 			}

	jmp	$L80442
$L80443:

; 515  : 		}
; 516  : 
; 517  : 		// TPage file
; 518  : 		else if (Compare(word, "TPAGE")) {

	jmp	$L80448
$L80437:
	push	OFFSET FLAT:??_C@_05DKECMECL@TPAGE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80449

; 519  : 			ReadFileName(word, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadFileName@@YA_NPADPAU_iobuf@@@Z	; ReadFileName
	add	esp, 8

; 520  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80451
$L80452:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80451:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80453

; 521  : 				strncpy(CarInfo[CarList[iCar]].TPageFile, word, MAX_CAR_FILENAME);

	push	64					; 00000040H
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCar$[ebp]
	mov	edx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	eax, DWORD PTR [edx+ecx*4]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	edx, DWORD PTR [ecx+eax+1216]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 522  : 			}

	jmp	SHORT $L80452
$L80453:

; 523  : 		}
; 524  : 
; 525  : 		// ENV RGB
; 526  : 		else if (Compare(word, "ENVRGB")) {

	jmp	$L80448
$L80449:
	push	OFFSET FLAT:??_C@_06CADPFKMD@ENVRGB?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80455

; 527  : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 528  : 			ReadInt(&tInt2, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt2$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 529  : 			ReadInt(&tInt3, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt3$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 530  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80457
$L80458:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80457:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80459

; 531  : 				CarInfo[CarList[iCar]].EnvRGB = (tInt << 16) | (tInt2 << 8) | tInt3;

	mov	eax, DWORD PTR _tInt$[ebp]
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _tInt2$[ebp]
	shl	ecx, 8
	or	eax, ecx
	or	eax, DWORD PTR _tInt3$[ebp]
	mov	edx, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+edx*4]
	imul	edx, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	DWORD PTR [ecx+edx+1344], eax

; 532  : 			}

	jmp	SHORT $L80458
$L80459:

; 533  : 		}
; 534  : 
; 535  : 		// COLLSKIN file
; 536  : 		else if (Compare(word, "COLL")) {

	jmp	$L80448
$L80455:
	push	OFFSET FLAT:??_C@_04MALFBGLN@COLL?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80461

; 537  : 			ReadFileName(word, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadFileName@@YA_NPADPAU_iobuf@@@Z	; ReadFileName
	add	esp, 8

; 538  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80463
$L80464:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80463:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80465

; 539  : 				strncpy(CarInfo[CarList[iCar]].CollFile, word, MAX_CAR_FILENAME);

	push	64					; 00000040H
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCar$[ebp]
	mov	edx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	eax, DWORD PTR [edx+ecx*4]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	edx, DWORD PTR [ecx+eax+1280]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 540  : 			}

	jmp	SHORT $L80464
$L80465:

; 541  : 		}
; 542  : 
; 543  : 		// CoM position
; 544  : 		else if (Compare(word, "COM")) {

	jmp	$L80448
$L80461:
	push	OFFSET FLAT:??_C@_03GJALCMIF@COM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80467

; 545  : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 546  : 			//VecMulScalar(&tVec, OGU2GU_LENGTH)
; 547  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80469
$L80470:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80469:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80471

; 548  : 				CopyVec(&tVec, &CarInfo[CarList[iCar]].CoMOffset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [eax+edx+1436], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [eax+edx+1440], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [eax+edx+1444], ecx

; 549  : 			}

	jmp	$L80470
$L80471:

; 550  : 		}
; 551  : 
; 552  : 		// Weapon Offset
; 553  : 		else if (Compare(word, "WEAPON")) {

	jmp	$L80448
$L80467:
	push	OFFSET FLAT:??_C@_06GANGLKEK@WEAPON?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80473

; 554  : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 555  : 			//VecMulScalar(&tVec, OGU2GU_LENGTH)
; 556  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80475
$L80476:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80475:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80477

; 557  : 				CopyVec(&tVec, &CarInfo[CarList[iCar]].WeaponOffset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [eax+edx+1452], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [eax+edx+1456], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [eax+edx+1460], ecx

; 558  : 			}

	jmp	$L80476
$L80477:

; 559  : 		}
; 560  : 
; 561  : 		// BODY
; 562  : 		else if (Compare(word, "BODY")) {

	jmp	$L80448
$L80473:
	push	OFFSET FLAT:??_C@_04MEHDIIKB@BODY?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80479

; 563  : 			ReadBodyInfo(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadBodyInfo@@YA_NPAU_iobuf@@@Z	; ReadBodyInfo
	add	esp, 4

; 564  : 		}
; 565  : 
; 566  : 		// WHEEL
; 567  : 		else if (Compare(word, "WHEEL")) {

	jmp	$L80448
$L80479:
	push	OFFSET FLAT:??_C@_05LBGCJCLG@WHEEL?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80482

; 568  : 			if ((WheelListSize = ReadNumberList(WheelList, CAR_NWHEELS, fp)) < 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	4
	push	OFFSET FLAT:?WheelList@@3PAHA		; WheelList
	call	?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z	; ReadNumberList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?WheelListSize@@3HA, eax	; WheelListSize
	cmp	DWORD PTR ?WheelListSize@@3HA, 1	; WheelListSize
	jge	SHORT $L80484

; 569  : 				InvalidNumberList("Wheel");

	push	OFFSET FLAT:??_C@_05HNFIHAMO@Wheel?$AA@
	call	?InvalidNumberList@@YAXPAD@Z		; InvalidNumberList
	add	esp, 4

; 570  : 				return FALSE;

	xor	al, al
	jmp	$L80417
$L80484:

; 571  : 			}
; 572  : 			ReadWheelInfo(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadWheelInfo@@YA_NPAU_iobuf@@@Z	; ReadWheelInfo
	add	esp, 4

; 573  : 		}
; 574  : 
; 575  : 		// AERIAL
; 576  : 		else if (Compare(word, "AERIAL")) {

	jmp	$L80448
$L80482:
	push	OFFSET FLAT:??_C@_06FGCBKJHB@AERIAL?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80487

; 577  : 			ReadAerialInfo(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadAerialInfo@@YA_NPAU_iobuf@@@Z	; ReadAerialInfo
	add	esp, 4

; 578  : 		}
; 579  : 
; 580  : 		// SPRING
; 581  : 		else if (Compare(word, "SPRING")) {

	jmp	$L80448
$L80487:
	push	OFFSET FLAT:??_C@_06BNNDCJEI@SPRING?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80490

; 582  : 			if ((SpringListSize = ReadNumberList(SpringList, CAR_NWHEELS, fp)) < 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	4
	push	OFFSET FLAT:?SpringList@@3PAHA		; SpringList
	call	?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z	; ReadNumberList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?SpringListSize@@3HA, eax	; SpringListSize
	cmp	DWORD PTR ?SpringListSize@@3HA, 1	; SpringListSize
	jge	SHORT $L80492

; 583  : 				InvalidNumberList("Spring");

	push	OFFSET FLAT:??_C@_06NGEFMOAG@Spring?$AA@
	call	?InvalidNumberList@@YAXPAD@Z		; InvalidNumberList
	add	esp, 4

; 584  : 				return FALSE;

	xor	al, al
	jmp	$L80417
$L80492:

; 585  : 			}
; 586  : 			ReadSpringInfo(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadSpringInfo@@YA_NPAU_iobuf@@@Z	; ReadSpringInfo
	add	esp, 4

; 587  : 		}
; 588  : 
; 589  : 		// AXLE
; 590  : 		else if (Compare(word, "AXLE")) {

	jmp	$L80448
$L80490:
	push	OFFSET FLAT:??_C@_04KGHJJBLC@AXLE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80495

; 591  : 			if ((AxleListSize = ReadNumberList(AxleList, CAR_NWHEELS, fp)) < 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	4
	push	OFFSET FLAT:?AxleList@@3PAHA		; AxleList
	call	?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z	; ReadNumberList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?AxleListSize@@3HA, eax	; AxleListSize
	cmp	DWORD PTR ?AxleListSize@@3HA, 1		; AxleListSize
	jge	SHORT $L80497

; 592  : 				InvalidNumberList("Axle");

	push	OFFSET FLAT:??_C@_04KLICFMMO@Axle?$AA@
	call	?InvalidNumberList@@YAXPAD@Z		; InvalidNumberList
	add	esp, 4

; 593  : 				return FALSE;

	xor	al, al
	jmp	$L80417
$L80497:

; 594  : 			}
; 595  : 			ReadAxleInfo(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadAxleInfo@@YA_NPAU_iobuf@@@Z	; ReadAxleInfo
	add	esp, 4

; 596  : 		}
; 597  : 
; 598  : 		// PIN
; 599  : 		else if (Compare(word, "PIN")) {

	jmp	$L80448
$L80495:
	push	OFFSET FLAT:??_C@_03EAHPLIF@PIN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80500

; 600  : 			if ((PinListSize = ReadNumberList(PinList, CAR_NWHEELS, fp)) < 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	4
	push	OFFSET FLAT:?PinList@@3PAHA		; PinList
	call	?ReadNumberList@@YAHPAHHPAU_iobuf@@@Z	; ReadNumberList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?PinListSize@@3HA, eax	; PinListSize
	cmp	DWORD PTR ?PinListSize@@3HA, 1		; PinListSize
	jge	SHORT $L80502

; 601  : 				InvalidNumberList("Pin");

	push	OFFSET FLAT:??_C@_03KJMOJJMH@Pin?$AA@
	call	?InvalidNumberList@@YAXPAD@Z		; InvalidNumberList
	add	esp, 4

; 602  : 				return FALSE;

	xor	al, al
	jmp	$L80417
$L80502:

; 603  : 			}
; 604  : 			ReadPinInfo(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadPinInfo@@YA_NPAU_iobuf@@@Z		; ReadPinInfo
	add	esp, 4

; 605  : 		}
; 606  : 
; 607  : 		// SPINNER
; 608  : 		else if (Compare(word, "SPINNER")) {

	jmp	$L80448
$L80500:
	push	OFFSET FLAT:??_C@_07CICCNPHL@SPINNER?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80505

; 609  : 			ReadSpinnerInfo(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?ReadSpinnerInfo@@YA_NPAU_iobuf@@@Z	; ReadSpinnerInfo
	add	esp, 4

; 610  : 		}
; 611  : 
; 612  : 		// STEERRATE
; 613  : 		else if (Compare(word, "STEERRATE")) {

	jmp	$L80448
$L80505:
	push	OFFSET FLAT:??_C@_09NACABLMM@STEERRATE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80508

; 614  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 615  : 			//tReal *= OGU2GU_FREQ;
; 616  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80510
$L80511:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80510:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80512

; 617  : 				CarInfo[CarList[iCar]].SteerRate = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1412], ecx

; 618  : 			}

	jmp	SHORT $L80511
$L80512:

; 619  : 		}
; 620  : 
; 621  : 		// STEERMOD
; 622  : 		else if (Compare(word, "STEERMOD")) {

	jmp	$L80448
$L80508:
	push	OFFSET FLAT:??_C@_08OJNPGGI@STEERMOD?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80514

; 623  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 624  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80516
$L80517:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80516:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80518

; 625  : 				CarInfo[CarList[iCar]].SteerModifier = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1416], ecx

; 626  : 			}

	jmp	SHORT $L80517
$L80518:

; 627  : 		}
; 628  : 
; 629  : 		// ENGINERATE
; 630  : 		else if (Compare(word, "ENGINERATE")) {

	jmp	$L80448
$L80514:
	push	OFFSET FLAT:??_C@_0L@PDFEHAIB@ENGINERATE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80520

; 631  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 632  : 			//tReal *= OGU2GU_FREQ;
; 633  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80522
$L80523:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80522:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80524

; 634  : 				CarInfo[CarList[iCar]].EngineRate = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1420], ecx

; 635  : 			}

	jmp	SHORT $L80523
$L80524:

; 636  : 		}
; 637  : 
; 638  : 		// TopSpeed
; 639  : 		else if (Compare(word, "TOPSPEED")) {

	jmp	$L80448
$L80520:
	push	OFFSET FLAT:??_C@_08BJKHBKGK@TOPSPEED?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80526

; 640  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 641  : 			tReal *= MPH2OGU_SPEED;// * OGU2GU_VEL;

	fld	DWORD PTR _tReal$[ebp]
	fmul	DWORD PTR __real@42b2e410
	fstp	DWORD PTR _tReal$[ebp]

; 642  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80529
$L80530:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80529:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80531

; 643  : 				CarInfo[CarList[iCar]].TopSpeed = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1424], ecx

; 644  : 			}

	jmp	SHORT $L80530
$L80531:

; 645  : 		}
; 646  : 
; 647  : 		// MaxRevs
; 648  : 		else if (Compare(word, "MAXREVS")) {

	jmp	$L80448
$L80526:
	push	OFFSET FLAT:??_C@_07DNFKGLMM@MAXREVS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80533

; 649  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 650  : 			tReal *= MPH2OGU_SPEED;// * OGU2GU_VEL;

	fld	DWORD PTR _tReal$[ebp]
	fmul	DWORD PTR __real@42b2e410
	fstp	DWORD PTR _tReal$[ebp]

; 651  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80536
$L80537:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80536:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80538

; 652  : 				CarInfo[CarList[iCar]].MaxRevs = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1428], ecx

; 653  : 			}

	jmp	SHORT $L80537
$L80538:

; 654  : 		}
; 655  : 
; 656  : 		// DownForcMod
; 657  : 		else if (Compare(word, "DOWNFORCEMOD")) {

	jmp	$L80448
$L80533:
	push	OFFSET FLAT:??_C@_0N@GILDKIMA@DOWNFORCEMOD?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80540

; 658  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 659  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80542
$L80543:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80542:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80544

; 660  : 				CarInfo[CarList[iCar]].DownForceMod = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1432], ecx

; 661  : 			}

	jmp	SHORT $L80543
$L80544:

; 662  : 		}
; 663  : 
; 664  : 		// NAME
; 665  : 		else if (Compare(word, "NAME")) {

	jmp	$L80448
$L80540:
	push	OFFSET FLAT:??_C@_04IPKHEEB@NAME?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80546

; 666  : 			ReadFileName(word, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadFileName@@YA_NPADPAU_iobuf@@@Z	; ReadFileName
	add	esp, 8

; 667  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80548
$L80549:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80548:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80550

; 668  : 				strncpy(CarInfo[CarList[iCar]].Name, word, CAR_NAMELEN - 1);

	push	63					; 0000003fH
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCar$[ebp]
	mov	edx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	eax, DWORD PTR [edx+ecx*4]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	edx, DWORD PTR [ecx+eax+1348]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 669  : 			}

	jmp	SHORT $L80549
$L80550:

; 670  : 		}
; 671  : 
; 672  : 		// ALLOWED BEST TIME
; 673  : 		else if (Compare(word, "BESTTIME")) {

	jmp	$L80448
$L80546:
	push	OFFSET FLAT:??_C@_08NDAOGOPN@BESTTIME?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80552

; 674  : 			ReadBool(&tBool, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tBool$[ebp]
	push	ecx
	call	?ReadBool@@YA_NPA_NPAU_iobuf@@@Z	; ReadBool
	add	esp, 8

; 675  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80554
$L80555:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80554:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80556

; 676  : 				CarInfo[CarList[iCar]].AllowedBestTime = tBool;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	cl, BYTE PTR _tBool$[ebp]
	mov	BYTE PTR [eax+edx+1448], cl

; 677  : 			}

	jmp	SHORT $L80555
$L80556:

; 678  : 		}
; 679  : 
; 680  : 		// SELECTABLE
; 681  : 		else if (Compare(word, "SELECTABLE")) {

	jmp	$L80448
$L80552:
	push	OFFSET FLAT:??_C@_0L@BGJAAOOG@SELECTABLE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80558

; 682  : 			ReadBool(&tBool, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tBool$[ebp]
	push	ecx
	call	?ReadBool@@YA_NPA_NPAU_iobuf@@@Z	; ReadBool
	add	esp, 8

; 683  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80560
$L80561:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80560:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80562

; 684  : 				CarInfo[CarList[iCar]].Selectable = tBool;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	cl, BYTE PTR _tBool$[ebp]
	mov	BYTE PTR [eax+edx+1449], cl

; 685  : 			}

	jmp	SHORT $L80561
$L80562:

; 686  : 		}
; 687  : 
; 688  : 		// DEFAULT
; 689  : 		else {

	jmp	SHORT $L80448
$L80558:

; 690  : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L80448

; 691  : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 692  : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80417
$L80448:

; 693  : 			}
; 694  : 		}
; 695  : 	}

	jmp	$L80434
$L80435:

; 696  : 
; 697  : 	return TRUE;

	mov	al, 1
$L80417:

; 698  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadCarInfo@@YA_NPAU_iobuf@@@Z ENDP			; ReadCarInfo
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IPJEKABE@Could?5not?5find?5file?5name?$AA@ ; `string'
PUBLIC	??_C@_04HIBGFPH@NULL?$AA@			; `string'
PUBLIC	??_C@_04OKGDLNCL@NONE?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
;	COMDAT ??_C@_0BJ@IPJEKABE@Could?5not?5find?5file?5name?$AA@
CONST	SEGMENT
??_C@_0BJ@IPJEKABE@Could?5not?5find?5file?5name?$AA@ DB 'Could not find f'
	DB	'ile name', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL?$AA@ DB 'NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OKGDLNCL@NONE?$AA@
CONST	SEGMENT
??_C@_04OKGDLNCL@NONE?$AA@ DB 'NONE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadFileName@@YA_NPADPAU_iobuf@@@Z
_TEXT	SEGMENT
_endOfName$ = -16					; size = 4
_delimiter$ = -9					; size = 1
_nameLen$ = -8						; size = 4
_iCh$ = -4						; size = 4
_name$ = 8						; size = 4
_fp$ = 12						; size = 4
?ReadFileName@@YA_NPADPAU_iobuf@@@Z PROC NEAR		; ReadFileName, COMDAT

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 85   : 	int iCh, nameLen;
; 86   : 	char delimiter;
; 87   : 	char *endOfName;
; 88   : 
; 89   : 	// Read next word
; 90   : 	if (!ReadWord(name, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L80255

; 91   : 		ShowErrorMessage("Could not find file name");

	push	OFFSET FLAT:??_C@_0BJ@IPJEKABE@Could?5not?5find?5file?5name?$AA@
	call	?ShowErrorMessage@@YAXPAD@Z		; ShowErrorMessage
	add	esp, 4

; 92   : 		return FALSE;

	xor	al, al
	jmp	$L80250
$L80255:

; 93   : 	}
; 94   : 
; 95   : 	// If the first letter is " or ' read words until the last letter
; 96   : 	// is also " or '
; 97   : 	delimiter = name[0];

	mov	eax, DWORD PTR _name$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _delimiter$[ebp], cl

; 98   : 	endOfName = name + strlen(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _endOfName$[ebp], eax
$L80258:

; 99   : 	while (((delimiter == '\"') || (delimiter == '\'')) && (*(endOfName-1) != delimiter)) {

	movsx	eax, BYTE PTR _delimiter$[ebp]
	cmp	eax, 34					; 00000022H
	je	SHORT $L80260
	movsx	eax, BYTE PTR _delimiter$[ebp]
	cmp	eax, 39					; 00000027H
	jne	$L80259
$L80260:
	mov	eax, DWORD PTR _endOfName$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	movsx	edx, BYTE PTR _delimiter$[ebp]
	cmp	ecx, edx
	je	$L80259
$L80262:

; 100  : 		while (isspace(*endOfName = fgetc(fp))) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	ecx, DWORD PTR _endOfName$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _endOfName$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80263

; 101  : 			endOfName++;

	mov	eax, DWORD PTR _endOfName$[ebp]
	add	eax, 1
	mov	DWORD PTR _endOfName$[ebp], eax

; 102  : 		}

	jmp	SHORT $L80262
$L80263:

; 103  : 		ungetc(*endOfName, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _endOfName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	_ungetc
	add	esp, 8

; 104  : 		if (!ReadWord(endOfName, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _endOfName$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L80264

; 105  : 			ShowErrorMessage("Could not find file name");

	push	OFFSET FLAT:??_C@_0BJ@IPJEKABE@Could?5not?5find?5file?5name?$AA@
	call	?ShowErrorMessage@@YAXPAD@Z		; ShowErrorMessage
	add	esp, 4

; 106  : 			return FALSE;

	xor	al, al
	jmp	$L80250
$L80264:

; 107  : 		}
; 108  : 		endOfName = name + strlen(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _endOfName$[ebp], eax

; 109  : 	}

	jmp	$L80258
$L80259:

; 110  : 	
; 111  : 	// Remove the quotes
; 112  : 	if (delimiter == '\'' || delimiter == '\"') {

	movsx	eax, BYTE PTR _delimiter$[ebp]
	cmp	eax, 39					; 00000027H
	je	SHORT $L80266
	movsx	eax, BYTE PTR _delimiter$[ebp]
	cmp	eax, 34					; 00000022H
	jne	SHORT $L80265
$L80266:

; 113  : 		nameLen = strlen(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nameLen$[ebp], eax

; 114  : 		for (iCh = 0; iCh < nameLen - 2; iCh++) {

	mov	DWORD PTR _iCh$[ebp], 0
	jmp	SHORT $L80267
$L80268:
	mov	eax, DWORD PTR _iCh$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCh$[ebp], eax
$L80267:
	mov	eax, DWORD PTR _nameLen$[ebp]
	sub	eax, 2
	cmp	DWORD PTR _iCh$[ebp], eax
	jge	SHORT $L80269

; 115  : 			name[iCh] = name[iCh+1];

	mov	eax, DWORD PTR _name$[ebp]
	add	eax, DWORD PTR _iCh$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, DWORD PTR _iCh$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax], dl

; 116  : 		}

	jmp	SHORT $L80268
$L80269:

; 117  : 		name[nameLen - 2] = '\0';

	mov	eax, DWORD PTR _name$[ebp]
	add	eax, DWORD PTR _nameLen$[ebp]
	mov	BYTE PTR [eax-2], 0
$L80265:

; 118  : 	}
; 119  : 
; 120  : 	// Check for NULL keywords
; 121  : 	if (Compare(name, "NULL") || Compare(name, "NONE") || Compare(name, "0")) {

	push	OFFSET FLAT:??_C@_04HIBGFPH@NULL?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80271
	push	OFFSET FLAT:??_C@_04OKGDLNCL@NONE?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80271
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80270
$L80271:

; 122  : 		name[0] = '\0';

	mov	eax, DWORD PTR _name$[ebp]
	mov	BYTE PTR [eax], 0
$L80270:

; 123  : 	}
; 124  : 
; 125  : 	return TRUE;

	mov	al, 1
$L80250:

; 126  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadFileName@@YA_NPADPAU_iobuf@@@Z ENDP		; ReadFileName
_TEXT	ENDS
PUBLIC	??_C@_04HCDDPBNL@TRUE?$AA@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_03IPHJCBHH@YES?$AA@			; `string'
PUBLIC	??_C@_05MAJJAKPI@FALSE?$AA@			; `string'
PUBLIC	??_C@_02NFLNFON@NO?$AA@				; `string'
;	COMDAT ??_C@_04HCDDPBNL@TRUE?$AA@
CONST	SEGMENT
??_C@_04HCDDPBNL@TRUE?$AA@ DB 'TRUE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IPHJCBHH@YES?$AA@
CONST	SEGMENT
??_C@_03IPHJCBHH@YES?$AA@ DB 'YES', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAJJAKPI@FALSE?$AA@
CONST	SEGMENT
??_C@_05MAJJAKPI@FALSE?$AA@ DB 'FALSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NFLNFON@NO?$AA@
CONST	SEGMENT
??_C@_02NFLNFON@NO?$AA@ DB 'NO', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadBool@@YA_NPA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_word$ = -256						; size = 256
_b$ = 8							; size = 4
_fp$ = 12						; size = 4
?ReadBool@@YA_NPA_NPAU_iobuf@@@Z PROC NEAR		; ReadBool, COMDAT

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi

; 154  : 	char word[READ_MAX_WORDLEN];
; 155  : 
; 156  : 	*b = FALSE;

	mov	eax, DWORD PTR _b$[ebp]
	mov	BYTE PTR [eax], 0

; 157  : 
; 158  : 	if (!ReadWord(word, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L80288

; 159  : 		return FALSE;

	xor	al, al
	jmp	$L80286
$L80288:

; 160  : 	}
; 161  : 
; 162  : 	if (Compare(word, "TRUE") || Compare(word, "1") || Compare(word, "YES")) {

	push	OFFSET FLAT:??_C@_04HCDDPBNL@TRUE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80290
	push	OFFSET FLAT:??_C@_01HIHLOKLC@1?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80290
	push	OFFSET FLAT:??_C@_03IPHJCBHH@YES?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80289
$L80290:

; 163  : 		*b = TRUE;

	mov	eax, DWORD PTR _b$[ebp]
	mov	BYTE PTR [eax], 1

; 164  : 	}
; 165  : 	else if (Compare(word, "FALSE") || Compare(word, "0") || Compare(word, "NO")) {

	jmp	SHORT $L80294
$L80289:
	push	OFFSET FLAT:??_C@_05MAJJAKPI@FALSE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80296
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80296
	push	OFFSET FLAT:??_C@_02NFLNFON@NO?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80295
$L80296:

; 166  : 		*b = FALSE;

	mov	eax, DWORD PTR _b$[ebp]
	mov	BYTE PTR [eax], 0

; 167  : 	}
; 168  : 	else {

	jmp	SHORT $L80294
$L80295:

; 169  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L80286
$L80294:

; 170  : 	}
; 171  : 
; 172  : 	return TRUE;

	mov	al, 1
$L80286:

; 173  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadBool@@YA_NPA_NPAU_iobuf@@@Z ENDP			; ReadBool
_TEXT	ENDS
EXTRN	_atof:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?ReadReal@@YA_NPAMPAU_iobuf@@@Z
_TEXT	SEGMENT
_word$ = -256						; size = 256
_r$ = 8							; size = 4
_fp$ = 12						; size = 4
?ReadReal@@YA_NPAMPAU_iobuf@@@Z PROC NEAR		; ReadReal, COMDAT

; 184  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi

; 185  : 	/*char ch;
; 186  : 	// Skip white space and commas
; 187  : 	while (isspace(ch = fgetc(fp)) || (ch == ',')) {
; 188  : 	};
; 189  : 
; 190  : 	if (fscanf(fp, "%f", r) == EOF) {
; 191  : 		return FALSE;
; 192  : 	} else {
; 193  : 		return TRUE;
; 194  : 	}*/
; 195  : 	char word[READ_MAX_WORDLEN];
; 196  : 
; 197  : 	if (!ReadWord(word, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L80305

; 198  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L80303
$L80305:

; 199  : 	} else {
; 200  : 		*r = (REAL)atof(word);

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	_atof
	add	esp, 4
	mov	ecx, DWORD PTR _r$[ebp]
	fstp	DWORD PTR [ecx]

; 201  : 		return TRUE;

	mov	al, 1
$L80303:

; 202  : 	}
; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadReal@@YA_NPAMPAU_iobuf@@@Z ENDP			; ReadReal
_TEXT	ENDS
PUBLIC	??_C@_0BG@PFDLKPNA@Could?5not?5read?5vector?$AA@ ; `string'
;	COMDAT ??_C@_0BG@PFDLKPNA@Could?5not?5read?5vector?$AA@
CONST	SEGMENT
??_C@_0BG@PFDLKPNA@Could?5not?5read?5vector?$AA@ DB 'Could not read vecto'
	DB	'r', 00H					; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_iR$ = -4						; size = 4
_vec$ = 8						; size = 4
_fp$ = 12						; size = 4
?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z PROC NEAR	; ReadVec, COMDAT

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 238  : 	int iR;
; 239  : 
; 240  : 	for (iR = 0; iR < 3; iR++) {

	mov	DWORD PTR _iR$[ebp], 0
	jmp	SHORT $L80313
$L80314:
	mov	eax, DWORD PTR _iR$[ebp]
	add	eax, 1
	mov	DWORD PTR _iR$[ebp], eax
$L80313:
	cmp	DWORD PTR _iR$[ebp], 3
	jge	SHORT $L80315

; 241  : 		if (!ReadReal(&vec->v[iR], fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iR$[ebp]
	mov	edx, DWORD PTR _vec$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L80316

; 242  : 			ShowErrorMessage("Could not read vector");

	push	OFFSET FLAT:??_C@_0BG@PFDLKPNA@Could?5not?5read?5vector?$AA@
	call	?ShowErrorMessage@@YAXPAD@Z		; ShowErrorMessage
	add	esp, 4

; 243  : 			return FALSE;

	xor	al, al
	jmp	SHORT $L80311
$L80316:

; 244  : 		}
; 245  : 	}

	jmp	SHORT $L80314
$L80315:

; 246  : 	return TRUE;

	mov	al, 1
$L80311:

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ENDP	; ReadVec
_TEXT	ENDS
PUBLIC	??_C@_08OACPFCKA@MODELNUM?$AA@			; `string'
PUBLIC	??_C@_06KPFMBGLO@OFFSET?$AA@			; `string'
PUBLIC	??_C@_04EFHKDFDM@MASS?$AA@			; `string'
PUBLIC	??_C@_07HHDLKAPO@INERTIA?$AA@			; `string'
PUBLIC	??_C@_07JIEIIHJI@GRAVITY?$AA@			; `string'
PUBLIC	??_C@_08NGNOIIA@HARDNESS?$AA@			; `string'
PUBLIC	??_C@_0L@NFJMCNIC@RESISTANCE?$AA@		; `string'
PUBLIC	??_C@_06NJKNDHJM@ANGRES?$AA@			; `string'
PUBLIC	??_C@_06HAFCDGMH@RESMOD?$AA@			; `string'
PUBLIC	??_C@_0P@NCOGJENF@STATICFRICTION?$AA@		; `string'
PUBLIC	??_C@_0BA@MKHKGPBI@KINETICFRICTION?$AA@		; `string'
PUBLIC	??_C@_04HHPKKAIJ@GRIP?$AA@			; `string'
EXTRN	?CopyMat@@YAXPATMatrixUnion@@0@Z:NEAR		; CopyMat
;	COMDAT ??_C@_08OACPFCKA@MODELNUM?$AA@
CONST	SEGMENT
??_C@_08OACPFCKA@MODELNUM?$AA@ DB 'MODELNUM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPFMBGLO@OFFSET?$AA@
CONST	SEGMENT
??_C@_06KPFMBGLO@OFFSET?$AA@ DB 'OFFSET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFHKDFDM@MASS?$AA@
CONST	SEGMENT
??_C@_04EFHKDFDM@MASS?$AA@ DB 'MASS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHDLKAPO@INERTIA?$AA@
CONST	SEGMENT
??_C@_07HHDLKAPO@INERTIA?$AA@ DB 'INERTIA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JIEIIHJI@GRAVITY?$AA@
CONST	SEGMENT
??_C@_07JIEIIHJI@GRAVITY?$AA@ DB 'GRAVITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGNOIIA@HARDNESS?$AA@
CONST	SEGMENT
??_C@_08NGNOIIA@HARDNESS?$AA@ DB 'HARDNESS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFJMCNIC@RESISTANCE?$AA@
CONST	SEGMENT
??_C@_0L@NFJMCNIC@RESISTANCE?$AA@ DB 'RESISTANCE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NJKNDHJM@ANGRES?$AA@
CONST	SEGMENT
??_C@_06NJKNDHJM@ANGRES?$AA@ DB 'ANGRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HAFCDGMH@RESMOD?$AA@
CONST	SEGMENT
??_C@_06HAFCDGMH@RESMOD?$AA@ DB 'RESMOD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCOGJENF@STATICFRICTION?$AA@
CONST	SEGMENT
??_C@_0P@NCOGJENF@STATICFRICTION?$AA@ DB 'STATICFRICTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKHKGPBI@KINETICFRICTION?$AA@
CONST	SEGMENT
??_C@_0BA@MKHKGPBI@KINETICFRICTION?$AA@ DB 'KINETICFRICTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HHPKKAIJ@GRIP?$AA@
CONST	SEGMENT
??_C@_04HHPKKAIJ@GRIP?$AA@ DB 'GRIP', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadBodyInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tMat$ = -320						; size = 36
_tVec$ = -284						; size = 12
_tReal$ = -272						; size = 4
_tInt$ = -268						; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadBodyInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadBodyInfo, COMDAT

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	push	ebx
	push	esi
	push	edi
$L80576:

; 709  : 	char	ch;
; 710  : 	char	word[READ_MAX_WORDLEN];
; 711  : 	int		iCar;
; 712  : 
; 713  : 	int		tInt;
; 714  : 	REAL	tReal;
; 715  : 	VEC	tVec;
; 716  : 	MAT	tMat;
; 717  : 
; 718  : 	// Find the opening braces
; 719  : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80577
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80577

; 720  : 	}

	jmp	SHORT $L80576
$L80577:

; 721  : 	if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80579
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L80581
$L80579:

; 722  : 		return FALSE;

	xor	al, al
	jmp	$L80567
$L80581:

; 723  : 	}
; 724  : 
; 725  : 	// Read in keywords and act on them
; 726  : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80582
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L80582

; 727  : 	
; 728  : 		// MODEL NUMBER
; 729  : 		if (Compare(word, "MODELNUM")) {

	push	OFFSET FLAT:??_C@_08OACPFCKA@MODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80583

; 730  : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 731  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80585
$L80586:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80585:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80587

; 732  : 				CarInfo[CarList[iCar]].Body.ModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [eax+edx+1464], ecx

; 733  : 			}

	jmp	SHORT $L80586
$L80587:

; 734  : 		}
; 735  : 
; 736  : 		// OFFSET
; 737  : 		else if (Compare(word, "OFFSET")) {

	jmp	$L80588
$L80583:
	push	OFFSET FLAT:??_C@_06KPFMBGLO@OFFSET?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80589

; 738  : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 739  : 			//VecMulScalar(&tVec, OGU2GU_LENGTH);
; 740  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80591
$L80592:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80591:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80593

; 741  : 				CopyVec(&tVec, &CarInfo[CarList[iCar]].Body.Offset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [eax+edx+1468], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [eax+edx+1472], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [eax+edx+1476], ecx

; 742  : 			}

	jmp	$L80592
$L80593:

; 743  : 		}
; 744  : 
; 745  : 		// MASS
; 746  : 		else if (Compare(word, "MASS")) {

	jmp	$L80588
$L80589:
	push	OFFSET FLAT:??_C@_04EFHKDFDM@MASS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80595

; 747  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 748  : 			//tReal *= OGU2GU_MASS;
; 749  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80597
$L80598:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80597:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80599

; 750  : 				CarInfo[CarList[iCar]].Body.Mass = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1480], ecx

; 751  : 			}

	jmp	SHORT $L80598
$L80599:

; 752  : 		}
; 753  : 
; 754  : 		// INERTIA
; 755  : 		else if (Compare(word, "INERTIA")) {

	jmp	$L80588
$L80595:
	push	OFFSET FLAT:??_C@_07HHDLKAPO@INERTIA?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80601

; 756  : 			ReadMat(&tMat, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tMat$[ebp]
	push	ecx
	call	?ReadMat@@YA_NPATMatrixUnion@@PAU_iobuf@@@Z ; ReadMat
	add	esp, 8

; 757  : 			//tReal *= OGU2GU_INERTIA;
; 758  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80603
$L80604:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80603:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80605

; 759  : 				CopyMat(&tMat, &CarInfo[CarList[iCar]].Body.Inertia);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	ecx, DWORD PTR [eax+edx+1484]
	push	ecx
	lea	edx, DWORD PTR _tMat$[ebp]
	push	edx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 760  : 			}

	jmp	SHORT $L80604
$L80605:

; 761  : 		}
; 762  : 
; 763  : 		// GRAVITY
; 764  : 		else if (Compare(word, "GRAVITY")) {

	jmp	$L80588
$L80601:
	push	OFFSET FLAT:??_C@_07JIEIIHJI@GRAVITY?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80607

; 765  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 766  : 			//tReal *= OGU2GU_ACC;
; 767  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80609
$L80610:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80609:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80611

; 768  : 				CarInfo[CarList[iCar]].Body.Gravity = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1520], ecx

; 769  : 			}

	jmp	SHORT $L80610
$L80611:

; 770  : 		}
; 771  : 
; 772  : 		// HARDNESS
; 773  : 		else if (Compare(word, "HARDNESS")) {

	jmp	$L80588
$L80607:
	push	OFFSET FLAT:??_C@_08NGNOIIA@HARDNESS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80613

; 774  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 775  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80615
$L80616:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80615:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80617

; 776  : 				CarInfo[CarList[iCar]].Body.Hardness = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1524], ecx

; 777  : 			}

	jmp	SHORT $L80616
$L80617:

; 778  : 		}
; 779  : 
; 780  : 		// RESISTANCE
; 781  : 		else if (Compare(word, "RESISTANCE")) {

	jmp	$L80588
$L80613:
	push	OFFSET FLAT:??_C@_0L@NFJMCNIC@RESISTANCE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80619

; 782  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 783  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80621
$L80622:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80621:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80623

; 784  : 				CarInfo[CarList[iCar]].Body.Resistance = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1528], ecx

; 785  : 			}

	jmp	SHORT $L80622
$L80623:

; 786  : 		}
; 787  : 
; 788  : 		// RESISTANCE
; 789  : 		else if (Compare(word, "ANGRES")) {

	jmp	$L80588
$L80619:
	push	OFFSET FLAT:??_C@_06NJKNDHJM@ANGRES?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80625

; 790  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 791  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80627
$L80628:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80627:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80629

; 792  : 				CarInfo[CarList[iCar]].Body.AngResistance = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1532], ecx

; 793  : 			}

	jmp	SHORT $L80628
$L80629:

; 794  : 		}
; 795  : 
; 796  : 		// RESMOD
; 797  : 		else if (Compare(word, "RESMOD")) {

	jmp	$L80588
$L80625:
	push	OFFSET FLAT:??_C@_06HAFCDGMH@RESMOD?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80631

; 798  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 799  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80633
$L80634:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80633:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80635

; 800  : 				CarInfo[CarList[iCar]].Body.ResModifier = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1536], ecx

; 801  : 			}

	jmp	SHORT $L80634
$L80635:

; 802  : 		}
; 803  : 
; 804  : 		// STATICFRICTION
; 805  : 		else if (Compare(word, "STATICFRICTION")) {

	jmp	$L80588
$L80631:
	push	OFFSET FLAT:??_C@_0P@NCOGJENF@STATICFRICTION?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80637

; 806  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 807  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80639
$L80640:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80639:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80641

; 808  : 				CarInfo[CarList[iCar]].Body.StaticFriction = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1544], ecx

; 809  : 			}

	jmp	SHORT $L80640
$L80641:

; 810  : 		}
; 811  : 
; 812  : 		// KINETICFRICTION
; 813  : 		else if (Compare(word, "KINETICFRICTION")) {

	jmp	$L80588
$L80637:
	push	OFFSET FLAT:??_C@_0BA@MKHKGPBI@KINETICFRICTION?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80643

; 814  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 815  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80645
$L80646:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80645:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80647

; 816  : 				CarInfo[CarList[iCar]].Body.KineticFriction = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1548], ecx

; 817  : 			}

	jmp	SHORT $L80646
$L80647:

; 818  : 		}
; 819  : 
; 820  : 		// GRIP
; 821  : 		else if (Compare(word, "GRIP")) {

	jmp	$L80588
$L80643:
	push	OFFSET FLAT:??_C@_04HHPKKAIJ@GRIP?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80649

; 822  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 823  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80651
$L80652:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80651:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80653

; 824  : 				CarInfo[CarList[iCar]].Body.Grip = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+1540], ecx

; 825  : 			}

	jmp	SHORT $L80652
$L80653:

; 826  : 		}
; 827  : 
; 828  : 		// Default
; 829  : 		else {

	jmp	SHORT $L80588
$L80649:

; 830  : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L80588

; 831  : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 832  : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80567
$L80588:

; 833  : 			}
; 834  : 		}
; 835  : 	}

	jmp	$L80581
$L80582:

; 836  : 
; 837  : 	return TRUE;

	mov	al, 1
$L80567:

; 838  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadBodyInfo@@YA_NPAU_iobuf@@@Z ENDP			; ReadBodyInfo
_TEXT	ENDS
PUBLIC	??_C@_0BG@MNAHJMBI@Could?5not?5read?5Matrix?$AA@ ; `string'
;	COMDAT ??_C@_0BG@MNAHJMBI@Could?5not?5read?5Matrix?$AA@
CONST	SEGMENT
??_C@_0BG@MNAHJMBI@Could?5not?5read?5Matrix?$AA@ DB 'Could not read Matri'
	DB	'x', 00H					; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadMat@@YA_NPATMatrixUnion@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_iV$ = -4						; size = 4
_mat$ = 8						; size = 4
_fp$ = 12						; size = 4
?ReadMat@@YA_NPATMatrixUnion@@PAU_iobuf@@@Z PROC NEAR	; ReadMat, COMDAT

; 257  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 258  : 	int iV;
; 259  : 
; 260  : 	for (iV = 0; iV < 3; iV++) {

	mov	DWORD PTR _iV$[ebp], 0
	jmp	SHORT $L80323
$L80324:
	mov	eax, DWORD PTR _iV$[ebp]
	add	eax, 1
	mov	DWORD PTR _iV$[ebp], eax
$L80323:
	cmp	DWORD PTR _iV$[ebp], 3
	jge	SHORT $L80325

; 261  : 		if (!ReadVec(&mat->mv[iV], fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iV$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L80326

; 262  : 			ShowErrorMessage("Could not read Matrix");

	push	OFFSET FLAT:??_C@_0BG@MNAHJMBI@Could?5not?5read?5Matrix?$AA@
	call	?ShowErrorMessage@@YAXPAD@Z		; ShowErrorMessage
	add	esp, 4

; 263  : 			return FALSE;

	xor	al, al
	jmp	SHORT $L80321
$L80326:

; 264  : 		}
; 265  : 	}

	jmp	SHORT $L80324
$L80325:

; 266  : 	return TRUE;

	mov	al, 1
$L80321:

; 267  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadMat@@YA_NPATMatrixUnion@@PAU_iobuf@@@Z ENDP	; ReadMat
_TEXT	ENDS
PUBLIC	??_C@_07OKCLMFCP@OFFSET1?$AA@			; `string'
PUBLIC	??_C@_07MBAGJGOM@OFFSET2?$AA@			; `string'
PUBLIC	??_C@_06KCFDAKCE@RADIUS?$AA@			; `string'
PUBLIC	??_C@_06KKHFKCDD@MAXPOS?$AA@			; `string'
PUBLIC	??_C@_0N@NCEBIKPJ@AXLEFRICTION?$AA@		; `string'
PUBLIC	??_C@_0L@OMPJAECO@STEERRATIO?$AA@		; `string'
PUBLIC	??_C@_0M@OELHENGI@ENGINERATIO?$AA@		; `string'
PUBLIC	??_C@_0L@HIDOAEMD@ISTURNABLE?$AA@		; `string'
PUBLIC	??_C@_09NALINNHD@ISPOWERED?$AA@			; `string'
PUBLIC	??_C@_09PMFGHDFJ@ISPRESENT?$AA@			; `string'
PUBLIC	??_C@_09JHAMDBMI@SKIDWIDTH?$AA@			; `string'
;	COMDAT ??_C@_07OKCLMFCP@OFFSET1?$AA@
CONST	SEGMENT
??_C@_07OKCLMFCP@OFFSET1?$AA@ DB 'OFFSET1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBAGJGOM@OFFSET2?$AA@
CONST	SEGMENT
??_C@_07MBAGJGOM@OFFSET2?$AA@ DB 'OFFSET2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCFDAKCE@RADIUS?$AA@
CONST	SEGMENT
??_C@_06KCFDAKCE@RADIUS?$AA@ DB 'RADIUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKHFKCDD@MAXPOS?$AA@
CONST	SEGMENT
??_C@_06KKHFKCDD@MAXPOS?$AA@ DB 'MAXPOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NCEBIKPJ@AXLEFRICTION?$AA@
CONST	SEGMENT
??_C@_0N@NCEBIKPJ@AXLEFRICTION?$AA@ DB 'AXLEFRICTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OMPJAECO@STEERRATIO?$AA@
CONST	SEGMENT
??_C@_0L@OMPJAECO@STEERRATIO?$AA@ DB 'STEERRATIO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OELHENGI@ENGINERATIO?$AA@
CONST	SEGMENT
??_C@_0M@OELHENGI@ENGINERATIO?$AA@ DB 'ENGINERATIO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HIDOAEMD@ISTURNABLE?$AA@
CONST	SEGMENT
??_C@_0L@HIDOAEMD@ISTURNABLE?$AA@ DB 'ISTURNABLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NALINNHD@ISPOWERED?$AA@
CONST	SEGMENT
??_C@_09NALINNHD@ISPOWERED?$AA@ DB 'ISPOWERED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PMFGHDFJ@ISPRESENT?$AA@
CONST	SEGMENT
??_C@_09PMFGHDFJ@ISPRESENT?$AA@ DB 'ISPRESENT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHAMDBMI@SKIDWIDTH?$AA@
CONST	SEGMENT
??_C@_09JHAMDBMI@SKIDWIDTH?$AA@ DB 'SKIDWIDTH', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadWheelInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tVec$ = -292						; size = 12
_tReal$ = -280						; size = 4
_tBool$ = -273						; size = 1
_tInt$ = -272						; size = 4
_iWheel$ = -268						; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadWheelInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadWheelInfo, COMDAT

; 849  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	push	ebx
	push	esi
	push	edi
$L80668:

; 850  : 	char	ch;
; 851  : 	char	word[READ_MAX_WORDLEN];
; 852  : 	int		iCar, iWheel;
; 853  : 
; 854  : 	int		tInt;
; 855  : 	bool	tBool;
; 856  : 	REAL	tReal;
; 857  : 	VEC	tVec;
; 858  : 
; 859  : 	// Find the opening braces
; 860  : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80669
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80669

; 861  : 	}

	jmp	SHORT $L80668
$L80669:

; 862  : 	if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80671
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L80673
$L80671:

; 863  : 		return FALSE;

	xor	al, al
	jmp	$L80658
$L80673:

; 864  : 	}
; 865  : 
; 866  : 	// Read in keywords and act on them
; 867  : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80674
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L80674

; 868  : 	
; 869  : 		// MODEL NUMBER
; 870  : 		if (Compare(word, "MODELNUM")) {

	push	OFFSET FLAT:??_C@_08OACPFCKA@MODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80675

; 871  : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 872  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80676
$L80677:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80676:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	$L80678

; 873  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80679
$L80680:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80679:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	$L80681

; 874  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].ModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [edx+ecx+1552], eax

; 875  : 					if (tInt == CAR_MODEL_NONE) {

	cmp	DWORD PTR _tInt$[ebp], -1
	jne	SHORT $L80682

; 876  : 						CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].IsPresent = FALSE;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	BYTE PTR [edx+ecx+1624], 0

; 877  : 					} else {

	jmp	SHORT $L80683
$L80682:

; 878  : 						CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].IsPresent = TRUE;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	BYTE PTR [edx+ecx+1624], 1
$L80683:

; 879  : 					}
; 880  : 				}

	jmp	$L80680
$L80681:

; 881  : 			}

	jmp	$L80677
$L80678:

; 882  : 		}
; 883  : 
; 884  : 		// OFFSETS
; 885  : 		else if (Compare(word, "OFFSET1")) {

	jmp	$L80684
$L80675:
	push	OFFSET FLAT:??_C@_07OKCLMFCP@OFFSET1?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80685

; 886  : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 887  : 			//VecMulScalar(&tVec, OGU2GU_LENGTH);
; 888  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80687
$L80688:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80687:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	$L80689

; 889  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80690
$L80691:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80690:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	$L80692

; 890  : 					CopyVec(&tVec, &CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].Offset1);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [edx+ecx+1556], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [edx+ecx+1560], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [edx+ecx+1564], eax

; 891  : 				}

	jmp	$L80691
$L80692:

; 892  : 			}

	jmp	$L80688
$L80689:

; 893  : 		}
; 894  : 		else if (Compare(word, "OFFSET2")) {

	jmp	$L80684
$L80685:
	push	OFFSET FLAT:??_C@_07MBAGJGOM@OFFSET2?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80694

; 895  : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 896  : 			//VecMulScalar(&tVec, OGU2GU_LENGTH);
; 897  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80696
$L80697:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80696:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	$L80698

; 898  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80699
$L80700:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80699:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	$L80701

; 899  : 					CopyVec(&tVec, &CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].Offset2);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [edx+ecx+1568], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [edx+ecx+1572], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [edx+ecx+1576], eax

; 900  : 				}

	jmp	$L80700
$L80701:

; 901  : 			}

	jmp	$L80697
$L80698:

; 902  : 		}
; 903  : 
; 904  : 		// RADIUS
; 905  : 		else if (Compare(word, "RADIUS")) {

	jmp	$L80684
$L80694:
	push	OFFSET FLAT:??_C@_06KCFDAKCE@RADIUS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80703

; 906  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 907  : 			//tReal *= OGU2GU_LENGTH;
; 908  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80705
$L80706:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80705:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80707

; 909  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80708
$L80709:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80708:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80710

; 910  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].Radius = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1580], eax

; 911  : 				}

	jmp	SHORT $L80709
$L80710:

; 912  : 			}

	jmp	$L80706
$L80707:

; 913  : 		}
; 914  : 
; 915  : 		// MASS
; 916  : 		else if (Compare(word, "MASS")) {

	jmp	$L80684
$L80703:
	push	OFFSET FLAT:??_C@_04EFHKDFDM@MASS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80712

; 917  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 918  : 			//tReal *= OGU2GU_MASS;
; 919  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80713
$L80714:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80713:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80715

; 920  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80716
$L80717:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80716:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80718

; 921  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].Mass = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1584], eax

; 922  : 				}

	jmp	SHORT $L80717
$L80718:

; 923  : 			}

	jmp	$L80714
$L80715:

; 924  : 		}
; 925  : 
; 926  : 		// GRAVITY
; 927  : 		else if (Compare(word, "GRAVITY")) {

	jmp	$L80684
$L80712:
	push	OFFSET FLAT:??_C@_07JIEIIHJI@GRAVITY?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80720

; 928  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 929  : 			//tReal *= OGU2GU_ACC;
; 930  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80721
$L80722:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80721:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80723

; 931  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80724
$L80725:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80724:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80726

; 932  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].Gravity = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1588], eax

; 933  : 				}

	jmp	SHORT $L80725
$L80726:

; 934  : 			}

	jmp	$L80722
$L80723:

; 935  : 		}
; 936  : 
; 937  : 		// MAXPOS
; 938  : 		else if (Compare(word, "MAXPOS")) {

	jmp	$L80684
$L80720:
	push	OFFSET FLAT:??_C@_06KKHFKCDD@MAXPOS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80728

; 939  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 940  : 			//tReal *= OGU2GU_LENGTH;
; 941  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80730
$L80731:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80730:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80732

; 942  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80733
$L80734:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80733:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80735

; 943  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].MaxPos = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1616], eax

; 944  : 				}

	jmp	SHORT $L80734
$L80735:

; 945  : 			}

	jmp	$L80731
$L80732:

; 946  : 		}
; 947  : 		
; 948  : 		// Grip
; 949  : 		else if (Compare(word, "GRIP")) {

	jmp	$L80684
$L80728:
	push	OFFSET FLAT:??_C@_04HHPKKAIJ@GRIP?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80737

; 950  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 951  : 			//tReal *= OGU2GU_GRIP;
; 952  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80738
$L80739:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80738:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80740

; 953  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80741
$L80742:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80741:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80743

; 954  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].Grip = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1592], eax

; 955  : 				}

	jmp	SHORT $L80742
$L80743:

; 956  : 			}

	jmp	$L80739
$L80740:

; 957  : 		}
; 958  : 
; 959  : 		// STATIC FRICTION
; 960  : 		else if (Compare(word, "STATICFRICTION")) {

	jmp	$L80684
$L80737:
	push	OFFSET FLAT:??_C@_0P@NCOGJENF@STATICFRICTION?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80745

; 961  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 962  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80746
$L80747:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80746:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80748

; 963  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80749
$L80750:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80749:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80751

; 964  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].StaticFriction = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1596], eax

; 965  : 				}

	jmp	SHORT $L80750
$L80751:

; 966  : 			}

	jmp	$L80747
$L80748:

; 967  : 		}
; 968  : 
; 969  : 		// KINETIC FRICTION
; 970  : 		else if (Compare(word, "KINETICFRICTION")) {

	jmp	$L80684
$L80745:
	push	OFFSET FLAT:??_C@_0BA@MKHKGPBI@KINETICFRICTION?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80753

; 971  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 972  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80754
$L80755:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80754:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80756

; 973  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80757
$L80758:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80757:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80759

; 974  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].KineticFriction = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1600], eax

; 975  : 				}

	jmp	SHORT $L80758
$L80759:

; 976  : 			}

	jmp	$L80755
$L80756:

; 977  : 		}
; 978  : 
; 979  : 		// AXLE FRICTION
; 980  : 		else if (Compare(word, "AXLEFRICTION")) {

	jmp	$L80684
$L80753:
	push	OFFSET FLAT:??_C@_0N@NCEBIKPJ@AXLEFRICTION?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80761

; 981  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 982  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80763
$L80764:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80763:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80765

; 983  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80766
$L80767:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80766:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80768

; 984  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].AxleFriction = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1604], eax

; 985  : 				}

	jmp	SHORT $L80767
$L80768:

; 986  : 			}

	jmp	$L80764
$L80765:

; 987  : 		}
; 988  : 
; 989  : 		// STEER RATIO
; 990  : 		else if (Compare(word, "STEERRATIO")) {

	jmp	$L80684
$L80761:
	push	OFFSET FLAT:??_C@_0L@OMPJAECO@STEERRATIO?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80770

; 991  : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 992  : 			//tReal *= OGU2GU_FORCE;
; 993  : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80772
$L80773:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80772:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80774

; 994  : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80775
$L80776:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80775:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80777

; 995  : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].SteerRatio = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1608], eax

; 996  : 				}

	jmp	SHORT $L80776
$L80777:

; 997  : 			}

	jmp	$L80773
$L80774:

; 998  : 		}
; 999  : 
; 1000 : 		// ENGINE RATIO
; 1001 : 		else if (Compare(word, "ENGINERATIO")) {

	jmp	$L80684
$L80770:
	push	OFFSET FLAT:??_C@_0M@OELHENGI@ENGINERATIO?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80779

; 1002 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1003 : 			//tReal *= OGU2GU_FORCE;
; 1004 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80781
$L80782:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80781:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80783

; 1005 : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80784
$L80785:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80784:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80786

; 1006 : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].EngineRatio = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1612], eax

; 1007 : 				}

	jmp	SHORT $L80785
$L80786:

; 1008 : 			}

	jmp	$L80782
$L80783:

; 1009 : 		}
; 1010 : 
; 1011 : 		// WHEEL STATUS
; 1012 : 		else if (Compare(word, "ISTURNABLE")) {

	jmp	$L80684
$L80779:
	push	OFFSET FLAT:??_C@_0L@HIDOAEMD@ISTURNABLE?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80788

; 1013 : 			ReadBool(&tBool, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tBool$[ebp]
	push	ecx
	call	?ReadBool@@YA_NPA_NPAU_iobuf@@@Z	; ReadBool
	add	esp, 8

; 1014 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80790
$L80791:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80790:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80792

; 1015 : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80793
$L80794:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80793:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80795

; 1016 : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].IsTurnable = tBool;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	al, BYTE PTR _tBool$[ebp]
	mov	BYTE PTR [edx+ecx+1625], al

; 1017 : 				}

	jmp	SHORT $L80794
$L80795:

; 1018 : 			}

	jmp	$L80791
$L80792:

; 1019 : 		}
; 1020 : 		else if (Compare(word, "ISPOWERED")) {

	jmp	$L80684
$L80788:
	push	OFFSET FLAT:??_C@_09NALINNHD@ISPOWERED?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80797

; 1021 : 			ReadBool(&tBool, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tBool$[ebp]
	push	ecx
	call	?ReadBool@@YA_NPA_NPAU_iobuf@@@Z	; ReadBool
	add	esp, 8

; 1022 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80799
$L80800:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80799:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80801

; 1023 : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80802
$L80803:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80802:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80804

; 1024 : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].IsPowered = tBool;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	al, BYTE PTR _tBool$[ebp]
	mov	BYTE PTR [edx+ecx+1626], al

; 1025 : 				}

	jmp	SHORT $L80803
$L80804:

; 1026 : 			}

	jmp	$L80800
$L80801:

; 1027 : 		}
; 1028 : 		else if (Compare(word, "ISPRESENT")) {

	jmp	$L80684
$L80797:
	push	OFFSET FLAT:??_C@_09PMFGHDFJ@ISPRESENT?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80806

; 1029 : 			ReadBool(&tBool, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tBool$[ebp]
	push	ecx
	call	?ReadBool@@YA_NPA_NPAU_iobuf@@@Z	; ReadBool
	add	esp, 8

; 1030 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80808
$L80809:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80808:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80810

; 1031 : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80811
$L80812:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80811:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80813

; 1032 : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].IsPresent = tBool;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	al, BYTE PTR _tBool$[ebp]
	mov	BYTE PTR [edx+ecx+1624], al

; 1033 : 				}

	jmp	SHORT $L80812
$L80813:

; 1034 : 			}

	jmp	$L80809
$L80810:

; 1035 : 		}
; 1036 : 
; 1037 : 		// SKIDWIDTH
; 1038 : 		else if (Compare(word, "SKIDWIDTH")) {

	jmp	$L80684
$L80806:
	push	OFFSET FLAT:??_C@_09JHAMDBMI@SKIDWIDTH?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80815

; 1039 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1040 : 			//tReal *= OGU2GU_LENGTH;
; 1041 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80817
$L80818:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80817:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80819

; 1042 : 				for (iWheel = 0; iWheel < WheelListSize; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L80820
$L80821:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L80820:
	mov	eax, DWORD PTR _iWheel$[ebp]
	cmp	eax, DWORD PTR ?WheelListSize@@3HA	; WheelListSize
	jge	SHORT $L80822

; 1043 : 					CarInfo[CarList[iCar]].Wheel[WheelList[iWheel]].SkidWidth = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iWheel$[ebp]
	mov	ecx, DWORD PTR ?WheelList@@3PAHA[eax*4]
	imul	ecx, 76					; 0000004cH
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1620], eax

; 1044 : 				}

	jmp	SHORT $L80821
$L80822:

; 1045 : 			}

	jmp	$L80818
$L80819:

; 1046 : 		}
; 1047 : 
; 1048 : 
; 1049 : 		// Default
; 1050 : 		else {

	jmp	SHORT $L80684
$L80815:

; 1051 : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L80684

; 1052 : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1053 : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80658
$L80684:

; 1054 : 			}
; 1055 : 		}
; 1056 : 
; 1057 : 	}

	jmp	$L80673
$L80674:

; 1058 : 
; 1059 : 	return TRUE;

	mov	al, 1
$L80658:

; 1060 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadWheelInfo@@YA_NPAU_iobuf@@@Z ENDP			; ReadWheelInfo
_TEXT	ENDS
PUBLIC	??_C@_06MLIGBJO@LENGTH?$AA@			; `string'
PUBLIC	??_C@_09BNIFBKBF@STIFFNESS?$AA@			; `string'
PUBLIC	??_C@_07HNIDCKIK@DAMPING?$AA@			; `string'
PUBLIC	??_C@_0M@NFADOHD@RESTITUTION?$AA@		; `string'
;	COMDAT ??_C@_06MLIGBJO@LENGTH?$AA@
CONST	SEGMENT
??_C@_06MLIGBJO@LENGTH?$AA@ DB 'LENGTH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNIFBKBF@STIFFNESS?$AA@
CONST	SEGMENT
??_C@_09BNIFBKBF@STIFFNESS?$AA@ DB 'STIFFNESS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HNIDCKIK@DAMPING?$AA@
CONST	SEGMENT
??_C@_07HNIDCKIK@DAMPING?$AA@ DB 'DAMPING', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFADOHD@RESTITUTION?$AA@
CONST	SEGMENT
??_C@_0M@NFADOHD@RESTITUTION?$AA@ DB 'RESTITUTION', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadSpringInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tVec$ = -288						; size = 12
_tReal$ = -276						; size = 4
_tInt$ = -272						; size = 4
_iSpring$ = -268					; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadSpringInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadSpringInfo, COMDAT

; 1071 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	push	ebx
	push	esi
	push	edi
$L80836:

; 1072 : 	char	ch;
; 1073 : 	char	word[READ_MAX_WORDLEN];
; 1074 : 	int		iCar, iSpring;
; 1075 : 
; 1076 : 	int		tInt;
; 1077 : 	REAL	tReal;
; 1078 : 	VEC	tVec;
; 1079 : 
; 1080 : 	// Find the opening braces
; 1081 : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80837
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80837

; 1082 : 	}

	jmp	SHORT $L80836
$L80837:

; 1083 : 	if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80839
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L80841
$L80839:

; 1084 : 		return FALSE;

	xor	al, al
	jmp	$L80827
$L80841:

; 1085 : 	}
; 1086 : 
; 1087 : 	// Read in keywords and act on them
; 1088 : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80842
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L80842

; 1089 : 
; 1090 : 		// MODEL NUMBER
; 1091 : 		if (Compare(word, "MODELNUM")) {

	push	OFFSET FLAT:??_C@_08OACPFCKA@MODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80843

; 1092 : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 1093 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80844
$L80845:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80844:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80846

; 1094 : 				for (iSpring = 0; iSpring < SpringListSize; iSpring++) {

	mov	DWORD PTR _iSpring$[ebp], 0
	jmp	SHORT $L80847
$L80848:
	mov	eax, DWORD PTR _iSpring$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpring$[ebp], eax
$L80847:
	mov	eax, DWORD PTR _iSpring$[ebp]
	cmp	eax, DWORD PTR ?SpringListSize@@3HA	; SpringListSize
	jge	SHORT $L80849

; 1095 : 					CarInfo[CarList[iCar]].Spring[SpringList[iSpring]].ModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [edx+ecx+1856], eax

; 1096 : 				}

	jmp	SHORT $L80848
$L80849:

; 1097 : 			}

	jmp	$L80845
$L80846:

; 1098 : 		}
; 1099 : 
; 1100 : 		// OFFSETS
; 1101 : 		else if (Compare(word, "OFFSET")) {

	jmp	$L80850
$L80843:
	push	OFFSET FLAT:??_C@_06KPFMBGLO@OFFSET?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80851

; 1102 : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 1103 : 			//VecMulScalar(&tVec, OGU2GU_LENGTH);
; 1104 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80852
$L80853:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80852:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	$L80854

; 1105 : 				for (iSpring = 0; iSpring < SpringListSize; iSpring++) {

	mov	DWORD PTR _iSpring$[ebp], 0
	jmp	SHORT $L80855
$L80856:
	mov	eax, DWORD PTR _iSpring$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpring$[ebp], eax
$L80855:
	mov	eax, DWORD PTR _iSpring$[ebp]
	cmp	eax, DWORD PTR ?SpringListSize@@3HA	; SpringListSize
	jge	$L80857

; 1106 : 					CopyVec(&tVec, &CarInfo[CarList[iCar]].Spring[SpringList[iSpring]].Offset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [edx+ecx+1860], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [edx+ecx+1864], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [edx+ecx+1868], eax

; 1107 : 				}

	jmp	$L80856
$L80857:

; 1108 : 			}

	jmp	$L80853
$L80854:

; 1109 : 		}
; 1110 : 	
; 1111 : 		// LENGTH
; 1112 : 		else if (Compare(word, "LENGTH")) {

	jmp	$L80850
$L80851:
	push	OFFSET FLAT:??_C@_06MLIGBJO@LENGTH?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80859

; 1113 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1114 : 			//tReal *= OGU2GU_LENGTH;
; 1115 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80861
$L80862:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80861:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80863

; 1116 : 				for (iSpring = 0; iSpring < SpringListSize; iSpring++) {

	mov	DWORD PTR _iSpring$[ebp], 0
	jmp	SHORT $L80864
$L80865:
	mov	eax, DWORD PTR _iSpring$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpring$[ebp], eax
$L80864:
	mov	eax, DWORD PTR _iSpring$[ebp]
	cmp	eax, DWORD PTR ?SpringListSize@@3HA	; SpringListSize
	jge	SHORT $L80866

; 1117 : 					CarInfo[CarList[iCar]].Spring[SpringList[iSpring]].Length = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1872], eax

; 1118 : 				}

	jmp	SHORT $L80865
$L80866:

; 1119 : 			}

	jmp	$L80862
$L80863:

; 1120 : 		}
; 1121 : 
; 1122 : 		// Stiffness
; 1123 : 		else if (Compare(word, "STIFFNESS")) {

	jmp	$L80850
$L80859:
	push	OFFSET FLAT:??_C@_09BNIFBKBF@STIFFNESS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80868

; 1124 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1125 : 			//tReal *= OGU2GU_STIFFNESS;
; 1126 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80870
$L80871:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80870:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80872

; 1127 : 				for (iSpring = 0; iSpring < SpringListSize; iSpring++) {

	mov	DWORD PTR _iSpring$[ebp], 0
	jmp	SHORT $L80873
$L80874:
	mov	eax, DWORD PTR _iSpring$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpring$[ebp], eax
$L80873:
	mov	eax, DWORD PTR _iSpring$[ebp]
	cmp	eax, DWORD PTR ?SpringListSize@@3HA	; SpringListSize
	jge	SHORT $L80875

; 1128 : 					CarInfo[CarList[iCar]].Spring[SpringList[iSpring]].Stiffness = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1876], eax

; 1129 : 				}

	jmp	SHORT $L80874
$L80875:

; 1130 : 			}

	jmp	$L80871
$L80872:

; 1131 : 		}
; 1132 : 
; 1133 : 		// Damping
; 1134 : 		else if (Compare(word, "DAMPING")) {

	jmp	$L80850
$L80868:
	push	OFFSET FLAT:??_C@_07HNIDCKIK@DAMPING?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80877

; 1135 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1136 : 			//tReal *= OGU2GU_DAMPING;
; 1137 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80879
$L80880:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80879:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80881

; 1138 : 				for (iSpring = 0; iSpring < SpringListSize; iSpring++) {

	mov	DWORD PTR _iSpring$[ebp], 0
	jmp	SHORT $L80882
$L80883:
	mov	eax, DWORD PTR _iSpring$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpring$[ebp], eax
$L80882:
	mov	eax, DWORD PTR _iSpring$[ebp]
	cmp	eax, DWORD PTR ?SpringListSize@@3HA	; SpringListSize
	jge	SHORT $L80884

; 1139 : 					CarInfo[CarList[iCar]].Spring[SpringList[iSpring]].Damping = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1880], eax

; 1140 : 				}

	jmp	SHORT $L80883
$L80884:

; 1141 : 			}

	jmp	$L80880
$L80881:

; 1142 : 		}
; 1143 : 
; 1144 : 		// Restitution
; 1145 : 		else if (Compare(word, "RESTITUTION")) {

	jmp	$L80850
$L80877:
	push	OFFSET FLAT:??_C@_0M@NFADOHD@RESTITUTION?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80886

; 1146 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1147 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80888
$L80889:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80888:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80890

; 1148 : 				for (iSpring = 0; iSpring < SpringListSize; iSpring++) {

	mov	DWORD PTR _iSpring$[ebp], 0
	jmp	SHORT $L80891
$L80892:
	mov	eax, DWORD PTR _iSpring$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSpring$[ebp], eax
$L80891:
	mov	eax, DWORD PTR _iSpring$[ebp]
	cmp	eax, DWORD PTR ?SpringListSize@@3HA	; SpringListSize
	jge	SHORT $L80893

; 1149 : 					CarInfo[CarList[iCar]].Spring[SpringList[iSpring]].Restitution = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iSpring$[ebp]
	mov	ecx, DWORD PTR ?SpringList@@3PAHA[eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+1884], eax

; 1150 : 				}

	jmp	SHORT $L80892
$L80893:

; 1151 : 			}

	jmp	$L80889
$L80890:

; 1152 : 		}
; 1153 : 
; 1154 : 		// Default
; 1155 : 		else {

	jmp	SHORT $L80850
$L80886:

; 1156 : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L80850

; 1157 : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1158 : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80827
$L80850:

; 1159 : 			}
; 1160 : 		}
; 1161 : 	}

	jmp	$L80841
$L80842:

; 1162 : 	
; 1163 : 	return TRUE;

	mov	al, 1
$L80827:

; 1164 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadSpringInfo@@YA_NPAU_iobuf@@@Z ENDP			; ReadSpringInfo
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ReadAxleInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tVec$ = -288						; size = 12
_tReal$ = -276						; size = 4
_tInt$ = -272						; size = 4
_iAxle$ = -268						; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadAxleInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadAxleInfo, COMDAT

; 1174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	push	ebx
	push	esi
	push	edi
$L80907:

; 1175 : 	char	ch;
; 1176 : 	char	word[READ_MAX_WORDLEN];
; 1177 : 	int		iCar, iAxle;
; 1178 : 
; 1179 : 	int		tInt;
; 1180 : 	REAL	tReal;
; 1181 : 	VEC	tVec;
; 1182 : 
; 1183 : 	// Find the opening braces
; 1184 : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80908
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80908

; 1185 : 	}

	jmp	SHORT $L80907
$L80908:

; 1186 : 	if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80910
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L80912
$L80910:

; 1187 : 		return FALSE;

	xor	al, al
	jmp	$L80898
$L80912:

; 1188 : 	}
; 1189 : 
; 1190 : 	// Read in keywords and act on them
; 1191 : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80913
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L80913

; 1192 : 
; 1193 : 		// MODEL NUMBER
; 1194 : 		if (Compare(word, "MODELNUM")) {

	push	OFFSET FLAT:??_C@_08OACPFCKA@MODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80914

; 1195 : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 1196 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80915
$L80916:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80915:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80917

; 1197 : 				for (iAxle = 0; iAxle < AxleListSize; iAxle++) {

	mov	DWORD PTR _iAxle$[ebp], 0
	jmp	SHORT $L80918
$L80919:
	mov	eax, DWORD PTR _iAxle$[ebp]
	add	eax, 1
	mov	DWORD PTR _iAxle$[ebp], eax
$L80918:
	mov	eax, DWORD PTR _iAxle$[ebp]
	cmp	eax, DWORD PTR ?AxleListSize@@3HA	; AxleListSize
	jge	SHORT $L80920

; 1198 : 					CarInfo[CarList[iCar]].Axle[AxleList[iAxle]].ModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iAxle$[ebp]
	mov	ecx, DWORD PTR ?AxleList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [edx+ecx+1984], eax

; 1199 : 				}

	jmp	SHORT $L80919
$L80920:

; 1200 : 			}

	jmp	$L80916
$L80917:

; 1201 : 		}
; 1202 : 
; 1203 : 		// OFFSET
; 1204 : 		else if (Compare(word, "OFFSET")) {

	jmp	$L80921
$L80914:
	push	OFFSET FLAT:??_C@_06KPFMBGLO@OFFSET?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80922

; 1205 : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 1206 : 			//VecMulScalar(&tVec, OGU2GU_LENGTH);
; 1207 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80923
$L80924:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80923:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	$L80925

; 1208 : 				for (iAxle = 0; iAxle < AxleListSize; iAxle++) {

	mov	DWORD PTR _iAxle$[ebp], 0
	jmp	SHORT $L80926
$L80927:
	mov	eax, DWORD PTR _iAxle$[ebp]
	add	eax, 1
	mov	DWORD PTR _iAxle$[ebp], eax
$L80926:
	mov	eax, DWORD PTR _iAxle$[ebp]
	cmp	eax, DWORD PTR ?AxleListSize@@3HA	; AxleListSize
	jge	$L80928

; 1209 : 					CopyVec(&tVec, &CarInfo[CarList[iCar]].Axle[AxleList[iAxle]].Offset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iAxle$[ebp]
	mov	ecx, DWORD PTR ?AxleList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [edx+ecx+1988], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iAxle$[ebp]
	mov	ecx, DWORD PTR ?AxleList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [edx+ecx+1992], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iAxle$[ebp]
	mov	ecx, DWORD PTR ?AxleList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [edx+ecx+1996], eax

; 1210 : 				}

	jmp	$L80927
$L80928:

; 1211 : 			}

	jmp	$L80924
$L80925:

; 1212 : 		}
; 1213 : 	
; 1214 : 		// LENGTH
; 1215 : 		else if (Compare(word, "LENGTH")) {

	jmp	$L80921
$L80922:
	push	OFFSET FLAT:??_C@_06MLIGBJO@LENGTH?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80930

; 1216 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1217 : 			//tReal *= OGU2GU_LENGTH;
; 1218 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80931
$L80932:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80931:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80933

; 1219 : 				for (iAxle = 0; iAxle < AxleListSize; iAxle++) {

	mov	DWORD PTR _iAxle$[ebp], 0
	jmp	SHORT $L80934
$L80935:
	mov	eax, DWORD PTR _iAxle$[ebp]
	add	eax, 1
	mov	DWORD PTR _iAxle$[ebp], eax
$L80934:
	mov	eax, DWORD PTR _iAxle$[ebp]
	cmp	eax, DWORD PTR ?AxleListSize@@3HA	; AxleListSize
	jge	SHORT $L80936

; 1220 : 					CarInfo[CarList[iCar]].Axle[AxleList[iAxle]].Length = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iAxle$[ebp]
	mov	ecx, DWORD PTR ?AxleList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+2000], eax

; 1221 : 				}

	jmp	SHORT $L80935
$L80936:

; 1222 : 			}

	jmp	$L80932
$L80933:

; 1223 : 		}
; 1224 : 
; 1225 : 		// Default
; 1226 : 		else {

	jmp	SHORT $L80921
$L80930:

; 1227 : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L80921

; 1228 : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1229 : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80898
$L80921:

; 1230 : 			}
; 1231 : 		}
; 1232 : 	}

	jmp	$L80912
$L80913:

; 1233 : 	
; 1234 : 	return TRUE;

	mov	al, 1
$L80898:

; 1235 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadAxleInfo@@YA_NPAU_iobuf@@@Z ENDP			; ReadAxleInfo
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ReadPinInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tVec$ = -288						; size = 12
_tReal$ = -276						; size = 4
_tInt$ = -272						; size = 4
_iPin$ = -268						; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadPinInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadPinInfo, COMDAT

; 1245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	push	ebx
	push	esi
	push	edi
$L80950:

; 1246 : 	char	ch;
; 1247 : 	char	word[READ_MAX_WORDLEN];
; 1248 : 	int		iCar, iPin;
; 1249 : 
; 1250 : 	int		tInt;
; 1251 : 	REAL	tReal;
; 1252 : 	VEC	tVec;
; 1253 : 
; 1254 : 	// Find the opening braces
; 1255 : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80951
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80951

; 1256 : 	}

	jmp	SHORT $L80950
$L80951:

; 1257 : 	if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80953
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L80955
$L80953:

; 1258 : 		return FALSE;

	xor	al, al
	jmp	$L80941
$L80955:

; 1259 : 	}
; 1260 : 
; 1261 : 	// Read in keywords and act on them
; 1262 : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80956
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L80956

; 1263 : 
; 1264 : 		// MODEL NUMBER
; 1265 : 		if (Compare(word, "MODELNUM")) {

	push	OFFSET FLAT:??_C@_08OACPFCKA@MODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80957

; 1266 : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 1267 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80958
$L80959:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80958:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80960

; 1268 : 				for (iPin = 0; iPin < PinListSize; iPin++) {

	mov	DWORD PTR _iPin$[ebp], 0
	jmp	SHORT $L80961
$L80962:
	mov	eax, DWORD PTR _iPin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPin$[ebp], eax
$L80961:
	mov	eax, DWORD PTR _iPin$[ebp]
	cmp	eax, DWORD PTR ?PinListSize@@3HA	; PinListSize
	jge	SHORT $L80963

; 1269 : 					CarInfo[CarList[iCar]].Pin[PinList[iPin]].ModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iPin$[ebp]
	mov	ecx, DWORD PTR ?PinList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [edx+ecx+2064], eax

; 1270 : 				}

	jmp	SHORT $L80962
$L80963:

; 1271 : 			}

	jmp	$L80959
$L80960:

; 1272 : 		}
; 1273 : 
; 1274 : 		// OFFSET
; 1275 : 		else if (Compare(word, "OFFSET")) {

	jmp	$L80964
$L80957:
	push	OFFSET FLAT:??_C@_06KPFMBGLO@OFFSET?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80965

; 1276 : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 1277 : 			//VecMulScalar(&tVec, OGU2GU_LENGTH);
; 1278 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80966
$L80967:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80966:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	$L80968

; 1279 : 				for (iPin = 0; iPin < PinListSize; iPin++) {

	mov	DWORD PTR _iPin$[ebp], 0
	jmp	SHORT $L80969
$L80970:
	mov	eax, DWORD PTR _iPin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPin$[ebp], eax
$L80969:
	mov	eax, DWORD PTR _iPin$[ebp]
	cmp	eax, DWORD PTR ?PinListSize@@3HA	; PinListSize
	jge	$L80971

; 1280 : 					CopyVec(&tVec, &CarInfo[CarList[iCar]].Pin[PinList[iPin]].Offset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iPin$[ebp]
	mov	ecx, DWORD PTR ?PinList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [edx+ecx+2068], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iPin$[ebp]
	mov	ecx, DWORD PTR ?PinList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [edx+ecx+2072], eax
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iPin$[ebp]
	mov	ecx, DWORD PTR ?PinList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [edx+ecx+2076], eax

; 1281 : 				}

	jmp	$L80970
$L80971:

; 1282 : 			}

	jmp	$L80967
$L80968:

; 1283 : 		}
; 1284 : 	
; 1285 : 		// LENGTH
; 1286 : 		else if (Compare(word, "LENGTH")) {

	jmp	$L80964
$L80965:
	push	OFFSET FLAT:??_C@_06MLIGBJO@LENGTH?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L80973

; 1287 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1288 : 			//tReal *= OGU2GU_LENGTH;
; 1289 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L80974
$L80975:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L80974:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L80976

; 1290 : 				for (iPin = 0; iPin < PinListSize; iPin++) {

	mov	DWORD PTR _iPin$[ebp], 0
	jmp	SHORT $L80977
$L80978:
	mov	eax, DWORD PTR _iPin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPin$[ebp], eax
$L80977:
	mov	eax, DWORD PTR _iPin$[ebp]
	cmp	eax, DWORD PTR ?PinListSize@@3HA	; PinListSize
	jge	SHORT $L80979

; 1291 : 					CarInfo[CarList[iCar]].Pin[PinList[iPin]].Length = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	add	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR _iPin$[ebp]
	mov	ecx, DWORD PTR ?PinList@@3PAHA[eax*4]
	imul	ecx, 20					; 00000014H
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [edx+ecx+2080], eax

; 1292 : 				}

	jmp	SHORT $L80978
$L80979:

; 1293 : 			}

	jmp	$L80975
$L80976:

; 1294 : 		}
; 1295 : 
; 1296 : 		// Default
; 1297 : 		else {

	jmp	SHORT $L80964
$L80973:

; 1298 : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L80964

; 1299 : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1300 : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80941
$L80964:

; 1301 : 			}
; 1302 : 		}
; 1303 : 	}

	jmp	$L80955
$L80956:

; 1304 : 	
; 1305 : 	return TRUE;

	mov	al, 1
$L80941:

; 1306 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadPinInfo@@YA_NPAU_iobuf@@@Z ENDP			; ReadPinInfo
_TEXT	ENDS
PUBLIC	??_C@_04LMCKOGIO@AXIS?$AA@			; `string'
PUBLIC	??_C@_06JLJFKOFF@ANGVEL?$AA@			; `string'
;	COMDAT ??_C@_04LMCKOGIO@AXIS?$AA@
CONST	SEGMENT
??_C@_04LMCKOGIO@AXIS?$AA@ DB 'AXIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JLJFKOFF@ANGVEL?$AA@
CONST	SEGMENT
??_C@_06JLJFKOFF@ANGVEL?$AA@ DB 'ANGVEL', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadSpinnerInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tVec$ = -284						; size = 12
_tReal$ = -272						; size = 4
_tInt$ = -268						; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadSpinnerInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadSpinnerInfo, COMDAT

; 1315 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
$L80992:

; 1316 : 	char	ch;
; 1317 : 	char	word[READ_MAX_WORDLEN];
; 1318 : 	int		iCar;
; 1319 : 
; 1320 : 	int		tInt;
; 1321 : 	REAL	tReal;
; 1322 : 	VEC	tVec;
; 1323 : 
; 1324 : 	// Find the opening braces
; 1325 : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L80993
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80993

; 1326 : 	}

	jmp	SHORT $L80992
$L80993:

; 1327 : 	if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L80995
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L80997
$L80995:

; 1328 : 		return FALSE;

	xor	al, al
	jmp	$L80984
$L80997:

; 1329 : 	}
; 1330 : 
; 1331 : 	// Read in keywords and act on them
; 1332 : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L80998
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L80998

; 1333 : 
; 1334 : 		// MODEL NUMBERS
; 1335 : 		if (Compare(word, "MODELNUM")) {

	push	OFFSET FLAT:??_C@_08OACPFCKA@MODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L80999

; 1336 : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 1337 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81000
$L81001:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81000:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81002

; 1338 : 				CarInfo[CarList[iCar]].Spinner.ModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [eax+edx+2144], ecx

; 1339 : 			}

	jmp	SHORT $L81001
$L81002:

; 1340 : 		}
; 1341 : 
; 1342 : 		// OFFSET
; 1343 : 		else if (Compare(word, "OFFSET")) {

	jmp	$L81003
$L80999:
	push	OFFSET FLAT:??_C@_06KPFMBGLO@OFFSET?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L81004

; 1344 : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 1345 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81005
$L81006:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81005:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81007

; 1346 : 				CopyVec(&tVec, &CarInfo[CarList[iCar]].Spinner.Offset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [eax+edx+2148], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [eax+edx+2152], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [eax+edx+2156], ecx

; 1347 : 			}

	jmp	$L81006
$L81007:

; 1348 : 		}
; 1349 : 
; 1350 : 		// Axis of spin
; 1351 : 		else if (Compare(word, "AXIS")) {

	jmp	$L81003
$L81004:
	push	OFFSET FLAT:??_C@_04LMCKOGIO@AXIS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L81009

; 1352 : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 1353 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81011
$L81012:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81011:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81013

; 1354 : 				CopyVec(&tVec, &CarInfo[CarList[iCar]].Spinner.Axis);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [eax+edx+2160], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [eax+edx+2164], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [eax+edx+2168], ecx

; 1355 : 			}

	jmp	$L81012
$L81013:

; 1356 : 		}
; 1357 : 
; 1358 : 		// Spin angular velocity
; 1359 : 		else if (Compare(word, "ANGVEL")) {

	jmp	$L81003
$L81009:
	push	OFFSET FLAT:??_C@_06JLJFKOFF@ANGVEL?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L81015

; 1360 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1361 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81017
$L81018:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81017:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81019

; 1362 : 				CarInfo[CarList[iCar]].Spinner.AngVel = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+2172], ecx

; 1363 : 			}

	jmp	SHORT $L81018
$L81019:

; 1364 : 		}
; 1365 : 
; 1366 : 		// Default
; 1367 : 		else {

	jmp	SHORT $L81003
$L81015:

; 1368 : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L81003

; 1369 : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1370 : 				return FALSE;

	xor	al, al
	jmp	SHORT $L80984
$L81003:

; 1371 : 			}
; 1372 : 		}
; 1373 : 
; 1374 : 	}

	jmp	$L80997
$L80998:

; 1375 : 	return TRUE;

	mov	al, 1
$L80984:

; 1376 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadSpinnerInfo@@YA_NPAU_iobuf@@@Z ENDP		; ReadSpinnerInfo
_TEXT	ENDS
PUBLIC	??_C@_0M@OEIEABJD@SECMODELNUM?$AA@		; `string'
PUBLIC	??_C@_0M@LOCKIKHD@TOPMODELNUM?$AA@		; `string'
PUBLIC	??_C@_09EPFKIFGC@DIRECTION?$AA@			; `string'
;	COMDAT ??_C@_0M@OEIEABJD@SECMODELNUM?$AA@
CONST	SEGMENT
??_C@_0M@OEIEABJD@SECMODELNUM?$AA@ DB 'SECMODELNUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LOCKIKHD@TOPMODELNUM?$AA@
CONST	SEGMENT
??_C@_0M@LOCKIKHD@TOPMODELNUM?$AA@ DB 'TOPMODELNUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPFKIFGC@DIRECTION?$AA@
CONST	SEGMENT
??_C@_09EPFKIFGC@DIRECTION?$AA@ DB 'DIRECTION', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ReadAerialInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
_tVec$ = -284						; size = 12
_tReal$ = -272						; size = 4
_tInt$ = -268						; size = 4
_iCar$ = -264						; size = 4
_word$ = -260						; size = 256
_ch$ = -1						; size = 1
_fp$ = 8						; size = 4
?ReadAerialInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; ReadAerialInfo, COMDAT

; 1386 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
$L81032:

; 1387 : 	char	ch;
; 1388 : 	char	word[READ_MAX_WORDLEN];
; 1389 : 	int		iCar;
; 1390 : 
; 1391 : 	int		tInt;
; 1392 : 	REAL	tReal;
; 1393 : 	VEC	tVec;
; 1394 : 
; 1395 : 	// Find the opening braces
; 1396 : 	while (isspace(ch = fgetc(fp)) && ch != EOF) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $L81033
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L81033

; 1397 : 	}

	jmp	SHORT $L81032
$L81033:

; 1398 : 	if (ch == EOF || ch != '{') {

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, -1
	je	SHORT $L81035
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L81037
$L81035:

; 1399 : 		return FALSE;

	xor	al, al
	jmp	$L81024
$L81037:

; 1400 : 	}
; 1401 : 
; 1402 : 	// Read in keywords and act on them
; 1403 : 	while (ReadWord(word, fp) && !Compare(word, "}")) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	?ReadWord@@YA_NPADPAU_iobuf@@@Z		; ReadWord
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L81038
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$L81038

; 1404 : 
; 1405 : 		// MODEL NUMBERS
; 1406 : 		if (Compare(word, "SECMODELNUM")) {

	push	OFFSET FLAT:??_C@_0M@OEIEABJD@SECMODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L81039

; 1407 : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 1408 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81041
$L81042:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81041:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81043

; 1409 : 				CarInfo[CarList[iCar]].Aerial.SecModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [eax+edx+2176], ecx

; 1410 : 			}

	jmp	SHORT $L81042
$L81043:

; 1411 : 		}
; 1412 : 		else if (Compare(word, "TOPMODELNUM")) {

	jmp	$L81044
$L81039:
	push	OFFSET FLAT:??_C@_0M@LOCKIKHD@TOPMODELNUM?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L81045

; 1413 : 			ReadInt(&tInt, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tInt$[ebp]
	push	ecx
	call	?ReadInt@@YA_NPAHPAU_iobuf@@@Z		; ReadInt
	add	esp, 8

; 1414 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81047
$L81048:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81047:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81049

; 1415 : 				CarInfo[CarList[iCar]].Aerial.TopModelNum = tInt;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [eax+edx+2180], ecx

; 1416 : 			}

	jmp	SHORT $L81048
$L81049:

; 1417 : 		}
; 1418 : 
; 1419 : 		// OFFSET
; 1420 : 		else if (Compare(word, "OFFSET")) {

	jmp	$L81044
$L81045:
	push	OFFSET FLAT:??_C@_06KPFMBGLO@OFFSET?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L81051

; 1421 : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 1422 : 			//VecMulScalar(&tVec, OGU2GU_LENGTH);
; 1423 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81052
$L81053:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81052:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81054

; 1424 : 				CopyVec(&tVec, &CarInfo[CarList[iCar]].Aerial.Offset);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [eax+edx+2184], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [eax+edx+2188], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [eax+edx+2192], ecx

; 1425 : 			}

	jmp	$L81053
$L81054:

; 1426 : 		}
; 1427 : 	
; 1428 : 		// LENGTH
; 1429 : 		else if (Compare(word, "LENGTH")) {

	jmp	$L81044
$L81051:
	push	OFFSET FLAT:??_C@_06MLIGBJO@LENGTH?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L81056

; 1430 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1431 : 			//tReal *= OGU2GU_LENGTH;
; 1432 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81057
$L81058:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81057:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81059

; 1433 : 				CarInfo[CarList[iCar]].Aerial.SecLen = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+2208], ecx

; 1434 : 			}

	jmp	SHORT $L81058
$L81059:

; 1435 : 		}
; 1436 : 
; 1437 : 		// DIRECTION
; 1438 : 		else if (Compare(word, "DIRECTION")) {

	jmp	$L81044
$L81056:
	push	OFFSET FLAT:??_C@_09EPFKIFGC@DIRECTION?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$L81061

; 1439 : 			ReadVec(&tVec, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tVec$[ebp]
	push	ecx
	call	?ReadVec@@YA_NPAUVectorStruct@@PAU_iobuf@@@Z ; ReadVec
	add	esp, 8

; 1440 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81063
$L81064:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81063:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81065

; 1441 : 				CopyVec(&tVec, &CarInfo[CarList[iCar]].Aerial.Direction);

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp]
	mov	DWORD PTR [eax+edx+2196], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+4]
	mov	DWORD PTR [eax+edx+2200], ecx
	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tVec$[ebp+8]
	mov	DWORD PTR [eax+edx+2204], ecx

; 1442 : 			}

	jmp	$L81064
$L81065:

; 1443 : 		}
; 1444 : 
; 1445 : 		// STIFFNESS
; 1446 : 		else if (Compare(word, "STIFFNESS")) {

	jmp	$L81044
$L81061:
	push	OFFSET FLAT:??_C@_09BNIFBKBF@STIFFNESS?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L81067

; 1447 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1448 : 			//tReal *= OGU2GU_FORCE / OGU2GU_LENGTH;
; 1449 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81068
$L81069:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81068:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81070

; 1450 : 				CarInfo[CarList[iCar]].Aerial.Stiffness = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+2212], ecx

; 1451 : 			}

	jmp	SHORT $L81069
$L81070:

; 1452 : 		}
; 1453 : 
; 1454 : 		// DAMPING
; 1455 : 		else if (Compare(word, "DAMPING")) {

	jmp	$L81044
$L81067:
	push	OFFSET FLAT:??_C@_07HNIDCKIK@DAMPING?$AA@
	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?Compare@@YA_NPAD0@Z			; Compare
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L81072

; 1456 : 			ReadReal(&tReal, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tReal$[ebp]
	push	ecx
	call	?ReadReal@@YA_NPAMPAU_iobuf@@@Z		; ReadReal
	add	esp, 8

; 1457 : 			//tReal *= OGU2GU_DAMPING;
; 1458 : 			for (iCar = 0; iCar < CarListSize; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L81073
$L81074:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L81073:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?CarListSize@@3HA	; CarListSize
	jge	SHORT $L81075

; 1459 : 				CarInfo[CarList[iCar]].Aerial.Damping = tReal;

	mov	eax, DWORD PTR _iCar$[ebp]
	mov	ecx, DWORD PTR ?CarList@@3PAHA		; CarList
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, 2220				; 000008acH
	mov	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+edx+2216], ecx

; 1460 : 			}

	jmp	SHORT $L81074
$L81075:

; 1461 : 		}
; 1462 : 
; 1463 : 		// Default
; 1464 : 		else {

	jmp	SHORT $L81044
$L81072:

; 1465 : 			if (UnknownWordMessage(word) == IDNO) {

	lea	eax, DWORD PTR _word$[ebp]
	push	eax
	call	?UnknownWordMessage@@YAHPAD@Z		; UnknownWordMessage
	add	esp, 4
	cmp	eax, 7
	jne	SHORT $L81044

; 1466 : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 1467 : 				return FALSE;

	xor	al, al
	jmp	SHORT $L81024
$L81044:

; 1468 : 			}
; 1469 : 		}
; 1470 : 	}

	jmp	$L81037
$L81038:

; 1471 : 		
; 1472 : 	return TRUE;

	mov	al, 1
$L81024:

; 1473 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadAerialInfo@@YA_NPAU_iobuf@@@Z ENDP			; ReadAerialInfo
_TEXT	ENDS
PUBLIC	??_C@_0BA@BNOGOCOE@?$CC?$CFs?$CC?6?6Continue?$DP?$AA@ ; `string'
PUBLIC	??_C@_0BD@GOKDACMG@Unrecognised?5word?3?$AA@	; `string'
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	__imp__wsprintfA:NEAR
_BSS	SEGMENT
_ErrorMessage DB 0100H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@BNOGOCOE@?$CC?$CFs?$CC?6?6Continue?$DP?$AA@
CONST	SEGMENT
??_C@_0BA@BNOGOCOE@?$CC?$CFs?$CC?6?6Continue?$DP?$AA@ DB '"%s"', 0aH, 0aH
	DB	'Continue?', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GOKDACMG@Unrecognised?5word?3?$AA@
CONST	SEGMENT
??_C@_0BD@GOKDACMG@Unrecognised?5word?3?$AA@ DB 'Unrecognised word:', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UnknownWordMessage@@YAHPAD@Z
_TEXT	SEGMENT
_word$ = 8						; size = 4
?UnknownWordMessage@@YAHPAD@Z PROC NEAR			; UnknownWordMessage, COMDAT

; 1483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1484 : 
; 1485 : 	wsprintf(ErrorMessage, "\"%s\"\n\nContinue?", word);

	mov	eax, DWORD PTR _word$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BA@BNOGOCOE@?$CC?$CFs?$CC?6?6Continue?$DP?$AA@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 1486 : 	return Box("Unrecognised word:", ErrorMessage, MB_YESNO | MB_DEFBUTTON1 | MB_ICONQUESTION);

	push	36					; 00000024H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_0BD@GOKDACMG@Unrecognised?5word?3?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 1487 : 
; 1488 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnknownWordMessage@@YAHPAD@Z ENDP			; UnknownWordMessage
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BF@MAOHNJL@Initialisation?5Error?$AA@	; `string'
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MAOHNJL@Initialisation?5Error?$AA@
CONST	SEGMENT
??_C@_0BF@MAOHNJL@Initialisation?5Error?$AA@ DB 'Initialisation Error', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ShowErrorMessage@@YAXPAD@Z
_TEXT	SEGMENT
_word$ = 8						; size = 4
?ShowErrorMessage@@YAXPAD@Z PROC NEAR			; ShowErrorMessage, COMDAT

; 1491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1492 : 
; 1493 : 	wsprintf(ErrorMessage, "%s", word);

	mov	eax, DWORD PTR _word$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 1494 : 	Box("Initialisation Error", ErrorMessage, MB_OK);

	push	0
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_0BF@MAOHNJL@Initialisation?5Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 1495 : 
; 1496 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowErrorMessage@@YAXPAD@Z ENDP			; ShowErrorMessage
_TEXT	ENDS
PUBLIC	??_C@_0BL@GHAKLHEF@Invalid?5number?5list?5for?6?$CFs?$AA@ ; `string'
;	COMDAT ??_C@_0BL@GHAKLHEF@Invalid?5number?5list?5for?6?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@GHAKLHEF@Invalid?5number?5list?5for?6?$CFs?$AA@ DB 'Invalid num'
	DB	'ber list for', 0aH, '%s', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InvalidNumberList@@YAXPAD@Z
_TEXT	SEGMENT
_object$ = 8						; size = 4
?InvalidNumberList@@YAXPAD@Z PROC NEAR			; InvalidNumberList, COMDAT

; 1507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1508 : 
; 1509 : 	wsprintf(ErrorMessage, "Invalid number list for\n%s", object);

	mov	eax, DWORD PTR _object$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BL@GHAKLHEF@Invalid?5number?5list?5for?6?$CFs?$AA@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 1510 : 	Box("Initialisation Error", ErrorMessage, MB_OK);

	push	0
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_0BF@MAOHNJL@Initialisation?5Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 1511 : 
; 1512 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidNumberList@@YAXPAD@Z ENDP			; InvalidNumberList
_TEXT	ENDS
END
