; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\shadow.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawShadow@@YAXPAUVectorStruct@@000MMMMJMMJJPAUBoundingBoxStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClipShadowEdge@@YAXPAUSHADOW_VERT@@0M0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	__real@00000000
PUBLIC	__real@43800000
PUBLIC	__real@40000000
PUBLIC	__real@bdcccccd
PUBLIC	?DrawShadow@@YAXPAUVectorStruct@@000MMMMJMMJJPAUBoundingBoxStruct@@@Z ; DrawShadow
PUBLIC	?ClipShadowEdge@@YAXPAUSHADOW_VERT@@0M0@Z	; ClipShadowEdge
EXTRN	?ViewMatrixScaled@@3TMatrixUnion@@A:BYTE	; ViewMatrixScaled
EXTRN	?ViewTransScaled@@3UVectorStruct@@A:BYTE	; ViewTransScaled
EXTRN	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z:NEAR ; PosToCollGrid
EXTRN	__fltused:NEAR
EXTRN	?SemiPoly@@3PAUDRAW_SEMI_POLY@@A:BYTE		; SemiPoly
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
EXTRN	?SemiCount@@3JA:DWORD				; SemiCount
EXTRN	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z:NEAR ; RotTransPersVector
EXTRN	?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z:NEAR ; FindIntersection
_BSS	SEGMENT
_ShadowVertNum DW 01H DUP (?)
	ALIGN	4

_ShadowVertFree DW 01H DUP (?)
	ALIGN	4

_ShadowVertList DW 010H DUP (?)
_ShadowVert DB	0280H DUP (?)
_ShadowDrawVert DB 0100H DUP (?)
_BSS	ENDS
;	COMDAT __real@00000000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\shadow.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DrawShadow@@YAXPAUVectorStruct@@000MMMMJMMJJPAUBoundingBoxStruct@@@Z
_TEXT	SEGMENT
_svert$ = -168						; size = 4
_vert$ = -164						; size = 4
_header$ = -160						; size = 4
_plane$ = -156						; size = 4
_vert1$ = -152						; size = 4
_vert0$ = -148						; size = 4
_pos$ = -144						; size = 12
_lp3$ = -132						; size = 12
_lp2$ = -120						; size = 12
_lp1$ = -108						; size = 12
_lp0$ = -96						; size = 12
_p$ = -84						; size = 4
_zmax$ = -80						; size = 4
_zmin$ = -76						; size = 4
_ymax$ = -72						; size = 4
_ymin$ = -68						; size = 4
_xmax$ = -64						; size = 4
_xmin$ = -60						; size = 4
_ldist3$ = -56						; size = 4
_ldist2$ = -52						; size = 4
_ldist1$ = -48						; size = 4
_ldist0$ = -44						; size = 4
_dist3$ = -40						; size = 4
_dist2$ = -36						; size = 4
_dist1$ = -32						; size = 4
_dist0$ = -28						; size = 4
_togg$ = -24						; size = 2
_vcount$ = -20						; size = 2
_newcount$ = -16					; size = 2
_k$ = -12						; size = 2
_j$ = -8						; size = 2
_i$ = -4						; size = 2
_p0$ = 8						; size = 4
_p1$ = 12						; size = 4
_p2$ = 16						; size = 4
_p3$ = 20						; size = 4
_tu$ = 24						; size = 4
_tv$ = 28						; size = 4
_twidth$ = 32						; size = 4
_theight$ = 36						; size = 4
_rgb$ = 40						; size = 4
_yoff$ = 44						; size = 4
_maxy$ = 48						; size = 4
_semi$ = 52						; size = 4
_tpage$ = 56						; size = 4
_box$ = 60						; size = 4
?DrawShadow@@YAXPAUVectorStruct@@000MMMMJMMJJPAUBoundingBoxStruct@@@Z PROC NEAR ; DrawShadow, COMDAT

; 23   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi

; 24   : 	short i, j, k, newcount, vcount, togg;
; 25   : 	float dist0, dist1, dist2, dist3;
; 26   : 	float ldist0, ldist1, ldist2, ldist3;
; 27   : 	float xmin, xmax, ymin, ymax, zmin, zmax;
; 28   : 	NEWCOLLPOLY *p;
; 29   : 	VEC lp0, lp1, lp2, lp3, pos;
; 30   : 	SHADOW_VERT *vert0, *vert1;
; 31   : 	PLANE *plane;
; 32   : 	COLLGRID *header;
; 33   : 	VERTEX_TEX1 *vert;
; 34   : 	SHADOW_VERT *svert;
; 35   : 
; 36   : // create bounding box
; 37   : 
; 38   : 	xmin = xmax = p0->v[X];

	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xmax$[ebp], ecx
	mov	edx, DWORD PTR _xmax$[ebp]
	mov	DWORD PTR _xmin$[ebp], edx

; 39   : 	ymin = p0->v[Y];

	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ymin$[ebp], ecx

; 40   : 	zmin = zmax = p0->v[Z];

	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _zmax$[ebp], ecx
	mov	edx, DWORD PTR _zmax$[ebp]
	mov	DWORD PTR _zmin$[ebp], edx

; 41   : 
; 42   : 	if (p1->v[X] < xmin) xmin = p1->v[X];

	mov	eax, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _xmin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81115
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xmin$[ebp], ecx
$L81115:

; 43   : 	if (p1->v[X] > xmax) xmax = p1->v[X];

	mov	eax, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _xmax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81116
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xmax$[ebp], ecx
$L81116:

; 44   : 	if (p1->v[Y] < ymin) ymin = p1->v[Y];

	mov	eax, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR _ymin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81117
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ymin$[ebp], ecx
$L81117:

; 45   : 	if (p1->v[Z] < zmin) zmin = p1->v[Z];

	mov	eax, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR _zmin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81118
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _zmin$[ebp], ecx
$L81118:

; 46   : 	if (p1->v[Z] > zmax) zmax = p1->v[Z];

	mov	eax, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR _zmax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81119
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _zmax$[ebp], ecx
$L81119:

; 47   : 
; 48   : 	if (p2->v[X] < xmin) xmin = p2->v[X];

	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _xmin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81120
	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xmin$[ebp], ecx
$L81120:

; 49   : 	if (p2->v[X] > xmax) xmax = p2->v[X];

	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _xmax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81121
	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xmax$[ebp], ecx
$L81121:

; 50   : 	if (p2->v[Y] < ymin) ymin = p2->v[Y];

	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR _ymin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81122
	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ymin$[ebp], ecx
$L81122:

; 51   : 	if (p2->v[Z] < zmin) zmin = p2->v[Z];

	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR _zmin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81123
	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _zmin$[ebp], ecx
$L81123:

; 52   : 	if (p2->v[Z] > zmax) zmax = p2->v[Z];

	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR _zmax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81124
	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _zmax$[ebp], ecx
$L81124:

; 53   : 
; 54   : 	if (p3->v[X] < xmin) xmin = p3->v[X];

	mov	eax, DWORD PTR _p3$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _xmin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81125
	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xmin$[ebp], ecx
$L81125:

; 55   : 	if (p3->v[X] > xmax) xmax = p3->v[X];

	mov	eax, DWORD PTR _p3$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _xmax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81126
	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xmax$[ebp], ecx
$L81126:

; 56   : 	if (p3->v[Y] < ymin) ymin = p3->v[Y];

	mov	eax, DWORD PTR _p3$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR _ymin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81127
	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ymin$[ebp], ecx
$L81127:

; 57   : 	if (p3->v[Z] < zmin) zmin = p3->v[Z];

	mov	eax, DWORD PTR _p3$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR _zmin$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81128
	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _zmin$[ebp], ecx
$L81128:

; 58   : 	if (p3->v[Z] > zmax) zmax = p3->v[Z];

	mov	eax, DWORD PTR _p3$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR _zmax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81129
	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _zmax$[ebp], ecx
$L81129:

; 59   : 
; 60   : 	if (maxy)

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _maxy$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L81130

; 61   : 		ymax = ymin + maxy;

	fld	DWORD PTR _ymin$[ebp]
	fadd	DWORD PTR _maxy$[ebp]
	fstp	DWORD PTR _ymax$[ebp]

; 62   : 	else

	jmp	SHORT $L81131
$L81130:

; 63   : 		ymax = 1000000.0f;

	mov	DWORD PTR _ymax$[ebp], 1232348160	; 49742400H
$L81131:

; 64   : 
; 65   : // set 'above' vectors
; 66   : 
; 67   : 	SetVector(&lp0, p0->v[X], p0->v[Y] - 256, p0->v[Z]);

	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lp0$[ebp], ecx
	mov	eax, DWORD PTR _p0$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR __real@43800000
	fstp	DWORD PTR _lp0$[ebp+4]
	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lp0$[ebp+8], ecx

; 68   : 	SetVector(&lp1, p1->v[X], p1->v[Y] - 256, p1->v[Z]);

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lp1$[ebp], ecx
	mov	eax, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR __real@43800000
	fstp	DWORD PTR _lp1$[ebp+4]
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lp1$[ebp+8], ecx

; 69   : 	SetVector(&lp2, p2->v[X], p2->v[Y] - 256, p2->v[Z]);

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lp2$[ebp], ecx
	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR __real@43800000
	fstp	DWORD PTR _lp2$[ebp+4]
	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lp2$[ebp+8], ecx

; 70   : 	SetVector(&lp3, p3->v[X], p3->v[Y] - 256, p3->v[Z]);

	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lp3$[ebp], ecx
	mov	eax, DWORD PTR _p3$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR __real@43800000
	fstp	DWORD PTR _lp3$[ebp+4]
	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lp3$[ebp+8], ecx

; 71   : 
; 72   : // set default shadow bounding box
; 73   : 
; 74   : 	if (box)

	cmp	DWORD PTR _box$[ebp], 0
	je	SHORT $L81132

; 75   : 	{
; 76   : 		box->Xmin = box->Ymin = box->Zmin = 1000000.0f;

	mov	eax, DWORD PTR _box$[ebp]
	mov	DWORD PTR [eax+16], 1232348160		; 49742400H
	mov	ecx, DWORD PTR _box$[ebp]
	mov	DWORD PTR [ecx+8], 1232348160		; 49742400H
	mov	edx, DWORD PTR _box$[ebp]
	mov	DWORD PTR [edx], 1232348160		; 49742400H

; 77   : 		box->Xmax = box->Ymax = box->Zmax = -1000000.0f;

	mov	eax, DWORD PTR _box$[ebp]
	mov	DWORD PTR [eax+20], -915135488		; c9742400H
	mov	ecx, DWORD PTR _box$[ebp]
	mov	DWORD PTR [ecx+12], -915135488		; c9742400H
	mov	edx, DWORD PTR _box$[ebp]
	mov	DWORD PTR [edx+4], -915135488		; c9742400H
$L81132:

; 78   : 	}
; 79   : 
; 80   : // loop thru coll polys
; 81   : 
; 82   : 	SetVector(&pos, (p0->v[X] + p2->v[X]) / 2, (p0->v[Y] + p2->v[Y]) / 2, (p0->v[Z] + p2->v[Z]) / 2);

	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	fdiv	DWORD PTR __real@40000000
	fstp	DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	fdiv	DWORD PTR __real@40000000
	fstp	DWORD PTR _pos$[ebp+4]
	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	fdiv	DWORD PTR __real@40000000
	fstp	DWORD PTR _pos$[ebp+8]

; 83   : 	header = PosToCollGrid(&pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ; PosToCollGrid
	add	esp, 4
	mov	DWORD PTR _header$[ebp], eax

; 84   : 	if (header == NULL) return;

	cmp	DWORD PTR _header$[ebp], 0
	jne	SHORT $L81133
	jmp	$L81082
$L81133:

; 85   : 
; 86   : 	for (i = 0 ; i < header->NCollPolys ; i++)

	mov	WORD PTR _i$[ebp], 0
	jmp	SHORT $L81134
$L81135:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$L81134:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jge	$L81082

; 87   : 	{
; 88   : 
; 89   : // get this poly
; 90   : 
; 91   : 		p = header->CollPolyPtr[i];

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _p$[ebp], eax

; 92   : 
; 93   : // skip?
; 94   : 
; 95   : 		if (p->Plane.v[B] > -0.1f) continue;

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@bdcccccd
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81137
	jmp	SHORT $L81135
$L81137:

; 96   : 		if (xmin > p->BBox.XMax || xmax < p->BBox.XMin || zmin > p->BBox.ZMax || zmax < p->BBox.ZMin || ymin > p->BBox.YMax || ymax < p->BBox.YMin) continue;

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _xmin$[ebp]
	fcomp	DWORD PTR [eax+92]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81139
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _xmax$[ebp]
	fcomp	DWORD PTR [eax+88]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81139
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _zmin$[ebp]
	fcomp	DWORD PTR [eax+108]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81139
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _zmax$[ebp]
	fcomp	DWORD PTR [eax+104]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81139
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _ymin$[ebp]
	fcomp	DWORD PTR [eax+100]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81139
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _ymax$[ebp]
	fcomp	DWORD PTR [eax+96]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81138
$L81139:
	jmp	$L81135
$L81138:

; 97   : 
; 98   : // get plane distances for each corner
; 99   : 
; 100  : 		dist0 = -PlaneDist(&p->Plane, p0);

	mov	eax, DWORD PTR _p0$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _p0$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _p0$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _dist0$[ebp]

; 101  : 		dist1 = -PlaneDist(&p->Plane, p1);

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _dist1$[ebp]

; 102  : 		dist2 = -PlaneDist(&p->Plane, p2);

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _p2$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _dist2$[ebp]

; 103  : 		dist3 = -PlaneDist(&p->Plane, p3);

	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _p3$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _p3$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _dist3$[ebp]

; 104  : 
; 105  : // skip if all points below plane
; 106  : 
; 107  : 		if (dist0 >= 0 && dist1 >= 0 && dist2 >= 0 && dist3 >= 0) continue;

	fld	DWORD PTR _dist0$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81140
	fld	DWORD PTR _dist1$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81140
	fld	DWORD PTR _dist2$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81140
	fld	DWORD PTR _dist3$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81140
	jmp	$L81135
$L81140:

; 108  : 
; 109  : // get intersection points
; 110  : 
; 111  : 		ldist0 = -PlaneDist(&p->Plane, &lp0);

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp0$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp0$[ebp+4]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp0$[ebp+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _ldist0$[ebp]

; 112  : 		ldist1 = -PlaneDist(&p->Plane, &lp1);

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp1$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp1$[ebp+4]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp1$[ebp+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _ldist1$[ebp]

; 113  : 		ldist2 = -PlaneDist(&p->Plane, &lp2);

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp2$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp2$[ebp+4]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp2$[ebp+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _ldist2$[ebp]

; 114  : 		ldist3 = -PlaneDist(&p->Plane, &lp3);

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp3$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp3$[ebp+4]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _lp3$[ebp+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fadd	DWORD PTR [eax+20]
	fchs
	fstp	DWORD PTR _ldist3$[ebp]

; 115  : 
; 116  : 		FindIntersection(&lp0, ldist0, p0, dist0, &ShadowVert[0].Pos);

	push	OFFSET FLAT:_ShadowVert
	mov	eax, DWORD PTR _dist0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p0$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ldist0$[ebp]
	push	edx
	lea	eax, DWORD PTR _lp0$[ebp]
	push	eax
	call	?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z ; FindIntersection
	add	esp, 20					; 00000014H

; 117  : 		FindIntersection(&lp1, ldist1, p1, dist1, &ShadowVert[1].Pos);

	push	OFFSET FLAT:_ShadowVert+20
	mov	eax, DWORD PTR _dist1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ldist1$[ebp]
	push	edx
	lea	eax, DWORD PTR _lp1$[ebp]
	push	eax
	call	?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z ; FindIntersection
	add	esp, 20					; 00000014H

; 118  : 		FindIntersection(&lp2, ldist2, p2, dist2, &ShadowVert[2].Pos);

	push	OFFSET FLAT:_ShadowVert+40
	mov	eax, DWORD PTR _dist2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ldist2$[ebp]
	push	edx
	lea	eax, DWORD PTR _lp2$[ebp]
	push	eax
	call	?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z ; FindIntersection
	add	esp, 20					; 00000014H

; 119  : 		FindIntersection(&lp3, ldist3, p3, dist3, &ShadowVert[3].Pos);

	push	OFFSET FLAT:_ShadowVert+60
	mov	eax, DWORD PTR _dist3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ldist3$[ebp]
	push	edx
	lea	eax, DWORD PTR _lp3$[ebp]
	push	eax
	call	?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z ; FindIntersection
	add	esp, 20					; 00000014H

; 120  : 
; 121  : // set uv's
; 122  : 
; 123  : 		ShadowVert[0].tu = tu;

	mov	eax, DWORD PTR _tu$[ebp]
	mov	DWORD PTR _ShadowVert+12, eax

; 124  : 		ShadowVert[0].tv = tv;

	mov	eax, DWORD PTR _tv$[ebp]
	mov	DWORD PTR _ShadowVert+16, eax

; 125  : 		ShadowVert[1].tu = tu + twidth;

	fld	DWORD PTR _tu$[ebp]
	fadd	DWORD PTR _twidth$[ebp]
	fstp	DWORD PTR _ShadowVert+32

; 126  : 		ShadowVert[1].tv = tv;

	mov	eax, DWORD PTR _tv$[ebp]
	mov	DWORD PTR _ShadowVert+36, eax

; 127  : 		ShadowVert[2].tu = tu + twidth;

	fld	DWORD PTR _tu$[ebp]
	fadd	DWORD PTR _twidth$[ebp]
	fstp	DWORD PTR _ShadowVert+52

; 128  : 		ShadowVert[2].tv = tv + theight;

	fld	DWORD PTR _tv$[ebp]
	fadd	DWORD PTR _theight$[ebp]
	fstp	DWORD PTR _ShadowVert+56

; 129  : 		ShadowVert[3].tu = tu;

	mov	eax, DWORD PTR _tu$[ebp]
	mov	DWORD PTR _ShadowVert+72, eax

; 130  : 		ShadowVert[3].tv = tv + theight;

	fld	DWORD PTR _tv$[ebp]
	fadd	DWORD PTR _theight$[ebp]
	fstp	DWORD PTR _ShadowVert+76

; 131  : 
; 132  : // init clip vars
; 133  : 
; 134  : 		ShadowVertNum = 4;

	mov	WORD PTR _ShadowVertNum, 4

; 135  : 		ShadowVertFree = 4;

	mov	WORD PTR _ShadowVertFree, 4

; 136  : 
; 137  : 		ShadowVertList[0][0] = 0;

	mov	WORD PTR _ShadowVertList, 0

; 138  : 		ShadowVertList[0][1] = 1;

	mov	WORD PTR _ShadowVertList+2, 1

; 139  : 		ShadowVertList[0][2] = 2;

	mov	WORD PTR _ShadowVertList+4, 2

; 140  : 		ShadowVertList[0][3] = 3;

	mov	WORD PTR _ShadowVertList+6, 3

; 141  : 
; 142  : // loop thru all edges of coll poly
; 143  : 
; 144  : 		vcount = 3 + (p->Type & QUAD);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	add	ecx, 3
	mov	WORD PTR _vcount$[ebp], cx

; 145  : 		togg = TRUE;

	mov	WORD PTR _togg$[ebp], 1

; 146  : 
; 147  : 		for (j = 0 ; j < vcount ; j++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L81141
$L81142:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$L81141:
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _vcount$[ebp]
	cmp	eax, ecx
	jge	$L81143

; 148  : 		{
; 149  : 			plane = &p->EdgePlane[j];

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _p$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24]
	mov	DWORD PTR _plane$[ebp], edx

; 150  : 
; 151  : // clip shadow poly against one edge
; 152  : 
; 153  : 			for (k = newcount = 0 ; k < ShadowVertNum ; k++)

	mov	WORD PTR _newcount$[ebp], 0
	mov	ax, WORD PTR _newcount$[ebp]
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $L81144
$L81145:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L81144:
	movsx	eax, WORD PTR _k$[ebp]
	movzx	ecx, WORD PTR _ShadowVertNum
	cmp	eax, ecx
	jge	$L81146

; 154  : 			{
; 155  : 				vert0 = ShadowVert + ShadowVertList[!togg][k];

	movsx	eax, WORD PTR _togg$[ebp]
	neg	eax
	sbb	eax, eax
	inc	eax
	shl	eax, 4
	movsx	ecx, WORD PTR _k$[ebp]
	movzx	edx, WORD PTR _ShadowVertList[eax+ecx*2]
	imul	edx, 20					; 00000014H
	add	edx, OFFSET FLAT:_ShadowVert
	mov	DWORD PTR _vert0$[ebp], edx

; 156  : 				vert1 = ShadowVert + ShadowVertList[!togg][(k + 1) % ShadowVertNum];

	movsx	ecx, WORD PTR _togg$[ebp]
	neg	ecx
	sbb	ecx, ecx
	inc	ecx
	shl	ecx, 4
	movsx	eax, WORD PTR _k$[ebp]
	add	eax, 1
	movzx	esi, WORD PTR _ShadowVertNum
	cdq
	idiv	esi
	movzx	edx, WORD PTR _ShadowVertList[ecx+edx*2]
	imul	edx, 20					; 00000014H
	add	edx, OFFSET FLAT:_ShadowVert
	mov	DWORD PTR _vert1$[ebp], edx

; 157  : 
; 158  : 				dist0 = PlaneDist(plane, &vert0->Pos);

	mov	eax, DWORD PTR _vert0$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vert0$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vert0$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _dist0$[ebp]

; 159  : 				if (dist0 <= 0)

	fld	DWORD PTR _dist0$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$L81147

; 160  : 				{
; 161  : 					ShadowVertList[togg][newcount++] = ShadowVertList[!togg][k];

	movsx	eax, WORD PTR _togg$[ebp]
	neg	eax
	sbb	eax, eax
	inc	eax
	shl	eax, 4
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _togg$[ebp]
	shl	edx, 4
	movsx	esi, WORD PTR _newcount$[ebp]
	mov	ax, WORD PTR _ShadowVertList[eax+ecx*2]
	mov	WORD PTR _ShadowVertList[edx+esi*2], ax
	mov	cx, WORD PTR _newcount$[ebp]
	add	cx, 1
	mov	WORD PTR _newcount$[ebp], cx

; 162  : 
; 163  : 					dist1 = PlaneDist(plane, &vert1->Pos);

	mov	eax, DWORD PTR _vert1$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vert1$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vert1$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _dist1$[ebp]

; 164  : 					if (dist1 > 0)

	fld	DWORD PTR _dist1$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81148

; 165  : 					{
; 166  : 						ClipShadowEdge(vert1, vert0, dist1 / (dist1 - dist0), ShadowVert + ShadowVertFree);

	movzx	eax, WORD PTR _ShadowVertFree
	imul	eax, 20					; 00000014H
	add	eax, OFFSET FLAT:_ShadowVert
	push	eax
	fld	DWORD PTR _dist1$[ebp]
	fsub	DWORD PTR _dist0$[ebp]
	fdivr	DWORD PTR _dist1$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _vert0$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vert1$[ebp]
	push	edx
	call	?ClipShadowEdge@@YAXPAUSHADOW_VERT@@0M0@Z ; ClipShadowEdge
	add	esp, 16					; 00000010H

; 167  : 						ShadowVertList[togg][newcount++] = ShadowVertFree++;

	movsx	eax, WORD PTR _togg$[ebp]
	shl	eax, 4
	movsx	ecx, WORD PTR _newcount$[ebp]
	mov	dx, WORD PTR _ShadowVertFree
	mov	WORD PTR _ShadowVertList[eax+ecx*2], dx
	mov	ax, WORD PTR _newcount$[ebp]
	add	ax, 1
	mov	WORD PTR _newcount$[ebp], ax
	mov	cx, WORD PTR _ShadowVertFree
	add	cx, 1
	mov	WORD PTR _ShadowVertFree, cx
$L81148:

; 168  : 					}
; 169  : 				}
; 170  : 				else

	jmp	$L81149
$L81147:

; 171  : 				{
; 172  : 					dist1 = PlaneDist(plane, &vert1->Pos);

	mov	eax, DWORD PTR _vert1$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vert1$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vert1$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _dist1$[ebp]

; 173  : 					if (dist1 <= 0)

	fld	DWORD PTR _dist1$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L81149

; 174  : 					{
; 175  : 						ClipShadowEdge(vert0, vert1, dist0 / (dist0 - dist1), ShadowVert + ShadowVertFree);

	movzx	eax, WORD PTR _ShadowVertFree
	imul	eax, 20					; 00000014H
	add	eax, OFFSET FLAT:_ShadowVert
	push	eax
	fld	DWORD PTR _dist0$[ebp]
	fsub	DWORD PTR _dist1$[ebp]
	fdivr	DWORD PTR _dist0$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _vert1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vert0$[ebp]
	push	edx
	call	?ClipShadowEdge@@YAXPAUSHADOW_VERT@@0M0@Z ; ClipShadowEdge
	add	esp, 16					; 00000010H

; 176  : 						ShadowVertList[togg][newcount++] = ShadowVertFree++;

	movsx	eax, WORD PTR _togg$[ebp]
	shl	eax, 4
	movsx	ecx, WORD PTR _newcount$[ebp]
	mov	dx, WORD PTR _ShadowVertFree
	mov	WORD PTR _ShadowVertList[eax+ecx*2], dx
	mov	ax, WORD PTR _newcount$[ebp]
	add	ax, 1
	mov	WORD PTR _newcount$[ebp], ax
	mov	cx, WORD PTR _ShadowVertFree
	add	cx, 1
	mov	WORD PTR _ShadowVertFree, cx
$L81149:

; 177  : 					}
; 178  : 				}
; 179  : 			}

	jmp	$L81145
$L81146:

; 180  : 			ShadowVertNum = newcount;

	mov	ax, WORD PTR _newcount$[ebp]
	mov	WORD PTR _ShadowVertNum, ax

; 181  : 			togg = !togg;

	movsx	eax, WORD PTR _togg$[ebp]
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	WORD PTR _togg$[ebp], ax

; 182  : 		}

	jmp	$L81142
$L81143:

; 183  : 
; 184  : // process verts
; 185  : 
; 186  : 		for (j = 0 ; j < ShadowVertNum ; j++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L81151
$L81152:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$L81151:
	movsx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _ShadowVertNum
	cmp	eax, ecx
	jge	$L81153

; 187  : 		{
; 188  : 			svert = &ShadowVert[ShadowVertList[!togg][j]];

	movsx	eax, WORD PTR _togg$[ebp]
	neg	eax
	sbb	eax, eax
	inc	eax
	shl	eax, 4
	movsx	ecx, WORD PTR _j$[ebp]
	movzx	edx, WORD PTR _ShadowVertList[eax+ecx*2]
	imul	edx, 20					; 00000014H
	add	edx, OFFSET FLAT:_ShadowVert
	mov	DWORD PTR _svert$[ebp], edx

; 189  : 
; 190  : // update bounding box
; 191  : 
; 192  : 			if (box)

	cmp	DWORD PTR _box$[ebp], 0
	je	$L81154

; 193  : 			{
; 194  : 				if (svert->Pos.v[X] < box->Xmin) box->Xmin = svert->Pos.v[X];

	mov	eax, DWORD PTR _svert$[ebp]
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81155
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$L81155:

; 195  : 				if (svert->Pos.v[X] > box->Xmax) box->Xmax = svert->Pos.v[X];

	mov	eax, DWORD PTR _svert$[ebp]
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81156
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
$L81156:

; 196  : 				if (svert->Pos.v[Y] < box->Ymin) box->Ymin = svert->Pos.v[Y];

	mov	eax, DWORD PTR _svert$[ebp]
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81157
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
$L81157:

; 197  : 				if (svert->Pos.v[Y] > box->Ymax) box->Ymax = svert->Pos.v[Y];

	mov	eax, DWORD PTR _svert$[ebp]
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81158
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx
$L81158:

; 198  : 				if (svert->Pos.v[Z] < box->Zmin) box->Zmin = svert->Pos.v[Z];

	mov	eax, DWORD PTR _svert$[ebp]
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81159
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+16], edx
$L81159:

; 199  : 				if (svert->Pos.v[Z] > box->Zmax) box->Zmax = svert->Pos.v[Z];

	mov	eax, DWORD PTR _svert$[ebp]
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR [ecx+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81154
	mov	eax, DWORD PTR _box$[ebp]
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+20], edx
$L81154:

; 200  : 			}
; 201  : 
; 202  : // transform
; 203  : 
; 204  : 			svert->Pos.v[Y] += yoff;

	mov	eax, DWORD PTR _svert$[ebp]
	fld	DWORD PTR _yoff$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _svert$[ebp]
	fstp	DWORD PTR [ecx+4]

; 205  : 
; 206  : 			RotTransPersVector(&ViewMatrixScaled, &ViewTransScaled, &svert->Pos, &ShadowDrawVert[j].sx);

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	add	eax, OFFSET FLAT:_ShadowDrawVert
	push	eax
	mov	ecx, DWORD PTR _svert$[ebp]
	push	ecx
	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
	add	esp, 16					; 00000010H

; 207  : 			ShadowDrawVert[j].tu = svert->tu;

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ShadowDrawVert[eax+24], edx

; 208  : 			ShadowDrawVert[j].tv = svert->tv;

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _svert$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _ShadowDrawVert[eax+28], edx

; 209  : 			ShadowDrawVert[j].color = rgb;

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR _ShadowDrawVert[eax+16], ecx

; 210  : 
; 211  : 		}

	jmp	$L81152
$L81153:

; 212  : 
; 213  : // draw fan
; 214  : 
; 215  : 		if (semi == -1)

	cmp	DWORD PTR _semi$[ebp], -1
	jne	SHORT $L81161

; 216  : 		{
; 217  : 			D3Ddevice->DrawPrimitive(D3DPT_TRIANGLEFAN, FVF_TEX1, ShadowDrawVert, ShadowVertNum, D3DDP_DONOTUPDATEEXTENTS);

	push	8
	movzx	eax, WORD PTR _ShadowVertNum
	push	eax
	push	OFFSET FLAT:_ShadowDrawVert
	push	452					; 000001c4H
	push	6
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+112]

; 218  : 		}
; 219  : 		else

	jmp	$L81162
$L81161:

; 220  : 		{
; 221  : 			for (j = 0 ; j < ShadowVertNum - 2 ; j++)

	mov	WORD PTR _j$[ebp], 0
	jmp	SHORT $L81163
$L81164:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$L81163:
	movsx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _ShadowVertNum
	sub	ecx, 2
	cmp	eax, ecx
	jge	$L81162

; 222  : 			{
; 223  : 				if (!SEMI_POLY_FREE()) continue;

	cmp	DWORD PTR ?SemiCount@@3JA, 800		; SemiCount, 00000320H
	jl	SHORT $L81166
	jmp	SHORT $L81164
$L81166:

; 224  : 				SEMI_POLY_SETUP_ZBIAS(vert, FALSE, 3, tpage, TRUE, semi, -256.0f);

	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+12], 0
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+4], 3
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	ecx, DWORD PTR _tpage$[ebp]
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+8], ecx
	mov	eax, 1
	test	eax, eax
	je	SHORT $L81167
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax], 8
	jmp	SHORT $L81168
$L81167:
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax], 12 ; 0000000cH
$L81168:
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	ecx, DWORD PTR _semi$[ebp]
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+16], ecx
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	mov	DWORD PTR ?SemiPoly@@3PAUDRAW_SEMI_POLY@@A[eax+20], -1015021568 ; c3800000H
	mov	eax, DWORD PTR ?SemiCount@@3JA		; SemiCount
	imul	eax, 152				; 00000098H
	add	eax, OFFSET FLAT:?SemiPoly@@3PAUDRAW_SEMI_POLY@@A+24
	mov	DWORD PTR _vert$[ebp], eax
	mov	ecx, DWORD PTR ?SemiCount@@3JA		; SemiCount
	add	ecx, 1
	mov	DWORD PTR ?SemiCount@@3JA, ecx		; SemiCount

; 225  : 
; 226  : 				*(MEM32*)&vert[0] = *(MEM32*)&ShadowDrawVert[0];

	mov	ecx, 8
	mov	esi, OFFSET FLAT:_ShadowDrawVert
	mov	edi, DWORD PTR _vert$[ebp]
	rep movsd

; 227  : 				*(MEM32*)&vert[1] = *(MEM32*)&ShadowDrawVert[j + 1];

	movsx	esi, WORD PTR _j$[ebp]
	add	esi, 1
	shl	esi, 5
	add	esi, OFFSET FLAT:_ShadowDrawVert
	mov	edi, DWORD PTR _vert$[ebp]
	add	edi, 32					; 00000020H
	mov	ecx, 8
	rep movsd

; 228  : 				*(MEM32*)&vert[2] = *(MEM32*)&ShadowDrawVert[j + 2];

	movsx	esi, WORD PTR _j$[ebp]
	add	esi, 2
	shl	esi, 5
	add	esi, OFFSET FLAT:_ShadowDrawVert
	mov	edi, DWORD PTR _vert$[ebp]
	add	edi, 64					; 00000040H
	mov	ecx, 8
	rep movsd

; 229  : 			}

	jmp	$L81164
$L81162:

; 230  : 		}
; 231  : 	}

	jmp	$L81135
$L81082:

; 232  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawShadow@@YAXPAUVectorStruct@@000MMMMJMMJJPAUBoundingBoxStruct@@@Z ENDP ; DrawShadow
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ClipShadowEdge@@YAXPAUSHADOW_VERT@@0M0@Z
_TEXT	SEGMENT
_sv0$ = 8						; size = 4
_sv1$ = 12						; size = 4
_mul$ = 16						; size = 4
_svout$ = 20						; size = 4
?ClipShadowEdge@@YAXPAUSHADOW_VERT@@0M0@Z PROC NEAR	; ClipShadowEdge, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 240  : 	svout->Pos.v[X] = sv0->Pos.v[X] + (sv1->Pos.v[X] - sv0->Pos.v[X]) * mul;

	mov	eax, DWORD PTR _sv1$[ebp]
	mov	ecx, DWORD PTR _sv0$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fmul	DWORD PTR _mul$[ebp]
	mov	edx, DWORD PTR _sv0$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _svout$[ebp]
	fstp	DWORD PTR [eax]

; 241  : 	svout->Pos.v[Y] = sv0->Pos.v[Y] + (sv1->Pos.v[Y] - sv0->Pos.v[Y]) * mul;

	mov	eax, DWORD PTR _sv1$[ebp]
	mov	ecx, DWORD PTR _sv0$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fmul	DWORD PTR _mul$[ebp]
	mov	edx, DWORD PTR _sv0$[ebp]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _svout$[ebp]
	fstp	DWORD PTR [eax+4]

; 242  : 	svout->Pos.v[Z] = sv0->Pos.v[Z] + (sv1->Pos.v[Z] - sv0->Pos.v[Z]) * mul;

	mov	eax, DWORD PTR _sv1$[ebp]
	mov	ecx, DWORD PTR _sv0$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fmul	DWORD PTR _mul$[ebp]
	mov	edx, DWORD PTR _sv0$[ebp]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _svout$[ebp]
	fstp	DWORD PTR [eax+8]

; 243  : 
; 244  : 	svout->tu = sv0->tu + (sv1->tu - sv0->tu) * mul;

	mov	eax, DWORD PTR _sv1$[ebp]
	mov	ecx, DWORD PTR _sv0$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+12]
	fmul	DWORD PTR _mul$[ebp]
	mov	edx, DWORD PTR _sv0$[ebp]
	fadd	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _svout$[ebp]
	fstp	DWORD PTR [eax+12]

; 245  : 	svout->tv = sv0->tv + (sv1->tv - sv0->tv) * mul;

	mov	eax, DWORD PTR _sv1$[ebp]
	mov	ecx, DWORD PTR _sv0$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+16]
	fmul	DWORD PTR _mul$[ebp]
	mov	edx, DWORD PTR _sv0$[ebp]
	fadd	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _svout$[ebp]
	fstp	DWORD PTR [eax+16]

; 246  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClipShadowEdge@@YAXPAUSHADOW_VERT@@0M0@Z ENDP		; ClipShadowEdge
_TEXT	ENDS
END
