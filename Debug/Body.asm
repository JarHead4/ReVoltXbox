; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Body.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyBodyImpulse@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateBody@@YAXPAUNewBodyStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyPointVel@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupMassiveBody@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBodyInertia@@YAXPAUNewBodyStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFrameInertia@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildTwoBodyColMat@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@111PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OneBodyZeroFrictionImpulse@@YAMPAUNewBodyStruct@@PAUVectorStruct@@1M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TwoBodyZeroFrictionImpulse@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@11M1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreProcessBodyColls@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildCollisionEquations@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildCollisionEquations2@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBodyFriction@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PAUBodyCollInfoStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectBodyWorldColls@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectConvexHullPolyColls@@YAHPAUNewBodyStruct@@PAUCollPolyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTurboBoost@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostProcessBodyColls@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?DEBUG_NIts@@3HA				; DEBUG_NIts
PUBLIC	?DEBUG_Converged@@3_NA				; DEBUG_Converged
PUBLIC	?DEBUG_Res@@3MA					; DEBUG_Res
PUBLIC	?BDY_MassiveBody@@3UNewBodyStruct@@A		; BDY_MassiveBody
PUBLIC	?NThisBodySparks@@3HA				; NThisBodySparks
PUBLIC	?NThisBodySmoke@@3HA				; NThisBodySmoke
PUBLIC	?DEBUG_MaxImpulseMag@@3MA			; DEBUG_MaxImpulseMag
PUBLIC	?DEBUG_MaxAngImpulseMag@@3MA			; DEBUG_MaxAngImpulseMag
_BSS	SEGMENT
?DEBUG_NIts@@3HA DD 01H DUP (?)				; DEBUG_NIts
?DEBUG_Res@@3MA DD 01H DUP (?)				; DEBUG_Res
?BDY_MassiveBody@@3UNewBodyStruct@@A DB 0238H DUP (?)	; BDY_MassiveBody
?NThisBodySparks@@3HA DD 01H DUP (?)			; NThisBodySparks
?NThisBodySmoke@@3HA DD 01H DUP (?)			; NThisBodySmoke
?DEBUG_MaxImpulseMag@@3MA DD 01H DUP (?)		; DEBUG_MaxImpulseMag
?DEBUG_MaxAngImpulseMag@@3MA DD 01H DUP (?)		; DEBUG_MaxAngImpulseMag
_BSS	ENDS
_DATA	SEGMENT
?DEBUG_Converged@@3_NA DB 01H				; DEBUG_Converged
_DATA	ENDS
PUBLIC	?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z	; InitBodyDefault
EXTRN	__fltused:NEAR
EXTRN	?SetMatUnit@@YAXPATMatrixUnion@@@Z:NEAR		; SetMatUnit
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\body.cpp
;	COMDAT ?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_body$ = 8						; size = 4
?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z PROC NEAR	; InitBodyDefault, COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 58   : 	body->Centre.Mass = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax], 0

; 59   : 	body->Centre.InvMass = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+4], 0

; 60   : 
; 61   : 	body->Centre.Hardness = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+172], 0

; 62   : 	body->Centre.Resistance = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+176], 0

; 63   : 	body->Centre.Grip = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+180], 0

; 64   : 	body->Centre.StaticFriction = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+184], 0

; 65   : 	body->Centre.KineticFriction =ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+188], 0

; 66   : 	body->Centre.Gravity = Real(2000);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+192], 1157234688		; 44fa0000H

; 67   : 
; 68   : 	SetMatUnit(&body->BodyInertia);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	?SetMatUnit@@YAXPATMatrixUnion@@@Z	; SetMatUnit
	add	esp, 4

; 69   : 	SetMatUnit(&body->BodyInvInertia);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?SetMatUnit@@YAXPATMatrixUnion@@@Z	; SetMatUnit
	add	esp, 4

; 70   : 
; 71   : 	SetBodyConvex(body);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+472], 0

; 72   : 	body->CollSkin.Convex = NULL;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+380], 0

; 73   : 	body->CollSkin.WorldConvex = NULL;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+384], 0

; 74   : 	body->CollSkin.OldWorldConvex = NULL;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+388], 0

; 75   : 	body->CollSkin.Sphere = NULL;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+396], 0

; 76   : 	body->CollSkin.WorldSphere = NULL;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+400], 0

; 77   : 	body->CollSkin.OldWorldSphere = NULL;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+404], 0

; 78   : 	body->CollSkin.CollPoly = NULL;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+412], 0

; 79   : 	body->CollSkin.NConvex = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	WORD PTR [eax+392], 0

; 80   : 	body->CollSkin.NSpheres = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	WORD PTR [eax+408], 0

; 81   : 	body->CollSkin.NCollPolys = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	WORD PTR [eax+416], 0

; 82   : 	body->CollSkin.AllowWorldColls = TRUE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+476], 1

; 83   : 	body->CollSkin.AllowObjColls = TRUE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+477], 1

; 84   : 	SetBBox(&body->CollSkin.TightBBox, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+420], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+424], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+428], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+432], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+436], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+440], 0

; 85   : 
; 86   : 	body->DefaultAngRes = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+368], 0

; 87   : 	body->AngResMod = ONE;	

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+372], 1065353216		; 3f800000H

; 88   : 	body->AngResistance = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+376], 0

; 89   : 
; 90   : 	body->AllowSparks = FALSE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+532], 0

; 91   : 	body->ScrapeMaterial = MATERIAL_NONE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+536], -1

; 92   : 
; 93   : 	body->Banged = FALSE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+544], 0

; 94   : 	body->BangMag = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+548], 0

; 95   : 	SetPlane(&body->BangPlane, ZERO, -ONE, ZERO, ZERO);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+552], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+556], -1082130432	; bf800000H
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+560], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+564], 0

; 96   : 
; 97   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z ENDP		; InitBodyDefault
_TEXT	ENDS
PUBLIC	?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; SetBodyPos
PUBLIC	?GetFrameInertia@@YAXPATMatrixUnion@@00@Z	; GetFrameInertia
EXTRN	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; BuildWorldSkin
EXTRN	?CopyMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; CopyMatrix
EXTRN	?CopyMat@@YAXPATMatrixUnion@@0@Z:NEAR		; CopyMat
EXTRN	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z:NEAR ; MatToQuat
; Function compile flags: /Odt /ZI
;	COMDAT ?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
_body$ = 8						; size = 4
_pos$ = 12						; size = 4
_mat$ = 16						; size = 4
?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z PROC NEAR ; SetBodyPos, COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 108  : 
; 109  : 	// Set orientation and position
; 110  : 	CopyVec(pos, &body->Centre.Pos);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+28], edx

; 111  : 	CopyVec(&body->Centre.Pos, &body->Centre.OldPos);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+16], edx

; 112  : 	CopyMatrix(mat, &body->Centre.WMatrix);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 113  : 	CopyMat(&body->Centre.WMatrix, &body->Centre.OldWMatrix);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 114  : 	MatToQuat(&body->Centre.WMatrix, &body->Centre.Quat);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z ; MatToQuat
	add	esp, 8

; 115  : 	CopyQuat(&body->Centre.Quat, &body->Centre.OldQuat);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+88], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+92], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+96], edx

; 116  : 
; 117  : 	// Reset Velocities etc
; 118  : 	SetVecZero(&body->Centre.Vel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+40], 0

; 119  : 	SetVecZero(&body->Centre.Impulse);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+60], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+64], 0

; 120  : 	SetVecZero(&body->Centre.LastVel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+212], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+216], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+220], 0

; 121  : 	SetVecZero(&body->AngVel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+332], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+336], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+340], 0

; 122  : 	SetVecZero(&body->LastAngVel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+480], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+484], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+488], 0

; 123  : 	SetVecZero(&body->AngImpulse);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+356], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+360], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+364], 0

; 124  : 	SetVecZero(&body->Centre.Shift);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+200], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+204], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+208], 0

; 125  : 
; 126  : 	// Set the inverse inertia in the world frame
; 127  : 	GetFrameInertia(&body->BodyInvInertia, &body->Centre.WMatrix, &body->WorldInvInertia);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 296				; 00000128H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 260				; 00000104H
	push	edx
	call	?GetFrameInertia@@YAXPATMatrixUnion@@00@Z ; GetFrameInertia
	add	esp, 12					; 0000000cH

; 128  : 	BuildWorldSkin(&body->CollSkin, &body->Centre.Pos, &body->Centre.WMatrix);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	call	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
	add	esp, 12					; 0000000cH

; 129  : 
; 130  : 	// Jitter stuff
; 131  : 	body->IsJittering = FALSE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+492], 0

; 132  : 	body->JitterCount = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+496], 0

; 133  : 	body->JitterFrames = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+504], 0

; 134  : 
; 135  : 	// Misc
; 136  : 	body->NoContactTime = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+528], 0

; 137  : 	body->Centre.Boost = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+196], 0

; 138  : 	body->LastScrapeTime = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+540], 0

; 139  : 	body->ScrapeMaterial = MATERIAL_NONE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+536], -1

; 140  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ENDP ; SetBodyPos
_TEXT	ENDS
PUBLIC	?ApplyBodyImpulse@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z ; ApplyBodyImpulse
EXTRN	?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z:NEAR ; ApplyParticleImpulse
; Function compile flags: /Odt /ZI
;	COMDAT ?ApplyBodyImpulse@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT
_angImpulse$ = -12					; size = 12
_body$ = 8						; size = 4
_impulse$ = 12						; size = 4
_impPos$ = 16						; size = 4
?ApplyBodyImpulse@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z PROC NEAR ; ApplyBodyImpulse, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 151  : 	VEC angImpulse;
; 152  : 
; 153  : 	// Apply the linear impulse to the centre of mass
; 154  : 	ApplyParticleImpulse(&body->Centre, impulse);

	mov	eax, DWORD PTR _impulse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z ; ApplyParticleImpulse
	add	esp, 8

; 155  : 
; 156  : 	// Calculate the angular impulse and add it to the body
; 157  : 	CalcAngImpulse(impulse, impPos, &angImpulse);

	mov	eax, DWORD PTR _impPos$[ebp]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _impPos$[ebp]
	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _angImpulse$[ebp]
	mov	eax, DWORD PTR _impPos$[ebp]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _impPos$[ebp]
	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _angImpulse$[ebp+4]
	mov	eax, DWORD PTR _impPos$[ebp]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _impPos$[ebp]
	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _angImpulse$[ebp+8]

; 158  : 	ApplyBodyAngImpulse(body, &angImpulse);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _angImpulse$[ebp]
	fadd	DWORD PTR [eax+356]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+356]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _angImpulse$[ebp+4]
	fadd	DWORD PTR [eax+360]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _angImpulse$[ebp+8]
	fadd	DWORD PTR [eax+364]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+364]

; 159  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ApplyBodyImpulse@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z ENDP ; ApplyBodyImpulse
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	__real@3f000000
PUBLIC	__real@42f00000
PUBLIC	__real@3f800000
PUBLIC	__real@3727c5ac
PUBLIC	__real@00000000
PUBLIC	?UpdateBody@@YAXPAUNewBodyStruct@@M@Z		; UpdateBody
EXTRN	?UpdateParticle@@YAXPAUParticleStruct@@M@Z:NEAR	; UpdateParticle
EXTRN	?DEBUG_Impulse@@3UVectorStruct@@A:BYTE		; DEBUG_Impulse
EXTRN	?DEBUG_AngImpulse@@3UVectorStruct@@A:BYTE	; DEBUG_AngImpulse
EXTRN	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z:NEAR ; MatMulVec
EXTRN	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z:NEAR ; QuatToMat
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateBody@@YAXPAUNewBodyStruct@@M@Z
_TEXT	SEGMENT
_qLen$76760 = -36					; size = 4
_impMag$ = -32						; size = 4
_tmpQuat$ = -28						; size = 16
_tmpSphere$ = -12					; size = 4
_tmpConvex$ = -8					; size = 4
_scale$ = -4						; size = 4
_body$ = 8						; size = 4
_dt$ = 12						; size = 4
?UpdateBody@@YAXPAUNewBodyStruct@@M@Z PROC NEAR		; UpdateBody, COMDAT

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 171  : 	REAL		scale;
; 172  : 	CONVEX		*tmpConvex;
; 173  : 	SPHERE		*tmpSphere;
; 174  : 	QUATERNION	tmpQuat;
; 175  : 
; 176  : 	// DEBUGGING
; 177  : #if USE_DEBUG_ROUTINES
; 178  : 	
; 179  : 	REAL impMag;
; 180  : 	impMag = VecLen(&body->Centre.Impulse);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+60]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR [edx+64]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _impMag$[ebp]

; 181  : 	if (impMag > DEBUG_MaxImpulseMag) DEBUG_MaxImpulseMag = impMag;

	fld	DWORD PTR _impMag$[ebp]
	fcomp	DWORD PTR ?DEBUG_MaxImpulseMag@@3MA	; DEBUG_MaxImpulseMag
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76755
	mov	eax, DWORD PTR _impMag$[ebp]
	mov	DWORD PTR ?DEBUG_MaxImpulseMag@@3MA, eax
$L76755:

; 182  : 	impMag = VecLen(&body->AngImpulse);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+356]
	fmul	DWORD PTR [ecx+356]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+360]
	fmul	DWORD PTR [eax+360]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+364]
	fmul	DWORD PTR [edx+364]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _impMag$[ebp]

; 183  : 	if (impMag > DEBUG_MaxAngImpulseMag) DEBUG_MaxAngImpulseMag = impMag;

	fld	DWORD PTR _impMag$[ebp]
	fcomp	DWORD PTR ?DEBUG_MaxAngImpulseMag@@3MA	; DEBUG_MaxAngImpulseMag
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76757
	mov	eax, DWORD PTR _impMag$[ebp]
	mov	DWORD PTR ?DEBUG_MaxAngImpulseMag@@3MA, eax
$L76757:

; 184  : 
; 185  : 	CopyVec(&body->Centre.Impulse, &DEBUG_Impulse);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR ?DEBUG_Impulse@@3UVectorStruct@@A, ecx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR ?DEBUG_Impulse@@3UVectorStruct@@A+4, ecx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR ?DEBUG_Impulse@@3UVectorStruct@@A+8, ecx

; 186  : 	CopyVec(&body->AngImpulse, &DEBUG_AngImpulse);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR ?DEBUG_AngImpulse@@3UVectorStruct@@A, ecx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	mov	DWORD PTR ?DEBUG_AngImpulse@@3UVectorStruct@@A+4, ecx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+364]
	mov	DWORD PTR ?DEBUG_AngImpulse@@3UVectorStruct@@A+8, ecx

; 187  : 
; 188  : #endif
; 189  : 
; 190  : 	// Store last frames angular velocity
; 191  : 	CopyVec(&body->AngVel, &body->LastAngVel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+480], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	mov	DWORD PTR [eax+484], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+340]
	mov	DWORD PTR [eax+488], edx

; 192  : 
; 193  : 	// If object is jittering, reduce angular impulse
; 194  : #if REMOVE_JITTER
; 195  : 	if (body->IsJittering) {

	mov	eax, DWORD PTR _body$[ebp]
	movzx	ecx, BYTE PTR [eax+492]
	test	ecx, ecx
	je	SHORT $L76758

; 196  : 		VecMulScalar(&body->AngImpulse, HALF);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+356]
	fmul	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+356]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+360]
	fmul	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+364]
	fmul	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+364]
$L76758:

; 197  : 	}
; 198  : #endif
; 199  : 
; 200  : 	// Update the linear position, velocity etc.
; 201  : 	UpdateParticle(&body->Centre, dt);

	mov	eax, DWORD PTR _dt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?UpdateParticle@@YAXPAUParticleStruct@@M@Z ; UpdateParticle
	add	esp, 8

; 202  : 
; 203  : 	// Calculate the angular acceleration from the impulse (actually acceleration * dt)
; 204  : 	MatMulVec(&body->WorldInvInertia, &body->AngImpulse, &body->AngAcc);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 344				; 00000158H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 356				; 00000164H
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; MatMulVec
	add	esp, 12					; 0000000cH

; 205  : 
; 206  : 	// Update the body angular velocity
; 207  : 	VecPlusEqVec(&body->AngVel, &body->AngAcc);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+332]
	fadd	DWORD PTR [ecx+344]
	mov	edx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [edx+332]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+336]
	fadd	DWORD PTR [ecx+348]
	mov	edx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [edx+336]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+340]
	fadd	DWORD PTR [ecx+352]
	mov	edx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [edx+340]

; 208  : 
; 209  : 	// Damp the angular velocity from air resistance
; 210  : 	scale = MulScalar(body->AngResistance, MulScalar(dt, FRICTION_TIME_SCALE));

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+376]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR __real@42f00000
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _scale$[ebp]

; 211  : 	VecMulScalar(&body->AngVel, ONE - scale);

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [eax+332]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+332]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [eax+336]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+336]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [eax+340]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+340]

; 212  : 
; 213  : 	// Calculate change in quaternion this frame
; 214  : 	VecMulQuat(&body->AngVel, &body->Centre.Quat, &tmpQuat);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+76]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+72]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpQuat$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+68]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+76]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpQuat$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+68]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpQuat$[ebp+8]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+332]
	fchs
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+72]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+76]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpQuat$[ebp+12]

; 215  : 	scale = MulScalar(HALF, dt);

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dt$[ebp]
	fstp	DWORD PTR _scale$[ebp]

; 216  : 	QuatPlusEqScalarQuat(&body->Centre.Quat, scale, &tmpQuat);

	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _tmpQuat$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+68]
	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _tmpQuat$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+72]
	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _tmpQuat$[ebp+8]
	mov	eax, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+76]
	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _tmpQuat$[ebp+12]
	mov	eax, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+80]

; 217  : 	NormalizeQuat(&body->Centre.Quat);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+76]
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+80]
	fmul	DWORD PTR [ecx+80]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$76760[ebp]
	fld	DWORD PTR _qLen$76760[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76762
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$76760[ebp]
	fstp	DWORD PTR _qLen$76760[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _qLen$76760[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _qLen$76760[ebp]
	fmul	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _qLen$76760[ebp]
	fmul	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _qLen$76760[ebp]
	fmul	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+80]
$L76762:

; 218  : 	QuatToMat(&body->Centre.Quat, &body->Centre.WMatrix);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	call	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z ; QuatToMat
	add	esp, 8

; 219  : 
; 220  : 	// Set the inverse inertia in the world frame
; 221  : 	GetFrameInertia(&body->BodyInvInertia, &body->Centre.WMatrix, &body->WorldInvInertia);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 296				; 00000128H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 260				; 00000104H
	push	edx
	call	?GetFrameInertia@@YAXPATMatrixUnion@@00@Z ; GetFrameInertia
	add	esp, 12					; 0000000cH

; 222  : 
; 223  : 	// Set up the world collision skins
; 224  : 	tmpConvex = body->CollSkin.WorldConvex;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _tmpConvex$[ebp], ecx

; 225  : 	body->CollSkin.WorldConvex = body->CollSkin.OldWorldConvex;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR [eax+384], edx

; 226  : 	body->CollSkin.OldWorldConvex = tmpConvex;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _tmpConvex$[ebp]
	mov	DWORD PTR [eax+388], ecx

; 227  : 	tmpSphere = body->CollSkin.WorldSphere;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR _tmpSphere$[ebp], ecx

; 228  : 	body->CollSkin.WorldSphere = body->CollSkin.OldWorldSphere;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+404]
	mov	DWORD PTR [eax+400], edx

; 229  : 	body->CollSkin.OldWorldSphere = tmpSphere;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _tmpSphere$[ebp]
	mov	DWORD PTR [eax+404], ecx

; 230  : 	BuildWorldSkin(&body->CollSkin, &body->Centre.Pos, &body->Centre.WMatrix);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	call	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 	// Stuff for removing jitter
; 233  : #if REMOVE_JITTER
; 234  : 	body->JitterFrames++;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+504]
	add	ecx, 1
	mov	edx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [edx+504], ecx

; 235  : 	if (VecDotVec(&body->AngVel, &body->LastAngVel) < ZERO) {

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+480]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+484]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+488]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76763

; 236  : 		if (body->JitterFrames < body->JitterFramesMax) {

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [eax+504]
	cmp	edx, DWORD PTR [ecx+508]
	jge	SHORT $L76764

; 237  : 			body->JitterCount++;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+496]
	add	ecx, 1
	mov	edx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [edx+496], ecx

; 238  : 		} else {

	jmp	SHORT $L76765
$L76764:

; 239  : 			body->JitterCount = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+496], 0

; 240  : 			body->IsJittering = FALSE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+492], 0
$L76765:

; 241  : 		}
; 242  : 		body->JitterFrames = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+504], 0

; 243  : 
; 244  : 		if (body->JitterCount > body->JitterCountMax) {

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [eax+496]
	cmp	edx, DWORD PTR [ecx+500]
	jle	SHORT $L76766

; 245  : 			body->IsJittering = TRUE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+492], 1
$L76766:

; 246  : 		}
; 247  : 	} else if (body->IsJittering) {

	jmp	SHORT $L76767
$L76763:
	mov	eax, DWORD PTR _body$[ebp]
	movzx	ecx, BYTE PTR [eax+492]
	test	ecx, ecx
	je	SHORT $L76767

; 248  : 		if (body->JitterFrames > body->JitterFramesMax) {

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [eax+504]
	cmp	edx, DWORD PTR [ecx+508]
	jle	SHORT $L76767

; 249  : 			body->IsJittering = FALSE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+492], 0
$L76767:

; 250  : 		}
; 251  : 	}
; 252  : #endif
; 253  : 
; 254  : 	// Count time that body has been out of contact with the world
; 255  : 	if (body->NWorldContacts == 0) {

	mov	eax, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [eax+520], 0
	jne	SHORT $L76770

; 256  : 		body->NoContactTime += dt;

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _dt$[ebp]
	fadd	DWORD PTR [eax+528]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+528]

; 257  : 	} else {

	jmp	SHORT $L76771
$L76770:

; 258  : 		body->NoContactTime = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+528], 0
$L76771:

; 259  : 	}
; 260  : 
; 261  : 	// Zero the impulse for next time
; 262  : 	SetVecZero(&body->AngImpulse);

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+356], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+360], 0
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+364], 0

; 263  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateBody@@YAXPAUNewBodyStruct@@M@Z ENDP		; UpdateBody
_TEXT	ENDS
PUBLIC	?BodyPointVel@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z ; BodyPointVel
; Function compile flags: /Odt /ZI
;	COMDAT ?BodyPointVel@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT
_body$ = 8						; size = 4
_dR$ = 12						; size = 4
_vel$ = 16						; size = 4
?BodyPointVel@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z PROC NEAR ; BodyPointVel, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 274  : 	VecCrossVec(&body->AngVel, dR, vel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vel$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vel$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vel$[ebp]
	fstp	DWORD PTR [ecx+8]

; 275  : 	VecPlusEqVec(vel, &body->Centre.Vel);

	mov	eax, DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _vel$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _vel$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _vel$[ebp]
	fstp	DWORD PTR [edx+8]

; 276  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BodyPointVel@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1@Z ENDP ; BodyPointVel
_TEXT	ENDS
PUBLIC	?SetupMassiveBody@@YAXXZ			; SetupMassiveBody
EXTRN	?SetMatZero@@YAXPATMatrixUnion@@@Z:NEAR		; SetMatZero
; Function compile flags: /Odt /ZI
;	COMDAT ?SetupMassiveBody@@YAXXZ
_TEXT	SEGMENT
?SetupMassiveBody@@YAXXZ PROC NEAR			; SetupMassiveBody, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 288  : 	SetVecZero(&BDY_MassiveBody.Centre.Pos);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+20, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+24, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+28, 0

; 289  : 	SetVecZero(&BDY_MassiveBody.Centre.OldPos);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+8, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+12, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+16, 0

; 290  : 	SetVecZero(&BDY_MassiveBody.Centre.Vel);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+32, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+36, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+40, 0

; 291  : 	SetVecZero(&BDY_MassiveBody.Centre.OldPos);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+8, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+12, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+16, 0

; 292  : 	SetVecZero(&BDY_MassiveBody.Centre.Acc);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+44, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+48, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+52, 0

; 293  : 	SetVecZero(&BDY_MassiveBody.Centre.Impulse);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+56, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+60, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+64, 0

; 294  : 	SetQuatUnit(&BDY_MassiveBody.Centre.Quat);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+68, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+72, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+76, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+80, 1065353216 ; 3f800000H

; 295  : 	SetQuatUnit(&BDY_MassiveBody.Centre.OldQuat);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+84, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+88, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+92, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+96, 1065353216 ; 3f800000H

; 296  : 	SetMatUnit(&BDY_MassiveBody.Centre.WMatrix);

	push	OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A+100
	call	?SetMatUnit@@YAXPATMatrixUnion@@@Z	; SetMatUnit
	add	esp, 4

; 297  : 	SetMatUnit(&BDY_MassiveBody.Centre.OldWMatrix);

	push	OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A+136
	call	?SetMatUnit@@YAXPATMatrixUnion@@@Z	; SetMatUnit
	add	esp, 4

; 298  : 	SetVecZero(&BDY_MassiveBody.Centre.Shift);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+200, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+204, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+208, 0

; 299  : 
; 300  : 	BDY_MassiveBody.Centre.Mass = ZERO;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A, 0

; 301  : 	BDY_MassiveBody.Centre.InvMass = ZERO;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+4, 0

; 302  : 	SetMatZero(&BDY_MassiveBody.BodyInertia);

	push	OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A+224
	call	?SetMatZero@@YAXPATMatrixUnion@@@Z	; SetMatZero
	add	esp, 4

; 303  : 	SetMatZero(&BDY_MassiveBody.BodyInvInertia);

	push	OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A+260
	call	?SetMatZero@@YAXPATMatrixUnion@@@Z	; SetMatZero
	add	esp, 4

; 304  : 	SetMatZero(&BDY_MassiveBody.WorldInvInertia);

	push	OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A+296
	call	?SetMatZero@@YAXPATMatrixUnion@@@Z	; SetMatZero
	add	esp, 4

; 305  : 
; 306  : 	BDY_MassiveBody.Centre.StaticFriction = ONE;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+184, 1065353216 ; 3f800000H

; 307  : 	BDY_MassiveBody.Centre.KineticFriction = ONE;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+188, 1065353216 ; 3f800000H

; 308  : 	BDY_MassiveBody.Centre.Hardness = ZERO;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+172, 0

; 309  : 	BDY_MassiveBody.Centre.Resistance = ZERO;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+176, 0

; 310  : 	BDY_MassiveBody.Centre.Gravity = ZERO;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+192, 0

; 311  : 
; 312  : 	SetVecZero(&BDY_MassiveBody.AngVel);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+332, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+336, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+340, 0

; 313  : 	SetVecZero(&BDY_MassiveBody.AngAcc);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+344, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+348, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+352, 0

; 314  : 	SetVecZero(&BDY_MassiveBody.AngImpulse);

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+356, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+360, 0
	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+364, 0

; 315  : 	
; 316  : 	BDY_MassiveBody.CollSkin.Convex = NULL;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+380, 0

; 317  : 	BDY_MassiveBody.CollSkin.WorldConvex = NULL;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+384, 0

; 318  : 	BDY_MassiveBody.CollSkin.OldWorldConvex = NULL;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+388, 0

; 319  : 	BDY_MassiveBody.CollSkin.Sphere = NULL;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+396, 0

; 320  : 	BDY_MassiveBody.CollSkin.WorldSphere = NULL;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+400, 0

; 321  : 	BDY_MassiveBody.CollSkin.OldWorldSphere = NULL;

	mov	DWORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+404, 0

; 322  : 	BDY_MassiveBody.CollSkin.NConvex = 0;

	mov	WORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+392, 0

; 323  : 	BDY_MassiveBody.CollSkin.NSpheres = 0;

	mov	WORD PTR ?BDY_MassiveBody@@3UNewBodyStruct@@A+408, 0

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupMassiveBody@@YAXXZ ENDP				; SetupMassiveBody
_TEXT	ENDS
PUBLIC	?SetBodyInertia@@YAXPAUNewBodyStruct@@PATMatrixUnion@@@Z ; SetBodyInertia
EXTRN	?InvertMat@@YAXPATMatrixUnion@@@Z:NEAR		; InvertMat
; Function compile flags: /Odt /ZI
;	COMDAT ?SetBodyInertia@@YAXPAUNewBodyStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
_body$ = 8						; size = 4
_inertia$ = 12						; size = 4
?SetBodyInertia@@YAXPAUNewBodyStruct@@PATMatrixUnion@@@Z PROC NEAR ; SetBodyInertia, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 336  : 	CopyMat(inertia, &body->BodyInertia);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	mov	ecx, DWORD PTR _inertia$[ebp]
	push	ecx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 337  : 	CopyMat(inertia, &body->BodyInvInertia);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	mov	ecx, DWORD PTR _inertia$[ebp]
	push	ecx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 338  : 	InvertMat(&body->BodyInvInertia);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?InvertMat@@YAXPATMatrixUnion@@@Z	; InvertMat
	add	esp, 4

; 339  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetBodyInertia@@YAXPAUNewBodyStruct@@PATMatrixUnion@@@Z ENDP ; SetBodyInertia
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
EXTRN	?TransMatMulMat@@YAXPATMatrixUnion@@00@Z:NEAR	; TransMatMulMat
EXTRN	?MatMulMat@@YAXPATMatrixUnion@@00@Z:NEAR	; MatMulMat
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\body.cpp
;	COMDAT ?GetFrameInertia@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT
_tmpMat$ = -36						; size = 36
_bodyInvInertia$ = 8					; size = 4
_transform$ = 12					; size = 4
_worldInvInertia$ = 16					; size = 4
?GetFrameInertia@@YAXPATMatrixUnion@@00@Z PROC NEAR	; GetFrameInertia, COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 350  : 	MAT tmpMat;
; 351  : 
; 352  : 	TransMatMulMat(transform, bodyInvInertia, &tmpMat);

	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bodyInvInertia$[ebp]
	push	ecx
	mov	edx, DWORD PTR _transform$[ebp]
	push	edx
	call	?TransMatMulMat@@YAXPATMatrixUnion@@00@Z ; TransMatMulMat
	add	esp, 12					; 0000000cH

; 353  : 	MatMulMat(&tmpMat, transform, worldInvInertia);

	mov	eax, DWORD PTR _worldInvInertia$[ebp]
	push	eax
	mov	ecx, DWORD PTR _transform$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmpMat$[ebp]
	push	edx
	call	?MatMulMat@@YAXPATMatrixUnion@@00@Z	; MatMulMat
	add	esp, 12					; 0000000cH

; 354  : 
; 355  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrameInertia@@YAXPATMatrixUnion@@00@Z ENDP		; GetFrameInertia
_TEXT	ENDS
PUBLIC	?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z ; BuildOneBodyColMat
EXTRN	?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z:NEAR ; MatCrossVec
EXTRN	?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z:NEAR ; VecCrossMat
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z
_TEXT	SEGMENT
_workMat$ = -36						; size = 36
_body$ = 8						; size = 4
_colPos$ = 12						; size = 4
_colPos2$ = 16						; size = 4
_colMat$ = 20						; size = 4
?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z PROC NEAR ; BuildOneBodyColMat, COMDAT

; 372  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 373  : 
; 374  : 	MAT workMat;
; 375  : 
; 376  : 	VecCrossMat(colPos, &body->WorldInvInertia, &workMat);

	lea	eax, DWORD PTR _workMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	mov	edx, DWORD PTR _colPos$[ebp]
	push	edx
	call	?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z ; VecCrossMat
	add	esp, 12					; 0000000cH

; 377  : 	MatCrossVec(&workMat, colPos2, colMat);

	mov	eax, DWORD PTR _colMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _colPos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _workMat$[ebp]
	push	edx
	call	?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z ; MatCrossVec
	add	esp, 12					; 0000000cH

; 378  : 
; 379  : 	colMat->m[XX] = body->Centre.InvMass - colMat->m[XX];

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [edx]

; 380  : 	colMat->m[XY] = -colMat->m[XY];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+4]

; 381  : 	colMat->m[XZ] = -colMat->m[XZ];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 382  : 
; 383  : 	colMat->m[YX] = -colMat->m[YX];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+12]

; 384  : 	colMat->m[YY] = body->Centre.InvMass - colMat->m[YY];

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [edx+16]

; 385  : 	colMat->m[YZ] = -colMat->m[YZ];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+20]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+20]

; 386  : 
; 387  : 	colMat->m[ZX] = -colMat->m[ZX];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+24]

; 388  : 	colMat->m[ZY] = -colMat->m[ZY];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+28]

; 389  : 	colMat->m[ZZ] = body->Centre.InvMass - colMat->m[ZZ];

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [edx+32]

; 390  : 
; 391  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z ENDP ; BuildOneBodyColMat
_TEXT	ENDS
PUBLIC	?BuildTwoBodyColMat@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@111PATMatrixUnion@@@Z ; BuildTwoBodyColMat
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildTwoBodyColMat@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@111PATMatrixUnion@@@Z
_TEXT	SEGMENT
_workMat2$ = -72					; size = 36
_workMat1$ = -36					; size = 36
_body1$ = 8						; size = 4
_body2$ = 12						; size = 4
_colPos1$ = 16						; size = 4
_relPos1$ = 20						; size = 4
_colPos2$ = 24						; size = 4
_relPos2$ = 28						; size = 4
_colMat$ = 32						; size = 4
?BuildTwoBodyColMat@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@111PATMatrixUnion@@@Z PROC NEAR ; BuildTwoBodyColMat, COMDAT

; 408  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 409  : 	MAT workMat1, workMat2;
; 410  : 
; 411  : 	// Angular part
; 412  : 	VecCrossMat(relPos1, &body1->WorldInvInertia, &workMat1);

	lea	eax, DWORD PTR _workMat1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	mov	edx, DWORD PTR _relPos1$[ebp]
	push	edx
	call	?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z ; VecCrossMat
	add	esp, 12					; 0000000cH

; 413  : 	MatCrossVec(&workMat1, colPos1, colMat);

	mov	eax, DWORD PTR _colMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _colPos1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _workMat1$[ebp]
	push	edx
	call	?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z ; MatCrossVec
	add	esp, 12					; 0000000cH

; 414  : 	VecCrossMat(relPos2, &body2->WorldInvInertia, &workMat1);

	lea	eax, DWORD PTR _workMat1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	mov	edx, DWORD PTR _relPos2$[ebp]
	push	edx
	call	?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z ; VecCrossMat
	add	esp, 12					; 0000000cH

; 415  : 	MatCrossVec(&workMat1, colPos2, &workMat2);

	lea	eax, DWORD PTR _workMat2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _colPos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _workMat1$[ebp]
	push	edx
	call	?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z ; MatCrossVec
	add	esp, 12					; 0000000cH

; 416  : 	MatPlusEqMat(colMat, &workMat2);

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+12]
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+16]
	fadd	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+20]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+24]
	fadd	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+28]
	fadd	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR _workMat2$[ebp+32]
	fadd	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+32]

; 417  : 
; 418  : 	// Linear part
; 419  : 	colMat->m[XX] = body1->Centre.InvMass + body2->Centre.InvMass - colMat->m[XX];

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _colMat$[ebp]
	fsub	DWORD PTR [edx]
	mov	eax, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [eax]

; 420  : 	colMat->m[XY] = -colMat->m[XY];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+4]

; 421  : 	colMat->m[XZ] = -colMat->m[XZ];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 422  : 
; 423  : 	colMat->m[YX] = -colMat->m[YX];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+12]

; 424  : 	colMat->m[YY] = body1->Centre.InvMass + body2->Centre.InvMass  - colMat->m[YY];

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _colMat$[ebp]
	fsub	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [eax+16]

; 425  : 	colMat->m[YZ] = -colMat->m[YZ];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+20]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+20]

; 426  : 
; 427  : 	colMat->m[ZX] = -colMat->m[ZX];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+24]

; 428  : 	colMat->m[ZY] = -colMat->m[ZY];

	mov	eax, DWORD PTR _colMat$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [ecx+28]

; 429  : 	colMat->m[ZZ] = body1->Centre.InvMass + body2->Centre.InvMass  - colMat->m[ZZ];

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _colMat$[ebp]
	fsub	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _colMat$[ebp]
	fstp	DWORD PTR [eax+32]

; 430  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildTwoBodyColMat@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@111PATMatrixUnion@@@Z ENDP ; BuildTwoBodyColMat
_TEXT	ENDS
PUBLIC	?OneBodyZeroFrictionImpulse@@YAMPAUNewBodyStruct@@PAUVectorStruct@@1M@Z ; OneBodyZeroFrictionImpulse
; Function compile flags: /Odt /ZI
;	COMDAT ?OneBodyZeroFrictionImpulse@@YAMPAUNewBodyStruct@@PAUVectorStruct@@1M@Z
_TEXT	SEGMENT
_tmpVec2$ = -28						; size = 12
_tmpVec1$ = -16						; size = 12
_impMag$ = -4						; size = 4
_body$ = 8						; size = 4
_pos$ = 12						; size = 4
_normal$ = 16						; size = 4
_deltaVel$ = 20						; size = 4
?OneBodyZeroFrictionImpulse@@YAMPAUNewBodyStruct@@PAUVectorStruct@@1M@Z PROC NEAR ; OneBodyZeroFrictionImpulse, COMDAT

; 444  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 445  : 	REAL	impMag;
; 446  : 	VEC	tmpVec1, tmpVec2;
; 447  : 
; 448  : 	VecCrossVec(pos, normal, &tmpVec1);

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+8]

; 449  : 	MatMulVec(&body->WorldInvInertia, &tmpVec1, &tmpVec2);

	lea	eax, DWORD PTR _tmpVec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpVec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; MatMulVec
	add	esp, 12					; 0000000cH

; 450  : 	VecCrossVec(&tmpVec2, pos, &tmpVec1);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [ecx+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+8]

; 451  : 	impMag = body->Centre.InvMass + VecDotVec(&tmpVec1, normal);

	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp+4]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _impMag$[ebp]

; 452  : 
; 453  : 	return DivScalar(deltaVel, impMag);

	fld	DWORD PTR _deltaVel$[ebp]
	fdiv	DWORD PTR _impMag$[ebp]

; 454  : 
; 455  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OneBodyZeroFrictionImpulse@@YAMPAUNewBodyStruct@@PAUVectorStruct@@1M@Z ENDP ; OneBodyZeroFrictionImpulse
_TEXT	ENDS
PUBLIC	?TwoBodyZeroFrictionImpulse@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@11M1@Z ; TwoBodyZeroFrictionImpulse
; Function compile flags: /Odt /ZI
;	COMDAT ?TwoBodyZeroFrictionImpulse@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@11M1@Z
_TEXT	SEGMENT
_tmpVec2$ = -28						; size = 12
_tmpVec1$ = -16						; size = 12
_impMag$ = -4						; size = 4
_body1$ = 8						; size = 4
_body2$ = 12						; size = 4
_pos1$ = 16						; size = 4
_pos2$ = 20						; size = 4
_normal$ = 24						; size = 4
_deltaVel$ = 28						; size = 4
_impulse$ = 32						; size = 4
?TwoBodyZeroFrictionImpulse@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@11M1@Z PROC NEAR ; TwoBodyZeroFrictionImpulse, COMDAT

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 463  : 	REAL	impMag;
; 464  : 	VEC	tmpVec1, tmpVec2;
; 465  : 
; 466  : 	VecCrossVec(pos1, normal, &tmpVec1);

	mov	eax, DWORD PTR _pos1$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _pos1$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp]
	mov	eax, DWORD PTR _pos1$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _pos1$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+4]
	mov	eax, DWORD PTR _pos1$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _pos1$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+8]

; 467  : 	MatMulVec(&body1->WorldInvInertia, &tmpVec1, &tmpVec2);

	lea	eax, DWORD PTR _tmpVec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpVec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _body1$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; MatMulVec
	add	esp, 12					; 0000000cH

; 468  : 	VecCrossVec(&tmpVec2, pos1, &tmpVec1);

	mov	eax, DWORD PTR _pos1$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pos1$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [ecx+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp]
	mov	eax, DWORD PTR _pos1$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos1$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+4]
	mov	eax, DWORD PTR _pos1$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pos1$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+8]

; 469  : 	impMag = body1->Centre.InvMass + VecDotVec(&tmpVec1, normal);

	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp+4]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _body1$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _impMag$[ebp]

; 470  : 
; 471  : 	VecCrossVec(pos2, normal, &tmpVec1);

	mov	eax, DWORD PTR _pos2$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _pos2$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp]
	mov	eax, DWORD PTR _pos2$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _pos2$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+4]
	mov	eax, DWORD PTR _pos2$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _pos2$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+8]

; 472  : 	MatMulVec(&body2->WorldInvInertia, &tmpVec1, &tmpVec2);

	lea	eax, DWORD PTR _tmpVec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpVec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _body2$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; MatMulVec
	add	esp, 12					; 0000000cH

; 473  : 	VecCrossVec(&tmpVec2, pos2, &tmpVec1);

	mov	eax, DWORD PTR _pos2$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pos2$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [ecx+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp]
	mov	eax, DWORD PTR _pos2$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos2$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+4]
	mov	eax, DWORD PTR _pos2$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pos2$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec1$[ebp+8]

; 474  : 	impMag += body2->Centre.InvMass + VecDotVec(&tmpVec1, normal);

	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp+4]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _tmpVec1$[ebp+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _body2$[ebp]
	fadd	DWORD PTR [eax+4]
	fadd	DWORD PTR _impMag$[ebp]
	fstp	DWORD PTR _impMag$[ebp]

; 475  : 
; 476  : 	impMag = DivScalar(deltaVel, impMag);

	fld	DWORD PTR _deltaVel$[ebp]
	fdiv	DWORD PTR _impMag$[ebp]
	fstp	DWORD PTR _impMag$[ebp]

; 477  : 
; 478  : 	VecEqScalarVec(impulse, impMag, normal);

	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _impMag$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _impMag$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _impMag$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [ecx+8]

; 479  : 
; 480  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TwoBodyZeroFrictionImpulse@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@11M1@Z ENDP ; TwoBodyZeroFrictionImpulse
_TEXT	ENDS
PUBLIC	__real@43960000
PUBLIC	?PreProcessBodyColls@@YAXPAUNewBodyStruct@@@Z	; PreProcessBodyColls
PUBLIC	?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z ; RemoveBodyColl
EXTRN	?ModifyShift@@YAXPAUVectorStruct@@M0@Z:NEAR	; ModifyShift
EXTRN	?COL_NBodyDone@@3HA:DWORD			; COL_NBodyDone
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?PreProcessBodyColls@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_collInfo2$ = -64					; size = 4
_collInfo1$ = -60					; size = 4
_collDepth1$ = -56					; size = 4
_collPos2$ = -52					; size = 4
_collPos1$ = -48					; size = 4
_dRWLenSq$ = -44					; size = 4
_dRLenSq$ = -40						; size = 4
_shiftMod$ = -36					; size = 4
_n1Dotn2$ = -32						; size = 4
_dRW$ = -28						; size = 12
_dR$ = -16						; size = 12
_keepGoing$ = -1					; size = 1
_body$ = 8						; size = 4
?PreProcessBodyColls@@YAXPAUNewBodyStruct@@@Z PROC NEAR	; PreProcessBodyColls, COMDAT

; 491  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi

; 492  : 	bool keepGoing;
; 493  : 	VEC dR, dRW;
; 494  : 	REAL	n1Dotn2, shiftMod;
; 495  : 	REAL	dRLenSq, dRWLenSq;
; 496  : 	VEC	*collPos1, *collPos2;
; 497  : 	REAL	collDepth1;
; 498  : 	COLLINFO_BODY	*collInfo1, *collInfo2;
; 499  : 
; 500  : 
; 501  : 	for (collInfo1 = body->BodyCollHead; collInfo1 != NULL; collInfo1 = collInfo1->Next) {

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR _collInfo1$[ebp], ecx
	jmp	SHORT $L76843
$L76844:
	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _collInfo1$[ebp], ecx
$L76843:
	cmp	DWORD PTR _collInfo1$[ebp], 0
	je	SHORT $L76845

; 502  : 
; 503  : 		collPos1 = &collInfo1->Pos1;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	add	eax, 8
	mov	DWORD PTR _collPos1$[ebp], eax

; 504  : 		collDepth1 = collInfo1->Depth;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _collDepth1$[ebp], ecx

; 505  : 
; 506  : 		if (VecDotVec(&body->Centre.Shift, PlaneNormal(&collInfo1->Plane)) > -collDepth1) {

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo1$[ebp]
	fld	DWORD PTR [eax+200]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo1$[ebp]
	fld	DWORD PTR [edx+204]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _collInfo1$[ebp]
	fld	DWORD PTR [ecx+208]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _collDepth1$[ebp]
	fchs
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76849

; 507  : 			RemoveBodyColl(body, collInfo1);

	mov	eax, DWORD PTR _collInfo1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z ; RemoveBodyColl
	add	esp, 8

; 508  : 			continue;

	jmp	SHORT $L76844
$L76849:

; 509  : 		}
; 510  : 	}

	jmp	SHORT $L76844
$L76845:

; 511  : 
; 512  : 	collInfo1 = body->BodyCollHead;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR _collInfo1$[ebp], ecx
$L76851:

; 513  : 	while (collInfo1 != NULL) {

	cmp	DWORD PTR _collInfo1$[ebp], 0
	je	$L76830

; 514  : 
; 515  : 		collPos1 = &collInfo1->Pos1;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	add	eax, 8
	mov	DWORD PTR _collPos1$[ebp], eax

; 516  : 		collDepth1 = collInfo1->Depth;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _collDepth1$[ebp], ecx

; 517  : 
; 518  : 		// Make sure the body is extracted from colliding object
; 519  : 		if (collInfo1->Depth < ZERO) {

	mov	eax, DWORD PTR _collInfo1$[ebp]
	fld	DWORD PTR [eax+76]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76853

; 520  : 
; 521  : 			shiftMod = collInfo1->Body1->Centre.InvMass + collInfo1->Body2->Centre.InvMass;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _collInfo1$[ebp]
	mov	eax, DWORD PTR [edx+20]
	fld	DWORD PTR [ecx+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _shiftMod$[ebp]

; 522  : 			if (shiftMod > SMALL_REAL) {

	fld	DWORD PTR _shiftMod$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76854

; 523  : 				shiftMod = collInfo1->Body1->Centre.InvMass / shiftMod;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+4]
	fdiv	DWORD PTR _shiftMod$[ebp]
	fstp	DWORD PTR _shiftMod$[ebp]

; 524  : 			} else {

	jmp	SHORT $L76855
$L76854:

; 525  : 				shiftMod = ZERO;

	mov	DWORD PTR _shiftMod$[ebp], 0
$L76855:

; 526  : 			}
; 527  : 			ModifyShift(&body->Centre.Shift, -shiftMod * collDepth1, PlaneNormal(&collInfo1->Plane));

	mov	eax, DWORD PTR _collInfo1$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	fld	DWORD PTR _shiftMod$[ebp]
	fchs
	fmul	DWORD PTR _collDepth1$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 200				; 000000c8H
	push	ecx
	call	?ModifyShift@@YAXPAUVectorStruct@@M0@Z	; ModifyShift
	add	esp, 12					; 0000000cH
$L76853:

; 528  : 		}
; 529  : 
; 530  : 		// Merge close collisions
; 531  : 		collInfo2 = collInfo1->Next;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _collInfo2$[ebp], ecx

; 532  : 		keepGoing = TRUE;

	mov	BYTE PTR _keepGoing$[ebp], 1
$L76858:

; 533  : 		while ((collInfo2 != NULL) && keepGoing) {

	cmp	DWORD PTR _collInfo2$[ebp], 0
	je	$L76859
	movzx	eax, BYTE PTR _keepGoing$[ebp]
	test	eax, eax
	je	$L76859

; 534  : 
; 535  : 			collPos2 = &collInfo2->Pos1;

	mov	eax, DWORD PTR _collInfo2$[ebp]
	add	eax, 8
	mov	DWORD PTR _collPos2$[ebp], eax

; 536  : 
; 537  : 			VecMinusVec(collPos1, collPos2, &dR);

	mov	eax, DWORD PTR _collPos1$[ebp]
	mov	ecx, DWORD PTR _collPos2$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _collPos1$[ebp]
	mov	ecx, DWORD PTR _collPos2$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _collPos1$[ebp]
	mov	ecx, DWORD PTR _collPos2$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 538  : 			dRLenSq = VecDotVec(&dR, &dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dRLenSq$[ebp]

; 539  : 			VecMinusVec(&collInfo1->WorldPos, &collInfo2->WorldPos, &dRW);

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR [ecx+36]
	fstp	DWORD PTR _dRW$[ebp]
	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+40]
	fsub	DWORD PTR [ecx+40]
	fstp	DWORD PTR _dRW$[ebp+4]
	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+44]
	fsub	DWORD PTR [ecx+44]
	fstp	DWORD PTR _dRW$[ebp+8]

; 540  : 			dRWLenSq = VecDotVec(&dRW, &dRW);

	fld	DWORD PTR _dRW$[ebp]
	fmul	DWORD PTR _dRW$[ebp]
	fld	DWORD PTR _dRW$[ebp+4]
	fmul	DWORD PTR _dRW$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dRW$[ebp+8]
	fmul	DWORD PTR _dRW$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dRWLenSq$[ebp]

; 541  : 			n1Dotn2 = VecDotVec(PlaneNormal(&collInfo1->Plane), PlaneNormal(&collInfo2->Plane));

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _collInfo1$[ebp]
	mov	eax, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo1$[ebp]
	mov	edx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [ecx+68]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _n1Dotn2$[ebp]

; 542  : 			
; 543  : 			if (dRLenSq < CLOSE_BODY_COLL) {

	fld	DWORD PTR _dRLenSq$[ebp]
	fcomp	DWORD PTR __real@43960000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76867

; 544  : 				if (collInfo1->Depth < collInfo2->Depth) {

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+76]
	fcomp	DWORD PTR [ecx+76]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76868

; 545  : 					RemoveBodyColl(body, collInfo2);

	mov	eax, DWORD PTR _collInfo2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z ; RemoveBodyColl
	add	esp, 8

; 546  : 				} else {

	jmp	SHORT $L76869
$L76868:

; 547  : 					RemoveBodyColl(body, collInfo1);

	mov	eax, DWORD PTR _collInfo1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z ; RemoveBodyColl
	add	esp, 8

; 548  : 					keepGoing = FALSE;

	mov	BYTE PTR _keepGoing$[ebp], 0
$L76869:

; 549  : 				}
; 550  : 				COL_NBodyDone++;

	mov	eax, DWORD PTR ?COL_NBodyDone@@3HA	; COL_NBodyDone
	add	eax, 1
	mov	DWORD PTR ?COL_NBodyDone@@3HA, eax	; COL_NBodyDone
$L76867:

; 551  : 			}
; 552  : 			collInfo2 = collInfo2->Next;

	mov	eax, DWORD PTR _collInfo2$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _collInfo2$[ebp], ecx

; 553  : 		}

	jmp	$L76858
$L76859:

; 554  : 		collInfo1 = collInfo1->Next;

	mov	eax, DWORD PTR _collInfo1$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _collInfo1$[ebp], ecx

; 555  : 	}

	jmp	$L76851
$L76830:

; 556  : 
; 557  : 	// Set up the collision pointer list for this body
; 558  : 	//COL_NThisBodyColls = BuildThisBodyCollList(body);
; 559  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PreProcessBodyColls@@YAXPAUNewBodyStruct@@@Z ENDP	; PreProcessBodyColls
_TEXT	ENDS
PUBLIC	?BuildCollisionEquations@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z ; BuildCollisionEquations
EXTRN	?ClearBigMat@@YAXPAUBIGMAT@@@Z:NEAR		; ClearBigMat
EXTRN	?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z:NEAR	; BuildMatrixFromUp
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildCollisionEquations@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z
_TEXT	SEGMENT
_collInfo2$ = -132					; size = 4
_collInfo$ = -128					; size = 4
_collMat$ = -124					; size = 36
_collAxes$ = -88					; size = 36
_tmpVec2$ = -52						; size = 12
_tmpVec$ = -40						; size = 12
_dVelNorm$ = -28					; size = 4
_nEqns$ = -24						; size = 4
_iImp2$ = -20						; size = 4
_iImp$ = -16						; size = 4
_iEqn$ = -12						; size = 4
_iColl2$ = -8						; size = 4
_iColl$ = -4						; size = 4
_body$ = 8						; size = 4
_collInfoList$ = 12					; size = 4
_nColls$ = 16						; size = 4
_eqns$ = 20						; size = 4
_residual$ = 24						; size = 4
?BuildCollisionEquations@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z PROC NEAR ; BuildCollisionEquations, COMDAT

; 607  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 608  : 	int		iColl, iColl2, iEqn, iImp, iImp2;
; 609  : 	int		nEqns;
; 610  : 	REAL	dVelNorm;
; 611  : 	VEC	tmpVec, tmpVec2;
; 612  : 	MAT	collAxes, collMat;
; 613  : 	COLLINFO_BODY	*collInfo, *collInfo2;
; 614  : 
; 615  : 	// Number of simulataneous equations
; 616  : 	nEqns = 3 * nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
	imul	eax, 3
	mov	DWORD PTR _nEqns$[ebp], eax

; 617  : 
; 618  : 	// Initialise the equation matrix
; 619  : 	SetBigMatSize(eqns, nEqns, nEqns);

	mov	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _nEqns$[ebp]
	mov	DWORD PTR [eax+4096], ecx
	mov	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _nEqns$[ebp]
	mov	DWORD PTR [eax+4100], ecx

; 620  : 	SetBigVecSize(residual, nEqns);

	mov	eax, DWORD PTR _residual$[ebp]
	mov	ecx, DWORD PTR _nEqns$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 621  : 	ClearBigMat(eqns);

	mov	eax, DWORD PTR _eqns$[ebp]
	push	eax
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 622  : 
; 623  : 	// Set up the three equations for each contact point (currently zero friction)
; 624  : 	iEqn = 0;

	mov	DWORD PTR _iEqn$[ebp], 0

; 625  : 	for (iColl = 0; iColl < nColls; iColl++) {

	mov	DWORD PTR _iColl$[ebp], 0
	jmp	SHORT $L76890
$L76891:
	mov	eax, DWORD PTR _iColl$[ebp]
	add	eax, 1
	mov	DWORD PTR _iColl$[ebp], eax
$L76890:
	mov	eax, DWORD PTR _iColl$[ebp]
	cmp	eax, DWORD PTR _nColls$[ebp]
	jge	$L76876

; 626  : 		iImp = 3 * iColl;

	mov	eax, DWORD PTR _iColl$[ebp]
	imul	eax, 3
	mov	DWORD PTR _iImp$[ebp], eax

; 627  : 		collInfo = collInfoList[iColl];

	mov	eax, DWORD PTR _iColl$[ebp]
	mov	ecx, DWORD PTR _collInfoList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _collInfo$[ebp], edx

; 628  : 
; 629  : 		// build collision axes (up = normal; look, right = tangents)
; 630  : 		CopyVec(PlaneNormal(&collInfo->Plane), &collAxes.mv[U]);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _collAxes$[ebp+12], ecx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _collAxes$[ebp+16], ecx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _collAxes$[ebp+20], ecx

; 631  : 		BuildMatrixFromUp(&collAxes);

	lea	eax, DWORD PTR _collAxes$[ebp]
	push	eax
	call	?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z ; BuildMatrixFromUp
	add	esp, 4

; 632  : 
; 633  : 		// P_i.T_1i = 0
; 634  : 		eqns->m[iEqn][X + iImp] = collAxes.m[RX];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp$[ebp]
	mov	edx, DWORD PTR _collAxes$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 635  : 		eqns->m[iEqn][Y + iImp] = collAxes.m[RY];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp$[ebp]
	mov	edx, DWORD PTR _collAxes$[ebp+4]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 636  : 		eqns->m[iEqn][Z + iImp] = collAxes.m[RZ];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp$[ebp]
	mov	edx, DWORD PTR _collAxes$[ebp+8]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 637  : 		residual->v[iEqn] = ZERO;

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 638  : 		iEqn++;

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEqn$[ebp], eax

; 639  : 
; 640  : 		// P_i.T_2i = 0
; 641  : 		eqns->m[iEqn][X + iImp] = collAxes.m[LX];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp$[ebp]
	mov	edx, DWORD PTR _collAxes$[ebp+24]
	mov	DWORD PTR [eax+ecx*4], edx

; 642  : 		eqns->m[iEqn][Y + iImp] = collAxes.m[LY];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp$[ebp]
	mov	edx, DWORD PTR _collAxes$[ebp+28]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 643  : 		eqns->m[iEqn][Z + iImp] = collAxes.m[LZ];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp$[ebp]
	mov	edx, DWORD PTR _collAxes$[ebp+32]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 644  : 		residual->v[iEqn] = ZERO;

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 645  : 		iEqn++;

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEqn$[ebp], eax

; 646  : 
; 647  : 		// dV_i.n_i = -(1+e)V.n_i
; 648  : 		for (iColl2 = 0; iColl2 < nColls; iColl2++) {

	mov	DWORD PTR _iColl2$[ebp], 0
	jmp	SHORT $L76896
$L76897:
	mov	eax, DWORD PTR _iColl2$[ebp]
	add	eax, 1
	mov	DWORD PTR _iColl2$[ebp], eax
$L76896:
	mov	eax, DWORD PTR _iColl2$[ebp]
	cmp	eax, DWORD PTR _nColls$[ebp]
	jge	$L76898

; 649  : 			iImp2 = 3 * iColl2;

	mov	eax, DWORD PTR _iColl2$[ebp]
	imul	eax, 3
	mov	DWORD PTR _iImp2$[ebp], eax

; 650  : 			collInfo2 = collInfoList[iColl2];

	mov	eax, DWORD PTR _iColl2$[ebp]
	mov	ecx, DWORD PTR _collInfoList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _collInfo2$[ebp], edx

; 651  : 			BuildOneBodyColMat(body, &collInfo->Pos1, &collInfo2->Pos1, &collMat);

	lea	eax, DWORD PTR _collMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z ; BuildOneBodyColMat
	add	esp, 16					; 00000010H

; 652  : 
; 653  : 			eqns->m[iEqn][X + iImp2] = collMat.m[XX] * collAxes.m[UX] + collMat.m[YX] * collAxes.m[UY] + collMat.m[ZX] * collAxes.m[UZ];

	fld	DWORD PTR _collMat$[ebp]
	fmul	DWORD PTR _collAxes$[ebp+12]
	fld	DWORD PTR _collMat$[ebp+12]
	fmul	DWORD PTR _collAxes$[ebp+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _collMat$[ebp+24]
	fmul	DWORD PTR _collAxes$[ebp+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 654  : 			eqns->m[iEqn][Y + iImp2] = collMat.m[XY] * collAxes.m[UX] + collMat.m[YY] * collAxes.m[UY] + collMat.m[ZY] * collAxes.m[UZ];

	fld	DWORD PTR _collMat$[ebp+4]
	fmul	DWORD PTR _collAxes$[ebp+12]
	fld	DWORD PTR _collMat$[ebp+16]
	fmul	DWORD PTR _collAxes$[ebp+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _collMat$[ebp+28]
	fmul	DWORD PTR _collAxes$[ebp+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	fstp	DWORD PTR [eax+ecx*4+4]

; 655  : 			eqns->m[iEqn][Z + iImp2] = collMat.m[XZ] * collAxes.m[UX] + collMat.m[YZ] * collAxes.m[UY] + collMat.m[ZZ] * collAxes.m[UZ];

	fld	DWORD PTR _collMat$[ebp+8]
	fmul	DWORD PTR _collAxes$[ebp+12]
	fld	DWORD PTR _collMat$[ebp+20]
	fmul	DWORD PTR _collAxes$[ebp+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _collMat$[ebp+32]
	fmul	DWORD PTR _collAxes$[ebp+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	fstp	DWORD PTR [eax+ecx*4+8]

; 656  : 		}

	jmp	$L76897
$L76898:

; 657  : 		residual->v[iEqn] = -(ONE + collInfo->Restitution) * VecDotVec(&collInfo->Vel, &collAxes.mv[U]);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [eax+96]
	fchs
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collAxes$[ebp+12]
	fmul	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collAxes$[ebp+16]
	fmul	DWORD PTR [edx+52]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collAxes$[ebp+20]
	fmul	DWORD PTR [eax+56]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	mov	ecx, DWORD PTR _iEqn$[ebp]
	mov	edx, DWORD PTR _residual$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 658  : 		// Make sure the existing impulses are taken into account
; 659  : 		VecCrossVec(&body->AngImpulse, &collInfo->Pos1, &tmpVec);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+360]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+364]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+364]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+356]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+356]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+360]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 660  : 		MatMulVec(&body->WorldInvInertia, &tmpVec, &tmpVec2);

	lea	eax, DWORD PTR _tmpVec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpVec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; MatMulVec
	add	esp, 12					; 0000000cH

; 661  : 		VecPlusEqScalarVec(&tmpVec2, body->Centre.InvMass, &body->Centre.Impulse);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx+56]
	fadd	DWORD PTR _tmpVec2$[ebp]
	fstp	DWORD PTR _tmpVec2$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx+60]
	fadd	DWORD PTR _tmpVec2$[ebp+4]
	fstp	DWORD PTR _tmpVec2$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx+64]
	fadd	DWORD PTR _tmpVec2$[ebp+8]
	fstp	DWORD PTR _tmpVec2$[ebp+8]

; 662  : 		dVelNorm = VecDotVec(PlaneNormal(&collInfo->Plane), &tmpVec2);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dVelNorm$[ebp]

; 663  : 		if (dVelNorm < residual->v[iEqn]) {

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	fld	DWORD PTR _dVelNorm$[ebp]
	fcomp	DWORD PTR [ecx+eax*4]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76902

; 664  : 			residual->v[iEqn] -= dVelNorm;

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fsub	DWORD PTR _dVelNorm$[ebp]
	mov	edx, DWORD PTR _iEqn$[ebp]
	mov	eax, DWORD PTR _residual$[ebp]
	fstp	DWORD PTR [eax+edx*4]

; 665  : 		} else {

	jmp	SHORT $L76903
$L76902:

; 666  : 			residual->v[iEqn] = ZERO;

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
$L76903:

; 667  : 		}
; 668  : 		iEqn++;

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEqn$[ebp], eax

; 669  : 	}

	jmp	$L76891
$L76876:

; 670  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildCollisionEquations@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z ENDP ; BuildCollisionEquations
_TEXT	ENDS
PUBLIC	?BuildCollisionEquations2@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z ; BuildCollisionEquations2
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildCollisionEquations2@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z
_TEXT	SEGMENT
_collInfo2$ = -68					; size = 4
_collInfo$ = -64					; size = 4
_collMat$ = -60						; size = 36
_nEqns$ = -24						; size = 4
_iImp2$ = -20						; size = 4
_iImp$ = -16						; size = 4
_iEqn$ = -12						; size = 4
_iColl2$ = -8						; size = 4
_iColl$ = -4						; size = 4
_body$ = 8						; size = 4
_collInfoList$ = 12					; size = 4
_nColls$ = 16						; size = 4
_eqns$ = 20						; size = 4
_residual$ = 24						; size = 4
?BuildCollisionEquations2@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z PROC NEAR ; BuildCollisionEquations2, COMDAT

; 675  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 676  : 	int		iColl, iColl2, iEqn, iImp, iImp2;
; 677  : 	int		nEqns;
; 678  : 	MAT	collMat;
; 679  : 	COLLINFO_BODY	*collInfo, *collInfo2;
; 680  : 
; 681  : 	// Number of simulataneous equations
; 682  : 	nEqns = 3 * nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
	imul	eax, 3
	mov	DWORD PTR _nEqns$[ebp], eax

; 683  : 
; 684  : 	// Initialise the equation matrix
; 685  : 	SetBigMatSize(eqns, nEqns, nEqns);

	mov	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _nEqns$[ebp]
	mov	DWORD PTR [eax+4096], ecx
	mov	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _nEqns$[ebp]
	mov	DWORD PTR [eax+4100], ecx

; 686  : 	SetBigVecSize(residual, nEqns);

	mov	eax, DWORD PTR _residual$[ebp]
	mov	ecx, DWORD PTR _nEqns$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 687  : 	ClearBigMat(eqns);

	mov	eax, DWORD PTR _eqns$[ebp]
	push	eax
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 688  : 
; 689  : 	// Set up the three equations for each contact point (currently zero friction)
; 690  : 	iEqn = 0;

	mov	DWORD PTR _iEqn$[ebp], 0

; 691  : 	for (iColl = 0; iColl < nColls; iColl++) {

	mov	DWORD PTR _iColl$[ebp], 0
	jmp	SHORT $L76920
$L76921:
	mov	eax, DWORD PTR _iColl$[ebp]
	add	eax, 1
	mov	DWORD PTR _iColl$[ebp], eax
$L76920:
	mov	eax, DWORD PTR _iColl$[ebp]
	cmp	eax, DWORD PTR _nColls$[ebp]
	jge	$L76910

; 692  : 		iImp = 3 * iColl;

	mov	eax, DWORD PTR _iColl$[ebp]
	imul	eax, 3
	mov	DWORD PTR _iImp$[ebp], eax

; 693  : 		iEqn = 3 * iColl;

	mov	eax, DWORD PTR _iColl$[ebp]
	imul	eax, 3
	mov	DWORD PTR _iEqn$[ebp], eax

; 694  : 		collInfo = collInfoList[iColl];

	mov	eax, DWORD PTR _iColl$[ebp]
	mov	ecx, DWORD PTR _collInfoList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _collInfo$[ebp], edx

; 695  : 
; 696  : 		// dV_i = -(1+e)V
; 697  : 		for (iColl2 = 0; iColl2 < nColls; iColl2++) {

	mov	DWORD PTR _iColl2$[ebp], 0
	jmp	SHORT $L76923
$L76924:
	mov	eax, DWORD PTR _iColl2$[ebp]
	add	eax, 1
	mov	DWORD PTR _iColl2$[ebp], eax
$L76923:
	mov	eax, DWORD PTR _iColl2$[ebp]
	cmp	eax, DWORD PTR _nColls$[ebp]
	jge	$L76925

; 698  : 			iImp2 = 3 * iColl2;

	mov	eax, DWORD PTR _iColl2$[ebp]
	imul	eax, 3
	mov	DWORD PTR _iImp2$[ebp], eax

; 699  : 			collInfo2 = collInfoList[iColl2];

	mov	eax, DWORD PTR _iColl2$[ebp]
	mov	ecx, DWORD PTR _collInfoList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _collInfo2$[ebp], edx

; 700  : 			BuildOneBodyColMat(body, &collInfo->Pos1, &collInfo2->Pos1, &collMat);

	lea	eax, DWORD PTR _collMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z ; BuildOneBodyColMat
	add	esp, 16					; 00000010H

; 701  : 
; 702  : 			eqns->m[iEqn][0 + iImp2] = collMat.m[XX];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 703  : 			eqns->m[iEqn][1 + iImp2] = collMat.m[XY];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+4]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 704  : 			eqns->m[iEqn][2 + iImp2] = collMat.m[XZ];

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+8]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 705  : 			residual->v[iEqn] = -(ONE + collInfo->Restitution) * collInfo->Vel.v[X];

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [eax+96]
	fchs
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _iEqn$[ebp]
	mov	eax, DWORD PTR _residual$[ebp]
	fstp	DWORD PTR [eax+edx*4]

; 706  : 
; 707  : 			eqns->m[iEqn + 1][0 + iImp2] = collMat.m[YX];

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 1
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+12]
	mov	DWORD PTR [eax+ecx*4], edx

; 708  : 			eqns->m[iEqn + 1][1 + iImp2] = collMat.m[YY];

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 1
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+16]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 709  : 			eqns->m[iEqn + 1][2 + iImp2] = collMat.m[YZ];

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 1
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+20]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 710  : 			residual->v[iEqn + 1] = -(ONE + collInfo->Restitution) * collInfo->Vel.v[Y];

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [eax+96]
	fchs
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _iEqn$[ebp]
	mov	eax, DWORD PTR _residual$[ebp]
	fstp	DWORD PTR [eax+edx*4+4]

; 711  : 
; 712  : 			eqns->m[iEqn + 2][0 + iImp2] = collMat.m[ZX];

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 2
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+24]
	mov	DWORD PTR [eax+ecx*4], edx

; 713  : 			eqns->m[iEqn + 2][1 + iImp2] = collMat.m[ZY];

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 2
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+28]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 714  : 			eqns->m[iEqn + 2][2 + iImp2] = collMat.m[ZZ];

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 2
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iImp2$[ebp]
	mov	edx, DWORD PTR _collMat$[ebp+32]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 715  : 			residual->v[iEqn + 2] = -(ONE + collInfo->Restitution) * collInfo->Vel.v[Z];

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [eax+96]
	fchs
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _iEqn$[ebp]
	mov	eax, DWORD PTR _residual$[ebp]
	fstp	DWORD PTR [eax+edx*4+8]

; 716  : 		}

	jmp	$L76924
$L76925:

; 717  : 	}

	jmp	$L76921
$L76910:

; 718  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildCollisionEquations2@@YAXPAUNewBodyStruct@@PAPAUBodyCollInfoStruct@@HPAUBIGMAT@@PAUBIGVEC@@@Z ENDP ; BuildCollisionEquations2
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z@4JA ; `BuildCollisionEquations3'::`2'::__LINE__Var
PUBLIC	??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	?BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z ; BuildCollisionEquations3
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
;	COMDAT ??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\body.'
	DB	'cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z@4JA DD 02d2H ; `BuildCollisionEquations3'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z
_TEXT	SEGMENT
_nColls$ = -92						; size = 4
_collInfo2$ = -88					; size = 4
_collInfo$ = -84					; size = 4
_collMat$ = -80						; size = 36
_tmpVec2$ = -44						; size = 12
_tmpVec$ = -32						; size = 12
_tReal$ = -20						; size = 4
_dVelNorm$ = -16					; size = 4
_iEqn$ = -12						; size = 4
_iColl2$ = -8						; size = 4
_iColl$ = -4						; size = 4
_body$ = 8						; size = 4
_eqns$ = 12						; size = 4
_residual$ = 16						; size = 4
?BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z PROC NEAR ; BuildCollisionEquations3, COMDAT

; 722  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi

; 723  : 	int		iColl, iColl2, iEqn;
; 724  : 	REAL	dVelNorm, tReal;
; 725  : 	VEC	tmpVec, tmpVec2;
; 726  : 	MAT	collMat;
; 727  : 	COLLINFO_BODY	*collInfo, *collInfo2;
; 728  : 	int nColls = body->NBodyColls;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	mov	DWORD PTR _nColls$[ebp], ecx

; 729  : 
; 730  : 	// Initialise the equation matrix
; 731  : 	SetBigMatSize(eqns, nColls, nColls);

	mov	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR [eax+4096], ecx
	mov	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR [eax+4100], ecx

; 732  : 	SetBigVecSize(residual, nColls);

	mov	eax, DWORD PTR _residual$[ebp]
	mov	ecx, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 733  : 	ClearBigMat(eqns);

	mov	eax, DWORD PTR _eqns$[ebp]
	push	eax
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 734  : 
; 735  : 	iEqn = 0;

	mov	DWORD PTR _iEqn$[ebp], 0

; 736  : 	collInfo = body->BodyCollHead;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR _collInfo$[ebp], ecx

; 737  : 	for (iColl = 0; iColl < nColls; iColl++) {

	mov	DWORD PTR _iColl$[ebp], 0
	jmp	SHORT $L76942
$L76943:
	mov	eax, DWORD PTR _iColl$[ebp]
	add	eax, 1
	mov	DWORD PTR _iColl$[ebp], eax
$L76942:
	mov	eax, DWORD PTR _iColl$[ebp]
	cmp	eax, DWORD PTR _nColls$[ebp]
	jge	$L76930

; 738  : 		Assert(collInfo != NULL);

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z@4JA
	add	eax, 16					; 00000010H
	push	eax
	cmp	DWORD PTR _collInfo$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 739  : 
; 740  : 		// dV_i.n_i = -(1+e)V.n_i
; 741  : 		collInfo2 = body->BodyCollHead;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR _collInfo2$[ebp], ecx

; 742  : 		for (iColl2 = 0; iColl2 < nColls; iColl2++) {

	mov	DWORD PTR _iColl2$[ebp], 0
	jmp	SHORT $L76947
$L76948:
	mov	eax, DWORD PTR _iColl2$[ebp]
	add	eax, 1
	mov	DWORD PTR _iColl2$[ebp], eax
$L76947:
	mov	eax, DWORD PTR _iColl2$[ebp]
	cmp	eax, DWORD PTR _nColls$[ebp]
	jge	$L76949

; 743  : 			Assert(collInfo2 != NULL);

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z@4JA
	add	eax, 21					; 00000015H
	push	eax
	cmp	DWORD PTR _collInfo2$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 744  : 
; 745  : 			if (iColl2 == iColl) {

	mov	eax, DWORD PTR _iColl2$[ebp]
	cmp	eax, DWORD PTR _iColl$[ebp]
	jne	SHORT $L76950

; 746  : 				BuildTwoBodyColMat(collInfo->Body1, collInfo->Body2, &collInfo->Pos1, &collInfo2->Pos1, &collInfo->Pos2, &collInfo2->Pos2, &collMat);

	lea	eax, DWORD PTR _collMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _collInfo2$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?BuildTwoBodyColMat@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@111PATMatrixUnion@@@Z ; BuildTwoBodyColMat
	add	esp, 28					; 0000001cH

; 747  : 			} else {

	jmp	SHORT $L76951
$L76950:

; 748  : 				if (body == collInfo->Body1) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L76952

; 749  : 					BuildOneBodyColMat(collInfo->Body1, &collInfo->Pos1, &collInfo2->Pos1, &collMat);

	lea	eax, DWORD PTR _collMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z ; BuildOneBodyColMat
	add	esp, 16					; 00000010H

; 750  : 				} else {

	jmp	SHORT $L76951
$L76952:

; 751  : 					BuildOneBodyColMat(collInfo->Body2, &collInfo->Pos2, &collInfo2->Pos2, &collMat);

	lea	eax, DWORD PTR _collMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?BuildOneBodyColMat@@YAXPAUNewBodyStruct@@PAUVectorStruct@@1PATMatrixUnion@@@Z ; BuildOneBodyColMat
	add	esp, 16					; 00000010H
$L76951:

; 752  : 				}
; 753  : 			}
; 754  : 			tReal = 
; 755  : 				MulScalar(collMat.m[XX], collInfo2->Plane.v[X]) + 
; 756  : 				MulScalar(collMat.m[XY], collInfo2->Plane.v[Y]) + 
; 757  : 				MulScalar(collMat.m[XZ], collInfo2->Plane.v[Z]);

	mov	eax, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR _collMat$[ebp]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR _collMat$[ebp+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR _collMat$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _tReal$[ebp]

; 758  : 			eqns->m[iEqn][iColl2] = MulScalar(collInfo->Plane.v[X], tReal);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR _tReal$[ebp]
	mov	ecx, DWORD PTR _iEqn$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _eqns$[ebp]
	mov	edx, DWORD PTR _iColl2$[ebp]
	fstp	DWORD PTR [ecx+edx*4]

; 759  : 			tReal = 
; 760  : 				MulScalar(collMat.m[YX], collInfo2->Plane.v[X]) + 
; 761  : 				MulScalar(collMat.m[YY], collInfo2->Plane.v[Y]) + 
; 762  : 				MulScalar(collMat.m[YZ], collInfo2->Plane.v[Z]);

	mov	eax, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR _collMat$[ebp+12]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR _collMat$[ebp+16]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR _collMat$[ebp+20]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _tReal$[ebp]

; 763  : 			eqns->m[iEqn][iColl2] += MulScalar(collInfo->Plane.v[Y], tReal);

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR _tReal$[ebp]
	mov	edx, DWORD PTR _iColl2$[ebp]
	fadd	DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iColl2$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 764  : 			tReal = 
; 765  : 				MulScalar(collMat.m[ZX], collInfo2->Plane.v[X]) + 
; 766  : 				MulScalar(collMat.m[ZY], collInfo2->Plane.v[Y]) + 
; 767  : 				MulScalar(collMat.m[ZZ], collInfo2->Plane.v[Z]);

	mov	eax, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR _collMat$[ebp+24]
	mov	ecx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR _collMat$[ebp+28]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo2$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR _collMat$[ebp+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _tReal$[ebp]

; 768  : 			eqns->m[iEqn][iColl2] += MulScalar(collInfo->Plane.v[Z], tReal);

	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+68]
	fmul	DWORD PTR _tReal$[ebp]
	mov	edx, DWORD PTR _iColl2$[ebp]
	fadd	DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _iEqn$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _eqns$[ebp]
	mov	ecx, DWORD PTR _iColl2$[ebp]
	fstp	DWORD PTR [eax+ecx*4]

; 769  : 
; 770  : 			collInfo2 = collInfo2->Next;

	mov	eax, DWORD PTR _collInfo2$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _collInfo2$[ebp], ecx

; 771  : 		}

	jmp	$L76948
$L76949:

; 772  : 		residual->v[iEqn] = -MulScalar((ONE + collInfo->Restitution), VecDotVec(&collInfo->Vel, PlaneNormal(&collInfo->Plane)));

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+48]
	fmul	DWORD PTR [edx+60]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+52]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+56]
	fmul	DWORD PTR [eax+68]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fchs
	mov	ecx, DWORD PTR _iEqn$[ebp]
	mov	edx, DWORD PTR _residual$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 773  : 		// Make sure the existing impulses are taken into account
; 774  : 		VecCrossVec(&body->AngImpulse, &collInfo->Pos1, &tmpVec);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+360]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+364]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+364]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+356]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+356]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+360]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 775  : 		MatMulVec(&body->WorldInvInertia, &tmpVec, &tmpVec2);

	lea	eax, DWORD PTR _tmpVec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpVec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; MatMulVec
	add	esp, 12					; 0000000cH

; 776  : 		VecPlusEqScalarVec(&tmpVec2, body->Centre.InvMass, &body->Centre.Impulse);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx+56]
	fadd	DWORD PTR _tmpVec2$[ebp]
	fstp	DWORD PTR _tmpVec2$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx+60]
	fadd	DWORD PTR _tmpVec2$[ebp+4]
	fstp	DWORD PTR _tmpVec2$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx+64]
	fadd	DWORD PTR _tmpVec2$[ebp+8]
	fstp	DWORD PTR _tmpVec2$[ebp+8]

; 777  : 		dVelNorm = VecDotVec(PlaneNormal(&collInfo->Plane), &tmpVec2);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+4]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec2$[ebp+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dVelNorm$[ebp]

; 778  : 		if (dVelNorm < residual->v[iEqn]) {

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	fld	DWORD PTR _dVelNorm$[ebp]
	fcomp	DWORD PTR [ecx+eax*4]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76960

; 779  : 			residual->v[iEqn] -= dVelNorm;

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fsub	DWORD PTR _dVelNorm$[ebp]
	mov	edx, DWORD PTR _iEqn$[ebp]
	mov	eax, DWORD PTR _residual$[ebp]
	fstp	DWORD PTR [eax+edx*4]

; 780  : 		} else {

	jmp	SHORT $L76961
$L76960:

; 781  : 			residual->v[iEqn] = ZERO;

	mov	eax, DWORD PTR _iEqn$[ebp]
	mov	ecx, DWORD PTR _residual$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
$L76961:

; 782  : 		}
; 783  : 		iEqn++;

	mov	eax, DWORD PTR _iEqn$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEqn$[ebp], eax

; 784  : 
; 785  : 		collInfo = collInfo->Next;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _collInfo$[ebp], ecx

; 786  : 	}

	jmp	$L76943
$L76930:

; 787  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z ENDP ; BuildCollisionEquations3
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z@4JA ; `ProcessBodyColls3'::`2'::__LINE__Var
PUBLIC	__real@447a0000
PUBLIC	?ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z	; ProcessBodyColls3
PUBLIC	?AddBodyFriction@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PAUBodyCollInfoStruct@@@Z ; AddBodyFriction
EXTRN	?CopyBigMat@@YAXPAUBIGMAT@@0@Z:NEAR		; CopyBigMat
EXTRN	?CopyBigVec@@YAXPAUBIGVEC@@0@Z:NEAR		; CopyBigVec
EXTRN	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z:NEAR ; ConjGrad
_BSS	SEGMENT
_Soln	DB	084H DUP (?)
_Coefficients DB 01008H DUP (?)
_Residual DB	084H DUP (?)
_OrigCoefs DB	01008H DUP (?)
_OrigRes DB	084H DUP (?)
_NewRes	DB	084H DUP (?)
_BSS	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z@4JA DD 032fH ; `ProcessBodyColls3'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
tv248 = -144						; size = 4
tv86 = -144						; size = 4
_collInfo$ = -76					; size = 4
_totAngImpulse$ = -72					; size = 12
_totImpulse$ = -60					; size = 12
_collImpulse$ = -48					; size = 12
_tmpVec$ = -36						; size = 12
_knock$ = -24						; size = 4
_tol$ = -20						; size = 4
_res$ = -16						; size = 4
_maxIts$ = -12						; size = 4
_nIts$ = -8						; size = 4
_iColl$ = -4						; size = 4
_body$ = 8						; size = 4
?ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z PROC NEAR	; ProcessBodyColls3, COMDAT

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 816  : 	int iColl, nIts, maxIts;
; 817  : 	REAL res, tol, knock;
; 818  : 	VEC	tmpVec, collImpulse;
; 819  : 	VEC	totImpulse = {ZERO, ZERO, ZERO};

	mov	DWORD PTR _totImpulse$[ebp], 0
	mov	DWORD PTR _totImpulse$[ebp+4], 0
	mov	DWORD PTR _totImpulse$[ebp+8], 0

; 820  : 	VEC	totAngImpulse = {ZERO, ZERO, ZERO};

	mov	DWORD PTR _totAngImpulse$[ebp], 0
	mov	DWORD PTR _totAngImpulse$[ebp+4], 0
	mov	DWORD PTR _totAngImpulse$[ebp+8], 0

; 821  : 	COLLINFO_BODY *collInfo;
; 822  : #if DEBUG_SOLVER && FALSE
; 823  : 	char buf[256];
; 824  : #endif
; 825  : 
; 826  : 	// Set up the set of simulatneous equations
; 827  : 	BuildCollisionEquations3(body, &Coefficients, &Residual);

	push	OFFSET FLAT:_Residual
	push	OFFSET FLAT:_Coefficients
	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?BuildCollisionEquations3@@YAXPAUNewBodyStruct@@PAUBIGMAT@@PAUBIGVEC@@@Z ; BuildCollisionEquations3
	add	esp, 12					; 0000000cH

; 828  : 
; 829  : 	// Set up the solution vector
; 830  : 	SetBigVecSize(&Soln, body->NBodyColls);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	mov	DWORD PTR _Soln+128, ecx

; 831  : 
; 832  : #if DEBUG_SOLVER
; 833  : 	// Save original equations for debugging
; 834  : 	CopyBigMat(&Coefficients, &OrigCoefs);

	push	OFFSET FLAT:_OrigCoefs
	push	OFFSET FLAT:_Coefficients
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 835  : 	CopyBigVec(&Residual, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Residual
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 836  : 	SetBigVecSize(&NewRes, body->NBodyColls);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	mov	DWORD PTR _NewRes+128, ecx

; 837  : #endif
; 838  : 
; 839  : 	// Solve the collision equations
; 840  : 	maxIts = 5;

	mov	DWORD PTR _maxIts$[ebp], 5

; 841  : 	tol = Real(0.001);

	mov	DWORD PTR _tol$[ebp], 981668463		; 3a83126fH

; 842  : 	if (body->NBodyColls > 1) {

	mov	eax, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [eax+516], 1
	jle	SHORT $L76986

; 843  : 		ConjGrad(&Coefficients, &Residual, tol, maxIts, &Soln, &res, &nIts);

	lea	eax, DWORD PTR _nIts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$[ebp]
	push	ecx
	push	OFFSET FLAT:_Soln
	mov	edx, DWORD PTR _maxIts$[ebp]
	push	edx
	mov	eax, DWORD PTR _tol$[ebp]
	push	eax
	push	OFFSET FLAT:_Residual
	push	OFFSET FLAT:_Coefficients
	call	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ; ConjGrad
	add	esp, 28					; 0000001cH

; 844  : 	} else {

	jmp	SHORT $L76987
$L76986:

; 845  : 		Soln.v[0] = DivScalar(Residual.v[0], Coefficients.m[0][0]);

	fld	DWORD PTR _Residual
	fdiv	DWORD PTR _Coefficients
	fstp	DWORD PTR _Soln

; 846  : 		res = ZERO;

	mov	DWORD PTR _res$[ebp], 0
$L76987:

; 847  : 	}
; 848  : 
; 849  : #if USE_DEBUG_ROUTINES
; 850  : 	DEBUG_NIts = nIts;

	mov	eax, DWORD PTR _nIts$[ebp]
	mov	DWORD PTR ?DEBUG_NIts@@3HA, eax		; DEBUG_NIts

; 851  : 	DEBUG_Converged = TRUE;

	mov	BYTE PTR ?DEBUG_Converged@@3_NA, 1	; DEBUG_Converged

; 852  : #endif
; 853  : 
; 854  : 	// If not converged, do not apply impulses
; 855  : 	if (abs(res) > 1000 * tol) {

	fld	DWORD PTR _res$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77415
	mov	eax, DWORD PTR _res$[ebp]
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $L77416
$L77415:
	fld	DWORD PTR _res$[ebp]
	fchs
	fstp	DWORD PTR tv86[ebp]
$L77416:
	fld	DWORD PTR __real@447a0000
	fmul	DWORD PTR _tol$[ebp]
	fcomp	DWORD PTR tv86[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76988

; 856  : 
; 857  : #if DEBUG_SOLVER && defined(wsprintf) && (FALSE)
; 858  : 	// Check that the residual is less than the tolerance
; 859  : 		int ii, jj;
; 860  : 		wsprintf(buf, "\nCollision equations not converged\n");
; 861  : 		WriteLogEntry(buf);
; 862  : 		wsprintf(buf, "res = %d; tol = %d; its = %d\n\n", (int)(1.0e6 * res), (int)(1.0e6 * tol), nIts);
; 863  : 		WriteLogEntry(buf);
; 864  : 		for (ii = 0; ii < NRows(&OrigCoefs); ii++) {
; 865  : 			WriteLogEntry("| ");
; 866  : 			for (jj = 0; jj < NRows(&OrigCoefs); jj++) {
; 867  : 				wsprintf(buf, "%8d ", (int)(1.0e6 * OrigCoefs.m[ii][jj]));
; 868  : 				WriteLogEntry(buf);
; 869  : 			}
; 870  : 			wsprintf(buf, "|   | %8d | %s | %8d |\n",
; 871  : 				(int)(1.0e6 * Soln.v[ii]), 
; 872  : 				(ii == NRows(&OrigCoefs) / 2)? " = ": "   ",
; 873  : 				(int)(1.0e6 * OrigRes.v[ii]));
; 874  : 			WriteLogEntry(buf);
; 875  : 		}
; 876  : 		//TellChris = TRUE;
; 877  : #endif
; 878  : #if USE_DEBUG_ROUTINES
; 879  : 	// A few checks
; 880  : 		DEBUG_Converged = FALSE;

	mov	BYTE PTR ?DEBUG_Converged@@3_NA, 0	; DEBUG_Converged

; 881  : 		DEBUG_Res = res;

	mov	eax, DWORD PTR _res$[ebp]
	mov	DWORD PTR ?DEBUG_Res@@3MA, eax

; 882  : #endif
; 883  : 		return;

	jmp	$L76973
$L76988:

; 884  : 
; 885  : 	} else {
; 886  : 
; 887  : #if USE_DEBUG_ROUTINES
; 888  : 		DEBUG_Converged = TRUE;

	mov	BYTE PTR ?DEBUG_Converged@@3_NA, 1	; DEBUG_Converged

; 889  : #endif
; 890  : 
; 891  : 	}
; 892  : 
; 893  : 	// Add up the linear and angular components of the impulse
; 894  : 	NThisBodySparks = 0;

	mov	DWORD PTR ?NThisBodySparks@@3HA, 0	; NThisBodySparks

; 895  : 	NThisBodySmoke = 0;

	mov	DWORD PTR ?NThisBodySmoke@@3HA, 0	; NThisBodySmoke

; 896  : 	body->Banged = TRUE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	BYTE PTR [eax+544], 1

; 897  : 	
; 898  : 	collInfo = body->BodyCollHead;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR _collInfo$[ebp], ecx

; 899  : 	for (iColl = 0; iColl < body->NBodyColls; iColl++) {

	mov	DWORD PTR _iColl$[ebp], 0
	jmp	SHORT $L76990
$L76991:
	mov	eax, DWORD PTR _iColl$[ebp]
	add	eax, 1
	mov	DWORD PTR _iColl$[ebp], eax
$L76990:
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _iColl$[ebp]
	cmp	ecx, DWORD PTR [eax+516]
	jge	$L76992

; 900  : 		Assert(collInfo != NULL);

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z@4JA
	add	eax, 85					; 00000055H
	push	eax
	cmp	DWORD PTR _collInfo$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 901  : 
; 902  : 		// Frictionless impulse
; 903  : 		if (body == collInfo->Body1) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L76994

; 904  : 			VecEqScalarVec(&collImpulse, Soln.v[iColl], PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[eax*4]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+60]
	fstp	DWORD PTR _collImpulse$[ebp]
	mov	eax, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[eax*4]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+64]
	fstp	DWORD PTR _collImpulse$[ebp+4]
	mov	eax, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[eax*4]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+68]
	fstp	DWORD PTR _collImpulse$[ebp+8]

; 905  : 		} else {

	jmp	SHORT $L76998
$L76994:

; 906  : 			VecEqScalarVec(&collImpulse, -Soln.v[iColl], PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[eax*4]
	fchs
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+60]
	fstp	DWORD PTR _collImpulse$[ebp]
	mov	eax, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[eax*4]
	fchs
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+64]
	fstp	DWORD PTR _collImpulse$[ebp+4]
	mov	eax, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[eax*4]
	fchs
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [ecx+68]
	fstp	DWORD PTR _collImpulse$[ebp+8]
$L76998:

; 907  : 		}
; 908  : 
; 909  : 		// Add friction
; 910  : 		AddBodyFriction(body, &collImpulse, collInfo);

	mov	eax, DWORD PTR _collInfo$[ebp]
	push	eax
	lea	ecx, DWORD PTR _collImpulse$[ebp]
	push	ecx
	mov	edx, DWORD PTR _body$[ebp]
	push	edx
	call	?AddBodyFriction@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PAUBodyCollInfoStruct@@@Z ; AddBodyFriction
	add	esp, 12					; 0000000cH

; 911  : 
; 912  : 		// Store
; 913  : 		VecPlusEqVec(&totImpulse, &collImpulse);

	fld	DWORD PTR _totImpulse$[ebp]
	fadd	DWORD PTR _collImpulse$[ebp]
	fstp	DWORD PTR _totImpulse$[ebp]
	fld	DWORD PTR _totImpulse$[ebp+4]
	fadd	DWORD PTR _collImpulse$[ebp+4]
	fstp	DWORD PTR _totImpulse$[ebp+4]
	fld	DWORD PTR _totImpulse$[ebp+8]
	fadd	DWORD PTR _collImpulse$[ebp+8]
	fstp	DWORD PTR _totImpulse$[ebp+8]

; 914  : 		CalcAngImpulse(&collImpulse, &collInfo->Pos1, &tmpVec);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+8]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+4]
	fmul	DWORD PTR [ecx+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collImpulse$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+8]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _collImpulse$[ebp]
	fmul	DWORD PTR [ecx+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 915  : 		VecPlusEqVec(&totAngImpulse, &tmpVec);

	fld	DWORD PTR _totAngImpulse$[ebp]
	fadd	DWORD PTR _tmpVec$[ebp]
	fstp	DWORD PTR _totAngImpulse$[ebp]
	fld	DWORD PTR _totAngImpulse$[ebp+4]
	fadd	DWORD PTR _tmpVec$[ebp+4]
	fstp	DWORD PTR _totAngImpulse$[ebp+4]
	fld	DWORD PTR _totAngImpulse$[ebp+8]
	fadd	DWORD PTR _tmpVec$[ebp+8]
	fstp	DWORD PTR _totAngImpulse$[ebp+8]

; 916  : 
; 917  : 		// Check for hard knocks
; 918  : 		knock = MulScalar(abs(Soln.v[iColl]), body->Centre.InvMass);

	mov	eax, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[eax*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77417
	mov	ecx, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[ecx*4]
	fstp	DWORD PTR tv248[ebp]
	jmp	SHORT $L77418
$L77417:
	mov	edx, DWORD PTR _iColl$[ebp]
	fld	DWORD PTR _Soln[edx*4]
	fchs
	fstp	DWORD PTR tv248[ebp]
$L77418:
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR tv248[ebp]
	fstp	DWORD PTR _knock$[ebp]

; 919  : 		if (knock > body->BangMag) {

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _knock$[ebp]
	fcomp	DWORD PTR [eax+548]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77002

; 920  : 			body->BangMag = knock;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _knock$[ebp]
	mov	DWORD PTR [eax+548], ecx

; 921  : 			CopyPlane(&collInfo->Plane, &body->BangPlane);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+552], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+556], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+560], edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+564], edx
$L77002:

; 922  : 		}
; 923  : 
; 924  : 		collInfo = collInfo->Next;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _collInfo$[ebp], ecx

; 925  : 	}

	jmp	$L76991
$L76992:

; 926  : 
; 927  : 	// Apply the impulses to the body
; 928  : 	ApplyBodyAngImpulse(body, &totAngImpulse);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _totAngImpulse$[ebp]
	fadd	DWORD PTR [eax+356]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+356]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _totAngImpulse$[ebp+4]
	fadd	DWORD PTR [eax+360]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _totAngImpulse$[ebp+8]
	fadd	DWORD PTR [eax+364]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+364]

; 929  : 	ApplyParticleImpulse(&body->Centre, &totImpulse);

	lea	eax, DWORD PTR _totImpulse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z ; ApplyParticleImpulse
	add	esp, 8
$L76973:

; 930  : 
; 931  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z ENDP	; ProcessBodyColls3
_TEXT	ENDS
PUBLIC	__real@42c80000
PUBLIC	__real@46fffe00
PUBLIC	__real@bf000000
EXTRN	?COL_MaterialInfo@@3PAUMaterialStruct@@A:BYTE	; COL_MaterialInfo
EXTRN	_rand:NEAR
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z:NEAR ; CreateSpark
EXTRN	?SparkProbability@@YAMM@Z:NEAR			; SparkProbability
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AddBodyFriction@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PAUBodyCollInfoStruct@@@Z
_TEXT	SEGMENT
tv348 = -132						; size = 4
tv345 = -128						; size = 4
_sparkVel$ = -60					; size = 12
_velTan$ = -48						; size = 12
_impTan$ = -36						; size = 12
_impTanMod$ = -24					; size = 4
_impTanMax$ = -20					; size = 4
_impTanLen$ = -16					; size = 4
_velTanLen$ = -12					; size = 4
_velDotNorm$ = -8					; size = 4
_impDotNorm$ = -4					; size = 4
_body$ = 8						; size = 4
_impulse$ = 12						; size = 4
_collInfo$ = 16						; size = 4
?AddBodyFriction@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PAUBodyCollInfoStruct@@@Z PROC NEAR ; AddBodyFriction, COMDAT

; 942  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 943  : 	REAL	impDotNorm, velDotNorm, velTanLen, impTanLen, impTanMax, impTanMod;
; 944  : 	VEC	impTan, velTan, sparkVel;
; 945  : 	
; 946  : 	impDotNorm = VecDotVec(impulse, PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _impulse$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _impulse$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _impulse$[ebp]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _impDotNorm$[ebp]

; 947  : 	if (impDotNorm < ZERO) {

	fld	DWORD PTR _impDotNorm$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L77020

; 948  : 		return;

	jmp	$L77007
$L77020:

; 949  : 	}
; 950  : 	velDotNorm = VecDotVec(&collInfo->Vel, PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+52]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+56]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 951  : 	VecPlusScalarVec(&collInfo->Vel, -velDotNorm, PlaneNormal(&collInfo->Plane), &velTan);

	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fadd	DWORD PTR [ecx+48]
	fstp	DWORD PTR _velTan$[ebp]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fadd	DWORD PTR [ecx+52]
	fstp	DWORD PTR _velTan$[ebp+4]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fadd	DWORD PTR [ecx+56]
	fstp	DWORD PTR _velTan$[ebp+8]

; 952  : 
; 953  : 	// Calculate sliding velocity
; 954  : 	velTanLen = Length(&velTan);

	fld	DWORD PTR _velTan$[ebp]
	fmul	DWORD PTR _velTan$[ebp]
	fld	DWORD PTR _velTan$[ebp+4]
	fmul	DWORD PTR _velTan$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _velTan$[ebp+8]
	fmul	DWORD PTR _velTan$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _velTanLen$[ebp]

; 955  : 
; 956  : 	// Create a spark
; 957  : #ifndef _PSX
; 958  : 	if ((collInfo->Material != NULL) && 
; 959  : 		(velTanLen > MIN_SPARK_VEL) &&
; 960  : 		BodyAllowsSparks(body)) 

	mov	eax, DWORD PTR _collInfo$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	$L77029
	fld	DWORD PTR _velTanLen$[ebp]
	fcomp	DWORD PTR __real@42c80000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L77029
	mov	eax, DWORD PTR _body$[ebp]
	movzx	ecx, BYTE PTR [eax+532]
	test	ecx, ecx
	je	$L77029

; 961  : 	{
; 962  : 		body->ScrapeMaterial = collInfo->Material - COL_MaterialInfo;	// Material number

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [eax+100]
	sub	eax, OFFSET FLAT:?COL_MaterialInfo@@3PAUMaterialStruct@@A ; COL_MaterialInfo
	cdq
	mov	ecx, 40					; 00000028H
	idiv	ecx
	mov	edx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [edx+536], eax

; 963  : 		body->LastScrapeTime = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+540], 0

; 964  : 
; 965  : 		if (MaterialAllowsSparks(collInfo->Material) && 
; 966  : 			(NThisBodySparks < MAX_SPARKS_PER_BODY) && 
; 967  : 			(frand(ONE) < SparkProbability(velTanLen)))

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1
	je	$L77029
	cmp	DWORD PTR ?NThisBodySparks@@3HA, 10	; NThisBodySparks, 0000000aH
	jge	$L77029
	call	_rand
	mov	DWORD PTR tv345[ebp], eax
	fild	DWORD PTR tv345[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	fstp	DWORD PTR tv348[ebp]
	mov	eax, DWORD PTR _velTanLen$[ebp]
	push	eax
	call	?SparkProbability@@YAMM@Z		; SparkProbability
	add	esp, 4
	fcomp	DWORD PTR tv348[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77029

; 968  : 		{
; 969  : 			NThisBodySparks++;

	mov	eax, DWORD PTR ?NThisBodySparks@@3HA	; NThisBodySparks
	add	eax, 1
	mov	DWORD PTR ?NThisBodySparks@@3HA, eax	; NThisBodySparks

; 970  : #ifdef _PC
; 971  : 			VecEqScalarVec(&sparkVel, -HALF, &velTan);

	fld	DWORD PTR __real@bf000000
	fmul	DWORD PTR _velTan$[ebp]
	fstp	DWORD PTR _sparkVel$[ebp]
	fld	DWORD PTR __real@bf000000
	fmul	DWORD PTR _velTan$[ebp+4]
	fstp	DWORD PTR _sparkVel$[ebp+4]
	fld	DWORD PTR __real@bf000000
	fmul	DWORD PTR _velTan$[ebp+8]
	fstp	DWORD PTR _sparkVel$[ebp+8]

; 972  : #endif
; 973  : #ifdef _N64
; 974  : 			VecEqScalarVec(&sparkVel, -0.1, &velTan);
; 975  : #endif
; 976  : 			CreateSpark(SPARK_SPARK, &collInfo->WorldPos, &sparkVel, HALF * velTanLen, 0);

	push	0
	push	0
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _velTanLen$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _sparkVel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	push	0
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H
$L77029:

; 977  : 		}
; 978  : 	}
; 979  : #endif
; 980  : 
; 981  : 	// Turn sliding velocity into tangential impulse
; 982  : 	//impTanLen = -wheel->Grip * impDotNorm;
; 983  : 	impTanLen = MulScalar(body->Centre.Grip, impDotNorm);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+180]
	fmul	DWORD PTR _impDotNorm$[ebp]
	fstp	DWORD PTR _impTanLen$[ebp]

; 984  : 	CopyVec(&velTan, &impTan);

	mov	eax, DWORD PTR _velTan$[ebp]
	mov	DWORD PTR _impTan$[ebp], eax
	mov	eax, DWORD PTR _velTan$[ebp+4]
	mov	DWORD PTR _impTan$[ebp+4], eax
	mov	eax, DWORD PTR _velTan$[ebp+8]
	mov	DWORD PTR _impTan$[ebp+8], eax

; 985  : 	VecMulScalar(&impTan, -impTanLen);

	fld	DWORD PTR _impTanLen$[ebp]
	fchs
	fmul	DWORD PTR _impTan$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _impTanLen$[ebp]
	fchs
	fmul	DWORD PTR _impTan$[ebp+4]
	fstp	DWORD PTR _impTan$[ebp+4]
	fld	DWORD PTR _impTanLen$[ebp]
	fchs
	fmul	DWORD PTR _impTan$[ebp+8]
	fstp	DWORD PTR _impTan$[ebp+8]

; 986  : 	impTanLen = MulScalar(impTanLen, velTanLen);

	fld	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _velTanLen$[ebp]
	fstp	DWORD PTR _impTanLen$[ebp]

; 987  : 
; 988  : 	// Scale sliding to friction cone
; 989  : 	impTanMax = MulScalar(MulScalar(HALF, TimeStep), MulScalar(body->Centre.Mass, body->Centre.Gravity));

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+192]
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx]
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _impTanMax$[ebp]

; 990  : 	if (impTanLen > impTanMax) {

	fld	DWORD PTR _impTanLen$[ebp]
	fcomp	DWORD PTR _impTanMax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77032

; 991  : 		impTanMod = DivScalar(impTanMax, impTanLen);

	fld	DWORD PTR _impTanMax$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fstp	DWORD PTR _impTanMod$[ebp]

; 992  : 		//VecDivScalar(&impTan, impTanLen / (TimeStep * collInfo->KineticFriction * body->Centre.Mass * body->Centre.Gravity));
; 993  : 		VecMulScalar(&impTan, impTanMod);

	fld	DWORD PTR _impTan$[ebp]
	fmul	DWORD PTR _impTanMod$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _impTan$[ebp+4]
	fmul	DWORD PTR _impTanMod$[ebp]
	fstp	DWORD PTR _impTan$[ebp+4]
	fld	DWORD PTR _impTan$[ebp+8]
	fmul	DWORD PTR _impTanMod$[ebp]
	fstp	DWORD PTR _impTan$[ebp+8]

; 994  : 		//impTanLen = Length(&impTan);
; 995  : 		impTanLen = impTanMax;

	mov	eax, DWORD PTR _impTanMax$[ebp]
	mov	DWORD PTR _impTanLen$[ebp], eax
$L77032:

; 996  : 
; 997  : 	}
; 998  : 	impTanMax = MulScalar(collInfo->StaticFriction, impDotNorm);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+88]
	fmul	DWORD PTR _impDotNorm$[ebp]
	fstp	DWORD PTR _impTanMax$[ebp]

; 999  : 	if (impTanLen > impTanMax) {

	fld	DWORD PTR _impTanLen$[ebp]
	fcomp	DWORD PTR _impTanMax$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77033

; 1000 : 		impTanMod = DivScalar(MulScalar(collInfo->KineticFriction, impDotNorm), impTanLen);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR _impDotNorm$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fstp	DWORD PTR _impTanMod$[ebp]

; 1001 : 		//VecDivScalar(&impTan, impTanLen / (collInfo->KineticFriction * impDotNorm))
; 1002 : 		VecMulScalar(&impTan, impTanMod);

	fld	DWORD PTR _impTan$[ebp]
	fmul	DWORD PTR _impTanMod$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _impTan$[ebp+4]
	fmul	DWORD PTR _impTanMod$[ebp]
	fstp	DWORD PTR _impTan$[ebp+4]
	fld	DWORD PTR _impTan$[ebp+8]
	fmul	DWORD PTR _impTanMod$[ebp]
	fstp	DWORD PTR _impTan$[ebp+8]
$L77033:

; 1003 : 	}
; 1004 : 
; 1005 : 	VecPlusEqVec(impulse, &impTan);

	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR _impTan$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR _impTan$[ebp+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR _impTan$[ebp+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [ecx+8]
$L77007:

; 1006 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddBodyFriction@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PAUBodyCollInfoStruct@@@Z ENDP ; AddBodyFriction
_TEXT	ENDS
PUBLIC	?DetectBodyWorldColls@@YAXPAUNewBodyStruct@@@Z	; DetectBodyWorldColls
PUBLIC	?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z ; DetectBodyPolyColls
EXTRN	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z:NEAR ; PosToCollGrid
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectBodyWorldColls@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_collPoly$ = -20					; size = 4
_collPolyPtr$ = -16					; size = 4
_collGrid$ = -12					; size = 4
_nCollPolys$ = -8					; size = 4
_iPoly$ = -4						; size = 4
_body$ = 8						; size = 4
?DetectBodyWorldColls@@YAXPAUNewBodyStruct@@@Z PROC NEAR ; DetectBodyWorldColls, COMDAT

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1019 : 	long	iPoly;
; 1020 : 	long	nCollPolys;
; 1021 : 	COLLGRID *collGrid;
; 1022 : 
; 1023 : #ifndef _PSX
; 1024 : 	NEWCOLLPOLY **collPolyPtr;
; 1025 : #endif
; 1026 : 	NEWCOLLPOLY *collPoly;
; 1027 : 
; 1028 : 	// Calculate the grid position and which polys to check against
; 1029 : 	collGrid = PosToCollGrid(&body->Centre.Pos);

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ; PosToCollGrid
	add	esp, 4
	mov	DWORD PTR _collGrid$[ebp], eax

; 1030 : 	if (collGrid == NULL) return;

	cmp	DWORD PTR _collGrid$[ebp], 0
	jne	SHORT $L77042
	jmp	SHORT $L77036
$L77042:

; 1031 : 
; 1032 : #ifndef _PSX
; 1033 : 	collPolyPtr = collGrid->CollPolyPtr;

	mov	eax, DWORD PTR _collGrid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _collPolyPtr$[ebp], ecx

; 1034 : #endif
; 1035 : 	nCollPolys = collGrid->NCollPolys;

	mov	eax, DWORD PTR _collGrid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nCollPolys$[ebp], ecx

; 1036 : 
; 1037 : 	for (iPoly = 0; iPoly < nCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L77043
$L77044:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L77043:
	mov	eax, DWORD PTR _iPoly$[ebp]
	cmp	eax, DWORD PTR _nCollPolys$[ebp]
	jge	SHORT $L77036

; 1038 : 
; 1039 : #ifndef _PSX
; 1040 : 		collPoly = collPolyPtr[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	mov	ecx, DWORD PTR _collPolyPtr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _collPoly$[ebp], edx

; 1041 : #else
; 1042 : 		collPoly = &COL_WorldCollPoly[collGrid->CollPolyIndices[iPoly]];
; 1043 : #endif
; 1044 : 
; 1045 : 		if (PolyCameraOnly(collPoly)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $L77046
	jmp	SHORT $L77044
$L77046:

; 1046 : 
; 1047 : 		// BODY - WORLD
; 1048 : 		DetectBodyPolyColls(body, collPoly);

	mov	eax, DWORD PTR _collPoly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z ; DetectBodyPolyColls
	add	esp, 8

; 1049 : 
; 1050 : 	}

	jmp	SHORT $L77044
$L77036:

; 1051 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectBodyWorldColls@@YAXPAUNewBodyStruct@@@Z ENDP	; DetectBodyWorldColls
_TEXT	ENDS
PUBLIC	?DetectConvexHullPolyColls@@YAHPAUNewBodyStruct@@PAUCollPolyStruct@@@Z ; DetectConvexHullPolyColls
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z
_TEXT	SEGMENT
_body$ = 8						; size = 4
_collPoly$ = 12						; size = 4
?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z PROC NEAR ; DetectBodyPolyColls, COMDAT

; 1061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1062 : 	DetectConvexHullPolyColls(body, collPoly);

	mov	eax, DWORD PTR _collPoly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?DetectConvexHullPolyColls@@YAHPAUNewBodyStruct@@PAUCollPolyStruct@@@Z ; DetectConvexHullPolyColls
	add	esp, 8

; 1063 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z ENDP ; DetectBodyPolyColls
_TEXT	ENDS
PUBLIC	__real@3e19999a
PUBLIC	__real@3dcccccd
PUBLIC	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
EXTRN	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z:NEAR ; SphereCollPoly
EXTRN	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ:NEAR ; NextBodyCollInfo
EXTRN	?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z:NEAR ; AdjustBodyColl
EXTRN	?DownVec@@3UVectorStruct@@A:BYTE		; DownVec
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DetectConvexHullPolyColls@@YAHPAUNewBodyStruct@@PAUCollPolyStruct@@@Z
_TEXT	SEGMENT
tv450 = -88						; size = 4
tv132 = -88						; size = 4
_nColls$ = -20						; size = 4
_collInfo$ = -16					; size = 4
_newPos$ = -12						; size = 4
_oldPos$ = -8						; size = 4
_iSphere$ = -4						; size = 4
_body$ = 8						; size = 4
_collPoly$ = 12						; size = 4
?DetectConvexHullPolyColls@@YAHPAUNewBodyStruct@@PAUCollPolyStruct@@@Z PROC NEAR ; DetectConvexHullPolyColls, COMDAT

; 1069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1070 : 	int		iSphere;
; 1071 : 	VERTEX	*oldPos, *newPos;
; 1072 : 	COLLINFO_BODY *collInfo;
; 1073 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 1074 : 
; 1075 : 	// Quick Bounding-box check
; 1076 : 	if (!BBTestYXZ(&collPoly->BBox, &body->CollSkin.BBox)) return 0;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+96]
	fcomp	DWORD PTR [ecx+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77435
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+100]
	fcomp	DWORD PTR [eax+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77435
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+88]
	fcomp	DWORD PTR [edx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77435
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+92]
	fcomp	DWORD PTR [ecx+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77435
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+104]
	fcomp	DWORD PTR [eax+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77435
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+108]
	fcomp	DWORD PTR [edx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77435
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $L77436
$L77435:
	mov	DWORD PTR tv132[ebp], 0
$L77436:
	cmp	DWORD PTR tv132[ebp], 0
	jne	SHORT $L77060
	xor	eax, eax
	jmp	$L77054
$L77060:

; 1077 : 
; 1078 : #ifdef _PSX
; 1079 : 	NPassed++;
; 1080 : #endif
; 1081 : 
; 1082 : 	// Loop over collision spheres
; 1083 : 	for (iSphere = 0; iSphere < body->CollSkin.NSpheres; iSphere++) {

	mov	DWORD PTR _iSphere$[ebp], 0
	jmp	SHORT $L77061
$L77062:
	mov	eax, DWORD PTR _iSphere$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSphere$[ebp], eax
$L77061:
	mov	eax, DWORD PTR _body$[ebp]
	movsx	ecx, WORD PTR [eax+408]
	cmp	DWORD PTR _iSphere$[ebp], ecx
	jge	$L77063

; 1084 : 
; 1085 : 		// allocate the collision info storage
; 1086 : 		if ((collInfo = NextBodyCollInfo()) == NULL) return nColls;

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _collInfo$[ebp], eax
	cmp	DWORD PTR _collInfo$[ebp], 0
	jne	SHORT $L77064
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L77054
$L77064:

; 1087 : 
; 1088 : 		oldPos = &body->CollSkin.OldWorldSphere[iSphere].Pos;

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR [ecx+404]
	mov	DWORD PTR _oldPos$[ebp], eax

; 1089 : 		newPos = &body->CollSkin.WorldSphere[iSphere].Pos;

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR [ecx+400]
	mov	DWORD PTR _newPos$[ebp], eax

; 1090 : 
; 1091 : 		// Actual collision test against poly
; 1092 : 		if (!SphereCollPoly(oldPos, newPos, body->CollSkin.WorldSphere[iSphere].Radius, collPoly, &collInfo->Plane, &collInfo->Pos1, &collInfo->WorldPos, &collInfo->Depth, &collInfo->Time)) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _collPoly$[ebp]
	push	edx
	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR [edx+eax+12]
	push	eax
	mov	ecx, DWORD PTR _newPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oldPos$[ebp]
	push	edx
	call	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z ; SphereCollPoly
	add	esp, 36					; 00000024H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L77065

; 1093 : 			continue;

	jmp	$L77062
$L77065:

; 1094 : 		}
; 1095 : 		VecPlusEqVec(&collInfo->Pos1, newPos);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+16]

; 1096 : 		VecMinusEqVec(&collInfo->Pos1, &body->Centre.Pos);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+16]

; 1097 : 
; 1098 : 		// Check velocity is not directed away from face
; 1099 : 		VecCrossVec(&body->AngVel, &collInfo->Pos1, &collInfo->Vel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1100 : 		VecPlusEqVec(&collInfo->Vel, &body->Centre.Vel);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+52]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+56]

; 1101 : 		if (VecDotVec(&collInfo->Vel, PlaneNormal(&collPoly->Plane)) >= ZERO) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+52]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+56]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L77069

; 1102 : 			continue;

	jmp	$L77062
$L77069:

; 1103 : 		}
; 1104 : 
; 1105 : 		// COLLISION OCCURRED
; 1106 : 
; 1107 : 		collInfo->Body1 = body;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1108 : 		collInfo->Body2 = &BDY_MassiveBody;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+20], OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A ; BDY_MassiveBody

; 1109 : 		SetVecZero(&collInfo->Pos2);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1110 : 		CopyPlane(&collPoly->Plane, &collInfo->Plane);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+72], edx

; 1111 : 		collInfo->Grip = MulScalar(body->Centre.Grip, COL_MaterialInfo[collPoly->Material].Gripiness);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+180]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+8]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+84]

; 1112 : 		collInfo->StaticFriction = MulScalar(body->Centre.StaticFriction, COL_MaterialInfo[collPoly->Material].Roughness);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+184]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+88]

; 1113 : 		collInfo->KineticFriction = MulScalar(body->Centre.KineticFriction, COL_MaterialInfo[collPoly->Material].Roughness);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+92]

; 1114 : 		collInfo->Restitution = MulScalar(body->Centre.Hardness, COL_MaterialInfo[collPoly->Material].Hardness);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+172]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+12]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+96]

; 1115 : 		collInfo->Material = &COL_MaterialInfo[collPoly->Material];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:?COL_MaterialInfo@@3PAUMaterialStruct@@A ; COL_MaterialInfo
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 1116 : 		if (abs(VecDotVec(PlaneNormal(&collInfo->Plane), &DownVec)) < 0.15f) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77437
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv450[ebp]
	jmp	SHORT $L77438
$L77437:
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR tv450[ebp]
$L77438:
	fld	DWORD PTR tv450[ebp]
	fcomp	DWORD PTR __real@3e19999a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L77079

; 1117 : 			collInfo->StaticFriction = MulScalar(Real(0.1), collInfo->StaticFriction);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+88]
	fmul	DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+88]

; 1118 : 			collInfo->KineticFriction = MulScalar(Real(0.1), collInfo->KineticFriction);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+92]

; 1119 : 			collInfo->Restitution = collInfo->Restitution + 0.1f;

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+96]
	fadd	DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+96]
$L77079:

; 1120 : 		}
; 1121 : 
; 1122 : 		// Adjust collision info according to the material
; 1123 : 		AdjustBodyColl(collInfo, collInfo->Material);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	push	edx
	call	?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z ; AdjustBodyColl
	add	esp, 8

; 1124 : 
; 1125 : 		AddBodyColl(body, collInfo);

	mov	eax, DWORD PTR _collInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 1126 : 		nColls++;

	mov	eax, DWORD PTR _nColls$[ebp]
	add	eax, 1
	mov	DWORD PTR _nColls$[ebp], eax

; 1127 : 
; 1128 : 	}

	jmp	$L77062
$L77063:

; 1129 : 
; 1130 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L77054:

; 1131 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectConvexHullPolyColls@@YAHPAUNewBodyStruct@@PAUCollPolyStruct@@@Z ENDP ; DetectConvexHullPolyColls
_TEXT	ENDS
PUBLIC	?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z	; DetectBodyBodyColls
PUBLIC	?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z	; DetectHullHullColls
PUBLIC	?DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z ; DetectSphereSphereColls
PUBLIC	?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z	; DetectHullPolyColls
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT
_body1$ = 8						; size = 4
_body2$ = 12						; size = 4
?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z PROC NEAR ; DetectBodyBodyColls, COMDAT

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1143 : 
; 1144 : 	if (IsBodyConvex(body1)) {

	mov	eax, DWORD PTR _body1$[ebp]
	cmp	DWORD PTR [eax+472], 0
	jne	SHORT $L77086

; 1145 : 		if (IsBodyPoly(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 2
	jne	SHORT $L77087

; 1146 : 
; 1147 : 			return DetectHullPolyColls(body1, body2);

	mov	eax, DWORD PTR _body2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z ; DetectHullPolyColls
	add	esp, 8
	jmp	$L77085
$L77087:

; 1148 : 
; 1149 : 		} else if (IsBodySphere(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 1
	jne	SHORT $L77089

; 1150 : 
; 1151 : 			return DetectHullHullColls(body2, body1);

	mov	eax, DWORD PTR _body1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	push	ecx
	call	?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z ; DetectHullHullColls
	add	esp, 8
	jmp	$L77085
$L77089:

; 1152 : 
; 1153 : 		} else if (IsBodyConvex(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 0
	jne	SHORT $L77088

; 1154 : 
; 1155 : 			return DetectHullHullColls(body1, body2);

	mov	eax, DWORD PTR _body2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z ; DetectHullHullColls
	add	esp, 8
	jmp	$L77085
$L77088:

; 1156 : 
; 1157 : 		}
; 1158 : 	}
; 1159 : 	else if (IsBodySphere(body1)) {

	jmp	$L77092
$L77086:
	mov	eax, DWORD PTR _body1$[ebp]
	cmp	DWORD PTR [eax+472], 1
	jne	SHORT $L77093

; 1160 : 		if (IsBodyPoly(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 2
	jne	SHORT $L77094

; 1161 : 
; 1162 : 			return DetectHullPolyColls(body1, body2);

	mov	eax, DWORD PTR _body2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z ; DetectHullPolyColls
	add	esp, 8
	jmp	$L77085
$L77094:

; 1163 : 
; 1164 : 		} else if (IsBodySphere(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 1
	jne	SHORT $L77096

; 1165 : 
; 1166 : 			return DetectSphereSphereColls(body1, body2);

	mov	eax, DWORD PTR _body2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z ; DetectSphereSphereColls
	add	esp, 8
	jmp	SHORT $L77085
$L77096:

; 1167 : 
; 1168 : 		} else if (IsBodyConvex(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 0
	jne	SHORT $L77095

; 1169 : 
; 1170 : 			return DetectHullHullColls(body1, body2);

	mov	eax, DWORD PTR _body2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z ; DetectHullHullColls
	add	esp, 8
	jmp	SHORT $L77085
$L77095:

; 1171 : 
; 1172 : 		}
; 1173 : 	}
; 1174 : 	else if (IsBodyPoly(body1)) {

	jmp	SHORT $L77092
$L77093:
	mov	eax, DWORD PTR _body1$[ebp]
	cmp	DWORD PTR [eax+472], 2
	jne	SHORT $L77092

; 1175 : 		if (IsBodyPoly(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 2
	jne	SHORT $L77101

; 1176 : 
; 1177 : 			return 0;

	xor	eax, eax
	jmp	SHORT $L77085
$L77101:

; 1178 : 			
; 1179 : 		} else if (IsBodySphere(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 1
	jne	SHORT $L77103

; 1180 : 
; 1181 : 			return DetectHullPolyColls(body2, body1);

	mov	eax, DWORD PTR _body1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	push	ecx
	call	?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z ; DetectHullPolyColls
	add	esp, 8
	jmp	SHORT $L77085
$L77103:

; 1182 : 
; 1183 : 		} else if (IsBodyConvex(body2)) {

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 0
	jne	SHORT $L77092

; 1184 : 
; 1185 : 			return DetectHullPolyColls(body2, body1);

	mov	eax, DWORD PTR _body1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	push	ecx
	call	?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z ; DetectHullPolyColls
	add	esp, 8
	jmp	SHORT $L77085
$L77092:

; 1186 : 
; 1187 : 		}
; 1188 : 	}
; 1189 : 
; 1190 : 	return 0;

	xor	eax, eax
$L77085:

; 1191 : 
; 1192 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z ENDP	; DetectBodyBodyColls
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z@4JA ; `DetectHullPolyColls'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z@4JA DD 04abH ; `DetectHullPolyColls'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT
tv538 = -96						; size = 4
tv196 = -96						; size = 4
tv149 = -96						; size = 4
tv73 = -93						; size = 1
_nColls$ = -28						; size = 4
_collPoly$ = -24					; size = 4
_collInfo$ = -20					; size = 4
_newPos$ = -16						; size = 4
_oldPos$ = -12						; size = 4
_iPoly$ = -8						; size = 4
_iSphere$ = -4						; size = 4
_body1$ = 8						; size = 4
_body2$ = 12						; size = 4
?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z PROC NEAR ; DetectHullPolyColls, COMDAT

; 1195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1196 : 	int		iSphere, iPoly;
; 1197 : 	VERTEX	*oldPos, *newPos;
; 1198 : 	COLLINFO_BODY *collInfo;
; 1199 : 	NEWCOLLPOLY *collPoly;
; 1200 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 1201 : 
; 1202 : 	Assert(IsBodyPoly(body2) && !IsBodyPoly(body1));

	mov	eax, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [eax+472], 2
	jne	SHORT $L77447
	mov	ecx, DWORD PTR _body1$[ebp]
	cmp	DWORD PTR [ecx+472], 2
	je	SHORT $L77447
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $L77448
$L77447:
	mov	BYTE PTR tv73[ebp], 0
$L77448:
	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z@4JA
	add	edx, 7
	push	edx
	mov	al, BYTE PTR tv73[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1203 : 
; 1204 : 	if (!BBTestYXZ(&body1->CollSkin.BBox, &body2->CollSkin.BBox)) return 0;

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+452]
	fcomp	DWORD PTR [ecx+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L77449
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [edx+456]
	fcomp	DWORD PTR [eax+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77449
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	edx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [ecx+444]
	fcomp	DWORD PTR [edx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77449
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+448]
	fcomp	DWORD PTR [ecx+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77449
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [edx+460]
	fcomp	DWORD PTR [eax+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77449
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	edx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [ecx+464]
	fcomp	DWORD PTR [edx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77449
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $L77450
$L77449:
	mov	DWORD PTR tv149[ebp], 0
$L77450:
	cmp	DWORD PTR tv149[ebp], 0
	jne	SHORT $L77118
	xor	eax, eax
	jmp	$L77109
$L77118:

; 1205 : 
; 1206 : 	for (iPoly = 0; iPoly < body2->CollSkin.NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L77119
$L77120:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L77119:
	mov	eax, DWORD PTR _body2$[ebp]
	movsx	ecx, WORD PTR [eax+416]
	cmp	DWORD PTR _iPoly$[ebp], ecx
	jge	$L77121

; 1207 : 		collPoly = &body2->CollSkin.CollPoly[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _body2$[ebp]
	add	eax, DWORD PTR [ecx+412]
	mov	DWORD PTR _collPoly$[ebp], eax

; 1208 : 		
; 1209 : 		// Quick Bounding-box check
; 1210 : 		if (!BBTestYXZ(&collPoly->BBox, &body1->CollSkin.BBox)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+96]
	fcomp	DWORD PTR [ecx+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77451
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [edx+100]
	fcomp	DWORD PTR [eax+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77451
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [ecx+88]
	fcomp	DWORD PTR [edx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77451
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+92]
	fcomp	DWORD PTR [ecx+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77451
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [edx+104]
	fcomp	DWORD PTR [eax+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77451
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [ecx+108]
	fcomp	DWORD PTR [edx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77451
	mov	DWORD PTR tv196[ebp], 1
	jmp	SHORT $L77452
$L77451:
	mov	DWORD PTR tv196[ebp], 0
$L77452:
	cmp	DWORD PTR tv196[ebp], 0
	jne	SHORT $L77122
	jmp	$L77120
$L77122:

; 1211 : 
; 1212 : 		// Loop over collision spheres
; 1213 : 		for (iSphere = 0; iSphere < body1->CollSkin.NSpheres; iSphere++) {

	mov	DWORD PTR _iSphere$[ebp], 0
	jmp	SHORT $L77123
$L77124:
	mov	eax, DWORD PTR _iSphere$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSphere$[ebp], eax
$L77123:
	mov	eax, DWORD PTR _body1$[ebp]
	movsx	ecx, WORD PTR [eax+408]
	cmp	DWORD PTR _iSphere$[ebp], ecx
	jge	$L77125

; 1214 : 
; 1215 : 			if ((collInfo = NextBodyCollInfo()) == NULL) return nColls;

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _collInfo$[ebp], eax
	cmp	DWORD PTR _collInfo$[ebp], 0
	jne	SHORT $L77126
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L77109
$L77126:

; 1216 : 
; 1217 : 			oldPos = &body1->CollSkin.OldWorldSphere[iSphere].Pos;

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body1$[ebp]
	add	eax, DWORD PTR [ecx+404]
	mov	DWORD PTR _oldPos$[ebp], eax

; 1218 : 			newPos = &body1->CollSkin.WorldSphere[iSphere].Pos;

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body1$[ebp]
	add	eax, DWORD PTR [ecx+400]
	mov	DWORD PTR _newPos$[ebp], eax

; 1219 : 
; 1220 : 			// Actual collision test against poly
; 1221 : 			if (!SphereCollPoly(oldPos, newPos, body1->CollSkin.WorldSphere[iSphere].Radius, collPoly, &collInfo->Plane, &collInfo->Pos1, &collInfo->WorldPos, &collInfo->Depth, &collInfo->Time)) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _collPoly$[ebp]
	push	edx
	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR [edx+eax+12]
	push	eax
	mov	ecx, DWORD PTR _newPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oldPos$[ebp]
	push	edx
	call	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z ; SphereCollPoly
	add	esp, 36					; 00000024H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L77127

; 1222 : 				continue;

	jmp	$L77124
$L77127:

; 1223 : 			}
; 1224 : 			VecPlusEqVec(&collInfo->Pos1, newPos);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+16]

; 1225 : 			VecMinusEqVec(&collInfo->Pos1, &body1->Centre.Pos);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+16]

; 1226 : 
; 1227 : 			// Check velocity is not directed away from face
; 1228 : 			VecCrossVec(&body1->AngVel, &collInfo->Pos1, &collInfo->Vel);

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1229 : 			VecPlusEqVec(&collInfo->Vel, &body1->Centre.Vel);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+52]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+56]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+56]

; 1230 : 			VecMinusEqVec(&collInfo->Vel, &body2->Centre.Vel);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+56]

; 1231 : 			if (VecDotVec(&collInfo->Vel, PlaneNormal(&collPoly->Plane)) >= ZERO) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+52]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+56]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L77131

; 1232 : 				continue;

	jmp	$L77124
$L77131:

; 1233 : 			}
; 1234 : 
; 1235 : 			// COLLISION OCCURRED
; 1236 : 
; 1237 : 			collInfo->Body1 = body1;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1238 : 			collInfo->Body2 = &BDY_MassiveBody;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+20], OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A ; BDY_MassiveBody

; 1239 : 			SetVecZero(&collInfo->Pos2);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1240 : 			CopyPlane(&collPoly->Plane, &collInfo->Plane);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+72], edx

; 1241 : 			collInfo->Grip = MulScalar(body1->Centre.Grip, COL_MaterialInfo[collPoly->Material].Gripiness);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+180]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+8]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+84]

; 1242 : 			collInfo->StaticFriction = MulScalar(body1->Centre.StaticFriction, COL_MaterialInfo[collPoly->Material].Roughness);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+184]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+88]

; 1243 : 			collInfo->KineticFriction = MulScalar(body1->Centre.KineticFriction, COL_MaterialInfo[collPoly->Material].Roughness);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+92]

; 1244 : 			collInfo->Restitution = MulScalar(body1->Centre.Hardness, COL_MaterialInfo[collPoly->Material].Hardness);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+172]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 40					; 00000028H
	fmul	DWORD PTR ?COL_MaterialInfo@@3PAUMaterialStruct@@A[edx+12]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [eax+96]

; 1245 : 			collInfo->Material = &COL_MaterialInfo[collPoly->Material];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:?COL_MaterialInfo@@3PAUMaterialStruct@@A ; COL_MaterialInfo
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 1246 : 			if (abs(VecDotVec(PlaneNormal(&collInfo->Plane), &DownVec)) < 0.15f) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77453
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv538[ebp]
	jmp	SHORT $L77454
$L77453:
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR tv538[ebp]
$L77454:
	fld	DWORD PTR tv538[ebp]
	fcomp	DWORD PTR __real@3e19999a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L77141

; 1247 : 				collInfo->StaticFriction = MulScalar(Real(0.1), collInfo->StaticFriction);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+88]
	fmul	DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+88]

; 1248 : 				collInfo->KineticFriction = MulScalar(Real(0.1), collInfo->KineticFriction);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [ecx+92]
$L77141:

; 1249 : 			}
; 1250 : 
; 1251 : 			// Adjust collision info according to the material
; 1252 : 			AdjustBodyColl(collInfo, collInfo->Material);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	push	edx
	call	?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z ; AdjustBodyColl
	add	esp, 8

; 1253 : 
; 1254 : 			AddBodyColl(body1, collInfo);

	mov	eax, DWORD PTR _collInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 1255 : 			nColls++;

	mov	eax, DWORD PTR _nColls$[ebp]
	add	eax, 1
	mov	DWORD PTR _nColls$[ebp], eax

; 1256 : 
; 1257 : 		}

	jmp	$L77124
$L77125:

; 1258 : 
; 1259 : 	}

	jmp	$L77120
$L77121:

; 1260 : 
; 1261 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L77109:

; 1262 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectHullPolyColls@@YAHPAUNewBodyStruct@@0@Z ENDP	; DetectHullPolyColls
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z@4JA ; `DetectSphereSphereColls'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z@4JA DD 04f1H ; `DetectSphereSphereColls'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT
_sphere2$ = -32						; size = 4
_sphere1$ = -28						; size = 4
_bodyColl2$ = -24					; size = 4
_bodyColl1$ = -20					; size = 4
_dR$ = -16						; size = 12
_dRLen$ = -4						; size = 4
_body1$ = 8						; size = 4
_body2$ = 12						; size = 4
?DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z PROC NEAR ; DetectSphereSphereColls, COMDAT

; 1265 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1266 : 	REAL	dRLen;
; 1267 : 	VEC	dR;
; 1268 : 	COLLINFO_BODY	*bodyColl1, *bodyColl2;
; 1269 : 	SPHERE *sphere1, *sphere2;
; 1270 : 
; 1271 : 	sphere1 = &body1->CollSkin.WorldSphere[0];

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR _sphere1$[ebp], ecx

; 1272 : 	sphere2 = &body2->CollSkin.WorldSphere[0];

	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR _sphere2$[ebp], ecx

; 1273 : 
; 1274 : 	Assert(IsBodySphere(body1));

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z@4JA
	add	eax, 9
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	cmp	DWORD PTR [ecx+472], 1
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1275 : 	Assert(IsBodySphere(body2));

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z@4JA
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [ecx+472], 1
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1276 : 
; 1277 : 	// Relative position and separation
; 1278 : 	VecMinusVec(&sphere1->Pos, &sphere2->Pos, &dR);

	mov	eax, DWORD PTR _sphere1$[ebp]
	mov	ecx, DWORD PTR _sphere2$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _sphere1$[ebp]
	mov	ecx, DWORD PTR _sphere2$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _sphere1$[ebp]
	mov	ecx, DWORD PTR _sphere2$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 1279 : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 1280 : 
; 1281 : 	// Check for collision
; 1282 : 	if (dRLen > sphere1->Radius + sphere2->Radius) return 0;

	mov	eax, DWORD PTR _sphere1$[ebp]
	mov	ecx, DWORD PTR _sphere2$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+12]
	fcomp	DWORD PTR _dRLen$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L77156
	xor	eax, eax
	jmp	$L77147
$L77156:

; 1283 : 
; 1284 : 	if ((bodyColl1 = NextBodyCollInfo()) == NULL) return 0;

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _bodyColl1$[ebp], eax
	cmp	DWORD PTR _bodyColl1$[ebp], 0
	jne	SHORT $L77157
	xor	eax, eax
	jmp	$L77147
$L77157:

; 1285 : 	AddBodyColl(body1, bodyColl1);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 1286 : 	if ((bodyColl2 = NextBodyCollInfo()) == NULL) {

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _bodyColl2$[ebp], eax
	cmp	DWORD PTR _bodyColl2$[ebp], 0
	jne	SHORT $L77158

; 1287 : 		RemoveBodyColl(body1, bodyColl1);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z ; RemoveBodyColl
	add	esp, 8

; 1288 : 		return 0;

	xor	eax, eax
	jmp	$L77147
$L77158:

; 1289 : 	}
; 1290 : 	AddBodyColl(body2, bodyColl2);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 1291 : 
; 1292 : 	bodyColl1->Body1 = body1;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1293 : 	bodyColl1->Body2 = body2;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1294 : 	bodyColl2->Body1 = body2;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1295 : 	bodyColl2->Body2 = body1;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1296 : 
; 1297 : 	bodyColl1->Depth = (dRLen - sphere1->Radius - sphere2->Radius) * HALF;

	mov	eax, DWORD PTR _sphere1$[ebp]
	fld	DWORD PTR _dRLen$[ebp]
	fsub	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _sphere2$[ebp]
	fsub	DWORD PTR [ecx+12]
	fmul	DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+76]

; 1298 : 	bodyColl2->Depth = bodyColl1->Depth;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx

; 1299 : 
; 1300 : 	// Collision plane
; 1301 : 	if (dRLen > SMALL_REAL) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77159

; 1302 : 		CopyVec(&dR, PlaneNormal(&bodyColl1->Plane));

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	mov	DWORD PTR [eax+60], ecx
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp+4]
	mov	DWORD PTR [eax+64], ecx
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp+8]
	mov	DWORD PTR [eax+68], ecx

; 1303 : 		VecDivScalar(PlaneNormal(&bodyColl1->Plane), dRLen);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+60]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+64]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+68]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+68]

; 1304 : 		bodyColl1->Time = ONE - DivScalar(bodyColl1->Depth, dRLen);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+76]
	fdiv	DWORD PTR _dRLen$[ebp]
	fsubr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+80]

; 1305 : 	} else {

	jmp	SHORT $L77166
$L77159:

; 1306 : 		SetVec(PlaneNormal(&bodyColl1->Plane), ONE, ZERO, ZERO);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	DWORD PTR [eax+60], 1065353216		; 3f800000H
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	DWORD PTR [eax+64], 0
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	DWORD PTR [eax+68], 0

; 1307 : 		bodyColl1->Time = ONE;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	DWORD PTR [eax+80], 1065353216		; 3f800000H
$L77166:

; 1308 : 	}
; 1309 : 	FlipPlane(&bodyColl1->Plane, &bodyColl2->Plane);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+60]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+64]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+68]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+72]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+72]

; 1310 : 	bodyColl2->Time = bodyColl1->Time;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx

; 1311 : 
; 1312 : 	// collision positions
; 1313 : 	VecPlusScalarVec(&sphere1->Pos, sphere1->Radius, PlaneNormal(&bodyColl1->Plane), &bodyColl1->Pos1);

	mov	eax, DWORD PTR _sphere1$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _sphere1$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _sphere1$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _sphere1$[ebp]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _sphere1$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _sphere1$[ebp]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+16]

; 1314 : 	VecPlusScalarVec(&sphere2->Pos, -sphere2->Radius, PlaneNormal(&bodyColl1->Plane), &bodyColl1->Pos2);

	mov	eax, DWORD PTR _sphere2$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _sphere2$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _sphere2$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _sphere2$[ebp]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _sphere2$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _sphere2$[ebp]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+32]

; 1315 : 	VecMinusEqVec(&bodyColl1->Pos1, &body1->Centre.Pos);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+16]

; 1316 : 	VecMinusEqVec(&bodyColl1->Pos2, &body2->Centre.Pos);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+32]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+32]

; 1317 : 	VecPlusScalarVec(&sphere1->Pos, HALF, &dR, &bodyColl1->WorldPos);

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _sphere1$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+36]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _sphere1$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+40]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _sphere1$[ebp]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+44]

; 1318 : 	CopyVec(&bodyColl1->Pos2, &bodyColl2->Pos1);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+16], edx

; 1319 : 	CopyVec(&bodyColl1->Pos1, &bodyColl2->Pos2);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+32], edx

; 1320 : 	CopyVec(&bodyColl1->WorldPos, &bodyColl2->WorldPos);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 1321 : 	
; 1322 : 	// collsion velocity
; 1323 : 	VecCrossVec(&body1->AngVel, &bodyColl1->Pos1, &bodyColl1->Vel);

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1324 : 	VecPlusEqVec(&bodyColl1->Vel, &body1->Centre.Vel);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+52]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+56]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+56]

; 1325 : 	VecCrossVec(&body2->AngVel, &bodyColl2->Pos1, &bodyColl2->Vel);

	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1326 : 	VecPlusEqVec(&bodyColl2->Vel, &body2->Centre.Vel);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+52]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+56]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [edx+56]

; 1327 : 	VecMinusEqVec(&bodyColl1->Vel, &bodyColl2->Vel);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+56]

; 1328 : 	CopyVec(&bodyColl1->Vel, &bodyColl2->Vel);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 1329 : 	NegateVec(&bodyColl2->Vel);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+48]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+52]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+56]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1330 : 
; 1331 : 
; 1332 : 	// Other stuff
; 1333 : 	bodyColl1->Grip = MulScalar(body1->Centre.Grip, body2->Centre.Grip);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+180]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+180]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+84]

; 1334 : 	bodyColl1->StaticFriction = MulScalar(body1->Centre.StaticFriction, body2->Centre.StaticFriction);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+184]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+88]

; 1335 : 	bodyColl1->KineticFriction = MulScalar(body1->Centre.KineticFriction, body2->Centre.KineticFriction);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+92]

; 1336 : 	bodyColl1->Restitution = MulScalar(body1->Centre.Hardness, body2->Centre.Hardness);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+172]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+172]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+96]

; 1337 : 	bodyColl1->Material = NULL;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	DWORD PTR [eax+100], 0

; 1338 : 	
; 1339 : 	bodyColl2->Grip = bodyColl1->Grip;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx

; 1340 : 	bodyColl2->StaticFriction = bodyColl1->StaticFriction;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx

; 1341 : 	bodyColl2->KineticFriction = bodyColl1->KineticFriction;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx

; 1342 : 	bodyColl2->Restitution = bodyColl1->Restitution;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx

; 1343 : 	bodyColl2->Material = NULL;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	DWORD PTR [eax+100], 0

; 1344 : 
; 1345 : 	return 1;

	mov	eax, 1
$L77147:

; 1346 : 
; 1347 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectSphereSphereColls@@YAHPAUNewBodyStruct@@0@Z ENDP	; DetectSphereSphereColls
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z@4JA ; `DetectHullHullColls'::`2'::__LINE__Var
EXTRN	?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z:NEAR ; SphereConvex
;	COMDAT ?__LINE__Var@?1??DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z@4JA DD 0547H ; `DetectHullHullColls'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z
_TEXT	SEGMENT
tv187 = -136						; size = 4
tv88 = -133						; size = 1
tv69 = -133						; size = 1
_bodyColl2$ = -68					; size = 4
_bodyColl1$ = -64					; size = 4
_vel2$ = -60						; size = 12
_vel1$ = -48						; size = 12
_dR$ = -36						; size = 12
_ePos$ = -24						; size = 4
_sPos$ = -20						; size = 4
_radius$ = -16						; size = 4
_nColls$ = -12						; size = 4
_iSphere$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_body1$ = 8						; size = 4
_body2$ = 12						; size = 4
?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z PROC NEAR ; DetectHullHullColls, COMDAT

; 1351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 1352 : 	int		iSkin, iSphere;
; 1353 : 	int		nColls;
; 1354 : 	REAL	radius;
; 1355 : 	VEC	*sPos, *ePos, dR, vel1, vel2;
; 1356 : 	COLLINFO_BODY	*bodyColl1, *bodyColl2;
; 1357 : 	
; 1358 : 	Assert((body1 != NULL) && (body2 != NULL));

	cmp	DWORD PTR _body1$[ebp], 0
	je	SHORT $L77459
	cmp	DWORD PTR _body2$[ebp], 0
	je	SHORT $L77459
	mov	BYTE PTR tv69[ebp], 1
	jmp	SHORT $L77460
$L77459:
	mov	BYTE PTR tv69[ebp], 0
$L77460:
	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z@4JA
	add	eax, 7
	push	eax
	mov	cl, BYTE PTR tv69[ebp]
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1359 : 	Assert(IsBodyConvex(body2));

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z@4JA
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	cmp	DWORD PTR [ecx+472], 0
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1360 : 	Assert(IsBodySphere(body1) || IsBodyConvex(body1));

	mov	eax, DWORD PTR _body1$[ebp]
	cmp	DWORD PTR [eax+472], 1
	je	SHORT $L77461
	mov	ecx, DWORD PTR _body1$[ebp]
	cmp	DWORD PTR [ecx+472], 0
	je	SHORT $L77461
	mov	BYTE PTR tv88[ebp], 0
	jmp	SHORT $L77462
$L77461:
	mov	BYTE PTR tv88[ebp], 1
$L77462:
	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z@4JA
	add	edx, 9
	push	edx
	mov	al, BYTE PTR tv88[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1361 : 
; 1362 : 	// Relative position
; 1363 : 	VecMinusVec(&body1->Centre.Pos, &body2->Centre.Pos, &dR);

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dR$[ebp+8]

; 1364 : 
; 1365 : 	// Bounding box test
; 1366 : 	if (!BBTestXZY(&body2->CollSkin.BBox, &body1->CollSkin.BBox)) return 0;

	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+444]
	fcomp	DWORD PTR [ecx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L77463
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [edx+448]
	fcomp	DWORD PTR [eax+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77463
	mov	ecx, DWORD PTR _body2$[ebp]
	mov	edx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [ecx+460]
	fcomp	DWORD PTR [edx+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77463
	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+464]
	fcomp	DWORD PTR [ecx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77463
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [edx+452]
	fcomp	DWORD PTR [eax+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L77463
	mov	ecx, DWORD PTR _body2$[ebp]
	mov	edx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [ecx+456]
	fcomp	DWORD PTR [edx+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L77463
	mov	DWORD PTR tv187[ebp], 1
	jmp	SHORT $L77464
$L77463:
	mov	DWORD PTR tv187[ebp], 0
$L77464:
	cmp	DWORD PTR tv187[ebp], 0
	jne	SHORT $L77192
	xor	eax, eax
	jmp	$L77179
$L77192:

; 1367 : 
; 1368 : 	nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 1369 : 	// Check for points of body1 in body2
; 1370 : 	for (iSphere = 0; iSphere < body1->CollSkin.NSpheres; iSphere++) {

	mov	DWORD PTR _iSphere$[ebp], 0
	jmp	SHORT $L77193
$L77194:
	mov	eax, DWORD PTR _iSphere$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSphere$[ebp], eax
$L77193:
	mov	eax, DWORD PTR _body1$[ebp]
	movsx	ecx, WORD PTR [eax+408]
	cmp	DWORD PTR _iSphere$[ebp], ecx
	jge	$L77195

; 1371 : 
; 1372 : 		sPos = &body1->CollSkin.OldWorldSphere[iSphere].Pos;

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body1$[ebp]
	add	eax, DWORD PTR [ecx+404]
	mov	DWORD PTR _sPos$[ebp], eax

; 1373 : 		ePos = &body1->CollSkin.WorldSphere[iSphere].Pos;

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body1$[ebp]
	add	eax, DWORD PTR [ecx+400]
	mov	DWORD PTR _ePos$[ebp], eax

; 1374 : 		radius = body1->CollSkin.WorldSphere[iSphere].Radius;

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR [edx+eax+12]
	mov	DWORD PTR _radius$[ebp], eax

; 1375 : 
; 1376 : 		for (iSkin = 0; iSkin < body2->CollSkin.NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L77196
$L77197:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L77196:
	mov	eax, DWORD PTR _body2$[ebp]
	movsx	ecx, WORD PTR [eax+392]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L77198

; 1377 : 
; 1378 : 			if ((bodyColl1 = NextBodyCollInfo()) == NULL) return nColls;

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _bodyColl1$[ebp], eax
	cmp	DWORD PTR _bodyColl1$[ebp], 0
	jne	SHORT $L77199
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L77179
$L77199:

; 1379 : 
; 1380 : 			// Collision?
; 1381 : 			if (!SphereConvex(
; 1382 : 					ePos, 
; 1383 : 					radius, 
; 1384 : 					&body2->CollSkin.WorldConvex[iSkin], 
; 1385 : 					&bodyColl1->Pos1, &bodyColl1->Plane, 
; 1386 : 					&bodyColl1->Depth)) 

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _body2$[ebp]
	add	eax, DWORD PTR [ecx+384]
	push	eax
	mov	edx, DWORD PTR _radius$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePos$[ebp]
	push	eax
	call	?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z ; SphereConvex
	add	esp, 24					; 00000018H
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L77200

; 1387 : 			{
; 1388 : 				continue;

	jmp	SHORT $L77197
$L77200:

; 1389 : 			}
; 1390 : 			nColls++;

	mov	eax, DWORD PTR _nColls$[ebp]
	add	eax, 1
	mov	DWORD PTR _nColls$[ebp], eax

; 1391 : 
; 1392 : 
; 1393 : 			// Store collision info for sphere
; 1394 : 			bodyColl1->Body1 = body1;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1395 : 			bodyColl1->Body2 = body2;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1396 : 
; 1397 : 			// Calculate the relative collision points for response
; 1398 : 			VecMinusEqVec(&bodyColl1->Pos1, &body1->Centre.Pos);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+16]

; 1399 : 			VecPlusScalarVec(&body1->Centre.Pos, -(radius + bodyColl1->Depth), PlaneNormal(&bodyColl1->Plane), &bodyColl1->WorldPos);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [eax+76]
	fchs
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _body1$[ebp]
	fadd	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+36]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [eax+76]
	fchs
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _body1$[ebp]
	fadd	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+40]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [eax+76]
	fchs
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _body1$[ebp]
	fadd	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+44]

; 1400 : 			VecMinusVec(&bodyColl1->WorldPos, &body2->Centre.Pos, &bodyColl1->Pos2);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+40]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	fld	DWORD PTR [eax+44]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+32]

; 1401 : 
; 1402 : 			// Calculate velocity
; 1403 : 			VecCrossVec(&body1->AngVel, &bodyColl1->Pos1, &vel1);

	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vel1$[ebp]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vel1$[ebp+4]
	mov	eax, DWORD PTR _body1$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body1$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vel1$[ebp+8]

; 1404 : 			VecPlusEqVec(&vel1, &body1->Centre.Vel);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR _vel1$[ebp]
	fadd	DWORD PTR [eax+32]
	fstp	DWORD PTR _vel1$[ebp]
	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR _vel1$[ebp+4]
	fadd	DWORD PTR [eax+36]
	fstp	DWORD PTR _vel1$[ebp+4]
	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR _vel1$[ebp+8]
	fadd	DWORD PTR [eax+40]
	fstp	DWORD PTR _vel1$[ebp+8]

; 1405 : 			VecCrossVec(&body2->AngVel, &bodyColl1->Pos2, &vel2);

	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+28]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vel2$[ebp]
	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vel2$[ebp+4]
	mov	eax, DWORD PTR _body2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _body2$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+24]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vel2$[ebp+8]

; 1406 : 			VecPlusEqVec(&vel2, &body2->Centre.Vel);

	mov	eax, DWORD PTR _body2$[ebp]
	fld	DWORD PTR _vel2$[ebp]
	fadd	DWORD PTR [eax+32]
	fstp	DWORD PTR _vel2$[ebp]
	mov	eax, DWORD PTR _body2$[ebp]
	fld	DWORD PTR _vel2$[ebp+4]
	fadd	DWORD PTR [eax+36]
	fstp	DWORD PTR _vel2$[ebp+4]
	mov	eax, DWORD PTR _body2$[ebp]
	fld	DWORD PTR _vel2$[ebp+8]
	fadd	DWORD PTR [eax+40]
	fstp	DWORD PTR _vel2$[ebp+8]

; 1407 : 			VecMinusVec(&vel1, &vel2, &bodyColl1->Vel);

	fld	DWORD PTR _vel1$[ebp]
	fsub	DWORD PTR _vel2$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+48]
	fld	DWORD PTR _vel1$[ebp+4]
	fsub	DWORD PTR _vel2$[ebp+4]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+52]
	fld	DWORD PTR _vel1$[ebp+8]
	fsub	DWORD PTR _vel2$[ebp+8]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [eax+56]

; 1408 : 			// Make sure that the sphere is not already travelling away from the surface
; 1409 : 			if (VecDotVec(&bodyColl1->Vel, PlaneNormal(&bodyColl1->Plane)) > ZERO) continue;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [edx+52]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [ecx+56]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77207
	jmp	$L77197
$L77207:

; 1410 : 
; 1411 : 			// Collision has occurred
; 1412 : 			AddBodyColl(body1, bodyColl1);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 1413 : 			if ((bodyColl2 = NextBodyCollInfo()) == NULL) {

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _bodyColl2$[ebp], eax
	cmp	DWORD PTR _bodyColl2$[ebp], 0
	jne	SHORT $L77208

; 1414 : 				RemoveBodyColl(body1, bodyColl1);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body1$[ebp]
	push	ecx
	call	?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z ; RemoveBodyColl
	add	esp, 8

; 1415 : 				return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L77179
$L77208:

; 1416 : 			}
; 1417 : 			AddBodyColl(body2, bodyColl2);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body2$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 1418 : 
; 1419 : 			bodyColl2->Body1 = body2;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _body2$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1420 : 			bodyColl2->Body2 = body1;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _body1$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1421 : 			CopyVec(&bodyColl1->Pos2, &bodyColl2->Pos1);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+16], edx

; 1422 : 			CopyVec(&bodyColl1->Pos1, &bodyColl2->Pos2);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+32], edx

; 1423 : 			CopyVec(&bodyColl1->Vel, &bodyColl2->Vel);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 1424 : 			NegateVec(&bodyColl2->Vel);

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+48]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+52]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _bodyColl2$[ebp]
	fld	DWORD PTR [eax+56]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1425 : 
; 1426 : 			FlipPlane(&bodyColl1->Plane, &bodyColl2->Plane);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+60]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+64]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+68]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+72]
	fchs
	mov	ecx, DWORD PTR _bodyColl2$[ebp]
	fstp	DWORD PTR [ecx+72]

; 1427 : 			bodyColl1->Depth = MulScalar(HALF, bodyColl1->Depth);

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [ecx+76]

; 1428 : 			bodyColl2->Depth = bodyColl1->Depth;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx

; 1429 : 			bodyColl1->Time = ZERO;		// DODGY...

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	DWORD PTR [eax+80], 0

; 1430 : 			bodyColl2->Time = ZERO;		// DODGY...

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	DWORD PTR [eax+80], 0

; 1431 : 
; 1432 : 			bodyColl1->Grip = MulScalar(body1->Centre.Grip, body2->Centre.Grip);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+180]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+180]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+84]

; 1433 : 			bodyColl1->StaticFriction = MulScalar(body1->Centre.StaticFriction, body2->Centre.StaticFriction);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+184]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+88]

; 1434 : 			bodyColl1->KineticFriction = MulScalar(body1->Centre.KineticFriction, body2->Centre.KineticFriction);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+92]

; 1435 : 			bodyColl1->Restitution = MulScalar(body1->Centre.Hardness, body2->Centre.Hardness);

	mov	eax, DWORD PTR _body1$[ebp]
	fld	DWORD PTR [eax+172]
	mov	ecx, DWORD PTR _body2$[ebp]
	fmul	DWORD PTR [ecx+172]
	mov	edx, DWORD PTR _bodyColl1$[ebp]
	fstp	DWORD PTR [edx+96]

; 1436 : 			bodyColl1->Material = NULL;

	mov	eax, DWORD PTR _bodyColl1$[ebp]
	mov	DWORD PTR [eax+100], 0

; 1437 : 			bodyColl2->StaticFriction = bodyColl1->StaticFriction;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx

; 1438 : 			bodyColl2->KineticFriction = bodyColl1->KineticFriction;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx

; 1439 : 			bodyColl2->Restitution = bodyColl1->Restitution;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx

; 1440 : 			bodyColl2->Grip = bodyColl1->Grip;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	ecx, DWORD PTR _bodyColl1$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx

; 1441 : 			bodyColl2->Material = NULL;

	mov	eax, DWORD PTR _bodyColl2$[ebp]
	mov	DWORD PTR [eax+100], 0

; 1442 : 
; 1443 : 		}

	jmp	$L77197
$L77198:

; 1444 : 	}

	jmp	$L77194
$L77195:

; 1445 : 
; 1446 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L77179:

; 1447 : 
; 1448 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectHullHullColls@@YAHPAUNewBodyStruct@@0@Z ENDP	; DetectHullHullColls
_TEXT	ENDS
PUBLIC	?BodyTurboBoost@@YAXPAUNewBodyStruct@@@Z	; BodyTurboBoost
; Function compile flags: /Odt /ZI
;	COMDAT ?BodyTurboBoost@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_boostMag$ = -4						; size = 4
_body$ = 8						; size = 4
?BodyTurboBoost@@YAXPAUNewBodyStruct@@@Z PROC NEAR	; BodyTurboBoost, COMDAT

; 1458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1459 : 	REAL boostMag;
; 1460 : 	// Make sure the body is being boosted
; 1461 : 	if (body->Centre.Boost < SMALL_REAL) return;

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+196]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L77213
	jmp	SHORT $L77211
$L77213:

; 1462 : 
; 1463 : 	boostMag = MulScalar(MulScalar(TimeStep, body->Centre.Boost), body->Centre.Mass);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+196]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _body$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _boostMag$[ebp]

; 1464 : 	VecPlusEqScalarVec(&body->Centre.Impulse, boostMag, &body->Centre.WMatrix.mv[L]);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _boostMag$[ebp]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [edx+56]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _boostMag$[ebp]
	fmul	DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [edx+60]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _boostMag$[ebp]
	fmul	DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _body$[ebp]
	fadd	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [edx+64]
$L77211:

; 1465 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BodyTurboBoost@@YAXPAUNewBodyStruct@@@Z ENDP		; BodyTurboBoost
_TEXT	ENDS
PUBLIC	?PostProcessBodyColls@@YAXPAUNewBodyStruct@@@Z	; PostProcessBodyColls
; Function compile flags: /Odt /ZI
;	COMDAT ?PostProcessBodyColls@@YAXPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_body$ = 8						; size = 4
?PostProcessBodyColls@@YAXPAUNewBodyStruct@@@Z PROC NEAR ; PostProcessBodyColls, COMDAT

; 1474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1475 : 
; 1476 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PostProcessBodyColls@@YAXPAUNewBodyStruct@@@Z ENDP	; PostProcessBodyColls
_TEXT	ENDS
EXTRN	?COL_NBodyColls@@3HA:DWORD			; COL_NBodyColls
; Function compile flags: /Odt /ZI
;	COMDAT ?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z
_TEXT	SEGMENT
_oldHead$ = -4						; size = 4
_body$ = 8						; size = 4
_newHead$ = 12						; size = 4
?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z PROC NEAR ; AddBodyColl, COMDAT

; 1486 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1487 : 	COLLINFO_BODY *oldHead = body->BodyCollHead;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR _oldHead$[ebp], ecx

; 1488 : 
; 1489 : 	body->BodyCollHead = newHead;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _newHead$[ebp]
	mov	DWORD PTR [eax+512], ecx

; 1490 : 	newHead->Next = oldHead;

	mov	eax, DWORD PTR _newHead$[ebp]
	mov	ecx, DWORD PTR _oldHead$[ebp]
	mov	DWORD PTR [eax+104], ecx

; 1491 : 	newHead->Prev = NULL;

	mov	eax, DWORD PTR _newHead$[ebp]
	mov	DWORD PTR [eax+108], 0

; 1492 : 
; 1493 : 	if (oldHead != NULL) {

	cmp	DWORD PTR _oldHead$[ebp], 0
	je	SHORT $L77222

; 1494 : 		oldHead->Prev = newHead;

	mov	eax, DWORD PTR _oldHead$[ebp]
	mov	ecx, DWORD PTR _newHead$[ebp]
	mov	DWORD PTR [eax+108], ecx
$L77222:

; 1495 : 	}
; 1496 : 
; 1497 : 	newHead->Active = TRUE;

	mov	eax, DWORD PTR _newHead$[ebp]
	mov	BYTE PTR [eax], 1

; 1498 : 
; 1499 : 	body->NBodyColls++;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	add	ecx, 1
	mov	edx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [edx+516], ecx

; 1500 : 	COL_NBodyColls++;

	mov	eax, DWORD PTR ?COL_NBodyColls@@3HA	; COL_NBodyColls
	add	eax, 1
	mov	DWORD PTR ?COL_NBodyColls@@3HA, eax	; COL_NBodyColls

; 1501 : 
; 1502 : 	return newHead;

	mov	eax, DWORD PTR _newHead$[ebp]

; 1503 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ENDP ; AddBodyColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z@4JA ; `RemoveBodyColl'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z@4JA DD 05e8H ; `RemoveBodyColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z
_TEXT	SEGMENT
tv133 = -68						; size = 4
_body$ = 8						; size = 4
_collInfo$ = 12						; size = 4
?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z PROC NEAR ; RemoveBodyColl, COMDAT

; 1512 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1513 : 	Assert(collInfo != NULL);

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z@4JA
	add	eax, 1
	push	eax
	cmp	DWORD PTR _collInfo$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1514 : 	Assert(collInfo->Active);

	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z@4JA
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	dl, BYTE PTR [ecx]
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1515 : 
; 1516 : 	if (collInfo->Next != NULL) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $L77228

; 1517 : 		(collInfo->Next)->Prev = collInfo->Prev;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+108], eax
$L77228:

; 1518 : 	}
; 1519 : 
; 1520 : 	if (collInfo->Prev != NULL) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	cmp	DWORD PTR [eax+108], 0
	je	SHORT $L77229

; 1521 : 		(collInfo->Prev)->Next = collInfo->Next;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR [ecx+104], eax

; 1522 : 	} else {

	jmp	SHORT $L77230
$L77229:

; 1523 : 		body->BodyCollHead = collInfo->Next;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+512], edx
$L77230:

; 1524 : 	}
; 1525 : 
; 1526 : 	collInfo->Active = FALSE;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	BYTE PTR [eax], 0

; 1527 : 
; 1528 : 	body->NBodyColls--;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	sub	ecx, 1
	mov	edx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [edx+516], ecx

; 1529 : 
; 1530 : 	Assert((body->NBodyColls == 0)? (body->BodyCollHead == NULL): (body->BodyCollHead != NULL));

	mov	eax, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [eax+516], 0
	jne	SHORT $L77473
	mov	ecx, DWORD PTR _body$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+512], 0
	sete	dl
	mov	DWORD PTR tv133[ebp], edx
	jmp	SHORT $L77474
$L77473:
	mov	eax, DWORD PTR _body$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+512], 0
	setne	cl
	mov	DWORD PTR tv133[ebp], ecx
$L77474:
	push	OFFSET FLAT:??_C@_0IJ@IOGJMEHI@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z@4JA
	add	edx, 18					; 00000012H
	push	edx
	mov	al, BYTE PTR tv133[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1531 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveBodyColl@@YAXPAUNewBodyStruct@@PAUBodyCollInfoStruct@@@Z ENDP ; RemoveBodyColl
_TEXT	ENDS
END
