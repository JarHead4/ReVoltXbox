; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\car.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitCar@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextValidCarID@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrevValidCarID@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupCar@@YAXPAUPlayerStruct@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeCar@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitRemoteCarData@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextRemoteData@@YAPAURemoteDataStruct@@PAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendLocalCarData@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCarAerialPos@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCarInfo@@YAPAUCAR_INFO@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyCarInfo@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCarModels@@YAPAUCAR_MODEL@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyCarModels@@YAXPAUCAR_MODEL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetCarWheelPos@@YAXPAUCarStruct@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectCarWheelColls2@@YAXPAUCarStruct@@HPAUCollPolyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreProcessCarWheelColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCarWheelColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostProcessCarWheelColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAllCarCoMs@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveCarCoM@@YAXPAUCAR_INFO@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CarWheelImpulse2@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCarAngResistance@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectCarWorldColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectWheelSphereColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectWheelWheelColls@@YAHPAUCarStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectCarCarColls@@YAHPAUCarStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRemotePlayer@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadOneCarModelSet@@YAXPAUPlayerStruct@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeOneCarModelSet@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CarAccTimings@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CarDownForce@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyCarModels@@YAXPAUCAR_MODEL@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateCarModels@@YAPAUCAR_MODEL@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyCarInfo@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateCarInfo@@YAPAUCAR_INFO@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?CarInfo@@3PAUCAR_INFO@@A			; CarInfo
PUBLIC	?NCarTypes@@3JA					; NCarTypes
PUBLIC	?CAR_DrawCarBBoxes@@3_NA			; CAR_DrawCarBBoxes
PUBLIC	?CAR_DrawCarAxes@@3_NA				; CAR_DrawCarAxes
PUBLIC	?CAR_WheelsHaveSuspension@@3_NA			; CAR_WheelsHaveSuspension
PUBLIC	?CarGridStarts@@3PAY0M@UGRID_POS@@A		; CarGridStarts
PUBLIC	?DBG_PosDiff@@3UVectorStruct@@A			; DBG_PosDiff
PUBLIC	?DBG_VelDiff@@3UVectorStruct@@A			; DBG_VelDiff
PUBLIC	?DEBUG_DownForce@@3UVectorStruct@@A		; DEBUG_DownForce
PUBLIC	?MaxCannotMoveTime@@3MA				; MaxCannotMoveTime
PUBLIC	?SmokeVel@@3UVectorStruct@@A			; SmokeVel
PUBLIC	?TurboVel@@3UVectorStruct@@A			; TurboVel
_BSS	SEGMENT
?CarInfo@@3PAUCAR_INFO@@A DD 01H DUP (?)		; CarInfo
?NCarTypes@@3JA DD 01H DUP (?)				; NCarTypes
?CAR_DrawCarBBoxes@@3_NA DB 01H DUP (?)			; CAR_DrawCarBBoxes
	ALIGN	4

?CAR_DrawCarAxes@@3_NA DB 01H DUP (?)			; CAR_DrawCarAxes
	ALIGN	4

?DBG_PosDiff@@3UVectorStruct@@A DB 0cH DUP (?)		; DBG_PosDiff
?DBG_VelDiff@@3UVectorStruct@@A DB 0cH DUP (?)		; DBG_VelDiff
?DEBUG_DownForce@@3UVectorStruct@@A DB 0cH DUP (?)	; DEBUG_DownForce
_BSS	ENDS
_DATA	SEGMENT
?MaxCannotMoveTime@@3MA DD 040400000r		; 3	; MaxCannotMoveTime
?CAR_WheelsHaveSuspension@@3_NA DB 01H			; CAR_WheelsHaveSuspension
	ORG $+3
?SmokeVel@@3UVectorStruct@@A DD 000000000r	; 0	; SmokeVel
	DD	0c2900000r			; -72
	DD	000000000r			; 0
?TurboVel@@3UVectorStruct@@A DD 000000000r	; 0	; TurboVel
	DD	0c2800000r			; -64
	DD	000000000r			; 0
?CarGridStarts@@3PAY0M@UGRID_POS@@A DD 0c3000000r ; -128 ; CarGridStarts
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	0c2800000r			; -64
	DD	000000000r			; 0
	DD	0c3000000r			; -128
	DD	0c3000000r			; -128
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	0c3400000r			; -192
	DD	000000000r			; 0
	DD	0c3000000r			; -128
	DD	0c3800000r			; -256
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	0c3a00000r			; -320
	DD	000000000r			; 0
	DD	0c3000000r			; -128
	DD	0c3c00000r			; -384
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	0c3e00000r			; -448
	DD	000000000r			; 0
	DD	0c3000000r			; -128
	DD	0c4000000r			; -512
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	0c4100000r			; -576
	DD	000000000r			; 0
	DD	0c3000000r			; -128
	DD	0c4200000r			; -640
	DD	000000000r			; 0
	DD	043000000r			; 128
	DD	0c4300000r			; -704
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c37a0000r			; -250
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0437a0000r			; 250
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c3a00000r			; -320
	DD	000000000r			; 0
	DD	0c37a0000r			; -250
	DD	0c3a00000r			; -320
	DD	000000000r			; 0
	DD	0437a0000r			; 250
	DD	0c3a00000r			; -320
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c4200000r			; -640
	DD	000000000r			; 0
	DD	0c37a0000r			; -250
	DD	0c4200000r			; -640
	DD	000000000r			; 0
	DD	0437a0000r			; 250
	DD	0c4200000r			; -640
	DD	000000000r			; 0
	ORG $+36
	DD	0c3160000r			; -150
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042480000r			; 50
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	043160000r			; 150
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c3160000r			; -150
	DD	0c3800000r			; -256
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	0c3800000r			; -256
	DD	000000000r			; 0
	DD	042480000r			; 50
	DD	0c3800000r			; -256
	DD	000000000r			; 0
	DD	043160000r			; 150
	DD	0c3800000r			; -256
	DD	000000000r			; 0
	ORG $+48
	DD	0c3480000r			; -200
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	043480000r			; 200
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c3480000r			; -200
	DD	0c3a00000r			; -320
	DD	000000000r			; 0
	DD	043480000r			; 200
	DD	0c3a00000r			; -320
	DD	000000000r			; 0
	DD	0c3480000r			; -200
	DD	0c4200000r			; -640
	DD	000000000r			; 0
	DD	043480000r			; 200
	DD	0c4200000r			; -640
	DD	000000000r			; 0
	DD	0c3480000r			; -200
	DD	0c4700000r			; -960
	DD	000000000r			; 0
	DD	043480000r			; 200
	DD	0c4700000r			; -960
	DD	000000000r			; 0
	DD	0c3480000r			; -200
	DD	0c4870000r			; -1080
	DD	000000000r			; 0
	DD	043480000r			; 200
	DD	0c4870000r			; -1080
	DD	000000000r			; 0
	ORG $+24
_DATA	ENDS
PUBLIC	?InitCar@@YAXPAUCarStruct@@@Z			; InitCar
EXTRN	__fltused:NEAR
EXTRN	?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z:NEAR	; InitBodyDefault
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\car.cpp
;	COMDAT ?InitCar@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_car$ = 8						; size = 4
?InitCar@@YAXPAUCarStruct@@@Z PROC NEAR			; InitCar, COMDAT

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 171  : 
; 172  : // init model / coll misc
; 173  : 
; 174  : 	InitBodyDefault(car->Body);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	call	?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z ; InitBodyDefault
	add	esp, 4

; 175  : 	car->Models = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+820], 0

; 176  : 
; 177  : // init lap stuff
; 178  : 
; 179  : 	car->NextSplit = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3416], 0

; 180  : 	car->Laps = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3420], 0

; 181  : 	car->CurrentLapTime = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3424], 0

; 182  : 	car->LastLapTime = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3428], 0

; 183  : 	car->LastRaceTime = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3436], 0

; 184  : #ifdef _PC
; 185  : 	car->BestLapTime = MAKE_TIME(5, 0, 0);

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3432], 300000		; 000493e0H

; 186  : 	car->BestRaceTime = MAKE_TIME(60, 0, 0);

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3440], 3600000		; 0036ee80H

; 187  : #endif
; 188  : 	car->Best0to15 = 100;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3488], 1120403456	; 42c80000H

; 189  : 	car->Best0to25 = 100;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3496], 1120403456	; 42c80000H

; 190  : 	car->Current0to15 = -ONE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3484], -1082130432	; bf800000H

; 191  : 	car->Current0to25 = -ONE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3492], -1082130432	; bf800000H

; 192  : 	car->Timing0to15 = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3817], 0

; 193  : 	car->Timing0to25 = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3818], 0

; 194  : 	car->Righting = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3814], 0

; 195  : 	car->AddLit = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3516], 0

; 196  : 	car->DrawScale = ONE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3520], 1065353216	; 3f800000H

; 197  : 	car->PowerTimer = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3512], 0

; 198  : 	car->IsBomb = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3524], 0

; 199  : 	car->WillDetonate = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3528], 0

; 200  : 	car->NoReturnTimer = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3532], 0

; 201  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitCar@@YAXPAUCarStruct@@@Z ENDP			; InitCar
_TEXT	ENDS
PUBLIC	?NextValidCarID@@YAHH@Z				; NextValidCarID
; Function compile flags: /Odt /ZI
;	COMDAT ?NextValidCarID@@YAHH@Z
_TEXT	SEGMENT
_carID$ = -4						; size = 4
_currentID$ = 8						; size = 4
?NextValidCarID@@YAHH@Z PROC NEAR			; NextValidCarID, COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 213  : 	int carID;
; 214  : 
; 215  : 	// Check all higher carIDs
; 216  : 	for (carID = currentID + 1; carID < NCarTypes; carID++) {

	mov	eax, DWORD PTR _currentID$[ebp]
	add	eax, 1
	mov	DWORD PTR _carID$[ebp], eax
	jmp	SHORT $L81885
$L81886:
	mov	eax, DWORD PTR _carID$[ebp]
	add	eax, 1
	mov	DWORD PTR _carID$[ebp], eax
$L81885:
	mov	eax, DWORD PTR _carID$[ebp]
	cmp	eax, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	jge	SHORT $L81887

; 217  : 		if (CarInfo[carID].Selectable) {

	mov	eax, DWORD PTR _carID$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	movzx	edx, BYTE PTR [ecx+eax+1449]
	test	edx, edx
	je	SHORT $L81888

; 218  : 			return carID;

	mov	eax, DWORD PTR _carID$[ebp]
	jmp	SHORT $L81883
$L81888:

; 219  : 		}
; 220  : 	}

	jmp	SHORT $L81886
$L81887:

; 221  : 	// Check lower car IDs
; 222  : 	for (carID = 0; carID < currentID; carID++) {

	mov	DWORD PTR _carID$[ebp], 0
	jmp	SHORT $L81889
$L81890:
	mov	eax, DWORD PTR _carID$[ebp]
	add	eax, 1
	mov	DWORD PTR _carID$[ebp], eax
$L81889:
	mov	eax, DWORD PTR _carID$[ebp]
	cmp	eax, DWORD PTR _currentID$[ebp]
	jge	SHORT $L81891

; 223  : 		if (CarInfo[carID].Selectable) {

	mov	eax, DWORD PTR _carID$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	movzx	edx, BYTE PTR [ecx+eax+1449]
	test	edx, edx
	je	SHORT $L81892

; 224  : 			return carID;

	mov	eax, DWORD PTR _carID$[ebp]
	jmp	SHORT $L81883
$L81892:

; 225  : 		}
; 226  : 	}

	jmp	SHORT $L81890
$L81891:

; 227  : 	// No other selectables - return passed ID
; 228  : 	return currentID;

	mov	eax, DWORD PTR _currentID$[ebp]
$L81883:

; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextValidCarID@@YAHH@Z ENDP				; NextValidCarID
_TEXT	ENDS
PUBLIC	?PrevValidCarID@@YAHH@Z				; PrevValidCarID
; Function compile flags: /Odt /ZI
;	COMDAT ?PrevValidCarID@@YAHH@Z
_TEXT	SEGMENT
_carID$ = -4						; size = 4
_currentID$ = 8						; size = 4
?PrevValidCarID@@YAHH@Z PROC NEAR			; PrevValidCarID, COMDAT

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 233  : 	int carID;
; 234  : 
; 235  : 	// Check all lower carIDs
; 236  : 	for (carID = currentID - 1; carID >= 0; carID--) {

	mov	eax, DWORD PTR _currentID$[ebp]
	sub	eax, 1
	mov	DWORD PTR _carID$[ebp], eax
	jmp	SHORT $L81897
$L81898:
	mov	eax, DWORD PTR _carID$[ebp]
	sub	eax, 1
	mov	DWORD PTR _carID$[ebp], eax
$L81897:
	cmp	DWORD PTR _carID$[ebp], 0
	jl	SHORT $L81899

; 237  : 		if (CarInfo[carID].Selectable) {

	mov	eax, DWORD PTR _carID$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	movzx	edx, BYTE PTR [ecx+eax+1449]
	test	edx, edx
	je	SHORT $L81900

; 238  : 			return carID;

	mov	eax, DWORD PTR _carID$[ebp]
	jmp	SHORT $L81895
$L81900:

; 239  : 		}
; 240  : 	}

	jmp	SHORT $L81898
$L81899:

; 241  : 	// Check higher car IDs
; 242  : 	for (carID = NCarTypes - 1; carID > currentID; carID--) {

	mov	eax, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	sub	eax, 1
	mov	DWORD PTR _carID$[ebp], eax
	jmp	SHORT $L81901
$L81902:
	mov	eax, DWORD PTR _carID$[ebp]
	sub	eax, 1
	mov	DWORD PTR _carID$[ebp], eax
$L81901:
	mov	eax, DWORD PTR _carID$[ebp]
	cmp	eax, DWORD PTR _currentID$[ebp]
	jle	SHORT $L81903

; 243  : 		if (CarInfo[carID].Selectable) {

	mov	eax, DWORD PTR _carID$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	movzx	edx, BYTE PTR [ecx+eax+1449]
	test	edx, edx
	je	SHORT $L81904

; 244  : 			return carID;

	mov	eax, DWORD PTR _carID$[ebp]
	jmp	SHORT $L81895
$L81904:

; 245  : 		}
; 246  : 	}

	jmp	SHORT $L81902
$L81903:

; 247  : 	// No other selectables - return passed ID
; 248  : 	return currentID;

	mov	eax, DWORD PTR _currentID$[ebp]
$L81895:

; 249  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrevValidCarID@@YAHH@Z ENDP				; PrevValidCarID
_TEXT	ENDS
PUBLIC	?SetupCar@@YAXPAUPlayerStruct@@H@Z		; SetupCar
PUBLIC	?LoadOneCarModelSet@@YAXPAUPlayerStruct@@J@Z	; LoadOneCarModelSet
PUBLIC	?FreeOneCarModelSet@@YAXPAUPlayerStruct@@@Z	; FreeOneCarModelSet
EXTRN	?SetAerialSprings@@YAXPAUAERIAL@@MMM@Z:NEAR	; SetAerialSprings
EXTRN	?InitAerial@@YAXPAUAERIAL@@PAUVectorStruct@@MMMMM@Z:NEAR ; InitAerial
EXTRN	?SetupWheel@@YAXPAUWHEEL@@PAUWHEEL_INFO@@@Z:NEAR ; SetupWheel
EXTRN	?SetupSuspension@@YAXPAUSPRING@@PAUSPRING_INFO@@@Z:NEAR ; SetupSuspension
EXTRN	?CopyMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; CopyMatrix
EXTRN	?CopyMat@@YAXPATMatrixUnion@@0@Z:NEAR		; CopyMat
EXTRN	?IdentityMatrix@@3TMatrixUnion@@A:BYTE		; IdentityMatrix
EXTRN	?Identity@@3TMatrixUnion@@A:BYTE		; Identity
EXTRN	?DestroyConvex@@YAXPAUConvexStruct@@H@Z:NEAR	; DestroyConvex
EXTRN	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z:NEAR ; CreateCopyCollSkin
EXTRN	?DestroySpheres@@YAXPAUSphereStruct@@@Z:NEAR	; DestroySpheres
EXTRN	?SetParticleMass@@YAXPAUParticleStruct@@M@Z:NEAR ; SetParticleMass
EXTRN	?SetBodyInertia@@YAXPAUNewBodyStruct@@PATMatrixUnion@@@Z:NEAR ; SetBodyInertia
; Function compile flags: /Odt /ZI
;	COMDAT ?SetupCar@@YAXPAUPlayerStruct@@H@Z
_TEXT	SEGMENT
_car$ = -8						; size = 4
_ii$ = -4						; size = 4
_player$ = 8						; size = 4
_carType$ = 12						; size = 4
?SetupCar@@YAXPAUPlayerStruct@@H@Z PROC NEAR		; SetupCar, COMDAT

; 257  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 258  : 	long	ii;
; 259  : 	CAR		*car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 260  : 
; 261  : 	// load models + tpage
; 262  : #ifndef _PSX
; 263  : 	if (car->Models) {

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+820], 0
	je	SHORT $L81911

; 264  : 		FreeOneCarModelSet(player);

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	?FreeOneCarModelSet@@YAXPAUPlayerStruct@@@Z ; FreeOneCarModelSet
	add	esp, 4
$L81911:

; 265  : 	}
; 266  : 	car->Models = &player->carmodels;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 3864				; 00000f18H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+820], eax

; 267  : 	LoadOneCarModelSet(player, carType);

	mov	eax, DWORD PTR _carType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	call	?LoadOneCarModelSet@@YAXPAUPlayerStruct@@J@Z ; LoadOneCarModelSet
	add	esp, 8

; 268  : #else
; 269  : 	car->Models = &Car_Model[0];
; 270  : #endif
; 271  : 
; 272  : 	// Create / re-create the world-frame collision skins
; 273  : 	if (car->Body->CollSkin.WorldConvex != NULL) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	cmp	DWORD PTR [ecx+384], 0
	je	SHORT $L81912

; 274  : 		DestroyConvex(car->Body->CollSkin.WorldConvex, car->Body->CollSkin.NConvex);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	movsx	edx, WORD PTR [ecx+392]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 275  : 		car->Body->CollSkin.WorldConvex = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+384], 0
$L81912:

; 276  : 	}
; 277  : 	if (car->Body->CollSkin.OldWorldConvex != NULL) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	cmp	DWORD PTR [ecx+388], 0
	je	SHORT $L81913

; 278  : 		DestroyConvex(car->Body->CollSkin.OldWorldConvex, car->Body->CollSkin.NConvex);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	movsx	edx, WORD PTR [ecx+392]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+388]
	push	edx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 279  : 		car->Body->CollSkin.OldWorldConvex = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+388], 0
$L81913:

; 280  : 	}
; 281  : 	if (car->Body->CollSkin.WorldSphere != NULL) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	cmp	DWORD PTR [ecx+400], 0
	je	SHORT $L81914

; 282  : 		DestroySpheres(car->Body->CollSkin.WorldSphere);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+400]
	push	edx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 283  : 		car->Body->CollSkin.WorldSphere = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+400], 0
$L81914:

; 284  : 	}
; 285  : 	if (car->Body->CollSkin.OldWorldSphere != NULL) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	cmp	DWORD PTR [ecx+404], 0
	je	SHORT $L81915

; 286  : 		DestroySpheres(car->Body->CollSkin.OldWorldSphere);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+404]
	push	edx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 287  : 		car->Body->CollSkin.OldWorldSphere = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+404], 0
$L81915:

; 288  : 	}
; 289  : 	car->Body->CollSkin.NConvex = car->Models->CollSkin.NConvex;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	cx, WORD PTR [ecx+6160]
	mov	WORD PTR [eax+392], cx

; 290  : 	car->Body->CollSkin.NSpheres = car->Models->CollSkin.NSpheres;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	cx, WORD PTR [ecx+6176]
	mov	WORD PTR [eax+408], cx

; 291  : 	car->Body->CollSkin.Convex = car->Models->CollSkin.Convex;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6148]
	mov	DWORD PTR [eax+380], ecx

; 292  : 	car->Body->CollSkin.Sphere = car->Models->CollSkin.Sphere;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6164]
	mov	DWORD PTR [eax+396], ecx

; 293  : 	CopyBBox(&car->Models->CollSkin.TightBBox, &car->Body->CollSkin.TightBBox);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6188]
	mov	DWORD PTR [eax+420], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6192]
	mov	DWORD PTR [eax+424], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6196]
	mov	DWORD PTR [eax+428], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6200]
	mov	DWORD PTR [eax+432], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6204]
	mov	DWORD PTR [eax+436], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+6208]
	mov	DWORD PTR [eax+440], ecx

; 294  : 	CreateCopyCollSkin(&car->Body->CollSkin);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 380				; 0000017cH
	push	ecx
	call	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z ; CreateCopyCollSkin
	add	esp, 4

; 295  : 
; 296  : 
; 297  : #ifndef _PSX
; 298  : 
; 299  : 	// fix env matrix
; 300  : 	CopyMatrix(&IdentityMatrix, &car->EnvMatrix);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 784				; 00000310H
	push	eax
	push	OFFSET FLAT:?IdentityMatrix@@3TMatrixUnion@@A ; IdentityMatrix
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 301  : 
; 302  : #endif
; 303  : 
; 304  : 
; 305  : 	// Set car ID
; 306  : 	car->CarID = carType;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _carType$[ebp]
	mov	DWORD PTR [eax+768], ecx

; 307  : 
; 308  : 	// Set car misc stuff
; 309  : 	car->SteerRate = CarInfo[carType].SteerRate;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1412]
	mov	DWORD PTR [ecx+828], eax

; 310  : 	car->SteerModifier = CarInfo[carType].SteerModifier;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1416]
	mov	DWORD PTR [ecx+832], eax

; 311  : 	car->EngineRate = CarInfo[carType].EngineRate;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1420]
	mov	DWORD PTR [ecx+840], eax

; 312  : 	car->TopSpeed = car->DefaultTopSpeed = CarInfo[carType].TopSpeed;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1424]
	mov	DWORD PTR [ecx+848], eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+848]
	mov	DWORD PTR [ecx+844], eax

; 313  : 	car->MaxRevs = CarInfo[carType].MaxRevs;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1428]
	mov	DWORD PTR [ecx+3508], eax

; 314  : 	car->AllowedBestTime = CarInfo[carType].AllowedBestTime;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	al, BYTE PTR [edx+eax+1448]
	mov	BYTE PTR [ecx+3812], al

; 315  : 	car->DownForceMod = CarInfo[carType].DownForceMod;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1432]
	mov	DWORD PTR [ecx+852], eax

; 316  : 	car->Selectable = CarInfo[carType].Selectable;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	al, BYTE PTR [edx+eax+1449]
	mov	BYTE PTR [ecx+3813], al

; 317  : 	CopyVec(&CarInfo[carType].WeaponOffset, &car->WeaponOffset);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1452]
	mov	DWORD PTR [ecx+3400], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1456]
	mov	DWORD PTR [ecx+3404], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1460]
	mov	DWORD PTR [ecx+3408], eax

; 318  : 	car->Best0to15 = -ONE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3488], -1082130432	; bf800000H

; 319  : 	car->Best0to25 = -ONE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3496], -1082130432	; bf800000H

; 320  : 	car->Current0to15 = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3484], 0

; 321  : 	car->Current0to25 = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3492], 0

; 322  : 
; 323  : 	// Car Body Stuff
; 324  : 	SetBodyConvex(car->Body);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+472], 0

; 325  : 	CopyVec(&CarInfo[carType].Body.Offset, &car->BodyOffset);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1468]
	mov	DWORD PTR [ecx+3172], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1472]
	mov	DWORD PTR [ecx+3176], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+1476]
	mov	DWORD PTR [ecx+3180], eax

; 326  : 	SetParticleMass(&car->Body->Centre, CarInfo[carType].Body.Mass);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	edx, DWORD PTR [ecx+eax+1480]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	call	?SetParticleMass@@YAXPAUParticleStruct@@M@Z ; SetParticleMass
	add	esp, 8

; 327  : 	SetBodyInertia(car->Body, &CarInfo[carType].Body.Inertia);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	edx, DWORD PTR [ecx+eax+1484]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	call	?SetBodyInertia@@YAXPAUNewBodyStruct@@PATMatrixUnion@@@Z ; SetBodyInertia
	add	esp, 8

; 328  : 	car->Body->Centre.Gravity = CarInfo[carType].Body.Gravity;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1520]
	mov	DWORD PTR [edx+192], eax

; 329  : 	car->Body->Centre.Hardness = CarInfo[carType].Body.Hardness;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1524]
	mov	DWORD PTR [edx+172], eax

; 330  : 	car->Body->Centre.Resistance = CarInfo[carType].Body.Resistance;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1528]
	mov	DWORD PTR [edx+176], eax

; 331  : 	car->Body->Centre.StaticFriction = CarInfo[carType].Body.StaticFriction;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1544]
	mov	DWORD PTR [edx+184], eax

; 332  : 	car->Body->Centre.KineticFriction = CarInfo[carType].Body.KineticFriction;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1548]
	mov	DWORD PTR [edx+188], eax

; 333  : 	car->Body->DefaultAngRes = CarInfo[carType].Body.AngResistance;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1532]
	mov	DWORD PTR [edx+368], eax

; 334  : 	car->Body->AngResistance = CarInfo[carType].Body.AngResistance;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1532]
	mov	DWORD PTR [edx+376], eax

; 335  : 	car->Body->AngResMod = CarInfo[carType].Body.ResModifier;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1536]
	mov	DWORD PTR [edx+372], eax

; 336  : 	car->Body->Centre.Grip = CarInfo[carType].Body.Grip;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [ecx+eax+1540]
	mov	DWORD PTR [edx+180], eax

; 337  : 	car->Body->AllowSparks = TRUE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	BYTE PTR [ecx+532], 1

; 338  : 
; 339  : 	// Jitter stuff
; 340  : 	car->Body->JitterCountMax = 2;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+500], 2

; 341  : 	car->Body->JitterFramesMax = 10;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+508], 10			; 0000000aH

; 342  : 
; 343  : 	// Car Wheel Stuff
; 344  : 	for (ii = 0; ii < CAR_NWHEELS; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L81916
$L81917:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L81916:
	cmp	DWORD PTR _ii$[ebp], 4
	jge	$L81918

; 345  : 		// Set the wheel offset and adjust for spring compression
; 346  : 		CopyVec(&CarInfo[carType].Wheel[ii].Offset1, &car->WheelOffset[ii]);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1556]
	mov	DWORD PTR [esi+edx+3184], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1560]
	mov	DWORD PTR [esi+edx+3188], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1564]
	mov	DWORD PTR [esi+edx+3192], eax

; 347  : 		CopyVec(&CarInfo[carType].Wheel[ii].Offset2, &car->WheelCentre[ii]);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1568]
	mov	DWORD PTR [esi+edx+3232], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1572]
	mov	DWORD PTR [esi+edx+3236], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1576]
	mov	DWORD PTR [esi+edx+3240], eax

; 348  : 		// Set up the rest of the wheel stuff
; 349  : 		SetupWheel(&car->Wheel[ii], &CarInfo[carType].Wheel[ii]);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 76					; 0000004cH
	lea	edx, DWORD PTR [eax+ecx+1552]
	push	edx
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	push	edx
	call	?SetupWheel@@YAXPAUWHEEL@@PAUWHEEL_INFO@@@Z ; SetupWheel
	add	esp, 8

; 350  : 	}

	jmp	$L81917
$L81918:

; 351  : 
; 352  : 
; 353  : 	// Suspension
; 354  : 	for (ii = 0; ii < CAR_NWHEELS; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L81919
$L81920:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L81919:
	cmp	DWORD PTR _ii$[ebp], 4
	jge	$L81921

; 355  : #ifndef _PSX
; 356  : 		car->Sus[ii].SpringLen = car->Models->SpringLen[ii];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 192				; 000000c0H
	mov	eax, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+312]
	mov	DWORD PTR [eax+edx], ecx

; 357  : 		car->Sus[ii].AxleLen = car->Models->AxleLen[ii];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 192				; 000000c0H
	mov	eax, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+328]
	mov	DWORD PTR [eax+edx+4], ecx

; 358  : 		car->Sus[ii].PinLen = car->Models->PinLen[ii];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 192				; 000000c0H
	mov	eax, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+344]
	mov	DWORD PTR [eax+edx+8], ecx

; 359  : #endif
; 360  : 		CopyVec(&CarInfo[carType].Spring[ii].Offset, &car->SuspOffset[ii]);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1860]
	mov	DWORD PTR [esi+edx+3280], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1864]
	mov	DWORD PTR [esi+edx+3284], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1868]
	mov	DWORD PTR [esi+edx+3288], eax

; 361  : 		CopyVec(&CarInfo[carType].Axle[ii].Offset, &car->AxleOffset[ii]);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1988]
	mov	DWORD PTR [esi+edx+3328], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1992]
	mov	DWORD PTR [esi+edx+3332], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	esi, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1996]
	mov	DWORD PTR [esi+edx+3336], eax

; 362  : 		SetupSuspension(&car->Spring[ii], &CarInfo[carType].Spring[ii]);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 5
	lea	edx, DWORD PTR [eax+ecx+1856]
	push	edx
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3000]
	push	edx
	call	?SetupSuspension@@YAXPAUSPRING@@PAUSPRING_INFO@@@Z ; SetupSuspension
	add	esp, 8

; 363  : 	}

	jmp	$L81920
$L81921:

; 364  : 
; 365  : 	// Set up the car's spinny thing
; 366  : 	CopyMat(&Identity, &car->Spinner.Matrix);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3084				; 00000c0cH
	push	eax
	push	OFFSET FLAT:?Identity@@3TMatrixUnion@@A	; Identity
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 367  : 	CopyVec(&CarInfo[carType].Spinner.Offset, &car->SpinnerOffset);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2148]
	mov	DWORD PTR [ecx+3376], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2152]
	mov	DWORD PTR [ecx+3380], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2156]
	mov	DWORD PTR [ecx+3384], eax

; 368  : 	CopyVec(&CarInfo[carType].Spinner.Axis, &car->Spinner.Axis);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2160]
	mov	DWORD PTR [ecx+3132], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2164]
	mov	DWORD PTR [ecx+3136], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2168]
	mov	DWORD PTR [ecx+3140], eax

; 369  : 	car->Spinner.AngVel = CarInfo[carType].Spinner.AngVel;

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2172]
	mov	DWORD PTR [ecx+3144], eax

; 370  : 
; 371  : 
; 372  : 	// Set up the car's aerial
; 373  : 	CopyVec(&CarInfo[carType].Aerial.Offset, &car->AerialOffset);

	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2184]
	mov	DWORD PTR [ecx+3388], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2188]
	mov	DWORD PTR [ecx+3392], eax
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	eax, DWORD PTR [edx+eax+2192]
	mov	DWORD PTR [ecx+3396], eax

; 374  : #ifndef _PSX
; 375  : 	InitAerial(&car->Aerial, 
; 376  : 		&car->Models->DirAerial, 
; 377  : 		car->Models->AerialLen, 
; 378  : 		1.0f, 1.0f, 0.00f, 100.0f);

	push	1120403456				; 42c80000H
	push	0
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	edx, DWORD PTR [ecx+360]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	add	ecx, 284				; 0000011cH
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	add	edx, 860				; 0000035cH
	push	edx
	call	?InitAerial@@YAXPAUAERIAL@@PAUVectorStruct@@MMMMM@Z ; InitAerial
	add	esp, 28					; 0000001cH

; 379  : #else 
; 380  : 	InitAerial(&car->Aerial, 
; 381  : 		&UpVec, 
; 382  : 		TO_LENGTH(20<<16), 
; 383  : 		1.0f, 1.0f, 0.00f, 100.0f);
; 384  : #endif
; 385  : 	SetAerialSprings(&car->Aerial, 
; 386  : 		CarInfo[carType].Aerial.Stiffness, 
; 387  : 		CarInfo[carType].Aerial.Damping,
; 388  : 		6000.0f);

	push	1169915904				; 45bb8000H
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	edx, DWORD PTR [ecx+eax+2216]
	push	edx
	mov	eax, DWORD PTR _carType$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	edx, DWORD PTR [ecx+eax+2212]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 860				; 0000035cH
	push	eax
	call	?SetAerialSprings@@YAXPAUAERIAL@@MMM@Z	; SetAerialSprings
	add	esp, 16					; 00000010H

; 389  : 
; 390  : 
; 391  : 
; 392  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupCar@@YAXPAUPlayerStruct@@H@Z ENDP			; SetupCar
_TEXT	ENDS
PUBLIC	?FreeCar@@YAXPAUPlayerStruct@@@Z		; FreeCar
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeCar@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_car$ = -4						; size = 4
_player$ = 8						; size = 4
?FreeCar@@YAXPAUPlayerStruct@@@Z PROC NEAR		; FreeCar, COMDAT

; 401  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 402  : 	CAR *car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 403  : 
; 404  : #ifndef _PSX
; 405  : 	FreeOneCarModelSet(player);

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	?FreeOneCarModelSet@@YAXPAUPlayerStruct@@@Z ; FreeOneCarModelSet
	add	esp, 4

; 406  : #endif
; 407  : 	DestroyConvex(car->Body->CollSkin.OldWorldConvex, car->Body->CollSkin.NConvex);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	movsx	edx, WORD PTR [ecx+392]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+388]
	push	edx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 408  : 	DestroyConvex(car->Body->CollSkin.WorldConvex, car->Body->CollSkin.NConvex);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	movsx	edx, WORD PTR [ecx+392]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 409  : 	car->Body->CollSkin.OldWorldConvex = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+388], 0

; 410  : 	car->Body->CollSkin.WorldConvex = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+384], 0

; 411  : 
; 412  : 	DestroySpheres(car->Body->CollSkin.OldWorldSphere);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+404]
	push	edx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 413  : 	DestroySpheres(car->Body->CollSkin.WorldSphere);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+400]
	push	edx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 414  : 	car->Body->CollSkin.OldWorldSphere = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+404], 0

; 415  : 	car->Body->CollSkin.WorldSphere = NULL;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+400], 0

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeCar@@YAXPAUPlayerStruct@@@Z ENDP			; FreeCar
_TEXT	ENDS
PUBLIC	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
EXTRN	?RotMatrixY@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixY
EXTRN	?LEV_StartPos@@3UVectorStruct@@A:BYTE		; LEV_StartPos
EXTRN	?LEV_StartRot@@3MA:DWORD			; LEV_StartRot
EXTRN	?LEV_StartGrid@@3JA:DWORD			; LEV_StartGrid
EXTRN	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z:NEAR ; VecMulMat
; Function compile flags: /Odt /ZI
;	COMDAT ?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
_off$ = -16						; size = 12
_grid$ = -4						; size = 4
_position$ = 8						; size = 4
_pos$ = 12						; size = 4
_mat$ = 16						; size = 4
?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z PROC NEAR ; GetCarGrid, COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 424  : 	GRID_POS *grid;
; 425  : 	VEC off;
; 426  : 
; 427  : // get grid pos
; 428  : 
; 429  : 	grid = &CarGridStarts[LEV_StartGrid][position];

	mov	eax, DWORD PTR ?LEV_StartGrid@@3JA	; LEV_StartGrid
	imul	eax, 144				; 00000090H
	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR ?CarGridStarts@@3PAY0M@UGRID_POS@@A[eax+ecx]
	mov	DWORD PTR _grid$[ebp], edx

; 430  : 
; 431  : // get start matrix
; 432  : 
; 433  : #ifndef _PSX
; 434  : 	RotMatrixY(mat, -LEV_StartRot - grid->rotoff);

	fld	DWORD PTR ?LEV_StartRot@@3MA		; LEV_StartRot
	fchs
	mov	eax, DWORD PTR _grid$[ebp]
	fsub	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 435  : #else
; 436  : 	SetMatUnit(mat);
; 437  : #endif
; 438  : 
; 439  : // transform start offset into start pos
; 440  : 
; 441  : 	SetVector(&off, grid->xoff, 0, grid->zoff);

	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _off$[ebp], ecx
	mov	DWORD PTR _off$[ebp+4], 0
	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _off$[ebp+8], ecx

; 442  : 	VecMulMat(&off, mat, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _off$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 443  : 	VecPlusEqVec(pos, &LEV_StartPos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?LEV_StartPos@@3UVectorStruct@@A
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pos$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?LEV_StartPos@@3UVectorStruct@@A+4
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pos$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR ?LEV_StartPos@@3UVectorStruct@@A+8
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pos$[ebp]
	fstp	DWORD PTR [ecx+8]

; 444  : 	
; 445  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ENDP ; GetCarGrid
_TEXT	ENDS
PUBLIC	?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; SetCarPos
PUBLIC	?SetCarAerialPos@@YAXPAUCarStruct@@@Z		; SetCarAerialPos
PUBLIC	?ResetCarWheelPos@@YAXPAUCarStruct@@H@Z		; ResetCarWheelPos
PUBLIC	?InitRemoteCarData@@YAXPAUCarStruct@@@Z		; InitRemoteCarData
EXTRN	?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z:NEAR ; AddPosRadToBBox
EXTRN	?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; SetBodyPos
; Function compile flags: /Odt /ZI
;	COMDAT ?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
_iWheel$ = -4						; size = 4
_car$ = 8						; size = 4
_pos$ = 12						; size = 4
_mat$ = 16						; size = 4
?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z PROC NEAR ; SetCarPos, COMDAT

; 452  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 453  : 
; 454  : 	int iWheel;
; 455  : 
; 456  : 	// Set the body position and orientation
; 457  : 	SetBodyPos(car->Body, pos, mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	push	eax
	call	?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; SetBodyPos
	add	esp, 12					; 0000000cH

; 458  : 
; 459  : 	// Other stuff
; 460  : 	car->SteerAngle = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+824], 0

; 461  : 	car->EngineVolt = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+836], 0

; 462  : 	
; 463  : 	// Set Wheel orientation and positions
; 464  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L81939
$L81940:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L81939:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	SHORT $L81941

; 465  : 		ResetCarWheelPos(car, iWheel);

	mov	eax, DWORD PTR _iWheel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?ResetCarWheelPos@@YAXPAUCarStruct@@H@Z	; ResetCarWheelPos
	add	esp, 8

; 466  : 	}

	jmp	SHORT $L81940
$L81941:

; 467  : 
; 468  : 	// Set car's bounding box
; 469  : 	CopyBBox(&car->Body->CollSkin.BBox, &car->BBox);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+444]
	mov	DWORD PTR [edx+3148], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+448]
	mov	DWORD PTR [edx+3152], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+452]
	mov	DWORD PTR [edx+3156], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+456]
	mov	DWORD PTR [edx+3160], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+460]
	mov	DWORD PTR [edx+3164], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+464]
	mov	DWORD PTR [edx+3168], eax

; 470  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L81942
$L81943:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L81942:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	SHORT $L81944

; 471  : 		AddPosRadToBBox(&car->BBox, &car->Wheel[iWheel].WPos, car->Wheel[iWheel].Radius);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1580]
	push	edx
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1720]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3148				; 00000c4cH
	push	eax
	call	?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z ; AddPosRadToBBox
	add	esp, 12					; 0000000cH

; 472  : 	}

	jmp	SHORT $L81943
$L81944:

; 473  : 
; 474  : 	// Set the starting aerial position
; 475  : 	SetCarAerialPos(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?SetCarAerialPos@@YAXPAUCarStruct@@@Z	; SetCarAerialPos
	add	esp, 4

; 476  : 
; 477  : 
; 478  : #ifdef _PC
; 479  : 	SetVecZero(&car->FieldVec);

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3564], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3568], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3572], 0

; 480  : 	// Setup the remote car data stores
; 481  : 	InitRemoteCarData(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?InitRemoteCarData@@YAXPAUCarStruct@@@Z	; InitRemoteCarData
	add	esp, 4

; 482  : #endif
; 483  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ENDP ; SetCarPos
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?InitRemoteCarData@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_car$ = 8						; size = 4
?InitRemoteCarData@@YAXPAUCarStruct@@@Z PROC NEAR	; InitRemoteCarData, COMDAT

; 494  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 495  : 	long i;
; 496  : 
; 497  : 	car->OldDat = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3800], 0

; 498  : 	car->Dat = 1;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3804], 1

; 499  : 	car->NewDat = 2;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3808], 2

; 500  : 
; 501  : 	for (i = 0 ; i < 3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81949
$L81950:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81949:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L81947

; 502  : 	{
; 503  : 		car->RemoteData[i].PacketInfo = 0xffffffff;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+eax+3608], -1

; 504  : 		car->RemoteData[i].NewData = FALSE;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _car$[ebp]
	mov	BYTE PTR [ecx+eax+3612], 0

; 505  : 		CopyVec(&car->Body->Centre.Pos, &car->RemoteData[i].Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+edx+3616], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+edx+3620], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+edx+3624], ecx

; 506  : 		CopyVec(&car->Body->Centre.Vel, &car->RemoteData[i].Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+edx+3628], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+edx+3632], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+edx+3636], ecx

; 507  : 		CopyVec(&car->Body->AngVel, &car->RemoteData[i].AngVel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+edx+3640], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+336]
	mov	DWORD PTR [eax+edx+3644], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+340]
	mov	DWORD PTR [eax+edx+3648], ecx

; 508  : 		CopyQuat(&car->Body->Centre.Quat, &car->RemoteData[i].Quat);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+edx+3652], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+edx+3656], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+edx+3660], ecx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+edx+3664], ecx

; 509  : 	}

	jmp	$L81950
$L81947:

; 510  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitRemoteCarData@@YAXPAUCarStruct@@@Z ENDP		; InitRemoteCarData
_TEXT	ENDS
PUBLIC	?NextRemoteData@@YAPAURemoteDataStruct@@PAUCarStruct@@@Z ; NextRemoteData
; Function compile flags: /Odt /ZI
;	COMDAT ?NextRemoteData@@YAPAURemoteDataStruct@@PAUCarStruct@@@Z
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_car$ = 8						; size = 4
?NextRemoteData@@YAPAURemoteDataStruct@@PAUCarStruct@@@Z PROC NEAR ; NextRemoteData, COMDAT

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 524  : 	int	tmp;
; 525  : 
; 526  : 	// If the newest data has not been used, overwrite it
; 527  : 	if (car->RemoteData[car->NewDat].NewData) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3808]
	shl	ecx, 6
	mov	edx, DWORD PTR _car$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3612]
	test	eax, eax
	je	SHORT $L81956

; 528  : 		return &car->RemoteData[car->NewDat];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3808]
	shl	ecx, 6
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3608]
	jmp	SHORT $L81954
$L81956:

; 529  : 	}
; 530  : 
; 531  : 	// Shift data stores and return pointer to oldest for overwriting
; 532  : 	tmp = car->OldDat;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3800]
	mov	DWORD PTR _tmp$[ebp], ecx

; 533  : 	car->OldDat = car->Dat;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3804]
	mov	DWORD PTR [eax+3800], edx

; 534  : 	car->Dat = car->NewDat;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3808]
	mov	DWORD PTR [eax+3804], edx

; 535  : 	car->NewDat = tmp;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax+3808], ecx

; 536  : 
; 537  : 	return &car->RemoteData[tmp];

	mov	eax, DWORD PTR _tmp$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [ecx+eax+3608]
$L81954:

; 538  : 
; 539  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextRemoteData@@YAPAURemoteDataStruct@@PAUCarStruct@@@Z ENDP ; NextRemoteData
_TEXT	ENDS
PUBLIC	?SendLocalCarData@@YAXXZ			; SendLocalCarData
PUBLIC	__real@42c80000
PUBLIC	__real@40400000
PUBLIC	__real@447a0000
EXTRN	?PLR_LocalPlayer@@3PAUPlayerStruct@@A:DWORD	; PLR_LocalPlayer
EXTRN	?TransmitMessage@@YAXPADFKJ@Z:NEAR		; TransmitMessage
EXTRN	?TransmitBuff@@3PADA:BYTE			; TransmitBuff
EXTRN	__ftol2:NEAR
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SendLocalCarData@@YAXXZ
_TEXT	SEGMENT
_ptr$ = -16						; size = 4
_sh$ = -12						; size = 4
_car$ = -8						; size = 4
_header$ = -4						; size = 4
?SendLocalCarData@@YAXXZ PROC NEAR			; SendLocalCarData, COMDAT

; 546  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 547  : 	MESSAGE_HEADER *header = (MESSAGE_HEADER*)TransmitBuff;

	mov	DWORD PTR _header$[ebp], OFFSET FLAT:?TransmitBuff@@3PADA ; TransmitBuff

; 548  : 	CAR *car = &PLR_LocalPlayer->car;

	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 549  : 	short *sh;
; 550  : 	char *ptr = (CHAR*)(header + 1);

	mov	eax, DWORD PTR _header$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 551  : 
; 552  : // setup header
; 553  : 
; 554  : 	header->Type = MESSAGE_CAR_DATA;

	mov	eax, DWORD PTR _header$[ebp]
	mov	WORD PTR [eax], 1

; 555  : 	header->Contents = 0;

	mov	eax, DWORD PTR _header$[ebp]
	mov	WORD PTR [eax+2], 0

; 556  : 
; 557  : // set pos
; 558  : 
; 559  : 	CopyVec(&car->Body->Centre.Pos, (VEC*)ptr);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+8], eax

; 560  : 	ptr += sizeof(VEC);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _ptr$[ebp], eax

; 561  : 	header->Contents |= MESSAGE_CONTENTS_CAR_POS;

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	or	ecx, 2
	mov	edx, DWORD PTR _header$[ebp]
	mov	WORD PTR [edx+2], cx

; 562  : 
; 563  : // set quat
; 564  : 
; 565  : 	*ptr++ = (char)(car->Body->Centre.Quat.v[VX] * CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+68]
	fmul	DWORD PTR __real@42c80000
	call	__ftol2
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 566  : 	*ptr++ = (char)(car->Body->Centre.Quat.v[VY] * CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+72]
	fmul	DWORD PTR __real@42c80000
	call	__ftol2
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 567  : 	*ptr++ = (char)(car->Body->Centre.Quat.v[VZ] * CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+76]
	fmul	DWORD PTR __real@42c80000
	call	__ftol2
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 568  : 	*ptr++ = (char)(car->Body->Centre.Quat.v[S] * CAR_REMOTE_QUAT_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR __real@42c80000
	call	__ftol2
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 569  : 	header->Contents |= MESSAGE_CONTENTS_CAR_QUAT;

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	or	ecx, 4
	mov	edx, DWORD PTR _header$[ebp]
	mov	WORD PTR [edx+2], cx

; 570  : 	//CopyQuat(&car->Body->Centre.Quat, (QUATERNION*)ptr);
; 571  : 	//ptr += sizeof(QUATERNION);
; 572  : 
; 573  : // set vel
; 574  : 
; 575  : 	sh = (short*)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sh$[ebp], eax

; 576  : 	*sh++ = (short)(car->Body->Centre.Vel.v[X] * CAR_REMOTE_VEL_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR __real@40400000
	call	__ftol2
	mov	edx, DWORD PTR _sh$[ebp]
	mov	WORD PTR [edx], ax
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 577  : 	*sh++ = (short)(car->Body->Centre.Vel.v[Y] * CAR_REMOTE_VEL_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+36]
	fmul	DWORD PTR __real@40400000
	call	__ftol2
	mov	edx, DWORD PTR _sh$[ebp]
	mov	WORD PTR [edx], ax
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 578  : 	*sh++ = (short)(car->Body->Centre.Vel.v[Z] * CAR_REMOTE_VEL_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR __real@40400000
	call	__ftol2
	mov	edx, DWORD PTR _sh$[ebp]
	mov	WORD PTR [edx], ax
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 579  : 	header->Contents |= MESSAGE_CONTENTS_CAR_VEL;

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	or	ecx, 8
	mov	edx, DWORD PTR _header$[ebp]
	mov	WORD PTR [edx+2], cx

; 580  : 	ptr = (char*)sh;

	mov	eax, DWORD PTR _sh$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 581  : 	//CopyVec(&car->Body->Centre.Vel, (VEC*)ptr);
; 582  : 	//ptr += sizeof(VEC);
; 583  : 
; 584  : // set ang vel
; 585  : 
; 586  : 	sh = (short*)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _sh$[ebp], eax

; 587  : 	*sh++ = (short)(car->Body->AngVel.v[X] * CAR_REMOTE_ANGVEL_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR __real@447a0000
	call	__ftol2
	mov	edx, DWORD PTR _sh$[ebp]
	mov	WORD PTR [edx], ax
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 588  : 	*sh++ = (short)(car->Body->AngVel.v[Y] * CAR_REMOTE_ANGVEL_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR __real@447a0000
	call	__ftol2
	mov	edx, DWORD PTR _sh$[ebp]
	mov	WORD PTR [edx], ax
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 589  : 	*sh++ = (short)(car->Body->AngVel.v[Z] * CAR_REMOTE_ANGVEL_SCALE);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR __real@447a0000
	call	__ftol2
	mov	edx, DWORD PTR _sh$[ebp]
	mov	WORD PTR [edx], ax
	mov	eax, DWORD PTR _sh$[ebp]
	add	eax, 2
	mov	DWORD PTR _sh$[ebp], eax

; 590  : 	header->Contents |= MESSAGE_CONTENTS_CAR_ANGVEL;

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _header$[ebp]
	mov	WORD PTR [edx+2], cx

; 591  : 	ptr = (char*)sh;

	mov	eax, DWORD PTR _sh$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 592  : 	//CopyVec(&car->Body->AngVel, (VEC*)ptr);
; 593  : 	//ptr += sizeof(VEC);
; 594  : 
; 595  : // set control input
; 596  : 
; 597  : 	*ptr++ = PLR_LocalPlayer->controls.dx;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	mov	dl, BYTE PTR [ecx+28]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 598  : 	*ptr++ = PLR_LocalPlayer->controls.dy;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	mov	dl, BYTE PTR [ecx+29]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 599  : 	header->Contents |= MESSAGE_CONTENTS_CAR_CONTROL;

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _header$[ebp]
	mov	WORD PTR [edx+2], cx

; 600  : 
; 601  : 
; 602  : // send
; 603  : 
; 604  : //if (Keys[DIK_SPACE])
; 605  : //{
; 606  : //	DP->
; 607  : //}
; 608  : 
; 609  : //	CancelPriority(MESSAGE_PRIORITY_CAR);
; 610  : 	TransmitMessage(TransmitBuff, (short)(ptr - TransmitBuff), DPID_ALLPLAYERS, MESSAGE_PRIORITY_CAR);

	push	1
	push	0
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	push	eax
	push	OFFSET FLAT:?TransmitBuff@@3PADA	; TransmitBuff
	call	?TransmitMessage@@YAXPADFKJ@Z		; TransmitMessage
	add	esp, 16					; 00000010H

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SendLocalCarData@@YAXXZ ENDP				; SendLocalCarData
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?SetCarAerialPos@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_pSection$ = -36					; size = 4
_iCount$ = -32						; size = 4
_iSec$ = -28						; size = 4
_wDirection$ = -24					; size = 12
_vecTemp$ = -12						; size = 12
_car$ = 8						; size = 4
?SetCarAerialPos@@YAXPAUCarStruct@@@Z PROC NEAR		; SetCarAerialPos, COMDAT

; 624  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 625  : 	VEC vecTemp;
; 626  : 	VEC wDirection;
; 627  : 	int iSec, iCount;
; 628  : 	PARTICLE *pSection = &car->Aerial.Section[0];

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 888				; 00000378H
	mov	DWORD PTR _pSection$[ebp], eax

; 629  : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 630  : 
; 631  : 	// Set position of the base section and the aerial direction
; 632  : 	VecMulMat(&car->Aerial.Direction, &car->Body->Centre.WMatrix, &wDirection);

	lea	eax, DWORD PTR _wDirection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 860				; 0000035cH
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 633  : 	VecMulMat(&car->AerialOffset, &car->Body->Centre.WMatrix, &vecTemp);

	lea	eax, DWORD PTR _vecTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3388				; 00000d3cH
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 634  : 	VecPlusVec(&vecTemp, &car->Body->Centre.Pos, &pSection->Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _vecTemp$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _vecTemp$[ebp+4]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _vecTemp$[ebp+8]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [edx+28]

; 635  : 
; 636  : 	SetVecZero(&pSection->Vel);

	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+40], 0

; 637  : 	SetVecZero(&pSection->Acc);

	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+44], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+52], 0

; 638  : 	SetVecZero(&pSection->Impulse);

	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+60], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+64], 0

; 639  : 
; 640  : 	// Place all control sections in the correct place and set up their matrices
; 641  : 	for (iSec = AERIAL_START; iSec < AERIAL_NSECTIONS; iSec += AERIAL_SKIP) {

	mov	DWORD PTR _iSec$[ebp], 1
	jmp	SHORT $L81993
$L81994:
	mov	eax, DWORD PTR _iSec$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSec$[ebp], eax
$L81993:
	cmp	DWORD PTR _iSec$[ebp], 3
	jge	$L81987

; 642  : 		iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax

; 643  : 		// Store a pointer to the current section (avoid excessive dereferencing)
; 644  : 		pSection = &car->Aerial.Section[iSec];

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+888]
	mov	DWORD PTR _pSection$[ebp], edx

; 645  : 
; 646  : 		// Set the section positions
; 647  : 		VecEqScalarVec(&pSection->Pos, MulScalar(iCount, car->Aerial.Length), &wDirection);

	fild	DWORD PTR _iCount$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fmul	DWORD PTR [eax+872]
	fmul	DWORD PTR _wDirection$[ebp]
	mov	ecx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [ecx+20]
	fild	DWORD PTR _iCount$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fmul	DWORD PTR [eax+872]
	fmul	DWORD PTR _wDirection$[ebp+4]
	mov	ecx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [ecx+24]
	fild	DWORD PTR _iCount$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fmul	DWORD PTR [eax+872]
	fmul	DWORD PTR _wDirection$[ebp+8]
	mov	ecx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [ecx+28]

; 648  : 		VecPlusEqVec(&pSection->Pos, &car->Aerial.Section[0].Pos);

	mov	eax, DWORD PTR _pSection$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+908]
	mov	edx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+24]
	fadd	DWORD PTR [ecx+912]
	mov	edx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR [ecx+916]
	mov	edx, DWORD PTR _pSection$[ebp]
	fstp	DWORD PTR [edx+28]

; 649  : 
; 650  : 		// Zero the velocities
; 651  : 		SetVecZero(&pSection->Vel);

	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+40], 0

; 652  : 		SetVecZero(&pSection->Acc);

	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+44], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+52], 0

; 653  : 		SetVecZero(&pSection->Impulse);

	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+60], 0
	mov	eax, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax+64], 0

; 654  : 		
; 655  : 	}

	jmp	$L81994
$L81987:

; 656  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCarAerialPos@@YAXPAUCarStruct@@@Z ENDP		; SetCarAerialPos
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z		; UpdateCarAerial2
EXTRN	?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z:NEAR ; ApplyParticleImpulse
EXTRN	?UpdateParticle@@YAXPAUParticleStruct@@M@Z:NEAR	; UpdateParticle
EXTRN	?ParticleWorldColls@@YAXPAUParticleStruct@@@Z:NEAR ; ParticleWorldColls
; Function compile flags: /Odt /ZI
;	COMDAT ?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z
_TEXT	SEGMENT
_dRTot$ = -112						; size = 12
_impulse$ = -100					; size = 12
_velPar$ = -88						; size = 12
_velDotDir$ = -76					; size = 4
_velDotThis$ = -72					; size = 4
_crossLen$ = -68					; size = 4
_thisCrossPrev$ = -64					; size = 12
_thisLen$ = -52						; size = 4
_dRThis$ = -48						; size = 12
_scale$ = -36						; size = 4
_prevLen$ = -32						; size = 4
_dRPrev$ = -28						; size = 12
_vecTemp$ = -16						; size = 12
_iSec$ = -4						; size = 4
_car$ = 8						; size = 4
_dt$ = 12						; size = 4
?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z PROC NEAR	; UpdateCarAerial2, COMDAT

; 732  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi

; 733  : 	int iSec;
; 734  : 	VEC vecTemp;
; 735  : 	VEC dRPrev;
; 736  : 	REAL prevLen;
; 737  : 	REAL scale;
; 738  : 	VEC dRThis;
; 739  : 	REAL thisLen;
; 740  : 	VEC thisCrossPrev;
; 741  : 	REAL crossLen;
; 742  : 	REAL velDotThis;
; 743  : 	REAL velDotDir;
; 744  : 	VEC velPar;
; 745  : 	VEC impulse = {ZERO, ZERO, ZERO};

	mov	DWORD PTR _impulse$[ebp], 0
	mov	DWORD PTR _impulse$[ebp+4], 0
	mov	DWORD PTR _impulse$[ebp+8], 0

; 746  : 	VEC dRTot = {ZERO, ZERO, ZERO};

	mov	DWORD PTR _dRTot$[ebp], 0
	mov	DWORD PTR _dRTot$[ebp+4], 0
	mov	DWORD PTR _dRTot$[ebp+8], 0

; 747  : 
; 748  : 	// Calculate the world position of the aerial base from the car's
; 749  : 	// world position and world matrix
; 750  : 	// Calculate the aerial's look direction and set the world matrix
; 751  : 	VecMulMat(&car->AerialOffset, &car->Body->Centre.WMatrix, &vecTemp);

	lea	eax, DWORD PTR _vecTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3388				; 00000d3cH
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 752  : 	VecPlusVec(&vecTemp, &car->Body->Centre.Pos, &car->Aerial.Section[0].Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _vecTemp$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [edx+908]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _vecTemp$[ebp+4]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [edx+912]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _vecTemp$[ebp+8]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [edx+916]

; 753  : 	VecMulMat(&car->Aerial.Direction, &car->Body->Centre.WMatrix, &dRPrev);

	lea	eax, DWORD PTR _dRPrev$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 860				; 0000035cH
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 754  : 
; 755  : 	prevLen = ONE;

	mov	DWORD PTR _prevLen$[ebp], 1065353216	; 3f800000H

; 756  : 
; 757  : 	// calculate the position of the controlled nodes (others are interpolated)
; 758  : 	for (iSec = AERIAL_START; iSec < AERIAL_NSECTIONS; iSec += AERIAL_SKIP) {

	mov	DWORD PTR _iSec$[ebp], 1
	jmp	SHORT $L82014
$L82015:
	mov	eax, DWORD PTR _iSec$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSec$[ebp], eax
$L82014:
	cmp	DWORD PTR _iSec$[ebp], 3
	jge	$L81999

; 759  : 
; 760  : 		// Update the position of the node
; 761  : 		UpdateParticle(&car->Aerial.Section[iSec], dt);

	mov	eax, DWORD PTR _dt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSec$[ebp]
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+888]
	push	eax
	call	?UpdateParticle@@YAXPAUParticleStruct@@M@Z ; UpdateParticle
	add	esp, 8

; 762  : 
; 763  : 		// Calculate the length of this section of aerial and
; 764  : 		// the unit vector along this aerial section
; 765  : 		VecMinusVec(&car->Aerial.Section[iSec].Pos, &car->Aerial.Section[iSec - AERIAL_SKIP].Pos, &dRThis);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+908]
	fsub	DWORD PTR [esi+ecx+908]
	fstp	DWORD PTR _dRThis$[ebp]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+912]
	fsub	DWORD PTR [esi+ecx+912]
	fstp	DWORD PTR _dRThis$[ebp+4]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+916]
	fsub	DWORD PTR [esi+ecx+916]
	fstp	DWORD PTR _dRThis$[ebp+8]

; 766  : 		thisLen = Length(&dRThis);

	fld	DWORD PTR _dRThis$[ebp]
	fmul	DWORD PTR _dRThis$[ebp]
	fld	DWORD PTR _dRThis$[ebp+4]
	fmul	DWORD PTR _dRThis$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dRThis$[ebp+8]
	fmul	DWORD PTR _dRThis$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _thisLen$[ebp]

; 767  : 
; 768  : 		VecDivScalar(&dRThis, thisLen);

	fld	DWORD PTR _dRThis$[ebp]
	fdiv	DWORD PTR _thisLen$[ebp]
	fstp	DWORD PTR _dRThis$[ebp]
	fld	DWORD PTR _dRThis$[ebp+4]
	fdiv	DWORD PTR _thisLen$[ebp]
	fstp	DWORD PTR _dRThis$[ebp+4]
	fld	DWORD PTR _dRThis$[ebp+8]
	fdiv	DWORD PTR _thisLen$[ebp]
	fstp	DWORD PTR _dRThis$[ebp+8]

; 769  : 		
; 770  : 		// Move aerial section to keep aerial length constant
; 771  : 		VecPlusEqScalarVec(&car->Aerial.Section[iSec].Pos, car->Aerial.Length - thisLen, &dRThis);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+872]
	fsub	DWORD PTR _thisLen$[ebp]
	fmul	DWORD PTR _dRThis$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+908]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+eax+908]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+872]
	fsub	DWORD PTR _thisLen$[ebp]
	fmul	DWORD PTR _dRThis$[ebp+4]
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+912]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+eax+912]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+872]
	fsub	DWORD PTR _thisLen$[ebp]
	fmul	DWORD PTR _dRThis$[ebp+8]
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+916]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+eax+916]

; 772  : 
; 773  : 		// Calculate force on the end of the section due to the bend of the aerial
; 774  : 		VecCrossVec(&dRThis, &dRPrev, &thisCrossPrev);

	fld	DWORD PTR _dRThis$[ebp+4]
	fmul	DWORD PTR _dRPrev$[ebp+8]
	fld	DWORD PTR _dRThis$[ebp+8]
	fmul	DWORD PTR _dRPrev$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _thisCrossPrev$[ebp]
	fld	DWORD PTR _dRThis$[ebp+8]
	fmul	DWORD PTR _dRPrev$[ebp]
	fld	DWORD PTR _dRThis$[ebp]
	fmul	DWORD PTR _dRPrev$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _thisCrossPrev$[ebp+4]
	fld	DWORD PTR _dRThis$[ebp]
	fmul	DWORD PTR _dRPrev$[ebp+4]
	fld	DWORD PTR _dRThis$[ebp+4]
	fmul	DWORD PTR _dRPrev$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _thisCrossPrev$[ebp+8]

; 775  : 		crossLen = VecLen(&thisCrossPrev);

	fld	DWORD PTR _thisCrossPrev$[ebp]
	fmul	DWORD PTR _thisCrossPrev$[ebp]
	fld	DWORD PTR _thisCrossPrev$[ebp+4]
	fmul	DWORD PTR _thisCrossPrev$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _thisCrossPrev$[ebp+8]
	fmul	DWORD PTR _thisCrossPrev$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _crossLen$[ebp]

; 776  : 		VecCrossVec(&dRThis, &thisCrossPrev, &vecTemp);

	fld	DWORD PTR _dRThis$[ebp+4]
	fmul	DWORD PTR _thisCrossPrev$[ebp+8]
	fld	DWORD PTR _dRThis$[ebp+8]
	fmul	DWORD PTR _thisCrossPrev$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vecTemp$[ebp]
	fld	DWORD PTR _dRThis$[ebp+8]
	fmul	DWORD PTR _thisCrossPrev$[ebp]
	fld	DWORD PTR _dRThis$[ebp]
	fmul	DWORD PTR _thisCrossPrev$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vecTemp$[ebp+4]
	fld	DWORD PTR _dRThis$[ebp]
	fmul	DWORD PTR _thisCrossPrev$[ebp+4]
	fld	DWORD PTR _dRThis$[ebp+4]
	fmul	DWORD PTR _thisCrossPrev$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _vecTemp$[ebp+8]

; 777  : 		scale = MulScalar(car->Aerial.Length, car->Aerial.Stiffness);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+872]
	mov	ecx, DWORD PTR _car$[ebp]
	fmul	DWORD PTR [ecx+876]
	fstp	DWORD PTR _scale$[ebp]

; 778  : 		scale = MulScalar(scale, crossLen);

	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _crossLen$[ebp]
	fstp	DWORD PTR _scale$[ebp]

; 779  : 		VecEqScalarVec(&impulse, -scale, &vecTemp);

	fld	DWORD PTR _scale$[ebp]
	fchs
	fmul	DWORD PTR _vecTemp$[ebp]
	fstp	DWORD PTR _impulse$[ebp]
	fld	DWORD PTR _scale$[ebp]
	fchs
	fmul	DWORD PTR _vecTemp$[ebp+4]
	fstp	DWORD PTR _impulse$[ebp+4]
	fld	DWORD PTR _scale$[ebp]
	fchs
	fmul	DWORD PTR _vecTemp$[ebp+8]
	fstp	DWORD PTR _impulse$[ebp+8]

; 780  : 
; 781  : 		// add the spring damping
; 782  : 		VecMinusVec(&car->Aerial.Section[iSec].Vel, &car->Aerial.Section[0].Vel, &velPar);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+eax+920]
	fsub	DWORD PTR [edx+920]
	fstp	DWORD PTR _velPar$[ebp]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+eax+924]
	fsub	DWORD PTR [edx+924]
	fstp	DWORD PTR _velPar$[ebp+4]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+eax+928]
	fsub	DWORD PTR [edx+928]
	fstp	DWORD PTR _velPar$[ebp+8]

; 783  : 		velDotDir = VecDotVec(&velPar, &dRPrev);

	fld	DWORD PTR _velPar$[ebp]
	fmul	DWORD PTR _dRPrev$[ebp]
	fld	DWORD PTR _velPar$[ebp+4]
	fmul	DWORD PTR _dRPrev$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _velPar$[ebp+8]
	fmul	DWORD PTR _dRPrev$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotDir$[ebp]

; 784  : 		VecPlusEqScalarVec(&velPar, -velDotDir, &dRPrev);

	fld	DWORD PTR _velDotDir$[ebp]
	fchs
	fmul	DWORD PTR _dRPrev$[ebp]
	fadd	DWORD PTR _velPar$[ebp]
	fstp	DWORD PTR _velPar$[ebp]
	fld	DWORD PTR _velDotDir$[ebp]
	fchs
	fmul	DWORD PTR _dRPrev$[ebp+4]
	fadd	DWORD PTR _velPar$[ebp+4]
	fstp	DWORD PTR _velPar$[ebp+4]
	fld	DWORD PTR _velDotDir$[ebp]
	fchs
	fmul	DWORD PTR _dRPrev$[ebp+8]
	fadd	DWORD PTR _velPar$[ebp+8]
	fstp	DWORD PTR _velPar$[ebp+8]

; 785  : 		VecPlusEqScalarVec(&impulse, -car->Aerial.Damping, &velPar);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+880]
	fchs
	fmul	DWORD PTR _velPar$[ebp]
	fadd	DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR _impulse$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+880]
	fchs
	fmul	DWORD PTR _velPar$[ebp+4]
	fadd	DWORD PTR _impulse$[ebp+4]
	fstp	DWORD PTR _impulse$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+880]
	fchs
	fmul	DWORD PTR _velPar$[ebp+8]
	fadd	DWORD PTR _impulse$[ebp+8]
	fstp	DWORD PTR _impulse$[ebp+8]

; 786  : 
; 787  : 		// Turn the force into an impulse
; 788  : 		VecMulScalar(&impulse, dt);

	fld	DWORD PTR _impulse$[ebp]
	fmul	DWORD PTR _dt$[ebp]
	fstp	DWORD PTR _impulse$[ebp]
	fld	DWORD PTR _impulse$[ebp+4]
	fmul	DWORD PTR _dt$[ebp]
	fstp	DWORD PTR _impulse$[ebp+4]
	fld	DWORD PTR _impulse$[ebp+8]
	fmul	DWORD PTR _dt$[ebp]
	fstp	DWORD PTR _impulse$[ebp+8]

; 789  : 
; 790  : 		// Apply the impulse to the node from the force
; 791  : 		ApplyParticleImpulse(&car->Aerial.Section[iSec], &impulse);

	lea	eax, DWORD PTR _impulse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSec$[ebp]
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+888]
	push	eax
	call	?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z ; ApplyParticleImpulse
	add	esp, 8

; 792  : 
; 793  : 		// This node will now become previous node
; 794  : 		CopyVec(&dRThis, &dRPrev);

	mov	eax, DWORD PTR _dRThis$[ebp]
	mov	DWORD PTR _dRPrev$[ebp], eax
	mov	eax, DWORD PTR _dRThis$[ebp+4]
	mov	DWORD PTR _dRPrev$[ebp+4], eax
	mov	eax, DWORD PTR _dRThis$[ebp+8]
	mov	DWORD PTR _dRPrev$[ebp+8], eax

; 795  : 		prevLen = thisLen;

	mov	eax, DWORD PTR _thisLen$[ebp]
	mov	DWORD PTR _prevLen$[ebp], eax

; 796  : 
; 797  : 		// Fudge the position so that the section lengths are restored
; 798  : 		VecMinusVec(&car->Aerial.Section[iSec].Pos, &car->Aerial.Section[iSec - AERIAL_SKIP].Pos, &dRThis);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+908]
	fsub	DWORD PTR [esi+ecx+908]
	fstp	DWORD PTR _dRThis$[ebp]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+912]
	fsub	DWORD PTR [esi+ecx+912]
	fstp	DWORD PTR _dRThis$[ebp+4]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+916]
	fsub	DWORD PTR [esi+ecx+916]
	fstp	DWORD PTR _dRThis$[ebp+8]

; 799  : 		thisLen = VecLen(&dRThis);

	fld	DWORD PTR _dRThis$[ebp]
	fmul	DWORD PTR _dRThis$[ebp]
	fld	DWORD PTR _dRThis$[ebp+4]
	fmul	DWORD PTR _dRThis$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dRThis$[ebp+8]
	fmul	DWORD PTR _dRThis$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _thisLen$[ebp]

; 800  : 		
; 801  : 		VecDivScalar(&dRThis, thisLen);

	fld	DWORD PTR _dRThis$[ebp]
	fdiv	DWORD PTR _thisLen$[ebp]
	fstp	DWORD PTR _dRThis$[ebp]
	fld	DWORD PTR _dRThis$[ebp+4]
	fdiv	DWORD PTR _thisLen$[ebp]
	fstp	DWORD PTR _dRThis$[ebp+4]
	fld	DWORD PTR _dRThis$[ebp+8]
	fdiv	DWORD PTR _thisLen$[ebp]
	fstp	DWORD PTR _dRThis$[ebp+8]

; 802  : 
; 803  : 		VecPlusEqScalarVec(&car->Aerial.Section[iSec].Pos, car->Aerial.Length - thisLen, &dRThis);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+872]
	fsub	DWORD PTR _thisLen$[ebp]
	fmul	DWORD PTR _dRThis$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+908]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+eax+908]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+872]
	fsub	DWORD PTR _thisLen$[ebp]
	fmul	DWORD PTR _dRThis$[ebp+4]
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+912]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+eax+912]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+872]
	fsub	DWORD PTR _thisLen$[ebp]
	fmul	DWORD PTR _dRThis$[ebp+8]
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+916]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+eax+916]

; 804  : 
; 805  : 		// Check for collisions
; 806  : #ifdef _PC
; 807  : 		ParticleWorldColls(&car->Aerial.Section[iSec]);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+888]
	push	edx
	call	?ParticleWorldColls@@YAXPAUParticleStruct@@@Z ; ParticleWorldColls
	add	esp, 4

; 808  : #endif
; 809  : 
; 810  : 		// remove component of velocity along direction of the aerial
; 811  : 		VecMinusVec(&car->Aerial.Section[iSec].Vel, &car->Aerial.Section[iSec - AERIAL_SKIP].Vel, &vecTemp);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+920]
	fsub	DWORD PTR [esi+ecx+920]
	fstp	DWORD PTR _vecTemp$[ebp]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+924]
	fsub	DWORD PTR [esi+ecx+924]
	fstp	DWORD PTR _vecTemp$[ebp+4]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	mov	ecx, DWORD PTR _iSec$[ebp]
	sub	ecx, 1
	imul	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _car$[ebp]
	mov	esi, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+eax+928]
	fsub	DWORD PTR [esi+ecx+928]
	fstp	DWORD PTR _vecTemp$[ebp+8]

; 812  : 		velDotThis = VecDotVec(&vecTemp, &dRThis);

	fld	DWORD PTR _vecTemp$[ebp]
	fmul	DWORD PTR _dRThis$[ebp]
	fld	DWORD PTR _vecTemp$[ebp+4]
	fmul	DWORD PTR _dRThis$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vecTemp$[ebp+8]
	fmul	DWORD PTR _dRThis$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotThis$[ebp]

; 813  : 		VecPlusEqScalarVec(&car->Aerial.Section[iSec].Vel, -velDotThis, &dRThis);

	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	fld	DWORD PTR _velDotThis$[ebp]
	fchs
	fmul	DWORD PTR _dRThis$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [ecx+eax+920]
	mov	edx, DWORD PTR _iSec$[ebp]
	imul	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+920]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	fld	DWORD PTR _velDotThis$[ebp]
	fchs
	fmul	DWORD PTR _dRThis$[ebp+4]
	mov	ecx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [ecx+eax+924]
	mov	edx, DWORD PTR _iSec$[ebp]
	imul	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+924]
	mov	eax, DWORD PTR _iSec$[ebp]
	imul	eax, 224				; 000000e0H
	fld	DWORD PTR _velDotThis$[ebp]
	fchs
	fmul	DWORD PTR _dRThis$[ebp+8]
	mov	ecx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [ecx+eax+928]
	mov	edx, DWORD PTR _iSec$[ebp]
	imul	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+928]

; 814  : 
; 815  : 
; 816  : 	}

	jmp	$L82015
$L81999:

; 817  : 
; 818  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z ENDP		; UpdateCarAerial2
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??CreateCarInfo@@YAPAUCAR_INFO@@J@Z@4JA ; `CreateCarInfo'::`2'::__LINE__Var
PUBLIC	??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	?CreateCarInfo@@YAPAUCAR_INFO@@J@Z		; CreateCarInfo
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
;	COMDAT ??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\car.cpp
CONST	SEGMENT
??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\car.c'
	DB	'pp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CreateCarInfo@@YAPAUCAR_INFO@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateCarInfo@@YAPAUCAR_INFO@@J@Z@4JA DD 03b6H ; `CreateCarInfo'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateCarInfo@@YAPAUCAR_INFO@@J@Z
_TEXT	SEGMENT
_nInfo$ = 8						; size = 4
?CreateCarInfo@@YAPAUCAR_INFO@@J@Z PROC NEAR		; CreateCarInfo, COMDAT

; 950  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 951  : 	return (CAR_INFO *)malloc(sizeof(CAR_INFO) * nInfo);

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateCarInfo@@YAPAUCAR_INFO@@J@Z@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _nInfo$[ebp]
	imul	ecx, 2220				; 000008acH
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH

; 952  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCarInfo@@YAPAUCAR_INFO@@J@Z ENDP			; CreateCarInfo
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyCarInfo@@YAXXZ@4JA	; `DestroyCarInfo'::`2'::__LINE__Var
PUBLIC	?DestroyCarInfo@@YAXXZ				; DestroyCarInfo
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??DestroyCarInfo@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DestroyCarInfo@@YAXXZ@4JA DD 03bbH	; `DestroyCarInfo'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DestroyCarInfo@@YAXXZ
_TEXT	SEGMENT
?DestroyCarInfo@@YAXXZ PROC NEAR			; DestroyCarInfo, COMDAT

; 955  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 956  : 	if ((CarInfo == NULL) || (NCarTypes == 0)) return;

	cmp	DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A, 0	; CarInfo
	je	SHORT $L82030
	cmp	DWORD PTR ?NCarTypes@@3JA, 0		; NCarTypes
	jne	SHORT $L82029
$L82030:
	jmp	SHORT $L82028
$L82029:

; 957  : 	free(CarInfo);

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyCarInfo@@YAXXZ@4JA
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 958  : 	CarInfo = NULL;

	mov	DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A, 0	; CarInfo

; 959  : 	NCarTypes = 0;

	mov	DWORD PTR ?NCarTypes@@3JA, 0		; NCarTypes
$L82028:

; 960  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyCarInfo@@YAXXZ ENDP				; DestroyCarInfo
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??CreateCarModels@@YAPAUCAR_MODEL@@J@Z@4JA ; `CreateCarModels'::`2'::__LINE__Var
PUBLIC	?CreateCarModels@@YAPAUCAR_MODEL@@J@Z		; CreateCarModels
;	COMDAT ?__LINE__Var@?1??CreateCarModels@@YAPAUCAR_MODEL@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateCarModels@@YAPAUCAR_MODEL@@J@Z@4JA DD 03caH ; `CreateCarModels'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateCarModels@@YAPAUCAR_MODEL@@J@Z
_TEXT	SEGMENT
_nModels$ = 8						; size = 4
?CreateCarModels@@YAPAUCAR_MODEL@@J@Z PROC NEAR		; CreateCarModels, COMDAT

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 971  : 	return (CAR_MODEL *)malloc(sizeof(CAR_MODEL) * nModels);

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateCarModels@@YAPAUCAR_MODEL@@J@Z@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _nModels$[ebp]
	imul	ecx, 6248				; 00001868H
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH

; 972  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCarModels@@YAPAUCAR_MODEL@@J@Z ENDP		; CreateCarModels
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyCarModels@@YAXPAUCAR_MODEL@@@Z@4JA ; `DestroyCarModels'::`2'::__LINE__Var
PUBLIC	?DestroyCarModels@@YAXPAUCAR_MODEL@@@Z		; DestroyCarModels
;	COMDAT ?__LINE__Var@?1??DestroyCarModels@@YAXPAUCAR_MODEL@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DestroyCarModels@@YAXPAUCAR_MODEL@@@Z@4JA DD 03cfH ; `DestroyCarModels'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DestroyCarModels@@YAXPAUCAR_MODEL@@@Z
_TEXT	SEGMENT
_carModels$ = 8						; size = 4
?DestroyCarModels@@YAXPAUCAR_MODEL@@@Z PROC NEAR	; DestroyCarModels, COMDAT

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 976  : 	free(carModels);

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyCarModels@@YAXPAUCAR_MODEL@@@Z@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _carModels$[ebp]
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 977  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyCarModels@@YAXPAUCAR_MODEL@@@Z ENDP		; DestroyCarModels
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ResetCarWheelPos@@YAXPAUCarStruct@@H@Z
_TEXT	SEGMENT
tv330 = -72						; size = 4
tv310 = -72						; size = 4
tv290 = -72						; size = 4
tv270 = -72						; size = 4
tv250 = -72						; size = 4
tv230 = -72						; size = 4
_wheel$ = -4						; size = 4
_car$ = 8						; size = 4
_iWheel$ = 12						; size = 4
?ResetCarWheelPos@@YAXPAUCarStruct@@H@Z PROC NEAR	; ResetCarWheelPos, COMDAT

; 987  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 988  : 	WHEEL	*wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 989  : 
; 990  : 	wheel->Pos = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+80], 0

; 991  : 	wheel->Vel = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+88], 0

; 992  : 	wheel->Acc = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+96], 0

; 993  : 	wheel->Impulse = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+104], 0

; 994  : 	wheel->AngPos = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+84], 0

; 995  : 	wheel->AngVel = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+92], 0

; 996  : 	wheel->AngAcc = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+100], 0

; 997  : 	wheel->AngImpulse = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+108], 0

; 998  : 
; 999  : 	wheel->TurnAngle = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+292], 0

; 1000 : 
; 1001 : 	VecMulMat(&car->WheelOffset[iWheel], &car->Body->Centre.WMatrix, &wheel->WPos);

	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 160				; 000000a0H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3184]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1002 : 	VecPlusEqVec(&wheel->WPos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+160]
	fadd	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+160]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+164]
	fadd	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+164]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+168]
	fadd	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+168]

; 1003 : 	CopyVec(&wheel->WPos, &wheel->OldWPos);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR [eax+172], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	DWORD PTR [eax+176], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [eax+180], edx

; 1004 : 	VecMulMat(&car->WheelCentre[iWheel], &car->Body->Centre.WMatrix, &wheel->CentrePos);

	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 184				; 000000b8H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3232]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1005 : 	VecPlusEqVec(&wheel->CentrePos, &wheel->WPos);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+184]
	fadd	DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+184]
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+188]
	fadd	DWORD PTR [ecx+164]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+188]
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+192]
	fadd	DWORD PTR [ecx+168]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+192]

; 1006 : 	CopyVec(&wheel->CentrePos, &wheel->OldCentrePos);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+196], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR [eax+200], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR [eax+204], edx

; 1007 : 
; 1008 : 	// Build bounding box
; 1009 : 	SetBBox(&wheel->BBox,
; 1010 : 		Min(wheel->OldCentrePos.v[X], wheel->CentrePos.v[X]) - wheel->Radius,
; 1011 : 		Max(wheel->OldCentrePos.v[X], wheel->CentrePos.v[X]) + wheel->Radius,
; 1012 : 		Min(wheel->OldCentrePos.v[Y], wheel->CentrePos.v[Y]) - wheel->Radius,
; 1013 : 		Max(wheel->OldCentrePos.v[Y], wheel->CentrePos.v[Y]) + wheel->Radius,
; 1014 : 		Min(wheel->OldCentrePos.v[Z], wheel->CentrePos.v[Z]) - wheel->Radius,
; 1015 : 		Max(wheel->OldCentrePos.v[Z], wheel->CentrePos.v[Z]) + wheel->Radius);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+184]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82885
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR tv230[ebp], eax
	jmp	SHORT $L82886
$L82885:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR tv230[ebp], edx
$L82886:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv230[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+184]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82887
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR tv250[ebp], eax
	jmp	SHORT $L82888
$L82887:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR tv250[ebp], edx
$L82888:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv250[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+188]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82889
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR tv270[ebp], eax
	jmp	SHORT $L82890
$L82889:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR tv270[ebp], edx
$L82890:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv270[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+188]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82891
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $L82892
$L82891:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR tv290[ebp], edx
$L82892:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv290[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+192]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82893
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR tv310[ebp], eax
	jmp	SHORT $L82894
$L82893:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR tv310[ebp], edx
$L82894:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv310[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+192]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82895
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR tv330[ebp], eax
	jmp	SHORT $L82896
$L82895:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR tv330[ebp], edx
$L82896:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv330[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+72]

; 1016 : 
; 1017 : 	CopyMat(&car->Body->Centre.WMatrix, &wheel->Axes);

	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 208				; 000000d0H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 1018 : 
; 1019 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetCarWheelPos@@YAXPAUCarStruct@@H@Z ENDP		; ResetCarWheelPos
_TEXT	ENDS
PUBLIC	?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z		; UpdateCarWheel
PUBLIC	__real@42f00000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
EXTRN	?SpringDampedForce@@YAMPAUSPRING@@MM@Z:NEAR	; SpringDampedForce
EXTRN	?MatMulMat@@YAXPATMatrixUnion@@00@Z:NEAR	; MatMulMat
EXTRN	?RotationX@@YAXPATMatrixUnion@@M@Z:NEAR		; RotationX
EXTRN	?RotationY@@YAXPATMatrixUnion@@M@Z:NEAR		; RotationY
EXTRN	?DownVec@@3UVectorStruct@@A:BYTE		; DownVec
EXTRN	?GoodWrap@@YAMPAMMM@Z:NEAR			; GoodWrap
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z
_TEXT	SEGMENT
tv866 = -152						; size = 4
tv854 = -152						; size = 4
tv681 = -152						; size = 4
tv661 = -152						; size = 4
tv641 = -152						; size = 4
tv621 = -152						; size = 4
tv601 = -152						; size = 4
tv581 = -152						; size = 4
_spring$ = -84						; size = 4
_wheel$ = -80						; size = 4
_tmpMat$ = -76						; size = 36
_centAcc$ = -40						; size = 12
_dR$ = -28						; size = 12
_tmpVec$ = -16						; size = 12
_scale$ = -4						; size = 4
_car$ = 8						; size = 4
_iWheel$ = 12						; size = 4
_dt$ = 16						; size = 4
?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z PROC NEAR	; UpdateCarWheel, COMDAT

; 1029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi

; 1030 : 	REAL scale;
; 1031 : 	VEC tmpVec;
; 1032 : 	VEC dR, centAcc;
; 1033 : 	MAT tmpMat;
; 1034 : 	WHEEL  *wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 1035 : 	SPRING *spring = &car->Spring[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3000]
	mov	DWORD PTR _spring$[ebp], edx

; 1036 : 
; 1037 : 	// Apply torque from engine
; 1038 : 	if ((IsWheelPowered(wheel) && !IsWheelInContact(wheel)) || (IsWheelSpinning(wheel) && IsWheelInContact(wheel))) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4
	je	SHORT $L82061
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $L82060
$L82061:
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 16					; 00000010H
	je	SHORT $L82059
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $L82059
$L82060:

; 1039 : 		//wheel->AngImpulse += MulScalar(dt, MulScalar(car->EngineVolt, wheel->EngineRatio));
; 1040 : 		wheel->AngImpulse += MulScalar(dt, MulScalar(car->EngineVolt, wheel->SpinAngImp));

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [ecx+120]
	fmul	DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [edx+108]
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+108]
$L82059:

; 1041 : 	}
; 1042 : 
; 1043 : 	// Get accelerations
; 1044 : 	wheel->Acc = MulScalar(wheel->InvMass, wheel->Impulse);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [ecx+104]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+96]

; 1045 : 	wheel->AngAcc = MulScalar(wheel->InvInertia, wheel->AngImpulse);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [ecx+108]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+100]

; 1046 : 
; 1047 : 	if (CAR_WheelsHaveSuspension) {

	movzx	eax, BYTE PTR ?CAR_WheelsHaveSuspension@@3_NA ; CAR_WheelsHaveSuspension
	test	eax, eax
	je	$L82062

; 1048 : 
; 1049 : 		// Remove centripetal acceleration from the spin of the car
; 1050 : 		// and up component of linear acceleration
; 1051 : #ifndef _PSX
; 1052 : 		VecMinusVec(&wheel->WPos, &car->Body->Centre.Pos, &dR);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+160]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+164]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+168]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dR$[ebp+8]

; 1053 : 		VecCrossVec(&dR, &car->Body->AngVel, &tmpVec);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR [ecx+340]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR [eax+336]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR [ecx+332]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR [eax+340]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR [ecx+336]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR [eax+332]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1054 : 		VecCrossVec(&car->Body->AngVel, &tmpVec, &centAcc);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR [ecx+336]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR [eax+340]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _centAcc$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR [ecx+340]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR [eax+332]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _centAcc$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR [ecx+332]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR [eax+336]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _centAcc$[ebp+8]

; 1055 : 		wheel->Acc += MulScalar(dt, VecDotVec(&centAcc, &car->Body->Centre.WMatrix.mv[U]));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _centAcc$[ebp]
	fmul	DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _centAcc$[ebp+4]
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR _centAcc$[ebp+8]
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+96]

; 1056 : 		wheel->Acc -= VecDotVec(&car->Body->Centre.Acc, &car->Body->Centre.WMatrix.mv[U]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+44]
	fmul	DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+48]
	fmul	DWORD PTR [ecx+116]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+52]
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheel$[ebp]
	fsubr	DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+96]
$L82062:

; 1057 : #endif
; 1058 : 
; 1059 : 	}
; 1060 : 
; 1061 : 	// Get new velocities
; 1062 : 	wheel->Vel += wheel->Acc;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	fadd	DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+88]

; 1063 : 	wheel->AngVel += wheel->AngAcc;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+92]
	fadd	DWORD PTR [ecx+100]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+92]

; 1064 : 
; 1065 : 	// Add damping
; 1066 : 	scale = MulScalar(MulScalar(FRICTION_TIME_SCALE, dt), wheel->AxleFriction);

	fld	DWORD PTR __real@42f00000
	fmul	DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [eax+48]
	fstp	DWORD PTR _scale$[ebp]

; 1067 : 	wheel->AngVel = MulScalar(wheel->AngVel, (ONE - scale));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+92]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _scale$[ebp]
	fmulp	ST(1), ST(0)
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+92]

; 1068 : 
; 1069 : 	// Get new positions
; 1070 : 	wheel->Pos += MulScalar(wheel->Vel, dt);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	fmul	DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+80]

; 1071 : 	Limit(wheel->Pos, -wheel->MaxPos, wheel->MaxPos);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+112]
	fchs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82064
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+112]
	fchs
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+80]
$L82064:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+112]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82065
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+80]
$L82065:

; 1072 : 	wheel->AngPos += MulScalar(wheel->AngVel, dt);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+84]

; 1073 : 	GoodWrap(&wheel->AngPos, ZERO, FULL_CIRCLE);

	push	1086918619				; 40c90fdbH
	push	0
	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	call	?GoodWrap@@YAMPAMMM@Z			; GoodWrap
	fstp	ST(0)
	add	esp, 12					; 0000000cH

; 1074 : 
; 1075 : 	if (CAR_WheelsHaveSuspension) {

	movzx	eax, BYTE PTR ?CAR_WheelsHaveSuspension@@3_NA ; CAR_WheelsHaveSuspension
	test	eax, eax
	je	$L82066

; 1076 : 
; 1077 : 		// Add spring forces
; 1078 : 		if (!IsWheelInContact(wheel)) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	jne	SHORT $L82067

; 1079 : 			wheel->Vel += MulScalar(wheel->InvMass, MulScalar(SpringDampedForce(spring, wheel->Pos, wheel->Vel), dt));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR tv854[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	mov	edx, DWORD PTR _spring$[ebp]
	push	edx
	call	?SpringDampedForce@@YAMPAUSPRING@@MM@Z	; SpringDampedForce
	add	esp, 12					; 0000000cH
	fmul	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR tv854[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+88]

; 1080 : 		} else {

	jmp	SHORT $L82066
$L82067:

; 1081 : 			wheel->Vel += MulScalar(wheel->InvMass, MulScalar(SpringDampedForce(spring, wheel->Pos, wheel->Vel), dt)) / 2;

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR tv866[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	mov	edx, DWORD PTR _spring$[ebp]
	push	edx
	call	?SpringDampedForce@@YAMPAUSPRING@@MM@Z	; SpringDampedForce
	add	esp, 12					; 0000000cH
	fmul	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR tv866[ebp]
	fdiv	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+88]
$L82066:

; 1082 : 		}
; 1083 : 
; 1084 : 	}
; 1085 : 
; 1086 : 	// Set the wheel angles
; 1087 : 	if (IsWheelTurnable(wheel)) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 2
	je	SHORT $L82069

; 1088 : 		wheel->TurnAngle = MulScalar(car->SteerAngle, wheel->SteerRatio);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+824]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+292]
$L82069:

; 1089 : 	}
; 1090 : 
; 1091 : 	// Calculate the wheel's world matrix and position
; 1092 : 	CopyVec(&wheel->WPos, &wheel->OldWPos);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR [eax+172], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	DWORD PTR [eax+176], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [eax+180], edx

; 1093 : 	VecPlusScalarVec(&car->WheelOffset[iWheel], wheel->Pos, &DownVec, &tmpVec);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+3184]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+3188]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	mov	edx, DWORD PTR _car$[ebp]
	fadd	DWORD PTR [edx+eax+3192]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1094 : 	VecMulMat(&tmpVec, &car->Body->Centre.WMatrix, &wheel->WPos);

	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 160				; 000000a0H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	lea	eax, DWORD PTR _tmpVec$[ebp]
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1095 : 	VecPlusEqVec(&wheel->WPos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+160]
	fadd	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+160]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+164]
	fadd	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+164]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+168]
	fadd	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+168]

; 1096 : 
; 1097 : 	CopyVec(&wheel->CentrePos, &wheel->OldCentrePos);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+196], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR [eax+200], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR [eax+204], edx

; 1098 : 	VecMulMat(&car->WheelCentre[iWheel], &car->Body->Centre.WMatrix, &tmpVec);

	lea	eax, DWORD PTR _tmpVec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3232]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1099 : 	VecPlusVec(&wheel->WPos, &tmpVec, &wheel->CentrePos);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fadd	DWORD PTR [eax+160]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+184]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fadd	DWORD PTR [eax+164]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+188]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fadd	DWORD PTR [eax+168]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+192]

; 1100 : 
; 1101 : 	// Spin the wheel according to its angular position
; 1102 : 	RotationY(&tmpMat, wheel->TurnAngle);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	lea	edx, DWORD PTR _tmpMat$[ebp]
	push	edx
	call	?RotationY@@YAXPATMatrixUnion@@M@Z	; RotationY
	add	esp, 8

; 1103 : 	MatMulMat(&tmpMat, &car->Body->Centre.WMatrix, &wheel->Axes);

	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 208				; 000000d0H
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	add	edx, 100				; 00000064H
	push	edx
	lea	eax, DWORD PTR _tmpMat$[ebp]
	push	eax
	call	?MatMulMat@@YAXPATMatrixUnion@@00@Z	; MatMulMat
	add	esp, 12					; 0000000cH

; 1104 : 	RotationX(&tmpMat, wheel->AngPos);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	lea	edx, DWORD PTR _tmpMat$[ebp]
	push	edx
	call	?RotationX@@YAXPATMatrixUnion@@M@Z	; RotationX
	add	esp, 8

; 1105 : 	MatMulMat(&tmpMat, &wheel->Axes, &wheel->WMatrix);

	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	mov	ecx, DWORD PTR _wheel$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _tmpMat$[ebp]
	push	edx
	call	?MatMulMat@@YAXPATMatrixUnion@@00@Z	; MatMulMat
	add	esp, 12					; 0000000cH

; 1106 : 
; 1107 : 
; 1108 : 
; 1109 : 	// Build bounding box
; 1110 : 	SetBBox(&wheel->BBox,
; 1111 : 		Min(wheel->OldCentrePos.v[X], wheel->CentrePos.v[X]) - wheel->Radius,
; 1112 : 		Max(wheel->OldCentrePos.v[X], wheel->CentrePos.v[X]) + wheel->Radius,
; 1113 : 		Min(wheel->OldCentrePos.v[Y], wheel->CentrePos.v[Y]) - wheel->Radius,
; 1114 : 		Max(wheel->OldCentrePos.v[Y], wheel->CentrePos.v[Y]) + wheel->Radius,
; 1115 : 		Min(wheel->OldCentrePos.v[Z], wheel->CentrePos.v[Z]) - wheel->Radius,
; 1116 : 		Max(wheel->OldCentrePos.v[Z], wheel->CentrePos.v[Z]) + wheel->Radius);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+184]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82899
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR tv581[ebp], eax
	jmp	SHORT $L82900
$L82899:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR tv581[ebp], edx
$L82900:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv581[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+184]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82901
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR tv601[ebp], eax
	jmp	SHORT $L82902
$L82901:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR tv601[ebp], edx
$L82902:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv601[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+188]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82903
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR tv621[ebp], eax
	jmp	SHORT $L82904
$L82903:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR tv621[ebp], edx
$L82904:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv621[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+188]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82905
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR tv641[ebp], eax
	jmp	SHORT $L82906
$L82905:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR tv641[ebp], edx
$L82906:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv641[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+192]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82907
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR tv661[ebp], eax
	jmp	SHORT $L82908
$L82907:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR tv661[ebp], edx
$L82908:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv661[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+192]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82909
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR tv681[ebp], eax
	jmp	SHORT $L82910
$L82909:
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR tv681[ebp], edx
$L82910:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR tv681[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+72]

; 1117 : 
; 1118 : 	// Zero impulses
; 1119 : 	wheel->Impulse = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+104], 0

; 1120 : 	wheel->AngImpulse = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+108], 0

; 1121 : 
; 1122 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z ENDP		; UpdateCarWheel
_TEXT	ENDS
PUBLIC	?DetectCarWheelColls2@@YAXPAUCarStruct@@HPAUCollPolyStruct@@@Z ; DetectCarWheelColls2
PUBLIC	?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ; AddWheelColl
PUBLIC	__real@3e4ccccd
PUBLIC	__real@00000000
EXTRN	?BDY_MassiveBody@@3UNewBodyStruct@@A:BYTE	; BDY_MassiveBody
EXTRN	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z:NEAR ; SphereCollPoly
EXTRN	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ:NEAR ; NextWheelCollInfo
EXTRN	?AdjustWheelColl@@YAXPAUWheelCollInfoStruct@@PAUMaterialStruct@@@Z:NEAR ; AdjustWheelColl
EXTRN	?COL_MaterialInfo@@3PAUMaterialStruct@@A:BYTE	; COL_MaterialInfo
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DetectCarWheelColls2@@YAXPAUCarStruct@@HPAUCollPolyStruct@@@Z
_TEXT	SEGMENT
tv131 = -92						; size = 4
_wheelColl$ = -24					; size = 4
_wheel$ = -20						; size = 4
_time$ = -16						; size = 4
_tmpVec$ = -12						; size = 12
_car$ = 8						; size = 4
_iWheel$ = 12						; size = 4
_worldPoly$ = 16					; size = 4
?DetectCarWheelColls2@@YAXPAUCarStruct@@HPAUCollPolyStruct@@@Z PROC NEAR ; DetectCarWheelColls2, COMDAT

; 1127 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1128 : 	VEC	tmpVec;//, tmpVec2;
; 1129 : 	REAL	time;
; 1130 : 	WHEEL	*wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 1131 : 	COLLINFO_WHEEL	*wheelColl;
; 1132 : 
; 1133 : 	// Make sure we don't overstep the collision array
; 1134 : 	if ((wheelColl = NextWheelCollInfo()) == NULL) return;

	call	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ; NextWheelCollInfo
	mov	DWORD PTR _wheelColl$[ebp], eax
	cmp	DWORD PTR _wheelColl$[ebp], 0
	jne	SHORT $L82079
	jmp	$L82074
$L82079:

; 1135 : 
; 1136 : 	// Quick swepth-volume axis-aligned bounding-box test
; 1137 : 	if (!BBTestYXZ(&wheel->BBox, &worldPoly->BBox)) return;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _worldPoly$[ebp]
	fld	DWORD PTR [eax+60]
	fcomp	DWORD PTR [ecx+100]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82919
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _worldPoly$[ebp]
	fld	DWORD PTR [edx+64]
	fcomp	DWORD PTR [eax+96]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82919
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _worldPoly$[ebp]
	fld	DWORD PTR [ecx+52]
	fcomp	DWORD PTR [edx+92]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82919
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _worldPoly$[ebp]
	fld	DWORD PTR [eax+56]
	fcomp	DWORD PTR [ecx+88]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82919
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _worldPoly$[ebp]
	fld	DWORD PTR [edx+68]
	fcomp	DWORD PTR [eax+108]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82919
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _worldPoly$[ebp]
	fld	DWORD PTR [ecx+72]
	fcomp	DWORD PTR [edx+104]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82919
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $L82920
$L82919:
	mov	DWORD PTR tv131[ebp], 0
$L82920:
	cmp	DWORD PTR tv131[ebp], 0
	jne	SHORT $L82080
	jmp	$L82074
$L82080:

; 1138 : 
; 1139 : 	// Do a sphere-to-poly collision test
; 1140 : 	if (SphereCollPoly(&wheel->OldCentrePos, &wheel->CentrePos,
; 1141 : 		wheel->Radius, 
; 1142 : 		worldPoly, 
; 1143 : 		&wheelColl->Plane,
; 1144 : 		&wheelColl->Pos,
; 1145 : 		&wheelColl->WorldPos,
; 1146 : 		&wheelColl->Depth,
; 1147 : 		&time))

	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _wheelColl$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _worldPoly$[ebp]
	push	edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _wheel$[ebp]
	add	edx, 184				; 000000b8H
	push	edx
	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 196				; 000000c4H
	push	eax
	call	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z ; SphereCollPoly
	add	esp, 36					; 00000024H
	movzx	ecx, al
	test	ecx, ecx
	je	$L82074

; 1148 : 	{
; 1149 : 
; 1150 : 		// Calculate the collision point on the plane (for skidmarks and smoke generator)
; 1151 : 		VecPlusEqScalarVec(&wheelColl->WorldPos, SKID_RAISE, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+44]

; 1152 : 
; 1153 : 		// Calculate the car-relative collision point for response
; 1154 : 		VecPlusEqVec(&wheelColl->Pos, &wheel->CentrePos);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+20]

; 1155 : 		VecMinusEqVec(&wheelColl->Pos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+20]

; 1156 : 
; 1157 : 		// Calculate world velocity of the wheel collision point (not including wheel spin)
; 1158 : 		VecCrossVec(&car->Body->AngVel, &wheelColl->Pos, &wheelColl->Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+16]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+20]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 1159 : 		VecPlusEqVec(&wheelColl->Vel, &car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+48]
	fadd	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+52]
	fadd	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+56]
	fadd	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 1160 : 
; 1161 : 		// Make sure that the wheel is not already travelling away from the surface
; 1162 : 		VecPlusScalarVec(&wheelColl->Vel, wheel->Vel, &car->Body->Centre.WMatrix.mv[U], &tmpVec);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+112]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [eax+48]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+116]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [eax+52]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+120]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [eax+56]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1163 : 		if (VecDotVec(&tmpVec, PlaneNormal(&wheelColl->Plane)) > ZERO) return;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82091
	jmp	$L82074
$L82091:

; 1164 : 
; 1165 : 		// Add bumps from surface corrugation
; 1166 : 		wheelColl->Material = &COL_MaterialInfo[worldPoly->Material];

	mov	eax, DWORD PTR _worldPoly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:?COL_MaterialInfo@@3PAUMaterialStruct@@A ; COL_MaterialInfo
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 1167 : 		AdjustWheelColl(wheelColl, wheelColl->Material);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _wheelColl$[ebp]
	push	edx
	call	?AdjustWheelColl@@YAXPAUWheelCollInfoStruct@@PAUMaterialStruct@@@Z ; AdjustWheelColl
	add	esp, 8

; 1168 : 
; 1169 : 		// Set other necessary stuff
; 1170 : 		wheelColl->Car = car;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax], ecx

; 1171 : 		wheelColl->IWheel = iWheel;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _iWheel$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1172 : 		wheelColl->Grip = MulScalar(wheel->Grip, wheelColl->Material->Gripiness);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	fmul	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+84]

; 1173 : 		wheelColl->StaticFriction = MulScalar(wheel->StaticFriction, wheelColl->Material->Roughness);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+88]

; 1174 : 		wheelColl->KineticFriction = MulScalar(wheel->KineticFriction, wheelColl->Material->Roughness);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+92]

; 1175 : 		wheelColl->Restitution = ZERO;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+96], 0

; 1176 : 		wheelColl->Body2 = &BDY_MassiveBody;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A ; BDY_MassiveBody

; 1177 : 		SetVecZero(&wheelColl->Pos2);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1178 : 
; 1179 : 
; 1180 : 		// Set the wheel-in-contact flag
; 1181 : 		SetWheelInContact(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 8
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx

; 1182 : 		SetWheelNotSpinning(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx

; 1183 : 
; 1184 : 		// add collision to car's list
; 1185 : 		AddWheelColl(car, wheelColl);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ; AddWheelColl
	add	esp, 8
$L82074:

; 1186 : 
; 1187 : 	}
; 1188 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectCarWheelColls2@@YAXPAUCarStruct@@HPAUCollPolyStruct@@@Z ENDP ; DetectCarWheelColls2
_TEXT	ENDS
PUBLIC	?PreProcessCarWheelColls@@YAXPAUCarStruct@@@Z	; PreProcessCarWheelColls
PUBLIC	?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z ; RemoveWheelColl
PUBLIC	__real@40200000
PUBLIC	__real@3f000000
PUBLIC	__real@402ccccd
EXTRN	?OilSlickCount@@3JA:DWORD			; OilSlickCount
EXTRN	?OilSlickList@@3PAUOILSLICK_LIST@@A:BYTE	; OilSlickList
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@402ccccd
CONST	SEGMENT
__real@402ccccd DD 0402ccccdr			; 2.7
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?PreProcessCarWheelColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
tv133 = -100						; size = 4
tv89 = -100						; size = 4
_dz$ = -32						; size = 4
_dx$ = -28						; size = 4
_collpos$ = -24						; size = 4
_wheelColl2$ = -20					; size = 4
_wheelColl1$ = -16					; size = 4
_wheel$ = -12						; size = 4
_iOil$ = -8						; size = 4
_keepGoing$ = -1					; size = 1
_car$ = 8						; size = 4
?PreProcessCarWheelColls@@YAXPAUCarStruct@@@Z PROC NEAR	; PreProcessCarWheelColls, COMDAT

; 1198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 1199 : 	bool	keepGoing;
; 1200 : 	int		iOil;
; 1201 : 	WHEEL	*wheel;
; 1202 : 	COLLINFO_WHEEL	*wheelColl1, *wheelColl2;
; 1203 : 	VEC		*collpos;
; 1204 : 	REAL	dx, dz;
; 1205 : 
; 1206 : 	for (wheelColl1 = car->WheelCollHead; wheelColl1 != NULL; wheelColl1 = wheelColl1->Next) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3576]
	mov	DWORD PTR _wheelColl1$[ebp], ecx
	jmp	SHORT $L82103
$L82104:
	mov	eax, DWORD PTR _wheelColl1$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _wheelColl1$[ebp], ecx
$L82103:
	cmp	DWORD PTR _wheelColl1$[ebp], 0
	je	$L82094

; 1207 : 
; 1208 : 		wheel = &car->Wheel[wheelColl1->IWheel];

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1560]
	mov	DWORD PTR _wheel$[ebp], eax

; 1209 : 
; 1210 : #ifndef _PSX
; 1211 : 		// check for oil slick contact
; 1212 : 		collpos = &wheelColl1->WorldPos;

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _collpos$[ebp], eax

; 1213 : 
; 1214 : 		for (iOil = 0 ; iOil < OilSlickCount ; iOil++)

	mov	DWORD PTR _iOil$[ebp], 0
	jmp	SHORT $L82106
$L82107:
	mov	eax, DWORD PTR _iOil$[ebp]
	add	eax, 1
	mov	DWORD PTR _iOil$[ebp], eax
$L82106:
	mov	eax, DWORD PTR _iOil$[ebp]
	cmp	eax, DWORD PTR ?OilSlickCount@@3JA	; OilSlickCount
	jge	$L82108

; 1215 : 		{
; 1216 : 			if (collpos->v[Y] < OilSlickList[iOil].Ymin)

	mov	eax, DWORD PTR _iOil$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _collpos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcomp	DWORD PTR ?OilSlickList@@3PAUOILSLICK_LIST@@A[eax+16]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82109

; 1217 : 				continue;

	jmp	SHORT $L82107
$L82109:

; 1218 : 
; 1219 : 			if (collpos->v[Y] > OilSlickList[iOil].Ymax)

	mov	eax, DWORD PTR _iOil$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _collpos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcomp	DWORD PTR ?OilSlickList@@3PAUOILSLICK_LIST@@A[eax+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82110

; 1220 : 				continue;

	jmp	SHORT $L82107
$L82110:

; 1221 : 
; 1222 : 			dx = OilSlickList[iOil].X - collpos->v[X];

	mov	eax, DWORD PTR _iOil$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _collpos$[ebp]
	fld	DWORD PTR ?OilSlickList@@3PAUOILSLICK_LIST@@A[eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dx$[ebp]

; 1223 : 			if (abs(dx) > OilSlickList[iOil].Radius)

	fld	DWORD PTR _dx$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82927
	mov	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $L82928
$L82927:
	fld	DWORD PTR _dx$[ebp]
	fchs
	fstp	DWORD PTR tv89[ebp]
$L82928:
	mov	ecx, DWORD PTR _iOil$[ebp]
	imul	ecx, 24					; 00000018H
	fld	DWORD PTR tv89[ebp]
	fcomp	DWORD PTR ?OilSlickList@@3PAUOILSLICK_LIST@@A[ecx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82111

; 1224 : 				continue;

	jmp	$L82107
$L82111:

; 1225 : 
; 1226 : 			dz = OilSlickList[iOil].Z - collpos->v[Z];

	mov	eax, DWORD PTR _iOil$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _collpos$[ebp]
	fld	DWORD PTR ?OilSlickList@@3PAUOILSLICK_LIST@@A[eax+4]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dz$[ebp]

; 1227 : 			if (abs(dz) > OilSlickList[iOil].Radius)

	fld	DWORD PTR _dz$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82929
	mov	eax, DWORD PTR _dz$[ebp]
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $L82930
$L82929:
	fld	DWORD PTR _dz$[ebp]
	fchs
	fstp	DWORD PTR tv133[ebp]
$L82930:
	mov	ecx, DWORD PTR _iOil$[ebp]
	imul	ecx, 24					; 00000018H
	fld	DWORD PTR tv133[ebp]
	fcomp	DWORD PTR ?OilSlickList@@3PAUOILSLICK_LIST@@A[ecx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82112

; 1228 : 				continue;

	jmp	$L82107
$L82112:

; 1229 : 
; 1230 : 			if ((dx * dx + dz * dz) > OilSlickList[iOil].SquaredRadius)

	fld	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _dx$[ebp]
	fld	DWORD PTR _dz$[ebp]
	fmul	DWORD PTR _dz$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iOil$[ebp]
	imul	eax, 24					; 00000018H
	fcomp	DWORD PTR ?OilSlickList@@3PAUOILSLICK_LIST@@A[eax+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82113

; 1231 : 				continue;

	jmp	$L82107
$L82113:

; 1232 : 
; 1233 : 			SetWheelInOil(&wheelColl1->Car->Wheel[wheelColl1->IWheel]);

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _wheelColl1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR [ecx+eax+1560]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _wheelColl1$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 360				; 00000168H
	mov	edx, DWORD PTR _wheelColl1$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [edx+eax+1560], ecx
$L82108:

; 1234 : 			break;
; 1235 : 		}
; 1236 : 
; 1237 : 		// Reduce friction if wheel is oiled up
; 1238 : 		if (wheel->OilTime < OILY_WHEEL_TIME) {

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+356]
	fcomp	DWORD PTR __real@40200000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82115

; 1239 : 			wheelColl1->StaticFriction *= HALF * (wheel->OilTime + TO_TIME(Real(0.2))) / (OILY_WHEEL_TIME + TO_TIME(Real(0.2)));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+356]
	fadd	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR __real@3f000000
	fdiv	DWORD PTR __real@402ccccd
	mov	ecx, DWORD PTR _wheelColl1$[ebp]
	fmul	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _wheelColl1$[ebp]
	fstp	DWORD PTR [edx+88]

; 1240 : 			wheelColl1->KineticFriction *= HALF * (wheel->OilTime + TO_TIME(Real(0.2))) / (OILY_WHEEL_TIME + TO_TIME(Real(0.2)));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+356]
	fadd	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR __real@3f000000
	fdiv	DWORD PTR __real@402ccccd
	mov	ecx, DWORD PTR _wheelColl1$[ebp]
	fmul	DWORD PTR [ecx+92]
	mov	edx, DWORD PTR _wheelColl1$[ebp]
	fstp	DWORD PTR [edx+92]
$L82115:

; 1241 : 		}
; 1242 : #endif
; 1243 : 
; 1244 : 
; 1245 : 		// Merge close collisions with similar planes
; 1246 : 		keepGoing = TRUE;

	mov	BYTE PTR _keepGoing$[ebp], 1

; 1247 : 		for (wheelColl2 = wheelColl1->Next; (wheelColl2 != NULL) && keepGoing; wheelColl2 = wheelColl2->Next) {

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _wheelColl2$[ebp], ecx
	jmp	SHORT $L82122
$L82123:
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _wheelColl2$[ebp], ecx
$L82122:
	cmp	DWORD PTR _wheelColl2$[ebp], 0
	je	$L82124
	movzx	eax, BYTE PTR _keepGoing$[ebp]
	test	eax, eax
	je	$L82124

; 1248 : 
; 1249 : 			if (wheelColl1->IWheel != wheelColl2->IWheel) continue;

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $L82125
	jmp	SHORT $L82123
$L82125:

; 1250 : 
; 1251 : 			//VecMinusVec(&wheelColl1->Pos, &wheelColl2->Pos, &tmpVec);
; 1252 : 			//if (VecDotVec(&tmpVec, &tmpVec) < 25.0f) {
; 1253 : 				if (VecDotVec(PlaneNormal(&wheelColl1->Plane), PlaneNormal(&wheelColl2->Plane)) > CLOSE_WHEEL_COLL_ANGLE) {

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _wheelColl1$[ebp]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _wheelColl1$[ebp]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [ecx+68]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@3f000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82132

; 1254 : 
; 1255 : 					if (wheelColl1->Depth > wheelColl2->Depth) {

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [eax+76]
	fcomp	DWORD PTR [ecx+76]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82133

; 1256 : 						RemoveWheelColl(car, wheelColl1);

	mov	eax, DWORD PTR _wheelColl1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z ; RemoveWheelColl
	add	esp, 8

; 1257 : 						keepGoing = FALSE;

	mov	BYTE PTR _keepGoing$[ebp], 0

; 1258 : 					} else {

	jmp	SHORT $L82132
$L82133:

; 1259 : 						RemoveWheelColl(car, wheelColl2);

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z ; RemoveWheelColl
	add	esp, 8
$L82132:

; 1260 : 					}
; 1261 : 
; 1262 : 					//COL_NWheelDone++;
; 1263 : 				}
; 1264 : 			//}
; 1265 : 		}

	jmp	$L82123
$L82124:

; 1266 : 	}

	jmp	$L82104
$L82094:

; 1267 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PreProcessCarWheelColls@@YAXPAUCarStruct@@@Z ENDP	; PreProcessCarWheelColls
_TEXT	ENDS
PUBLIC	?ProcessCarWheelColls@@YAXPAUCarStruct@@@Z	; ProcessCarWheelColls
PUBLIC	?CarWheelImpulse2@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@PAUVectorStruct@@@Z ; CarWheelImpulse2
EXTRN	?ModifyShift@@YAXPAUVectorStruct@@M0@Z:NEAR	; ModifyShift
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
; Function compile flags: /Odt /ZI
;	COMDAT ?ProcessCarWheelColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_totAngImpulse$ = -76					; size = 12
_totImpulse$ = -64					; size = 12
_shift$ = -52						; size = 12
_tmpVec$ = -40						; size = 12
_collImpulse$ = -28					; size = 12
_shiftDotUp$ = -16					; size = 4
_shiftLen$ = -12					; size = 4
_wheel$ = -8						; size = 4
_wheelColl$ = -4					; size = 4
_car$ = 8						; size = 4
?ProcessCarWheelColls@@YAXPAUCarStruct@@@Z PROC NEAR	; ProcessCarWheelColls, COMDAT

; 1282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 1283 : 	COLLINFO_WHEEL	*wheelColl;
; 1284 : 	WHEEL	*wheel;
; 1285 : 	REAL	shiftLen, shiftDotUp;
; 1286 : 	VEC	collImpulse, tmpVec, shift;
; 1287 : 	VEC	totImpulse = {0, 0, 0};

	mov	DWORD PTR _totImpulse$[ebp], 0
	mov	DWORD PTR _totImpulse$[ebp+4], 0
	mov	DWORD PTR _totImpulse$[ebp+8], 0

; 1288 : 	VEC	totAngImpulse = {0, 0, 0};

	mov	DWORD PTR _totAngImpulse$[ebp], 0
	mov	DWORD PTR _totAngImpulse$[ebp+4], 0
	mov	DWORD PTR _totAngImpulse$[ebp+8], 0

; 1289 : 
; 1290 : 	for (wheelColl = car->WheelCollHead; wheelColl != NULL; wheelColl = wheelColl->Next) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3576]
	mov	DWORD PTR _wheelColl$[ebp], ecx
	jmp	SHORT $L82147
$L82148:
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _wheelColl$[ebp], ecx
$L82147:
	cmp	DWORD PTR _wheelColl$[ebp], 0
	je	$L82149

; 1291 : 
; 1292 : 		wheel = &car->Wheel[wheelColl->IWheel];

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1560]
	mov	DWORD PTR _wheel$[ebp], eax

; 1293 : 	
; 1294 : 		// Calculate the shift required to extract the wheel from the road
; 1295 : 		if (CAR_WheelsHaveSuspension) {

	movzx	eax, BYTE PTR ?CAR_WheelsHaveSuspension@@3_NA ; CAR_WheelsHaveSuspension
	test	eax, eax
	je	$L82150

; 1296 : 			if (wheelColl->Depth < ZERO) {

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	$L82151

; 1297 : 				// Calculate shift to extract wheel from road
; 1298 : 				CopyVec(PlaneNormal(&wheelColl->Plane), &shift);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _shift$[ebp], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _shift$[ebp+4], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _shift$[ebp+8], ecx

; 1299 : 				VecMulScalar(&shift, -wheelColl->Depth);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fchs
	fmul	DWORD PTR _shift$[ebp]
	fstp	DWORD PTR _shift$[ebp]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fchs
	fmul	DWORD PTR _shift$[ebp+4]
	fstp	DWORD PTR _shift$[ebp+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fchs
	fmul	DWORD PTR _shift$[ebp+8]
	fstp	DWORD PTR _shift$[ebp+8]

; 1300 : 				shiftDotUp = VecDotVec(&shift, &car->Body->Centre.WMatrix.mv[U]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _shift$[ebp]
	fmul	DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR _shift$[ebp+4]
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR _shift$[ebp+8]
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _shiftDotUp$[ebp]

; 1301 : 				wheel->Pos += shiftDotUp;

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _shiftDotUp$[ebp]
	fadd	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+80]

; 1302 : 				if (wheel->Pos > wheel->MaxPos) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+80]
	fcomp	DWORD PTR [ecx+112]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82155

; 1303 : 					shiftDotUp -= wheel->Pos - wheel->MaxPos;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+80]
	fsub	DWORD PTR [ecx+112]
	fsubr	DWORD PTR _shiftDotUp$[ebp]
	fstp	DWORD PTR _shiftDotUp$[ebp]

; 1304 : 					wheel->Pos = wheel->MaxPos;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+80], edx

; 1305 : 				} else if (wheel->Pos < -wheel->MaxPos) {

	jmp	SHORT $L82156
$L82155:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+112]
	fchs
	mov	ecx, DWORD PTR _wheel$[ebp]
	fcomp	DWORD PTR [ecx+80]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82156

; 1306 : 					shiftDotUp -= wheel->Pos + wheel->MaxPos;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+80]
	fadd	DWORD PTR [ecx+112]
	fsubr	DWORD PTR _shiftDotUp$[ebp]
	fstp	DWORD PTR _shiftDotUp$[ebp]

; 1307 : 					wheel->Pos = -wheel->MaxPos;

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+112]
	fchs
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+80]
$L82156:

; 1308 : 				}
; 1309 : 
; 1310 : 				// Get shift needed to shift body out of road
; 1311 : 				shiftDotUp = MulScalar(shiftDotUp, VecDotVec(PlaneNormal(&wheelColl->Plane), &car->Body->Centre.WMatrix.mv[U]));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [ecx+116]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [ecx+120]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _shiftDotUp$[ebp]
	fstp	DWORD PTR _shiftDotUp$[ebp]

; 1312 : 				shiftLen = -wheelColl->Depth - shiftDotUp;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fchs
	fsub	DWORD PTR _shiftDotUp$[ebp]
	fstp	DWORD PTR _shiftLen$[ebp]

; 1313 : 				if (shiftLen > ZERO) {

	fld	DWORD PTR _shiftLen$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82161

; 1314 : 					ModifyShift(&car->Body->Centre.Shift, shiftLen, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheelColl$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _shiftLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 200				; 000000c8H
	push	eax
	call	?ModifyShift@@YAXPAUVectorStruct@@M0@Z	; ModifyShift
	add	esp, 12					; 0000000cH
$L82161:

; 1315 : 				}
; 1316 : 
; 1317 : 				// Stop wheel relative to road
; 1318 : 				VecCrossVec(&car->Body->AngVel, &wheelColl->Pos, &tmpVec);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+20]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1319 : 				VecPlusEqVec(&tmpVec, &car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _tmpVec$[ebp]
	fadd	DWORD PTR [ecx+32]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fadd	DWORD PTR [ecx+36]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fadd	DWORD PTR [ecx+40]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1320 : 				wheel->Vel = -MulScalar(VecDotVec(PlaneNormal(&wheelColl->Plane), &car->Body->Centre.WMatrix.mv[U]), VecDotVec(&tmpVec, PlaneNormal(&wheelColl->Plane)));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [ecx+116]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [ecx+120]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+88]

; 1321 : 				wheel->Vel += MulScalar(MulScalar(wheel->Gravity, TimeStep), VecDotVec(&DownVec, &car->Body->Centre.WMatrix.mv[U]));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [edx+112]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+116]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [eax+120]
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	mov	ecx, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+88]
$L82151:

; 1322 : 			}
; 1323 : 		} else {

	jmp	SHORT $L82169
$L82150:

; 1324 : 			if (wheelColl->Depth < ZERO) {

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82169

; 1325 : 				ModifyShift(&car->Body->Centre.Shift, -wheelColl->Depth, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheelColl$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+76]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	add	eax, 200				; 000000c8H
	push	eax
	call	?ModifyShift@@YAXPAUVectorStruct@@M0@Z	; ModifyShift
	add	esp, 12					; 0000000cH
$L82169:

; 1326 : 			}
; 1327 : 		}
; 1328 : 
; 1329 : 		// Calculate the impulse to apply to the car from the wheel
; 1330 : 		CarWheelImpulse2(car, wheelColl, &collImpulse);

	lea	eax, DWORD PTR _collImpulse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?CarWheelImpulse2@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@PAUVectorStruct@@@Z ; CarWheelImpulse2
	add	esp, 12					; 0000000cH

; 1331 : 
; 1332 : 		// Calculate and store the linear and angular components of the impulse
; 1333 : 		VecPlusEqVec(&totImpulse, &collImpulse);

	fld	DWORD PTR _totImpulse$[ebp]
	fadd	DWORD PTR _collImpulse$[ebp]
	fstp	DWORD PTR _totImpulse$[ebp]
	fld	DWORD PTR _totImpulse$[ebp+4]
	fadd	DWORD PTR _collImpulse$[ebp+4]
	fstp	DWORD PTR _totImpulse$[ebp+4]
	fld	DWORD PTR _totImpulse$[ebp+8]
	fadd	DWORD PTR _collImpulse$[ebp+8]
	fstp	DWORD PTR _totImpulse$[ebp+8]

; 1334 : 		CalcAngImpulse(&collImpulse, &wheelColl->Pos, &tmpVec);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+8]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+4]
	fmul	DWORD PTR [ecx+20]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _collImpulse$[ebp]
	fmul	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+8]
	fmul	DWORD PTR [ecx+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _collImpulse$[ebp+4]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _collImpulse$[ebp]
	fmul	DWORD PTR [ecx+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1335 : 		VecPlusEqVec(&totAngImpulse, &tmpVec);

	fld	DWORD PTR _totAngImpulse$[ebp]
	fadd	DWORD PTR _tmpVec$[ebp]
	fstp	DWORD PTR _totAngImpulse$[ebp]
	fld	DWORD PTR _totAngImpulse$[ebp+4]
	fadd	DWORD PTR _tmpVec$[ebp+4]
	fstp	DWORD PTR _totAngImpulse$[ebp+4]
	fld	DWORD PTR _totAngImpulse$[ebp+8]
	fadd	DWORD PTR _tmpVec$[ebp+8]
	fstp	DWORD PTR _totAngImpulse$[ebp+8]

; 1336 : 
; 1337 : 	}

	jmp	$L82148
$L82149:

; 1338 : 	
; 1339 : 	// Apply impulse from wheels to car body
; 1340 : 	ApplyBodyAngImpulse(car->Body, &totAngImpulse);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _totAngImpulse$[ebp]
	fadd	DWORD PTR [ecx+356]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+356]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _totAngImpulse$[ebp+4]
	fadd	DWORD PTR [ecx+360]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+360]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _totAngImpulse$[ebp+8]
	fadd	DWORD PTR [ecx+364]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+364]

; 1341 : 	ApplyParticleImpulse(&car->Body->Centre, &totImpulse);

	lea	eax, DWORD PTR _totImpulse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z ; ApplyParticleImpulse
	add	esp, 8

; 1342 : 
; 1343 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessCarWheelColls@@YAXPAUCarStruct@@@Z ENDP		; ProcessCarWheelColls
_TEXT	ENDS
PUBLIC	__real@3727c5ac
PUBLIC	__real@3f7ae148
PUBLIC	__real@3cf5c28f
PUBLIC	__real@43000000
PUBLIC	__real@41200000
PUBLIC	?PostProcessCarWheelColls@@YAXPAUCarStruct@@@Z	; PostProcessCarWheelColls
EXTRN	?AddSkid@@YAPAUSKIDMARK@@PAUSKIDMARK_START@@0J@Z:NEAR ; AddSkid
EXTRN	?MoveSkidEnd@@YAXPAUSKIDMARK@@PAUSKIDMARK_START@@@Z:NEAR ; MoveSkidEnd
EXTRN	?UpVec@@3UVectorStruct@@A:BYTE			; UpVec
EXTRN	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z:NEAR ; CreateSpark
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@3f7ae148
CONST	SEGMENT
__real@3f7ae148 DD 03f7ae148r			; 0.98
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?PostProcessCarWheelColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
tv750 = -208						; size = 4
tv439 = -208						; size = 4
_skidEnd$ = -140					; size = 56
_wheel$ = -84						; size = 4
_wheelColl$ = -80					; size = 4
_vel$ = -76						; size = 12
_lookVec$ = -64						; size = 12
_dR$ = -52						; size = 12
_velPar$ = -40						; size = 12
_carDotUp$ = -28					; size = 4
_dirDotDir$ = -24					; size = 4
_normDotNorm$ = -20					; size = 4
_velDotNorm$ = -16					; size = 4
_dRLen$ = -12						; size = 4
_velParLen$ = -8					; size = 4
_skidColour$ = -4					; size = 4
_car$ = 8						; size = 4
?PostProcessCarWheelColls@@YAXPAUCarStruct@@@Z PROC NEAR ; PostProcessCarWheelColls, COMDAT

; 1356 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 1357 : 	long	skidColour;
; 1358 : 	REAL	velParLen, dRLen;
; 1359 : 	REAL	velDotNorm;
; 1360 : 	REAL	normDotNorm, dirDotDir, carDotUp;
; 1361 : 	VEC	velPar, dR, lookVec, vel;
; 1362 : 	COLLINFO_WHEEL	*wheelColl;
; 1363 : 	WHEEL			*wheel;
; 1364 : 	SKIDMARK_START	skidEnd;
; 1365 : 
; 1366 : 	carDotUp = VecDotVec(&car->Body->Centre.WMatrix.mv[U], &DownVec);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A
	fmul	DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _carDotUp$[ebp]

; 1367 : 
; 1368 : 	for (wheelColl = car->WheelCollHead; wheelColl != NULL; wheelColl = wheelColl->Next) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3576]
	mov	DWORD PTR _wheelColl$[ebp], ecx
	jmp	SHORT $L82190
$L82191:
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _wheelColl$[ebp], ecx
$L82190:
	cmp	DWORD PTR _wheelColl$[ebp], 0
	je	$L82175

; 1369 : 
; 1370 : 		wheel = &car->Wheel[wheelColl->IWheel];

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1560]
	mov	DWORD PTR _wheel$[ebp], eax

; 1371 : 
; 1372 : 		// Count Wheel collisions with floor polys
; 1373 : 		if (carDotUp > ZERO) {

	fld	DWORD PTR _carDotUp$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82193

; 1374 : 			if ( MulScalar(carDotUp, VecDotVec(PlaneNormal(&wheelColl->Plane), &UpVec) ) > HALF) {

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _carDotUp$[ebp]
	fcomp	DWORD PTR __real@3f000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82193

; 1375 : 				car->NWheelFloorContacts++;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3588]
	add	ecx, 1
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3588], ecx
$L82193:

; 1376 : 			}
; 1377 : 		}
; 1378 : 
; 1379 : 		// Make sure the collision is with the world
; 1380 : 		if ((wheelColl->Material == NULL) || !(wheelColl->Material->Type & MATERIAL_SKID)) {

	mov	eax, DWORD PTR _wheelColl$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $L82199
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx]
	and	edx, 2
	jne	SHORT $L82198
$L82199:

; 1381 : 			// Reset the skid started flag
; 1382 : 			wheel->Skid.Started = FALSE;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+296], 0
$L82198:

; 1383 : 		}
; 1384 : 
; 1385 : 		// Calculate velocity parallel to plane
; 1386 : 		velDotNorm = VecDotVec(&wheelColl->Vel, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+52]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+56]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 1387 : 		VecPlusScalarVec(&wheelColl->Vel, -velDotNorm, PlaneNormal(&wheelColl->Plane), &velPar);

	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+48]
	fstp	DWORD PTR _velPar$[ebp]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+52]
	fstp	DWORD PTR _velPar$[ebp+4]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+56]
	fstp	DWORD PTR _velPar$[ebp+8]

; 1388 : 		velParLen = Length(&velPar);

	fld	DWORD PTR _velPar$[ebp]
	fmul	DWORD PTR _velPar$[ebp]
	fld	DWORD PTR _velPar$[ebp+4]
	fmul	DWORD PTR _velPar$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _velPar$[ebp+8]
	fmul	DWORD PTR _velPar$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _velParLen$[ebp]

; 1389 : 		if (velParLen > SMALL_REAL) {

	fld	DWORD PTR _velParLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82207

; 1390 : 			VecDivScalar(&velPar, velParLen);

	fld	DWORD PTR _velPar$[ebp]
	fdiv	DWORD PTR _velParLen$[ebp]
	fstp	DWORD PTR _velPar$[ebp]
	fld	DWORD PTR _velPar$[ebp+4]
	fdiv	DWORD PTR _velParLen$[ebp]
	fstp	DWORD PTR _velPar$[ebp+4]
	fld	DWORD PTR _velPar$[ebp+8]
	fdiv	DWORD PTR _velParLen$[ebp]
	fstp	DWORD PTR _velPar$[ebp+8]

; 1391 : 		} else {

	jmp	SHORT $L82208
$L82207:

; 1392 : 			SetVecZero(&velPar);

	mov	DWORD PTR _velPar$[ebp], 0
	mov	DWORD PTR _velPar$[ebp+4], 0
	mov	DWORD PTR _velPar$[ebp+8], 0
$L82208:

; 1393 : 		}
; 1394 : 		//if (velParLen > SKID_MAX_VELPAR) velParLen = SKID_MAX_VELPAR;
; 1395 : 
; 1396 : 		// If necessary, add a skidmark to the skidmark list
; 1397 : 		if (IsWheelSkidding(wheel) && wheel->Skid.Started) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 48					; 00000030H
	je	$L82209
	mov	eax, DWORD PTR _wheel$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	$L82209

; 1398 : 			// Calculate length of skidmark so far
; 1399 : 			VecMinusVec(&wheelColl->WorldPos, &wheel->Skid.Pos, &dR);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR [ecx+304]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+40]
	fsub	DWORD PTR [ecx+308]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+44]
	fsub	DWORD PTR [ecx+312]
	fstp	DWORD PTR _dR$[ebp+8]

; 1400 : 			dRLen = Length(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 1401 : 
; 1402 : 			// Parameters for this end of skid
; 1403 : 			VecCrossVec(PlaneNormal(&wheelColl->Plane), &wheel->Axes.mv[R], &lookVec);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [ecx+216]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [eax+212]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+208]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+216]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+212]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+208]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp+8]

; 1404 : 			CopyVec(&wheelColl->WorldPos, &skidEnd.Pos);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _skidEnd$[ebp+8], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _skidEnd$[ebp+12], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _skidEnd$[ebp+16], ecx

; 1405 : 			CopyVec(&velPar, &skidEnd.Dir);

	mov	eax, DWORD PTR _velPar$[ebp]
	mov	DWORD PTR _skidEnd$[ebp+20], eax
	mov	eax, DWORD PTR _velPar$[ebp+4]
	mov	DWORD PTR _skidEnd$[ebp+24], eax
	mov	eax, DWORD PTR _velPar$[ebp+8]
	mov	DWORD PTR _skidEnd$[ebp+28], eax

; 1406 : 			CopyVec(PlaneNormal(&wheelColl->Plane), &skidEnd.Normal);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _skidEnd$[ebp+32], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _skidEnd$[ebp+36], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _skidEnd$[ebp+40], ecx

; 1407 : 			skidEnd.Width = MulScalar( wheel->SkidWidth / 2, abs(VecDotVec(&lookVec, &skidEnd.Dir)) );

	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR _skidEnd$[ebp+20]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR _skidEnd$[ebp+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR _skidEnd$[ebp+28]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82941
	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR _skidEnd$[ebp+20]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR _skidEnd$[ebp+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR _skidEnd$[ebp+28]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv439[ebp]
	jmp	SHORT $L82942
$L82941:
	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR _skidEnd$[ebp+20]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR _skidEnd$[ebp+24]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR _skidEnd$[ebp+28]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR tv439[ebp]
$L82942:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+352]
	fdiv	DWORD PTR __real@40000000
	fmul	DWORD PTR tv439[ebp]
	fstp	DWORD PTR _skidEnd$[ebp+44]

; 1408 : 			if (skidEnd.Width < MulScalar( Real(0.2), wheel->SkidWidth) ) skidEnd.Width = MulScalar( Real(0.2), wheel->SkidWidth );

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+352]
	fmul	DWORD PTR __real@3e4ccccd
	fcomp	DWORD PTR _skidEnd$[ebp+44]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82221
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+352]
	fmul	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR _skidEnd$[ebp+44]
$L82221:

; 1409 : 			skidEnd.Material = wheelColl->Material;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _skidEnd$[ebp+48], ecx

; 1410 : 
; 1411 : 			dirDotDir = VecDotVec(&skidEnd.Dir, &wheel->Skid.Dir);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _skidEnd$[ebp+20]
	fmul	DWORD PTR [eax+316]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _skidEnd$[ebp+24]
	fmul	DWORD PTR [ecx+320]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _skidEnd$[ebp+28]
	fmul	DWORD PTR [edx+324]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dirDotDir$[ebp]

; 1412 : 			normDotNorm = VecDotVec(&skidEnd.Normal, &wheel->Skid.Normal);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _skidEnd$[ebp+32]
	fmul	DWORD PTR [eax+328]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _skidEnd$[ebp+36]
	fmul	DWORD PTR [ecx+332]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _skidEnd$[ebp+40]
	fmul	DWORD PTR [edx+336]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _normDotNorm$[ebp]

; 1413 : 
; 1414 : 
; 1415 : 			// Add a skidmark to the list or update the current one
; 1416 : 			if (wheel->Skid.CurrentSkid == NULL) {

	mov	eax, DWORD PTR _wheel$[ebp]
	cmp	DWORD PTR [eax+348], 0
	jne	$L82223

; 1417 : 				// Make sure we are on the same surface
; 1418 : 				if ((normDotNorm > SKID_MAX_DOT) && (skidEnd.Material == wheel->Skid.Material)) {

	fld	DWORD PTR _normDotNorm$[ebp]
	fcomp	DWORD PTR __real@3f7ae148
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82225
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp+48]
	cmp	ecx, DWORD PTR [eax+344]
	jne	SHORT $L82225

; 1419 : 					// Get skid colour
; 1420 : 					if (wheel->OilTime < OILY_WHEEL_TIME) {

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+356]
	fcomp	DWORD PTR __real@40200000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82227

; 1421 : 						skidColour = 0xffffff;

	mov	DWORD PTR _skidColour$[ebp], 16777215	; 00ffffffH

; 1422 : 					} else {

	jmp	SHORT $L82228
$L82227:

; 1423 : 						//skidColour = (long)(256.0f * velParLen / SKID_MAX_VELPAR);
; 1424 : 						//skidColour = skidColour << 26 | skidColour << 8 | skidColour;
; 1425 : 						skidColour = wheelColl->Material->SkidColour;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _skidColour$[ebp], edx
$L82228:

; 1426 : 					}
; 1427 : 					wheel->Skid.CurrentSkid = AddSkid(&wheel->Skid, &skidEnd, skidColour);

	mov	eax, DWORD PTR _skidColour$[ebp]
	push	eax
	lea	ecx, DWORD PTR _skidEnd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wheel$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	call	?AddSkid@@YAPAUSKIDMARK@@PAUSKIDMARK_START@@0J@Z ; AddSkid
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [ecx+348], eax

; 1428 : 				} else {

	jmp	SHORT $L82229
$L82225:

; 1429 : 					wheel->Skid.Started = FALSE;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+296], 0

; 1430 : 					continue;

	jmp	$L82191
$L82229:

; 1431 : 				}
; 1432 : 			} else {

	jmp	SHORT $L82230
$L82223:

; 1433 : 				if (dirDotDir < ZERO) {

	fld	DWORD PTR _dirDotDir$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82231

; 1434 : 					NegateVec(&skidEnd.Dir);

	fld	DWORD PTR _skidEnd$[ebp+20]
	fchs
	fstp	DWORD PTR _skidEnd$[ebp+20]
	fld	DWORD PTR _skidEnd$[ebp+24]
	fchs
	fstp	DWORD PTR _skidEnd$[ebp+24]
	fld	DWORD PTR _skidEnd$[ebp+28]
	fchs
	fstp	DWORD PTR _skidEnd$[ebp+28]
$L82231:

; 1435 : 				}
; 1436 : 				// Make sure we are on the same surface
; 1437 : 				if ((normDotNorm > SKID_MAX_DOT) && (skidEnd.Material == wheel->Skid.Material)) {

	fld	DWORD PTR _normDotNorm$[ebp]
	fcomp	DWORD PTR __real@3f7ae148
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82230
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp+48]
	cmp	ecx, DWORD PTR [eax+344]
	jne	SHORT $L82230

; 1438 : 					MoveSkidEnd(wheel->Skid.CurrentSkid, &skidEnd);

	lea	eax, DWORD PTR _skidEnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR [ecx+348]
	push	edx
	call	?MoveSkidEnd@@YAXPAUSKIDMARK@@PAUSKIDMARK_START@@@Z ; MoveSkidEnd
	add	esp, 8
$L82230:

; 1439 : 				}
; 1440 : 			}
; 1441 : 
; 1442 : #ifndef _PSX
; 1443 : 			// Smokin'
; 1444 : 			wheel->Skid.LastSmokeTime += TimeStep;

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+300]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+300]

; 1445 : 			if (car->Rendered && (wheel->Skid.LastSmokeTime > SKID_SMOKE_TIME)) {

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3412], 0
	je	SHORT $L82235
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+300]
	fcomp	DWORD PTR __real@3cf5c28f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82235

; 1446 : 				VecPlusVec(&SmokeVel, &velPar, &vel)

	fld	DWORD PTR ?SmokeVel@@3UVectorStruct@@A
	fadd	DWORD PTR _velPar$[ebp]
	fstp	DWORD PTR _vel$[ebp]
	fld	DWORD PTR ?SmokeVel@@3UVectorStruct@@A+4
	fadd	DWORD PTR _velPar$[ebp+4]
	fstp	DWORD PTR _vel$[ebp+4]
	fld	DWORD PTR ?SmokeVel@@3UVectorStruct@@A+8
	fadd	DWORD PTR _velPar$[ebp+8]
	fstp	DWORD PTR _vel$[ebp+8]

; 1447 : 				CreateSpark(SPARK_SMOKE1, &wheelColl->WorldPos, &vel, ZERO, 0);

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _vel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	push	10					; 0000000aH
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H

; 1448 : 				wheel->Skid.LastSmokeTime = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+300], 0
$L82235:

; 1449 : 			}
; 1450 : #endif
; 1451 : 
; 1452 : 			// Check to see if it is time to start a new skid
; 1453 : 			if ((dRLen > SKID_MAX_LEN) ||
; 1454 : 				((dRLen > SKID_MIN_LEN) && (dirDotDir < SKID_MAX_DOT)) ||
; 1455 : 				(normDotNorm < SKID_MAX_DOT)) 

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@43000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L82241
	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@41200000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82242
	fld	DWORD PTR _dirDotDir$[ebp]
	fcomp	DWORD PTR __real@3f7ae148
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82241
$L82242:
	fld	DWORD PTR _normDotNorm$[ebp]
	fcomp	DWORD PTR __real@3f7ae148
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82209
$L82241:

; 1456 : 			{
; 1457 : 				// Reset the skid started flag
; 1458 : 				wheel->Skid.Started = FALSE;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+296], 0
$L82209:

; 1459 : 			}
; 1460 : 		}
; 1461 : 
; 1462 : 		// Start a new skid if necessary
; 1463 : 		if (!IsWheelSkidding(wheel) || !wheel->Skid.Started) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 48					; 00000030H
	je	SHORT $L82244
	mov	eax, DWORD PTR _wheel$[ebp]
	cmp	DWORD PTR [eax+296], 0
	jne	$L82243
$L82244:

; 1464 : 			// Store skid parameters
; 1465 : 			VecCrossVec(PlaneNormal(&wheelColl->Plane), &wheel->Axes.mv[R], &lookVec);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [ecx+216]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [eax+212]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+208]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+216]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+212]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+208]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp+8]

; 1466 : 			CopyVec(&wheelColl->WorldPos, &wheel->Skid.Pos);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+304], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+308], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+312], edx

; 1467 : 			CopyVec(&velPar, &wheel->Skid.Dir);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _velPar$[ebp]
	mov	DWORD PTR [eax+316], ecx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _velPar$[ebp+4]
	mov	DWORD PTR [eax+320], ecx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _velPar$[ebp+8]
	mov	DWORD PTR [eax+324], ecx

; 1468 : 			CopyVec(PlaneNormal(&wheelColl->Plane), &wheel->Skid.Normal);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+328], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+332], edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+336], edx

; 1469 : 			wheel->Skid.Width = MulScalar( wheel->SkidWidth / 2, abs(VecDotVec(&lookVec, &wheel->Skid.Dir)) );

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR [eax+316]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR [ecx+320]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR [edx+324]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82943
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR [eax+316]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR [ecx+320]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR [edx+324]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv750[ebp]
	jmp	SHORT $L82944
$L82943:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR [eax+316]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR [ecx+320]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR [edx+324]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR tv750[ebp]
$L82944:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+352]
	fdiv	DWORD PTR __real@40000000
	fmul	DWORD PTR tv750[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+340]

; 1470 : 			if (wheel->Skid.Width < MulScalar( Real(0.2), wheel->SkidWidth) ) wheel->Skid.Width = MulScalar( Real(0.2), wheel->SkidWidth );

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+352]
	fmul	DWORD PTR __real@3e4ccccd
	mov	ecx, DWORD PTR _wheel$[ebp]
	fcomp	DWORD PTR [ecx+340]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82255
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+352]
	fmul	DWORD PTR __real@3e4ccccd
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+340]
$L82255:

; 1471 : 			wheel->Skid.Material = wheelColl->Material;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+344], edx

; 1472 : 			wheel->Skid.LastSmokeTime = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+300], 0

; 1473 : 
; 1474 : 			// Set the skid started flag
; 1475 : 			wheel->Skid.Started = TRUE;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+296], 1

; 1476 : 			wheel->Skid.CurrentSkid = NULL;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+348], 0
$L82243:

; 1477 : 		}
; 1478 : 	}

	jmp	$L82191
$L82175:

; 1479 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PostProcessCarWheelColls@@YAXPAUCarStruct@@@Z ENDP	; PostProcessCarWheelColls
_TEXT	ENDS
PUBLIC	?SetAllCarCoMs@@YAXXZ				; SetAllCarCoMs
PUBLIC	?MoveCarCoM@@YAXPAUCAR_INFO@@PAUVectorStruct@@@Z ; MoveCarCoM
; Function compile flags: /Odt /ZI
;	COMDAT ?SetAllCarCoMs@@YAXXZ
_TEXT	SEGMENT
_iCar$ = -4						; size = 4
?SetAllCarCoMs@@YAXXZ PROC NEAR				; SetAllCarCoMs, COMDAT

; 1490 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1491 : 	int iCar;
; 1492 : 
; 1493 : 	for (iCar = 0; iCar < NCarTypes; iCar++) {

	mov	DWORD PTR _iCar$[ebp], 0
	jmp	SHORT $L82260
$L82261:
	mov	eax, DWORD PTR _iCar$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCar$[ebp], eax
$L82260:
	mov	eax, DWORD PTR _iCar$[ebp]
	cmp	eax, DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	jge	SHORT $L82258

; 1494 : 
; 1495 : 		MoveCarCoM(&CarInfo[iCar], &CarInfo[iCar].CoMOffset);

	mov	eax, DWORD PTR _iCar$[ebp]
	imul	eax, 2220				; 000008acH
	mov	ecx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	edx, DWORD PTR [ecx+eax+1436]
	push	edx
	mov	eax, DWORD PTR _iCar$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	push	eax
	call	?MoveCarCoM@@YAXPAUCAR_INFO@@PAUVectorStruct@@@Z ; MoveCarCoM
	add	esp, 8

; 1496 : 
; 1497 : 	}

	jmp	SHORT $L82261
$L82258:

; 1498 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetAllCarCoMs@@YAXXZ ENDP				; SetAllCarCoMs
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?MoveCarCoM@@YAXPAUCAR_INFO@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_iWheel$ = -4						; size = 4
_carInfo$ = 8						; size = 4
_dR$ = 12						; size = 4
?MoveCarCoM@@YAXPAUCAR_INFO@@PAUVectorStruct@@@Z PROC NEAR ; MoveCarCoM, COMDAT

; 1509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1510 : 	int iWheel;
; 1511 : 
; 1512 : 	// Move the body model
; 1513 : 	VecPlusEqVec(&carInfo->Body.Offset, dR);

	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+1468]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+1468]
	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+1472]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+1472]
	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+1476]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+1476]

; 1514 : 
; 1515 : 	// Move the Wheels, axles and suspension fixing points
; 1516 : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L82268
$L82269:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L82268:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L82270

; 1517 : 		VecPlusEqVec(&carInfo->Wheel[iWheel].Offset1, dR);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1556]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1556]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1560]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1560]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1564]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1564]

; 1518 : 		VecPlusEqVec(&carInfo->Spring[iWheel].Offset, dR);

	mov	eax, DWORD PTR _iWheel$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1860]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _iWheel$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1860]
	mov	eax, DWORD PTR _iWheel$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1864]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1864]
	mov	eax, DWORD PTR _iWheel$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1868]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _iWheel$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1868]

; 1519 : 		VecPlusEqVec(&carInfo->Pin[iWheel].Offset, dR);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+2068]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+2068]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+2072]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+2072]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+2076]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+2076]

; 1520 : 		VecPlusEqVec(&carInfo->Axle[iWheel].Offset, dR);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1988]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1988]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1992]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1992]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	mov	edx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [ecx+eax+1996]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [ecx+eax+1996]

; 1521 : 	}

	jmp	$L82269
$L82270:

; 1522 : 
; 1523 : 	// Move the Aerial
; 1524 : 	VecPlusEqVec(&carInfo->Aerial.Offset, dR);

	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+2184]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+2184]
	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+2188]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+2188]
	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+2192]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+2192]

; 1525 : 
; 1526 : 	// Move car spinner
; 1527 : 	VecPlusEqVec(&carInfo->Spinner.Offset, dR);

	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+2148]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+2148]
	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+2152]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+2152]
	mov	eax, DWORD PTR _carInfo$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	fld	DWORD PTR [eax+2156]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _carInfo$[ebp]
	fstp	DWORD PTR [edx+2156]

; 1528 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveCarCoM@@YAXPAUCAR_INFO@@PAUVectorStruct@@@Z ENDP	; MoveCarCoM
_TEXT	ENDS
PUBLIC	__real@3f333333
PUBLIC	__real@40800000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3c23d70a
PUBLIC	__real@46fffe00
PUBLIC	__real@40a00000
PUBLIC	__real@42480000
PUBLIC	__real@3ba3d70a
EXTRN	?TwoBodyZeroFrictionImpulse@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@11M1@Z:NEAR ; TwoBodyZeroFrictionImpulse
EXTRN	?SparkProbability@@YAMM@Z:NEAR			; SparkProbability
EXTRN	_rand:NEAR
EXTRN	?COL_DustInfo@@3PAUDustStruct@@A:BYTE		; COL_DustInfo
EXTRN	?GameSettings@@3UGAME_SETTINGS@@A:BYTE		; GameSettings
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CarWheelImpulse2@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
tv783 = -244						; size = 4
tv471 = -244						; size = 4
tv784 = -240						; size = 4
tv472 = -240						; size = 4
tv1605 = -236						; size = 4
tv821 = -236						; size = 4
tv775 = -236						; size = 4
tv753 = -236						; size = 4
tv730 = -236						; size = 4
tv419 = -236						; size = 4
tv1602 = -232						; size = 4
tv1127 = -232						; size = 4
tv1116 = -232						; size = 4
tv1106 = -232						; size = 4
tv818 = -232						; size = 4
tv776 = -232						; size = 4
tv767 = -232						; size = 4
tv750 = -232						; size = 4
tv731 = -232						; size = 4
tv564 = -232						; size = 4
tv420 = -232						; size = 4
tv195 = -232						; size = 4
_sparkType$82372 = -164					; size = 4
_body$ = -160						; size = 4
_wheel$ = -156						; size = 4
_impTan$ = -152						; size = 12
_impNorm$ = -140					; size = 12
_doSpark$ = -125					; size = 1
_sparkVel$ = -124					; size = 12
_lookVec$ = -112					; size = 12
_velTan$ = -100						; size = 12
_tmpVec$ = -88						; size = 12
_dVel$ = -76						; size = 12
_tReal$ = -64						; size = 4
_maxTorque$ = -60					; size = 4
_fricMod$ = -56						; size = 4
_torque$ = -52						; size = 4
_impDotLook$ = -48					; size = 4
_velDotNorm$ = -44					; size = 4
_lookLen$ = -40						; size = 4
_angVel$ = -36						; size = 4
_impTanLen$ = -32					; size = 4
_velTanLen$ = -28					; size = 4
_knock$ = -24						; size = 4
_impDotNorm$ = -20					; size = 4
_scale$ = -16						; size = 4
_impUp$ = -12						; size = 4
_dVelNorm$ = -8						; size = 4
_hardness$ = -4						; size = 4
_car$ = 8						; size = 4
_collInfo$ = 12						; size = 4
_impulse$ = 16						; size = 4
?CarWheelImpulse2@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@PAUVectorStruct@@@Z PROC NEAR ; CarWheelImpulse2, COMDAT

; 1532 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi

; 1533 : 	REAL	hardness;
; 1534 : 	REAL	dVelNorm, impUp, scale, impDotNorm, knock;
; 1535 : 	REAL	velTanLen, impTanLen, angVel;
; 1536 : 	REAL	lookLen, velDotNorm, impDotLook, torque;
; 1537 : 	REAL	fricMod, maxTorque, tReal;
; 1538 : 	VEC	dVel, tmpVec;
; 1539 : 	VEC	velTan, lookVec;
; 1540 : 	VEC sparkVel;
; 1541 : //	COLLINFO_BODY *bodyColl;
; 1542 : 
; 1543 : 	bool doSpark = FALSE;

	mov	BYTE PTR _doSpark$[ebp], 0

; 1544 : 	VEC  impNorm = {ZERO, ZERO, ZERO};

	mov	DWORD PTR _impNorm$[ebp], 0
	mov	DWORD PTR _impNorm$[ebp+4], 0
	mov	DWORD PTR _impNorm$[ebp+8], 0

; 1545 : 	VEC	impTan = {ZERO, ZERO, ZERO};

	mov	DWORD PTR _impTan$[ebp], 0
	mov	DWORD PTR _impTan$[ebp+4], 0
	mov	DWORD PTR _impTan$[ebp+8], 0

; 1546 : 	WHEEL	*wheel = &car->Wheel[collInfo->IWheel];

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 360				; 00000168H
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1560]
	mov	DWORD PTR _wheel$[ebp], eax

; 1547 : 	NEWBODY *body = car->Body;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR _body$[ebp], ecx

; 1548 : 
; 1549 : 	// Calculate forward vector
; 1550 : 	VecCrossVec(PlaneNormal(&collInfo->Plane), &wheel->Axes.mv[R], &lookVec);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [ecx+216]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [eax+212]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+208]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+216]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+212]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+208]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _lookVec$[ebp+8]

; 1551 : 	lookLen = VecLen(&lookVec);

	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR _lookVec$[ebp]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR _lookVec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR _lookVec$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _lookLen$[ebp]

; 1552 : 
; 1553 : 	// Scale the friction if the sides of the wheels are the contact point
; 1554 : 	if (lookLen > Real(0.7)) {

	fld	DWORD PTR _lookLen$[ebp]
	fcomp	DWORD PTR __real@3f333333
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82310

; 1555 : 		hardness = collInfo->Restitution;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _hardness$[ebp], ecx

; 1556 : 		VecDivScalar(&lookVec, lookLen);

	fld	DWORD PTR _lookVec$[ebp]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _lookVec$[ebp]
	fld	DWORD PTR _lookVec$[ebp+4]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _lookVec$[ebp+4]
	fld	DWORD PTR _lookVec$[ebp+8]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _lookVec$[ebp+8]

; 1557 : 		fricMod = ONE;

	mov	DWORD PTR _fricMod$[ebp], 1065353216	; 3f800000H

; 1558 : 	} else {

	jmp	SHORT $L82311
$L82310:

; 1559 : 		hardness = Real(0.1);

	mov	DWORD PTR _hardness$[ebp], 1036831949	; 3dcccccdH

; 1560 : 		doSpark = TRUE;

	mov	BYTE PTR _doSpark$[ebp], 1

; 1561 : 		if (abs(collInfo->Plane.v[B]) > HALF) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+64]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82961
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+64]
	fstp	DWORD PTR tv195[ebp]
	jmp	SHORT $L82962
$L82961:
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+64]
	fchs
	fstp	DWORD PTR tv195[ebp]
$L82962:
	fld	DWORD PTR tv195[ebp]
	fcomp	DWORD PTR __real@3f000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82313

; 1562 : 			fricMod = ONE;

	mov	DWORD PTR _fricMod$[ebp], 1065353216	; 3f800000H

; 1563 : 		} else {

	jmp	SHORT $L82311
$L82313:

; 1564 : 			fricMod = Real(0.1) + lookLen / 4;

	fld	DWORD PTR _lookLen$[ebp]
	fdiv	DWORD PTR __real@40800000
	fadd	DWORD PTR __real@3dcccccd
	fstp	DWORD PTR _fricMod$[ebp]
$L82311:

; 1565 : 		}
; 1566 : 	}
; 1567 : 
; 1568 : 	// Calculate the change in normal velocity required for the collision
; 1569 : 	VecEqScalarVec(&dVel, -(ONE + hardness), &collInfo->Vel);

	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR _hardness$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+48]
	fstp	DWORD PTR _dVel$[ebp]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR _hardness$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+52]
	fstp	DWORD PTR _dVel$[ebp+4]
	fld	DWORD PTR __real@3f800000
	fadd	DWORD PTR _hardness$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+56]
	fstp	DWORD PTR _dVel$[ebp+8]

; 1570 : 	dVelNorm = VecDotVec(&dVel, PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _dVel$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _dVel$[ebp+4]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _dVel$[ebp+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dVelNorm$[ebp]

; 1571 : 
; 1572 : 	// Calculate normal (zero-friction) impulse required to get this change in velocity
; 1573 : 	//OneBodyZeroFrictionImpulse(body, &collInfo->Pos, PlaneNormal(&collInfo->Plane), dVelNorm, &impNorm);
; 1574 : 	TwoBodyZeroFrictionImpulse(body, collInfo->Body2, &collInfo->Pos, &collInfo->Pos2, PlaneNormal(&collInfo->Plane), dVelNorm, &impNorm);

	lea	eax, DWORD PTR _impNorm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dVelNorm$[ebp]
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	eax, DWORD PTR _collInfo$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?TwoBodyZeroFrictionImpulse@@YAXPAUNewBodyStruct@@0PAUVectorStruct@@11M1@Z ; TwoBodyZeroFrictionImpulse
	add	esp, 28					; 0000001cH

; 1575 : 	
; 1576 : 	// Rescale due to spring-damper system
; 1577 : 	if (CAR_WheelsHaveSuspension) {

	movzx	eax, BYTE PTR ?CAR_WheelsHaveSuspension@@3_NA ; CAR_WheelsHaveSuspension
	test	eax, eax
	je	$L82320

; 1578 : 
; 1579 : 		//if (abs(wheel->Pos) < wheel->MaxPos) {
; 1580 : 			// Normal suspension forces
; 1581 : 			// Dampers
; 1582 : 			impUp = VecDotVec(&impNorm, &body->Centre.WMatrix.mv[U]);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _impNorm$[ebp]
	fmul	DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR _impNorm$[ebp+4]
	fmul	DWORD PTR [ecx+116]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR _impNorm$[ebp+8]
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _impUp$[ebp]

; 1583 : 			impUp = MulScalar(impUp, VecDotVec(&body->Centre.WMatrix.mv[U], PlaneNormal(&collInfo->Plane)));

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+112]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+116]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+120]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _impUp$[ebp]
	fstp	DWORD PTR _impUp$[ebp]

; 1584 : 			scale = MulScalar((car->Spring[collInfo->IWheel].Restitution), impUp);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+ecx+3008]
	fmul	DWORD PTR _impUp$[ebp]
	fstp	DWORD PTR _scale$[ebp]

; 1585 : 			VecPlusEqScalarVec(&impNorm, scale, PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [eax+60]
	fadd	DWORD PTR _impNorm$[ebp]
	fstp	DWORD PTR _impNorm$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [eax+64]
	fadd	DWORD PTR _impNorm$[ebp+4]
	fstp	DWORD PTR _impNorm$[ebp+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [eax+68]
	fadd	DWORD PTR _impNorm$[ebp+8]
	fstp	DWORD PTR _impNorm$[ebp+8]

; 1586 : 
; 1587 : 			// Springs
; 1588 : 			VecMinusVec(&wheel->CentrePos, &car->Body->Centre.Pos, &tmpVec);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+184]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+188]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+192]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1589 : 			VecMinusEqVec(&tmpVec, &collInfo->Pos);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fsub	DWORD PTR [eax+12]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fsub	DWORD PTR [eax+16]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fsub	DWORD PTR [eax+20]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 1590 : 			if (Sign(wheel->Pos) == Sign(VecDotVec(&tmpVec, &body->Centre.WMatrix.mv[U]))) {

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+80]
	fld	DWORD PTR __real@00000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82965
	mov	DWORD PTR tv420[ebp], 0
	jmp	SHORT $L82966
$L82965:
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+80]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82963
	mov	DWORD PTR tv419[ebp], -1
	jmp	SHORT $L82964
$L82963:
	mov	DWORD PTR tv419[ebp], 1
$L82964:
	mov	edx, DWORD PTR tv419[ebp]
	mov	DWORD PTR tv420[ebp], edx
$L82966:
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR [ecx+116]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fld	DWORD PTR __real@00000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82969
	mov	DWORD PTR tv472[ebp], 0
	jmp	SHORT $L82970
$L82969:
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR [ecx+116]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82967
	mov	DWORD PTR tv471[ebp], -1
	jmp	SHORT $L82968
$L82967:
	mov	DWORD PTR tv471[ebp], 1
$L82968:
	mov	eax, DWORD PTR tv471[ebp]
	mov	DWORD PTR tv472[ebp], eax
$L82970:
	mov	ecx, DWORD PTR tv420[ebp]
	cmp	ecx, DWORD PTR tv472[ebp]
	jne	$L82327

; 1591 : 				scale = MulScalar(TimeStep, SpringDampedForce(&car->Spring[collInfo->IWheel], wheel->Pos, wheel->Vel));

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _car$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3000]
	push	ecx
	call	?SpringDampedForce@@YAMPAUSPRING@@MM@Z	; SpringDampedForce
	add	esp, 12					; 0000000cH
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _scale$[ebp]

; 1592 : 				scale = MulScalar(scale, VecDotVec(&body->Centre.WMatrix.mv[U], PlaneNormal(&collInfo->Plane)));

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+112]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+116]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+120]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR _scale$[ebp]

; 1593 : 				VecPlusEqScalarVec(&impNorm, -scale, PlaneNormal(&collInfo->Plane));

	fld	DWORD PTR _scale$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+60]
	fadd	DWORD PTR _impNorm$[ebp]
	fstp	DWORD PTR _impNorm$[ebp]
	fld	DWORD PTR _scale$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+64]
	fadd	DWORD PTR _impNorm$[ebp+4]
	fstp	DWORD PTR _impNorm$[ebp+4]
	fld	DWORD PTR _scale$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+68]
	fadd	DWORD PTR _impNorm$[ebp+8]
	fstp	DWORD PTR _impNorm$[ebp+8]
$L82327:

; 1594 : 			}
; 1595 : 
; 1596 : 			impDotNorm = VecDotVec(&impNorm, PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _impNorm$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _impNorm$[ebp+4]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _impNorm$[ebp+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _impDotNorm$[ebp]
$L82320:

; 1597 : 
; 1598 : 		/*} else {
; 1599 : 			// Body collision if suspension grounded out
; 1600 : 			// Add collision to car body
; 1601 : 			if ((bodyColl = NextBodyCollInfo()) != NULL) {
; 1602 : 				impDotNorm = VecDotVec(&impNorm, PlaneNormal(&collInfo->Plane));
; 1603 : 				VecPlusEqScalarVec(&impNorm, -impDotNorm, PlaneNormal(&collInfo->Plane));
; 1604 : 
; 1605 : 				bodyColl->Body1 = body;
; 1606 : 				bodyColl->Body2 = collInfo->Body2;
; 1607 : 				CopyVec(&collInfo->Pos, &bodyColl->Pos1);
; 1608 : 				//VecMinusVec(&wheel->CentrePos, &car->Body->Centre.Pos, &bodyColl->Pos1);
; 1609 : 				VecCrossVec(&body->AngVel, &bodyColl->Pos1, &bodyColl->Vel);
; 1610 : 				VecPlusEqVec(&bodyColl->Vel, &body->Centre.Vel);
; 1611 : 				//CopyVec(&collInfo->Vel, &bodyColl->Vel);
; 1612 : 				CopyPlane(&collInfo->Plane, &bodyColl->Plane);
; 1613 : 				CopyVec(&collInfo->WorldPos, &bodyColl->WorldPos);
; 1614 : 				//CopyVec(&wheel->WPos, &bodyColl->WorldPos);
; 1615 : 				bodyColl->Depth = -COLL_EPSILON;//collInfo->Depth;
; 1616 : 				bodyColl->Time = collInfo->Time;
; 1617 : 				bodyColl->StaticFriction = ZERO;//MulScalar(fricMod, collInfo->StaticFriction);
; 1618 : 				bodyColl->KineticFriction = ZERO;//MulScalar(fricMod, collInfo->KineticFriction);
; 1619 : 				bodyColl->Restitution = ZERO;
; 1620 : 				AddBodyColl(body, bodyColl);
; 1621 : 			}
; 1622 : 		}*/
; 1623 : 
; 1624 : 	}
; 1625 : 
; 1626 : 	// Flag a hard knock if necessary
; 1627 : 	knock = MulScalar(abs(impDotNorm), car->Body->Centre.InvMass);

	fld	DWORD PTR _impDotNorm$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82971
	mov	eax, DWORD PTR _impDotNorm$[ebp]
	mov	DWORD PTR tv564[ebp], eax
	jmp	SHORT $L82972
$L82971:
	fld	DWORD PTR _impDotNorm$[ebp]
	fchs
	fstp	DWORD PTR tv564[ebp]
$L82972:
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR tv564[ebp]
	fstp	DWORD PTR _knock$[ebp]

; 1628 : 	if (knock > car->Body->BangMag) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _knock$[ebp]
	fcomp	DWORD PTR [ecx+548]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82337

; 1629 : 		car->Body->BangMag = knock;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _knock$[ebp]
	mov	DWORD PTR [ecx+548], edx

; 1630 : 		CopyPlane(&collInfo->Plane, &car->Body->BangPlane);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+552], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+556], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx+560], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR [ecx+564], eax
$L82337:

; 1631 : 	}
; 1632 : 
; 1633 : 	// Calculate sliding velocity
; 1634 : 	velDotNorm = VecDotVec(&collInfo->Vel, PlaneNormal(&collInfo->Plane));

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [edx+52]
	fmul	DWORD PTR [eax+64]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+56]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 1635 : 	VecPlusScalarVec(&collInfo->Vel, -velDotNorm, PlaneNormal(&collInfo->Plane), &velTan);

	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fadd	DWORD PTR [ecx+48]
	fstp	DWORD PTR _velTan$[ebp]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fadd	DWORD PTR [ecx+52]
	fstp	DWORD PTR _velTan$[ebp+4]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collInfo$[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fadd	DWORD PTR [ecx+56]
	fstp	DWORD PTR _velTan$[ebp+8]

; 1636 : 	velTanLen = Length(&velTan);

	fld	DWORD PTR _velTan$[ebp]
	fmul	DWORD PTR _velTan$[ebp]
	fld	DWORD PTR _velTan$[ebp+4]
	fmul	DWORD PTR _velTan$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _velTan$[ebp+8]
	fmul	DWORD PTR _velTan$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _velTanLen$[ebp]

; 1637 : 
; 1638 : 	// Turn sliding velocities into fricitonal impulse
; 1639 : 	impTanLen = -MulScalar(collInfo->Grip, impDotNorm);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+84]
	fmul	DWORD PTR _impDotNorm$[ebp]
	fchs
	fstp	DWORD PTR _impTanLen$[ebp]

; 1640 : 	VecEqScalarVec(&impTan, impTanLen, &velTan);

	fld	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _velTan$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _velTan$[ebp+4]
	fstp	DWORD PTR _impTan$[ebp+4]
	fld	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _velTan$[ebp+8]
	fstp	DWORD PTR _impTan$[ebp+8]

; 1641 : 	impTanLen = MulScalar(impTanLen, velTanLen);

	fld	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _velTanLen$[ebp]
	fstp	DWORD PTR _impTanLen$[ebp]

; 1642 : 
; 1643 : 	// Remove friction along roll-direction of tyre if wheel not locked
; 1644 : 	if (!IsWheelLocked(wheel)) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 64					; 00000040H
	jne	SHORT $L82345

; 1645 : 		impDotLook = VecDotVec(&lookVec, &impTan);

	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR _impTan$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR _impTan$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _impDotLook$[ebp]

; 1646 : 		VecPlusEqScalarVec(&impTan, -impDotLook, &lookVec);

	fld	DWORD PTR _impDotLook$[ebp]
	fchs
	fmul	DWORD PTR _lookVec$[ebp]
	fadd	DWORD PTR _impTan$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _impDotLook$[ebp]
	fchs
	fmul	DWORD PTR _lookVec$[ebp+4]
	fadd	DWORD PTR _impTan$[ebp+4]
	fstp	DWORD PTR _impTan$[ebp+4]
	fld	DWORD PTR _impDotLook$[ebp]
	fchs
	fmul	DWORD PTR _lookVec$[ebp+8]
	fadd	DWORD PTR _impTan$[ebp+8]
	fstp	DWORD PTR _impTan$[ebp+8]
$L82345:

; 1647 : 	}
; 1648 : 
; 1649 : 	if (!IsWheelLocked(wheel)) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 64					; 00000040H
	jne	$L82346

; 1650 : 		// Add wheel torque
; 1651 : 		if (IsWheelPowered(wheel)) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4
	je	$L82347

; 1652 : 			torque = MulScalar(TimeStep, MulScalar(car->EngineVolt, wheel->EngineRatio));

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [ecx+44]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _torque$[ebp]

; 1653 : 			tReal = Sign(torque) * MulScalar(torque, DivScalar(MulScalar(wheel->AngVel, wheel->Radius), car->TopSpeed));

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _torque$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82975
	mov	DWORD PTR tv731[ebp], 0
	jmp	SHORT $L82976
$L82975:
	fld	DWORD PTR _torque$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82973
	mov	DWORD PTR tv730[ebp], -1
	jmp	SHORT $L82974
$L82973:
	mov	DWORD PTR tv730[ebp], 1
$L82974:
	mov	eax, DWORD PTR tv730[ebp]
	mov	DWORD PTR tv731[ebp], eax
$L82976:
	fild	DWORD PTR tv731[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+92]
	mov	edx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car$[ebp]
	fdiv	DWORD PTR [eax+844]
	fmul	DWORD PTR _torque$[ebp]
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _tReal$[ebp]

; 1654 : 			if (abs(tReal) > abs(torque)) {

	fld	DWORD PTR _tReal$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82977
	mov	eax, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR tv750[ebp], eax
	jmp	SHORT $L82978
$L82977:
	fld	DWORD PTR _tReal$[ebp]
	fchs
	fstp	DWORD PTR tv750[ebp]
$L82978:
	fld	DWORD PTR _torque$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82979
	mov	ecx, DWORD PTR _torque$[ebp]
	mov	DWORD PTR tv753[ebp], ecx
	jmp	SHORT $L82980
$L82979:
	fld	DWORD PTR _torque$[ebp]
	fchs
	fstp	DWORD PTR tv753[ebp]
$L82980:
	fld	DWORD PTR tv750[ebp]
	fcomp	DWORD PTR tv753[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82348

; 1655 : 				torque = MulScalar(0.01f, torque);

	fld	DWORD PTR __real@3c23d70a
	fmul	DWORD PTR _torque$[ebp]
	fstp	DWORD PTR _torque$[ebp]

; 1656 : 			} else {

	jmp	SHORT $L82349
$L82348:

; 1657 : 				torque -= tReal;

	fld	DWORD PTR _torque$[ebp]
	fsub	DWORD PTR _tReal$[ebp]
	fstp	DWORD PTR _torque$[ebp]
$L82349:

; 1658 : 			}
; 1659 : 		} else {

	jmp	SHORT $L82350
$L82347:

; 1660 : 			torque = ZERO;

	mov	DWORD PTR _torque$[ebp], 0
$L82350:

; 1661 : 		}
; 1662 : 
; 1663 : 		// Apply axle friction
; 1664 : 		if ((GameSettings.AutoBrake && abs(car->EngineVolt) < Real(0.01)) || (Sign(car->EngineVolt) == -Sign(wheel->AngVel))) {

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+20, 0
	je	SHORT $L82354
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82981
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+836]
	fstp	DWORD PTR tv767[ebp]
	jmp	SHORT $L82982
$L82981:
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+836]
	fchs
	fstp	DWORD PTR tv767[ebp]
$L82982:
	fld	DWORD PTR tv767[ebp]
	fcomp	DWORD PTR __real@3c23d70a
	fnstsw	ax
	test	ah, 5
	jnp	$L82353
$L82354:
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	fld	DWORD PTR __real@00000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82985
	mov	DWORD PTR tv776[ebp], 0
	jmp	SHORT $L82986
$L82985:
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+836]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82983
	mov	DWORD PTR tv775[ebp], -1
	jmp	SHORT $L82984
$L82983:
	mov	DWORD PTR tv775[ebp], 1
$L82984:
	mov	edx, DWORD PTR tv775[ebp]
	mov	DWORD PTR tv776[ebp], edx
$L82986:
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+92]
	fld	DWORD PTR __real@00000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82989
	mov	DWORD PTR tv784[ebp], 0
	jmp	SHORT $L82990
$L82989:
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+92]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82987
	mov	DWORD PTR tv783[ebp], -1
	jmp	SHORT $L82988
$L82987:
	mov	DWORD PTR tv783[ebp], 1
$L82988:
	mov	edx, DWORD PTR tv783[ebp]
	mov	DWORD PTR tv784[ebp], edx
$L82990:
	mov	eax, DWORD PTR tv784[ebp]
	neg	eax
	cmp	DWORD PTR tv776[ebp], eax
	jne	SHORT $L82352
$L82353:

; 1665 : 			tReal = MulScalar(wheel->AxleFriction, MulScalar(wheel->AngVel, wheel->Radius));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+92]
	mov	edx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [edx+20]
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _tReal$[ebp]

; 1666 : 			tReal = MulScalar(tReal, MulScalar(FRICTION_TIME_SCALE, TimeStep));

	fld	DWORD PTR __real@42f00000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR _tReal$[ebp]
	fstp	DWORD PTR _tReal$[ebp]

; 1667 : 			torque -= tReal;

	fld	DWORD PTR _torque$[ebp]
	fsub	DWORD PTR _tReal$[ebp]
	fstp	DWORD PTR _torque$[ebp]
$L82352:

; 1668 : 		}
; 1669 : 
; 1670 : 		// Check Engine Torque for wheelspin
; 1671 : 		maxTorque = MulScalar(MulScalar(wheel->Radius, fricMod), MulScalar(collInfo->StaticFriction, impDotNorm));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR _fricMod$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [ecx+88]
	fmul	DWORD PTR _impDotNorm$[ebp]
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _maxTorque$[ebp]

; 1672 : 		if (abs(torque) > abs(maxTorque)) {

	fld	DWORD PTR _torque$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82991
	mov	eax, DWORD PTR _torque$[ebp]
	mov	DWORD PTR tv818[ebp], eax
	jmp	SHORT $L82992
$L82991:
	fld	DWORD PTR _torque$[ebp]
	fchs
	fstp	DWORD PTR tv818[ebp]
$L82992:
	fld	DWORD PTR _maxTorque$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82993
	mov	ecx, DWORD PTR _maxTorque$[ebp]
	mov	DWORD PTR tv821[ebp], ecx
	jmp	SHORT $L82994
$L82993:
	fld	DWORD PTR _maxTorque$[ebp]
	fchs
	fstp	DWORD PTR tv821[ebp]
$L82994:
	fld	DWORD PTR tv818[ebp]
	fcomp	DWORD PTR tv821[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82356

; 1673 : 			SetWheelSpinning(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx
$L82356:

; 1674 : 		}
; 1675 : 
; 1676 : 		VecPlusEqScalarVec(&impTan, DivScalar(torque, wheel->Radius), &lookVec);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	fdivr	DWORD PTR _torque$[ebp]
	fmul	DWORD PTR _lookVec$[ebp]
	fadd	DWORD PTR _impTan$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	fdivr	DWORD PTR _torque$[ebp]
	fmul	DWORD PTR _lookVec$[ebp+4]
	fadd	DWORD PTR _impTan$[ebp+4]
	fstp	DWORD PTR _impTan$[ebp+4]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	fdivr	DWORD PTR _torque$[ebp]
	fmul	DWORD PTR _lookVec$[ebp+8]
	fadd	DWORD PTR _impTan$[ebp+8]
	fstp	DWORD PTR _impTan$[ebp+8]
$L82346:

; 1677 : 	}
; 1678 : 
; 1679 : 	// Scale sliding to friction cone
; 1680 : 	impTanLen = VecLen(&impTan);

	fld	DWORD PTR _impTan$[ebp]
	fmul	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _impTan$[ebp+4]
	fmul	DWORD PTR _impTan$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _impTan$[ebp+8]
	fmul	DWORD PTR _impTan$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _impTanLen$[ebp]

; 1681 : 	maxTorque = 2 * MulScalar(MulScalar(TimeStep, car->Body->Centre.Mass), car->Body->Centre.Gravity);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fmul	DWORD PTR [eax+192]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _maxTorque$[ebp]

; 1682 : 	if (impTanLen > maxTorque) {

	fld	DWORD PTR _impTanLen$[ebp]
	fcomp	DWORD PTR _maxTorque$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82358

; 1683 : 		VecMulScalar(&impTan, DivScalar(maxTorque, impTanLen));

	fld	DWORD PTR _maxTorque$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _impTan$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _maxTorque$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _impTan$[ebp+4]
	fstp	DWORD PTR _impTan$[ebp+4]
	fld	DWORD PTR _maxTorque$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _impTan$[ebp+8]
	fstp	DWORD PTR _impTan$[ebp+8]

; 1684 : 		impTanLen = maxTorque;

	mov	eax, DWORD PTR _maxTorque$[ebp]
	mov	DWORD PTR _impTanLen$[ebp], eax

; 1685 : 		SetWheelSliding(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx
$L82358:

; 1686 : 	}
; 1687 : 	maxTorque = MulScalar(MulScalar(collInfo->StaticFriction, fricMod), impDotNorm);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+88]
	fmul	DWORD PTR _fricMod$[ebp]
	fmul	DWORD PTR _impDotNorm$[ebp]
	fstp	DWORD PTR _maxTorque$[ebp]

; 1688 : 	if (impTanLen > maxTorque) {

	fld	DWORD PTR _impTanLen$[ebp]
	fcomp	DWORD PTR _maxTorque$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82359

; 1689 : 		maxTorque = MulScalar(MulScalar(collInfo->KineticFriction, fricMod), impDotNorm);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR _fricMod$[ebp]
	fmul	DWORD PTR _impDotNorm$[ebp]
	fstp	DWORD PTR _maxTorque$[ebp]

; 1690 : 		VecMulScalar(&impTan, DivScalar(maxTorque, impTanLen));

	fld	DWORD PTR _maxTorque$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _impTan$[ebp]
	fstp	DWORD PTR _impTan$[ebp]
	fld	DWORD PTR _maxTorque$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _impTan$[ebp+4]
	fstp	DWORD PTR _impTan$[ebp+4]
	fld	DWORD PTR _maxTorque$[ebp]
	fdiv	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR _impTan$[ebp+8]
	fstp	DWORD PTR _impTan$[ebp+8]

; 1691 : 		impTanLen = maxTorque;

	mov	eax, DWORD PTR _maxTorque$[ebp]
	mov	DWORD PTR _impTanLen$[ebp], eax

; 1692 : 		SetWheelSliding(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx
$L82359:

; 1693 : 	}
; 1694 : 
; 1695 : 	// Calculate wheel angular velocity
; 1696 : 	if (IsWheelLocked(wheel)) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 64					; 00000040H
	je	SHORT $L82360

; 1697 : 		wheel->AngVel = ZERO;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+92], 0

; 1698 : 	} else {

	jmp	SHORT $L82361
$L82360:

; 1699 : #ifndef _PSX
; 1700 : 		if (IsWheelSpinning(wheel)) {

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 16					; 00000010H
	je	SHORT $L82362

; 1701 : 			//wheel->AngImpulse += MulScalar(dt, MulScalar(car->EngineVolt, wheel->EngineRatio));
; 1702 : 			//wheel->AngImpulse += torque;
; 1703 : 		} else {

	jmp	SHORT $L82361
$L82362:

; 1704 : 			angVel = DivScalar(VecDotVec(&collInfo->Vel, &lookVec), wheel->Radius);

	mov	eax, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _lookVec$[ebp]
	fmul	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _lookVec$[ebp+4]
	fmul	DWORD PTR [ecx+52]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _collInfo$[ebp]
	fld	DWORD PTR _lookVec$[ebp+8]
	fmul	DWORD PTR [edx+56]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheel$[ebp]
	fdiv	DWORD PTR [eax+20]
	fstp	DWORD PTR _angVel$[ebp]

; 1705 : 			wheel->AngVel += MulScalar((angVel - wheel->AngVel),  DivScalar(MulScalar(FRICTION_TIME_SCALE, TimeStep), 4));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _angVel$[ebp]
	fsub	DWORD PTR [eax+92]
	fld	DWORD PTR __real@42f00000
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@40800000
	fmulp	ST(1), ST(0)
	mov	ecx, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [ecx+92]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+92]
$L82361:

; 1706 : 		}
; 1707 : #else
; 1708 : 		angVel = DivScalar(VecDotVec(&collInfo->Vel, &lookVec), wheel->Radius);
; 1709 : 		wheel->AngVel = angVel;
; 1710 : #endif
; 1711 : 	}
; 1712 : 
; 1713 : #ifndef _PSX
; 1714 : 	// Generate spark if side of wheel scraping
; 1715 : 	if (car->Rendered && doSpark &&  (collInfo->Material != NULL) && (velTanLen > MIN_SPARK_VEL))

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3412], 0
	je	$L82366
	movzx	eax, BYTE PTR _doSpark$[ebp]
	test	eax, eax
	je	$L82366
	mov	eax, DWORD PTR _collInfo$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	$L82366
	fld	DWORD PTR _velTanLen$[ebp]
	fcomp	DWORD PTR __real@42c80000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L82366

; 1716 : 	{
; 1717 : 		body->ScrapeMaterial = collInfo->Material - COL_MaterialInfo;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [eax+100]
	sub	eax, OFFSET FLAT:?COL_MaterialInfo@@3PAUMaterialStruct@@A ; COL_MaterialInfo
	cdq
	mov	ecx, 40					; 00000028H
	idiv	ecx
	mov	edx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [edx+536], eax

; 1718 : 		body->LastScrapeTime = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+540], 0

; 1719 : 		if ((frand(2.0f) < SparkProbability(velTanLen)) && MaterialAllowsSparks(collInfo->Material))

	call	_rand
	mov	DWORD PTR tv1602[ebp], eax
	fild	DWORD PTR tv1602[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fadd	ST(0), ST(0)
	fstp	DWORD PTR tv1605[ebp]
	mov	eax, DWORD PTR _velTanLen$[ebp]
	push	eax
	call	?SparkProbability@@YAMM@Z		; SparkProbability
	add	esp, 4
	fcomp	DWORD PTR tv1605[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82366
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1
	je	SHORT $L82366

; 1720 : 		{
; 1721 : 			VecEqScalarVec(&sparkVel, HALF, &velTan);

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _velTan$[ebp]
	fstp	DWORD PTR _sparkVel$[ebp]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _velTan$[ebp+4]
	fstp	DWORD PTR _sparkVel$[ebp+4]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _velTan$[ebp+8]
	fstp	DWORD PTR _sparkVel$[ebp+8]

; 1722 : 			CreateSpark(SPARK_SPARK, &collInfo->WorldPos, &sparkVel, velTanLen / 3, 0);

	push	0
	push	0
	fld	DWORD PTR _velTanLen$[ebp]
	fdiv	DWORD PTR __real@40400000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _sparkVel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	push	0
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H
$L82366:

; 1723 : 		}
; 1724 : 	}
; 1725 : 
; 1726 : 	// Spray dust if the material is dusty
; 1727 : 	if (car->Rendered && collInfo->Material != NULL && MaterialDusty(collInfo->Material) && impTanLen > 5 * body->Centre.InvMass * MIN_DUST_IMPULSE &&(frand(1.0f) < COL_DustInfo[collInfo->Material->DustType].SparkProbability, 0)) 

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3412], 0
	je	$L82371
	mov	eax, DWORD PTR _collInfo$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	$L82371
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx]
	and	edx, 32					; 00000020H
	je	$L82371
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR __real@40a00000
	fmul	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@40400000
	fcomp	DWORD PTR _impTanLen$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	$L82371
	call	_rand
	xor	eax, eax
	je	$L82371

; 1728 : 	{
; 1729 : 		enum SparkTypeEnum sparkType;
; 1730 : 		sparkType = (enum SparkTypeEnum)COL_DustInfo[collInfo->Material->DustType].SparkType;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?COL_DustInfo@@3PAUDustStruct@@A[edx]
	mov	DWORD PTR _sparkType$82372[ebp], eax

; 1731 : 		scale = body->Centre.InvMass * DUST_SCALE;

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@42480000
	fstp	DWORD PTR _scale$[ebp]

; 1732 : 		VecEqScalarVec(&sparkVel, -scale, &impTan);

	fld	DWORD PTR _scale$[ebp]
	fchs
	fmul	DWORD PTR _impTan$[ebp]
	fstp	DWORD PTR _sparkVel$[ebp]
	fld	DWORD PTR _scale$[ebp]
	fchs
	fmul	DWORD PTR _impTan$[ebp+4]
	fstp	DWORD PTR _sparkVel$[ebp+4]
	fld	DWORD PTR _scale$[ebp]
	fchs
	fmul	DWORD PTR _impTan$[ebp+8]
	fstp	DWORD PTR _sparkVel$[ebp+8]

; 1733 : 		VecPlusEqScalarVec(&sparkVel, HALF * scale * impTanLen, &UpVec);

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fadd	DWORD PTR _sparkVel$[ebp]
	fstp	DWORD PTR _sparkVel$[ebp]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fadd	DWORD PTR _sparkVel$[ebp+4]
	fstp	DWORD PTR _sparkVel$[ebp+4]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR _impTanLen$[ebp]
	fmul	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fadd	DWORD PTR _sparkVel$[ebp+8]
	fstp	DWORD PTR _sparkVel$[ebp+8]

; 1734 : 		VecPlusEqScalarVec(&sparkVel, HALF * body->Centre.InvMass * torque, &lookVec);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR [eax+4]
	fmul	DWORD PTR _torque$[ebp]
	fmul	DWORD PTR _lookVec$[ebp]
	fadd	DWORD PTR _sparkVel$[ebp]
	fstp	DWORD PTR _sparkVel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR [eax+4]
	fmul	DWORD PTR _torque$[ebp]
	fmul	DWORD PTR _lookVec$[ebp+4]
	fadd	DWORD PTR _sparkVel$[ebp+4]
	fstp	DWORD PTR _sparkVel$[ebp+4]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR [eax+4]
	fmul	DWORD PTR _torque$[ebp]
	fmul	DWORD PTR _lookVec$[ebp+8]
	fadd	DWORD PTR _sparkVel$[ebp+8]
	fstp	DWORD PTR _sparkVel$[ebp+8]

; 1735 : 		CreateSpark(sparkType, &collInfo->WorldPos, &sparkVel, COL_DustInfo[collInfo->Material->DustType].SparkVar * scale * impTanLen, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 12					; 0000000cH
	fld	DWORD PTR _scale$[ebp]
	fmul	DWORD PTR ?COL_DustInfo@@3PAUDustStruct@@A[edx+8]
	fmul	DWORD PTR _impTanLen$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _sparkVel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collInfo$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _sparkType$82372[ebp]
	push	edx
	call	?CreateSpark@@YA_NW4SparkTypeEnum@@PAUVectorStruct@@1M_K@Z ; CreateSpark
	add	esp, 24					; 00000018H
$L82371:

; 1736 : 	}
; 1737 : #endif
; 1738 : 
; 1739 : 	// Sum the impulses
; 1740 : 	VecPlusVec(&impNorm, &impTan, impulse);

	fld	DWORD PTR _impNorm$[ebp]
	fadd	DWORD PTR _impTan$[ebp]
	mov	eax, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR _impNorm$[ebp+4]
	fadd	DWORD PTR _impTan$[ebp+4]
	mov	eax, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR _impNorm$[ebp+8]
	fadd	DWORD PTR _impTan$[ebp+8]
	mov	eax, DWORD PTR _impulse$[ebp]
	fstp	DWORD PTR [eax+8]

; 1741 : 
; 1742 : 	// Zero the small components
; 1743 : 	if (abs(impulse->v[X]) < SMALL_IMPULSE_COMPONENT) impulse->v[X] = ZERO;

	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82995
	mov	ecx, DWORD PTR _impulse$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv1106[ebp], edx
	jmp	SHORT $L82996
$L82995:
	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax]
	fchs
	fstp	DWORD PTR tv1106[ebp]
$L82996:
	fld	DWORD PTR tv1106[ebp]
	fcomp	DWORD PTR __real@3ba3d70a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82376
	mov	eax, DWORD PTR _impulse$[ebp]
	mov	DWORD PTR [eax], 0
$L82376:

; 1744 : 	if (abs(impulse->v[Y]) < SMALL_IMPULSE_COMPONENT) impulse->v[Y] = ZERO;

	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82997
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR tv1116[ebp]
	jmp	SHORT $L82998
$L82997:
	mov	edx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [edx+4]
	fchs
	fstp	DWORD PTR tv1116[ebp]
$L82998:
	fld	DWORD PTR tv1116[ebp]
	fcomp	DWORD PTR __real@3ba3d70a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82378
	mov	eax, DWORD PTR _impulse$[ebp]
	mov	DWORD PTR [eax+4], 0
$L82378:

; 1745 : 	if (abs(impulse->v[Z]) < SMALL_IMPULSE_COMPONENT) impulse->v[Z] = ZERO;

	mov	eax, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82999
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv1127[ebp]
	jmp	SHORT $L83000
$L82999:
	mov	edx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [edx+8]
	fchs
	fstp	DWORD PTR tv1127[ebp]
$L83000:
	fld	DWORD PTR tv1127[ebp]
	fcomp	DWORD PTR __real@3ba3d70a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82275
	mov	eax, DWORD PTR _impulse$[ebp]
	mov	DWORD PTR [eax+8], 0
$L82275:

; 1746 : 
; 1747 : 
; 1748 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CarWheelImpulse2@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@PAUVectorStruct@@@Z ENDP ; CarWheelImpulse2
_TEXT	ENDS
PUBLIC	?SetCarAngResistance@@YAXPAUCarStruct@@@Z	; SetCarAngResistance
; Function compile flags: /Odt /ZI
;	COMDAT ?SetCarAngResistance@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_nCont$ = -8						; size = 4
_iWhl$ = -4						; size = 4
_car$ = 8						; size = 4
?SetCarAngResistance@@YAXPAUCarStruct@@@Z PROC NEAR	; SetCarAngResistance, COMDAT

; 2073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2074 : 	int iWhl;
; 2075 : 
; 2076 : 	int nCont = 0;

	mov	DWORD PTR _nCont$[ebp], 0

; 2077 : 
; 2078 : 	// Count wheels on the floor
; 2079 : 	for (iWhl = 0; iWhl < CAR_NWHEELS; iWhl++) {

	mov	DWORD PTR _iWhl$[ebp], 0
	jmp	SHORT $L82386
$L82387:
	mov	eax, DWORD PTR _iWhl$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWhl$[ebp], eax
$L82386:
	cmp	DWORD PTR _iWhl$[ebp], 4
	jge	SHORT $L82388

; 2080 : 		if (IsWheelInContact(&car->Wheel[iWhl])) {

	mov	eax, DWORD PTR _iWhl$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 8
	je	SHORT $L82389

; 2081 : 			nCont++;

	mov	eax, DWORD PTR _nCont$[ebp]
	add	eax, 1
	mov	DWORD PTR _nCont$[ebp], eax
$L82389:

; 2082 : 		}
; 2083 : 	}

	jmp	SHORT $L82387
$L82388:

; 2084 : 
; 2085 : 	// slow car spinning if no wheels on the floor
; 2086 : 	if (nCont == 0) {

	cmp	DWORD PTR _nCont$[ebp], 0
	jne	SHORT $L82390

; 2087 : 		car->Body->AngResistance = MulScalar(car->Body->AngResMod, car->Body->DefaultAngRes);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [ecx+372]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fmul	DWORD PTR [eax+368]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fstp	DWORD PTR [edx+376]

; 2088 : 	} else {

	jmp	SHORT $L82383
$L82390:

; 2089 : 		car->Body->AngResistance = car->Body->DefaultAngRes;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR [ecx+368]
	mov	DWORD PTR [eax+376], ecx
$L82383:

; 2090 : 	}
; 2091 : 
; 2092 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCarAngResistance@@YAXPAUCarStruct@@@Z ENDP		; SetCarAngResistance
_TEXT	ENDS
PUBLIC	?DetectCarWorldColls@@YAXPAUCarStruct@@@Z	; DetectCarWorldColls
EXTRN	?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z:NEAR ; DetectBodyPolyColls
EXTRN	?DEBUG_CollGrid@@3JA:DWORD			; DEBUG_CollGrid
EXTRN	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z:NEAR ; PosToCollGrid
EXTRN	?COL_CollGrid@@3PAUCOLLGRID@@A:DWORD		; COL_CollGrid
EXTRN	?COL_NCollsTested@@3HA:DWORD			; COL_NCollsTested
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectCarWorldColls@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
tv189 = -92						; size = 4
_collPoly$ = -24					; size = 4
_collPolyPtr$ = -20					; size = 4
_collGrid$ = -16					; size = 4
_nCollPolys$ = -12					; size = 4
_iWheel$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_car$ = 8						; size = 4
?DetectCarWorldColls@@YAXPAUCarStruct@@@Z PROC NEAR	; DetectCarWorldColls, COMDAT

; 2148 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 2149 : 	long	iPoly, iWheel;
; 2150 : 	long	nCollPolys;
; 2151 : 	COLLGRID *collGrid;
; 2152 : 
; 2153 : #ifndef _PSX
; 2154 : 	NEWCOLLPOLY **collPolyPtr;
; 2155 : #endif
; 2156 : 	NEWCOLLPOLY *collPoly;
; 2157 : 
; 2158 : 	// Calculate the grid position and which polys to check against
; 2159 : 	collGrid = PosToCollGrid(&car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ; PosToCollGrid
	add	esp, 4
	mov	DWORD PTR _collGrid$[ebp], eax

; 2160 : 	if (collGrid == NULL) return;

	cmp	DWORD PTR _collGrid$[ebp], 0
	jne	SHORT $L82401
	jmp	$L82394
$L82401:

; 2161 : 
; 2162 : #ifndef _PSX
; 2163 : 	collPolyPtr = collGrid->CollPolyPtr;

	mov	eax, DWORD PTR _collGrid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _collPolyPtr$[ebp], ecx

; 2164 : #endif
; 2165 : 	nCollPolys = collGrid->NCollPolys;

	mov	eax, DWORD PTR _collGrid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nCollPolys$[ebp], ecx

; 2166 : 
; 2167 : 	// Reset all collision related flags for the car
; 2168 : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L82402
$L82403:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L82402:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L82404

; 2169 : 		// Make sure skidmarks are stopped if the wheel is in the air
; 2170 : 		if (!IsWheelInContact(&car->Wheel[iWheel])) {

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 8
	jne	SHORT $L82405

; 2171 : 			car->Wheel[iWheel].Skid.Started = FALSE;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+eax+1856], 0
$L82405:

; 2172 : 		}
; 2173 : 
; 2174 : 		// Clear the contact / sliding / oil flags
; 2175 : 		SetWheelNotInContact(&car->Wheel[iWheel]);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+eax+1560], edx

; 2176 : 		SetWheelNotSliding(&car->Wheel[iWheel]);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+eax+1560], edx

; 2177 : 		if (IsWheelinOil(&car->Wheel[iWheel])) {

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 128				; 00000080H
	je	SHORT $L82406

; 2178 : 			SetWheelNotInOil(&car->Wheel[iWheel]);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, -129				; ffffff7fH
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+eax+1560], edx

; 2179 : 			car->Wheel[iWheel].OilTime = ZERO;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+eax+1916], 0

; 2180 : 		} else {

	jmp	SHORT $L82407
$L82406:

; 2181 : 			car->Wheel[iWheel].OilTime += TimeStep;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [ecx+eax+1916]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+edx+1916]
$L82407:

; 2182 : 		}
; 2183 : 	}

	jmp	$L82403
$L82404:

; 2184 : 
; 2185 : 	// Detect collisions
; 2186 : 	for (iPoly = 0; iPoly < nCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82408
$L82409:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82408:
	mov	eax, DWORD PTR _iPoly$[ebp]
	cmp	eax, DWORD PTR _nCollPolys$[ebp]
	jge	$L82410

; 2187 : 
; 2188 : #ifndef _PSX
; 2189 : 		collPoly = collPolyPtr[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	mov	ecx, DWORD PTR _collPolyPtr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _collPoly$[ebp], edx

; 2190 : #else 
; 2191 : 		collPoly = &COL_WorldCollPoly[collGrid->CollPolyIndices[iPoly]];
; 2192 : #endif
; 2193 : 
; 2194 : 		if (PolyCameraOnly(collPoly)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $L82411
	jmp	SHORT $L82409
$L82411:

; 2195 : 
; 2196 : 		// Full car-poly bounding box test
; 2197 : 		if (!BBTestYXZ(&collPoly->BBox, &car->BBox)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+96]
	fcomp	DWORD PTR [ecx+3160]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83021
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+100]
	fcomp	DWORD PTR [eax+3156]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83021
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+88]
	fcomp	DWORD PTR [edx+3152]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83021
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+92]
	fcomp	DWORD PTR [ecx+3148]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83021
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+104]
	fcomp	DWORD PTR [eax+3168]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83021
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+108]
	fcomp	DWORD PTR [edx+3164]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83021
	mov	DWORD PTR tv189[ebp], 1
	jmp	SHORT $L83022
$L83021:
	mov	DWORD PTR tv189[ebp], 0
$L83022:
	cmp	DWORD PTR tv189[ebp], 0
	jne	SHORT $L82412
	jmp	$L82409
$L82412:

; 2198 : 
; 2199 : 		COL_NCollsTested++;

	mov	eax, DWORD PTR ?COL_NCollsTested@@3HA	; COL_NCollsTested
	add	eax, 1
	mov	DWORD PTR ?COL_NCollsTested@@3HA, eax	; COL_NCollsTested

; 2200 : 
; 2201 : 		// WHEEL - WORLD
; 2202 : 		for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L82413
$L82414:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L82413:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	SHORT $L82415

; 2203 : 			if (IsWheelPresent(&car->Wheel[iWheel])) {

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 1
	je	SHORT $L82416

; 2204 : 				// Detect collision and add them to the list
; 2205 : 				DetectCarWheelColls2(car, iWheel, collPoly);

	mov	eax, DWORD PTR _collPoly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?DetectCarWheelColls2@@YAXPAUCarStruct@@HPAUCollPolyStruct@@@Z ; DetectCarWheelColls2
	add	esp, 12					; 0000000cH
$L82416:

; 2206 : 			}
; 2207 : 		}

	jmp	SHORT $L82414
$L82415:

; 2208 : 
; 2209 : 		// BODY - WORLD
; 2210 : 		DetectBodyPolyColls(car->Body, collPoly);

	mov	eax, DWORD PTR _collPoly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	?DetectBodyPolyColls@@YAXPAUNewBodyStruct@@PAUCollPolyStruct@@@Z ; DetectBodyPolyColls
	add	esp, 8

; 2211 : 
; 2212 : 	}

	jmp	$L82409
$L82410:

; 2213 : 
; 2214 : #if USE_DEBUG_ROUTINES
; 2215 : 	DEBUG_CollGrid = collGrid - COL_CollGrid;

	mov	eax, DWORD PTR _collGrid$[ebp]
	sub	eax, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR ?DEBUG_CollGrid@@3JA, eax	; DEBUG_CollGrid
$L82394:

; 2216 : #endif
; 2217 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectCarWorldColls@@YAXPAUCarStruct@@@Z ENDP		; DetectCarWorldColls
_TEXT	ENDS
PUBLIC	?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectWheelBodyColls
PUBLIC	?DetectWheelSphereColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ; DetectWheelSphereColls
PUBLIC	?DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ; DetectWheelConvexColls
PUBLIC	?DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ; DetectWheelPolyColls
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT
_nColls$ = -12						; size = 4
_wheel$ = -8						; size = 4
_iWheel$ = -4						; size = 4
_car$ = 8						; size = 4
_body$ = 12						; size = 4
?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z PROC NEAR ; DetectWheelBodyColls, COMDAT

; 2227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2228 : 	int		iWheel;
; 2229 : 	WHEEL	*wheel;
; 2230 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 2231 : 
; 2232 : 	// Check for each wheel
; 2233 : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L82424
$L82425:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L82424:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L82426

; 2234 : 		wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 2235 : 		if (!IsWheelPresent(wheel)) continue;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	jne	SHORT $L82427
	jmp	SHORT $L82425
$L82427:

; 2236 : 
; 2237 : 		if (IsBodyConvex(body)) {

	mov	eax, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [eax+472], 0
	jne	SHORT $L82428

; 2238 : 			nColls += DetectWheelConvexColls(car, iWheel, body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ; DetectWheelConvexColls
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2239 : 		} 
; 2240 : 		else if (IsBodySphere(body)) {

	jmp	SHORT $L82429
$L82428:
	mov	eax, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [eax+472], 1
	jne	SHORT $L82430

; 2241 : 			nColls += DetectWheelSphereColls(car, iWheel, body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?DetectWheelSphereColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ; DetectWheelSphereColls
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2242 : 		}
; 2243 : 		else if (IsBodyPoly(body)) {

	jmp	SHORT $L82429
$L82430:
	mov	eax, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [eax+472], 2
	jne	SHORT $L82429

; 2244 : 			nColls += DetectWheelPolyColls(car, iWheel, body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ; DetectWheelPolyColls
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax
$L82429:

; 2245 : 		}
; 2246 : 	}

	jmp	$L82425
$L82426:

; 2247 : 
; 2248 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]

; 2249 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ENDP ; DetectWheelBodyColls
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA ; `DetectWheelPolyColls'::`2'::__LINE__Var
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
;	COMDAT ?__LINE__Var@?1??DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA DD 08ccH ; `DetectWheelPolyColls'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
tv186 = -104						; size = 4
tv143 = -104						; size = 4
_wheelColl$ = -36					; size = 4
_wheel$ = -32						; size = 4
_nColls$ = -28						; size = 4
_collPoly$ = -24					; size = 4
_time$ = -20						; size = 4
_tmpVec$ = -16						; size = 12
_iPoly$ = -4						; size = 4
_car$ = 8						; size = 4
_iWheel$ = 12						; size = 4
_body$ = 16						; size = 4
?DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z PROC NEAR ; DetectWheelPolyColls, COMDAT

; 2252 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 2253 : 	int iPoly;
; 2254 : 	VEC	tmpVec;
; 2255 : 	REAL	time;
; 2256 : 	NEWCOLLPOLY *collPoly;
; 2257 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 2258 : 	WHEEL	*wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 2259 : 	COLLINFO_WHEEL	*wheelColl;
; 2260 : 
; 2261 : 	Assert(IsBodyPoly(body));

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
	add	eax, 9
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [ecx+472], 2
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 2262 : 
; 2263 : 	// Bounding box test
; 2264 : 	if (!BBTestYXZ(&wheel->BBox, &body->CollSkin.BBox)) return 0;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+60]
	fcomp	DWORD PTR [ecx+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83027
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+64]
	fcomp	DWORD PTR [eax+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83027
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+52]
	fcomp	DWORD PTR [edx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83027
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fcomp	DWORD PTR [ecx+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83027
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+68]
	fcomp	DWORD PTR [eax+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83027
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+72]
	fcomp	DWORD PTR [edx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83027
	mov	DWORD PTR tv143[ebp], 1
	jmp	SHORT $L83028
$L83027:
	mov	DWORD PTR tv143[ebp], 0
$L83028:
	cmp	DWORD PTR tv143[ebp], 0
	jne	SHORT $L82446
	xor	eax, eax
	jmp	$L82437
$L82446:

; 2265 : 
; 2266 : 	for (iPoly = 0; iPoly < body->CollSkin.NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82447
$L82448:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82447:
	mov	eax, DWORD PTR _body$[ebp]
	movsx	ecx, WORD PTR [eax+416]
	cmp	DWORD PTR _iPoly$[ebp], ecx
	jge	$L82449

; 2267 : 		collPoly = &body->CollSkin.CollPoly[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR [ecx+412]
	mov	DWORD PTR _collPoly$[ebp], eax

; 2268 : 
; 2269 : 		if ((wheelColl = NextWheelCollInfo()) == NULL) return nColls;

	call	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ; NextWheelCollInfo
	mov	DWORD PTR _wheelColl$[ebp], eax
	cmp	DWORD PTR _wheelColl$[ebp], 0
	jne	SHORT $L82450
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L82437
$L82450:

; 2270 : 	 
; 2271 : 		// Quick swepth-volume axis-aligned bounding-box test
; 2272 : 		if (!BBTestYXZ(&wheel->BBox, &collPoly->BBox)) continue;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax+60]
	fcomp	DWORD PTR [ecx+100]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83029
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+64]
	fcomp	DWORD PTR [eax+96]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83029
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+52]
	fcomp	DWORD PTR [edx+92]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83029
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax+56]
	fcomp	DWORD PTR [ecx+88]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83029
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+68]
	fcomp	DWORD PTR [eax+108]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83029
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+72]
	fcomp	DWORD PTR [edx+104]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83029
	mov	DWORD PTR tv186[ebp], 1
	jmp	SHORT $L83030
$L83029:
	mov	DWORD PTR tv186[ebp], 0
$L83030:
	cmp	DWORD PTR tv186[ebp], 0
	jne	SHORT $L82451
	jmp	$L82448
$L82451:

; 2273 : 
; 2274 : 		// Do a sphere-to-poly collision test
; 2275 : 		if (SphereCollPoly(&wheel->OldCentrePos, &wheel->CentrePos,
; 2276 : 			wheel->Radius, 
; 2277 : 			collPoly, 
; 2278 : 			&wheelColl->Plane,
; 2279 : 			&wheelColl->Pos,
; 2280 : 			&wheelColl->WorldPos,
; 2281 : 			&wheelColl->Depth,
; 2282 : 			&time))

	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _wheelColl$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _collPoly$[ebp]
	push	edx
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _wheel$[ebp]
	add	edx, 184				; 000000b8H
	push	edx
	mov	eax, DWORD PTR _wheel$[ebp]
	add	eax, 196				; 000000c4H
	push	eax
	call	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z ; SphereCollPoly
	add	esp, 36					; 00000024H
	movzx	ecx, al
	test	ecx, ecx
	je	$L82452

; 2283 : 		{
; 2284 : 
; 2285 : 			// Calculate the collision point on the plane (for skidmarks and smoke generator)
; 2286 : 			VecPlusEqScalarVec(&wheelColl->WorldPos, SKID_RAISE, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+44]

; 2287 : 
; 2288 : 			// Calculate the car-relative collision point for response
; 2289 : 			VecPlusEqVec(&wheelColl->Pos, &wheel->CentrePos);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+20]

; 2290 : 			VecMinusEqVec(&wheelColl->Pos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+20]

; 2291 : 
; 2292 : 			// Calculate world velocity of the wheel collision point (not including wheel spin)
; 2293 : 			VecCrossVec(&car->Body->AngVel, &wheelColl->Pos, &wheelColl->Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+16]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+20]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2294 : 			VecPlusEqVec(&wheelColl->Vel, &car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+48]
	fadd	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+52]
	fadd	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+56]
	fadd	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2295 : 			VecMinusEqVec(&wheelColl->Vel, &body->Centre.Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+56]

; 2296 : 
; 2297 : 			// Make sure that the wheel is not already travelling away from the surface
; 2298 : 			VecPlusScalarVec(&wheelColl->Vel, wheel->Vel, &car->Body->Centre.WMatrix.mv[U], &tmpVec);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+112]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [eax+48]
	fstp	DWORD PTR _tmpVec$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+116]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [eax+52]
	fstp	DWORD PTR _tmpVec$[ebp+4]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+120]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [eax+56]
	fstp	DWORD PTR _tmpVec$[ebp+8]

; 2299 : 			if (VecDotVec(&tmpVec, PlaneNormal(&wheelColl->Plane)) > ZERO) continue;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fmul	DWORD PTR [ecx+64]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fmul	DWORD PTR [edx+68]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82462
	jmp	$L82448
$L82462:

; 2300 : 
; 2301 : 			// Add bumps from surface corrugation
; 2302 : 			wheelColl->Material = &COL_MaterialInfo[collPoly->Material];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:?COL_MaterialInfo@@3PAUMaterialStruct@@A ; COL_MaterialInfo
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 2303 : 			//AdjustWheelColl(wheelColl, wheelColl->Material);
; 2304 : 
; 2305 : 			// Set other necessary stuff
; 2306 : 			wheelColl->Car = car;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax], ecx

; 2307 : 			wheelColl->IWheel = iWheel;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _iWheel$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2308 : 			wheelColl->Grip = MulScalar(wheel->Grip, wheelColl->Material->Gripiness);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	fmul	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+84]

; 2309 : 			wheelColl->StaticFriction = MulScalar(wheel->StaticFriction, wheelColl->Material->Roughness);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+88]

; 2310 : 			wheelColl->KineticFriction = MulScalar(wheel->KineticFriction, wheelColl->Material->Roughness);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+92]

; 2311 : 			wheelColl->Restitution = ZERO;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+96], 0

; 2312 : 			wheelColl->Body2 = &BDY_MassiveBody;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?BDY_MassiveBody@@3UNewBodyStruct@@A ; BDY_MassiveBody

; 2313 : 			SetVecZero(&wheelColl->Pos2);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+32], 0

; 2314 : 
; 2315 : 
; 2316 : 			// Set the wheel-in-contact flag
; 2317 : 			SetWheelInContact(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 8
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx

; 2318 : 			SetWheelNotSpinning(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx

; 2319 : 
; 2320 : 			AddWheelColl(car, wheelColl);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ; AddWheelColl
	add	esp, 8

; 2321 : 			nColls++;

	mov	eax, DWORD PTR _nColls$[ebp]
	add	eax, 1
	mov	DWORD PTR _nColls$[ebp], eax
$L82452:

; 2322 : 
; 2323 : 		}
; 2324 : 	}

	jmp	$L82448
$L82449:

; 2325 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L82437:

; 2326 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectWheelPolyColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ENDP ; DetectWheelPolyColls
_TEXT	ENDS
EXTRN	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z:NEAR ; AddBodyColl
EXTRN	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ:NEAR ; NextBodyCollInfo
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectWheelSphereColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
tv137 = -100						; size = 4
_sphere$ = -32						; size = 4
_wheel$ = -28						; size = 4
_bodyColl$ = -24					; size = 4
_wheelColl$ = -20					; size = 4
_dRLen$ = -16						; size = 4
_dR$ = -12						; size = 12
_car$ = 8						; size = 4
_iWheel$ = 12						; size = 4
_body$ = 16						; size = 4
?DetectWheelSphereColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z PROC NEAR ; DetectWheelSphereColls, COMDAT

; 2330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 2331 : 	VEC	dR;
; 2332 : 	REAL	dRLen;
; 2333 : 	COLLINFO_WHEEL	*wheelColl;
; 2334 : 	COLLINFO_BODY	*bodyColl;
; 2335 : 	WHEEL	*wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 2336 : 	SPHERE  *sphere = &body->CollSkin.WorldSphere[0];

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR _sphere$[ebp], ecx

; 2337 : 
; 2338 : 	// Bounding box test
; 2339 : 	if (!BBTestYXZ(&wheel->BBox, &body->CollSkin.BBox)) return 0;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+60]
	fcomp	DWORD PTR [ecx+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83033
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+64]
	fcomp	DWORD PTR [eax+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83033
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+52]
	fcomp	DWORD PTR [edx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83033
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fcomp	DWORD PTR [ecx+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83033
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+68]
	fcomp	DWORD PTR [eax+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83033
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+72]
	fcomp	DWORD PTR [edx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83033
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $L83034
$L83033:
	mov	DWORD PTR tv137[ebp], 0
$L83034:
	cmp	DWORD PTR tv137[ebp], 0
	jne	SHORT $L82474
	xor	eax, eax
	jmp	$L82467
$L82474:

; 2340 : 
; 2341 : 	// Set up the collision info
; 2342 : 	if ((wheelColl = NextWheelCollInfo()) == NULL) return 0;

	call	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ; NextWheelCollInfo
	mov	DWORD PTR _wheelColl$[ebp], eax
	cmp	DWORD PTR _wheelColl$[ebp], 0
	jne	SHORT $L82475
	xor	eax, eax
	jmp	$L82467
$L82475:

; 2343 : 	if ((bodyColl = NextBodyCollInfo()) == NULL) return 0;

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _bodyColl$[ebp], eax
	cmp	DWORD PTR _bodyColl$[ebp], 0
	jne	SHORT $L82476
	xor	eax, eax
	jmp	$L82467
$L82476:

; 2344 : 
; 2345 : 	//Get relative position
; 2346 : 	VecMinusVec(&wheel->CentrePos, &sphere->Pos, &dR);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _sphere$[ebp]
	fld	DWORD PTR [eax+184]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _sphere$[ebp]
	fld	DWORD PTR [eax+188]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _sphere$[ebp]
	fld	DWORD PTR [eax+192]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 2347 : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 2348 : 
; 2349 : 	// Check for collision
; 2350 : 	if (dRLen > wheel->Radius + sphere->Radius) return 0;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _sphere$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+12]
	fcomp	DWORD PTR _dRLen$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82478
	xor	eax, eax
	jmp	$L82467
$L82478:

; 2351 : 
; 2352 : 	// Collision Occurred
; 2353 : 
; 2354 : 	bodyColl->Body1 = body;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2355 : 	bodyColl->Body2 = car->Body;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	DWORD PTR [eax+20], edx

; 2356 : 	wheelColl->Car = car;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax], ecx

; 2357 : 	wheelColl->IWheel = iWheel;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _iWheel$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2358 : 	wheelColl->Body2 = body;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 2359 : 	SetVecZero(&wheelColl->WorldPos);	// DODGY....

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+44], 0

; 2360 : 	SetVecZero(&bodyColl->WorldPos);	// DODGY....

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+44], 0

; 2361 : 
; 2362 : 	bodyColl->Depth = HALF * (dRLen - wheel->Radius - sphere->Radius);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR _dRLen$[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _sphere$[ebp]
	fsub	DWORD PTR [ecx+12]
	fmul	DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+76]

; 2363 : 	wheelColl->Depth = bodyColl->Depth;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx

; 2364 : 
; 2365 : 	// Collision plane
; 2366 : 	if (dRLen > SMALL_REAL) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82479

; 2367 : 		CopyVec(&dR, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	mov	DWORD PTR [eax+60], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp+4]
	mov	DWORD PTR [eax+64], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp+8]
	mov	DWORD PTR [eax+68], ecx

; 2368 : 		VecDivScalar(PlaneNormal(&wheelColl->Plane), dRLen);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+60]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+64]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+68]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+68]

; 2369 : 		wheelColl->Time = ONE - (wheelColl->Depth / dRLen);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fdiv	DWORD PTR _dRLen$[ebp]
	fsubr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+80]

; 2370 : 	} else {

	jmp	SHORT $L82486
$L82479:

; 2371 : 		SetVec(PlaneNormal(&wheelColl->Plane), ONE, ZERO, ZERO);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+60], 1065353216		; 3f800000H
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+64], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+68], 0

; 2372 : 		wheelColl->Time = ONE;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+80], 1065353216		; 3f800000H
$L82486:

; 2373 : 	}
; 2374 : 	FlipPlane(&wheelColl->Plane, &bodyColl->Plane);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+60]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+64]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+68]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+72]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+72]

; 2375 : 	bodyColl->Time = wheelColl->Time;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx

; 2376 : 
; 2377 : 	// Calculate the collision points for response
; 2378 : 	VecEqScalarVec(&wheelColl->Pos, wheel->Radius, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+20]

; 2379 : 	VecPlusEqVec(&wheelColl->Pos, &wheel->CentrePos);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+20]

; 2380 : 	VecMinusEqVec(&wheelColl->Pos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+20]

; 2381 : 	//VecEqScalarVec(&bodyColl->Pos1, sphere->Radius, PlaneNormal(&bodyColl->Plane));
; 2382 : 	VecPlusScalarVec(&wheel->CentrePos, HALF, &dR, &wheelColl->WorldPos);

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [eax+184]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+36]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+40]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _wheel$[ebp]
	fadd	DWORD PTR [eax+192]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+44]

; 2383 : 	CopyVec(&wheelColl->Pos, &bodyColl->Pos2);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+32], edx

; 2384 : 	CopyVec(&wheelColl->WorldPos, &bodyColl->WorldPos);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 2385 : 	VecPlusScalarVec(&sphere->Pos, -sphere->Radius, PlaneNormal(&wheelColl->Plane), &bodyColl->Pos1);

	mov	eax, DWORD PTR _sphere$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _sphere$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _sphere$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _sphere$[ebp]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _sphere$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _sphere$[ebp]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [eax+16]

; 2386 : 	VecMinusEqVec(&bodyColl->Pos1, &body->Centre.Pos);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+16]

; 2387 : 	VecMinusVec(&bodyColl->WorldPos, &body->Centre.Pos, &bodyColl->Pos1);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+40]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+44]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+16]

; 2388 : 	CopyVec(&bodyColl->Pos1, &wheelColl->Pos2);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+32], edx

; 2389 : 
; 2390 : 	// Calculate velocity
; 2391 : 	VecCrossVec(&car->Body->AngVel, &wheelColl->Pos, &wheelColl->Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+16]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+20]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2392 : 	VecPlusEqVec(&wheelColl->Vel, &car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+48]
	fadd	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+52]
	fadd	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+56]
	fadd	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2393 : 	VecCrossVec(&body->AngVel, &bodyColl->Pos1, &bodyColl->Vel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+56]

; 2394 : 	VecPlusEqVec(&bodyColl->Vel, &body->Centre.Vel);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+52]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+56]

; 2395 : 	VecMinusEqVec(&bodyColl->Vel, &wheelColl->Vel);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+56]

; 2396 : 	CopyVec(&bodyColl->Vel, &wheelColl->Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 2397 : 	NegateVec(&wheelColl->Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+48]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+52]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+56]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+56]

; 2398 : 
; 2399 : 	wheelColl->Grip = wheel->Grip * body->Centre.Grip;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+180]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+84]

; 2400 : 	wheelColl->StaticFriction = wheel->StaticFriction * body->Centre.StaticFriction;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+88]

; 2401 : 	wheelColl->KineticFriction = wheel->KineticFriction * body->Centre.KineticFriction;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+36]
	fmul	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+92]

; 2402 : 	wheelColl->Restitution = car->Spring[iWheel].Restitution;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+eax+3008]
	mov	DWORD PTR [ecx+96], eax

; 2403 : 	wheelColl->Material = NULL;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+100], 0

; 2404 : 	bodyColl->Grip = wheelColl->Grip;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx

; 2405 : 	bodyColl->StaticFriction = wheelColl->StaticFriction;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx

; 2406 : 	bodyColl->KineticFriction = wheelColl->KineticFriction;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx

; 2407 : 	bodyColl->Restitution = wheelColl->Restitution;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx

; 2408 : 	bodyColl->Material = NULL;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+100], 0

; 2409 : 
; 2410 : 	AddWheelColl(car, wheelColl);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ; AddWheelColl
	add	esp, 8

; 2411 : 	AddBodyColl(body, bodyColl);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 2412 : 
; 2413 : 	return 1;

	mov	eax, 1
$L82467:

; 2414 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectWheelSphereColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ENDP ; DetectWheelSphereColls
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA ; `DetectWheelConvexColls'::`2'::__LINE__Var
EXTRN	?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z:NEAR ; SphereConvex
;	COMDAT ?__LINE__Var@?1??DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA DD 0971H ; `DetectWheelConvexColls'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z
_TEXT	SEGMENT
tv215 = -88						; size = 4
tv154 = -88						; size = 4
tv84 = -85						; size = 1
_nColls$ = -20						; size = 4
_wheel$ = -16						; size = 4
_bodyColl$ = -12					; size = 4
_wheelColl$ = -8					; size = 4
_iSkin$ = -4						; size = 4
_car$ = 8						; size = 4
_iWheel$ = 12						; size = 4
_body$ = 16						; size = 4
?DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z PROC NEAR ; DetectWheelConvexColls, COMDAT

; 2417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 2418 : 	int iSkin;
; 2419 : 	COLLINFO_WHEEL	*wheelColl;
; 2420 : 	COLLINFO_BODY	*bodyColl;
; 2421 : 	WHEEL *wheel = &car->Wheel[iWheel];

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel$[ebp], edx

; 2422 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 2423 : 
; 2424 : 	Assert(body != NULL);

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
	add	eax, 7
	push	eax
	cmp	DWORD PTR _body$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 2425 : 	Assert(car != NULL);

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
	add	eax, 8
	push	eax
	cmp	DWORD PTR _car$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 2426 : 	Assert((iWheel >= 0) && (iWheel < CAR_NWHEELS));

	cmp	DWORD PTR _iWheel$[ebp], 0
	jl	SHORT $L83037
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	SHORT $L83037
	mov	BYTE PTR tv84[ebp], 1
	jmp	SHORT $L83038
$L83037:
	mov	BYTE PTR tv84[ebp], 0
$L83038:
	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z@4JA
	add	eax, 9
	push	eax
	mov	cl, BYTE PTR tv84[ebp]
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 2427 : 
; 2428 : 	// Bounding box test
; 2429 : 	if (!BBTestYXZ(&wheel->BBox, &body->CollSkin.BBox)) return 0;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+60]
	fcomp	DWORD PTR [ecx+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83039
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+64]
	fcomp	DWORD PTR [eax+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83039
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+52]
	fcomp	DWORD PTR [edx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83039
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fcomp	DWORD PTR [ecx+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83039
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+68]
	fcomp	DWORD PTR [eax+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83039
	mov	ecx, DWORD PTR _wheel$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+72]
	fcomp	DWORD PTR [edx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83039
	mov	DWORD PTR tv154[ebp], 1
	jmp	SHORT $L83040
$L83039:
	mov	DWORD PTR tv154[ebp], 0
$L83040:
	cmp	DWORD PTR tv154[ebp], 0
	jne	SHORT $L82507
	xor	eax, eax
	jmp	$L82500
$L82507:

; 2430 : 
; 2431 : 	// Check against each convex hull
; 2432 : 	for (iSkin = 0; iSkin < body->CollSkin.NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82508
$L82509:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82508:
	mov	eax, DWORD PTR _body$[ebp]
	movsx	ecx, WORD PTR [eax+392]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L82510

; 2433 : 
; 2434 : 		// Bounding box test
; 2435 : 		if (!BBTestYXZ(&wheel->BBox, &body->CollSkin.WorldConvex[iSkin].BBox)) continue;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+384]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+60]
	fcomp	DWORD PTR [edx+eax+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L83041
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+64]
	fcomp	DWORD PTR [ecx+edx+16]
	fnstsw	ax
	test	ah, 5
	jnp	$L83041
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR [edx+384]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+52]
	fcomp	DWORD PTR [eax+ecx+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83041
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _body$[ebp]
	mov	edx, DWORD PTR [ecx+384]
	mov	ecx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [ecx+56]
	fcomp	DWORD PTR [edx+eax+8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83041
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+68]
	fcomp	DWORD PTR [ecx+edx+28]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83041
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR [edx+384]
	mov	edx, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [edx+72]
	fcomp	DWORD PTR [eax+ecx+24]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83041
	mov	DWORD PTR tv215[ebp], 1
	jmp	SHORT $L83042
$L83041:
	mov	DWORD PTR tv215[ebp], 0
$L83042:
	cmp	DWORD PTR tv215[ebp], 0
	jne	SHORT $L82511
	jmp	$L82509
$L82511:

; 2436 : 
; 2437 : 		// Set up the collision info
; 2438 : 		if ((wheelColl = NextWheelCollInfo()) == NULL) return nColls;

	call	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ; NextWheelCollInfo
	mov	DWORD PTR _wheelColl$[ebp], eax
	cmp	DWORD PTR _wheelColl$[ebp], 0
	jne	SHORT $L82512
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L82500
$L82512:

; 2439 : 		if ((bodyColl = NextBodyCollInfo()) == NULL) return nColls;

	call	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ; NextBodyCollInfo
	mov	DWORD PTR _bodyColl$[ebp], eax
	cmp	DWORD PTR _bodyColl$[ebp], 0
	jne	SHORT $L82513
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L82500
$L82513:

; 2440 : 
; 2441 : 		// Check for collision
; 2442 : 		if (!SphereConvex(&wheel->CentrePos, wheel->Radius, &body->CollSkin.WorldConvex[iSkin], &wheelColl->Pos, &wheelColl->Plane, &wheelColl->Depth)) {

	mov	eax, DWORD PTR _wheelColl$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _wheelColl$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR [ecx+384]
	push	eax
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _wheel$[ebp]
	add	ecx, 184				; 000000b8H
	push	ecx
	call	?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z ; SphereConvex
	add	esp, 24					; 00000018H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82514

; 2443 : 			continue;

	jmp	$L82509
$L82514:

; 2444 : 		}
; 2445 : 
; 2446 : 		// Collision Occurred
; 2447 : 		
; 2448 : 		bodyColl->Body1 = body;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2449 : 		bodyColl->Body2 = car->Body;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	DWORD PTR [eax+20], edx

; 2450 : 		wheelColl->Car = car;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax], ecx

; 2451 : 		wheelColl->IWheel = iWheel;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _iWheel$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2452 : 		wheelColl->Body2 = body;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 2453 : 		SetVecZero(&wheelColl->WorldPos);	// DODGY....

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+44], 0

; 2454 : 		SetVecZero(&bodyColl->WorldPos);	// DODGY....

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+44], 0

; 2455 : 
; 2456 : 		// Calculate the relative collision points for response
; 2457 : 		//VecPlusScalarVec(&wheel->CentrePos, -(wheel->radius + wheelColl->Depth), PlaneNormal(&wheelColl->Plane), &wheelColl->Pos);
; 2458 : 		VecMinusVec(&wheelColl->Pos, &body->Centre.Pos, &bodyColl->Pos1);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+16]

; 2459 : 		VecMinusEqVec(&wheelColl->Pos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+20]

; 2460 : 		CopyVec(&wheelColl->Pos, &bodyColl->Pos2);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+32], edx

; 2461 : 		CopyVec(&bodyColl->Pos1, &wheelColl->Pos2);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+32], edx

; 2462 : 
; 2463 : 		// Calculate velocity
; 2464 : 		VecCrossVec(&car->Body->AngVel, &wheelColl->Pos, &wheelColl->Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+16]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+20]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2465 : 		VecPlusEqVec(&wheelColl->Vel, &car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+48]
	fadd	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+52]
	fadd	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+56]
	fadd	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2466 : 		VecCrossVec(&body->AngVel, &bodyColl->Pos1, &bodyColl->Vel);

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [eax+336]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [edx+340]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [eax+340]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [edx+332]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [eax+332]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _body$[ebp]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	fld	DWORD PTR [edx+336]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+56]

; 2467 : 		VecPlusEqVec(&bodyColl->Vel, &body->Centre.Vel);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+52]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+56]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+56]

; 2468 : 		VecMinusEqVec(&bodyColl->Vel, &wheelColl->Vel);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [edx+56]

; 2469 : 		CopyVec(&bodyColl->Vel, &wheelColl->Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 2470 : 		NegateVec(&wheelColl->Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+48]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+52]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+56]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+56]

; 2471 : 
; 2472 : 		FlipPlane(&wheelColl->Plane, &bodyColl->Plane);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+60]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+64]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+68]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+72]
	fchs
	mov	ecx, DWORD PTR _bodyColl$[ebp]
	fstp	DWORD PTR [ecx+72]

; 2473 : 		bodyColl->Depth = wheelColl->Depth;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx

; 2474 : 		bodyColl->Time = ZERO;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+80], 0

; 2475 : 
; 2476 : 		// Make sure that the wheel is not already travelling away from the surface
; 2477 : 		//VecPlusScalarVec(&wheelColl->Vel, wheel->Vel, &car->Body->Centre.WMatrix.mv[U], &tmpVec);
; 2478 : 		//if (VecDotVec(&tmpVec, PlaneNormal(&wheelColl->Plane)) > ZERO) return;
; 2479 : 
; 2480 : 		wheelColl->Grip = wheel->Grip * body->Centre.Grip;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+180]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+84]

; 2481 : 		wheelColl->StaticFriction = wheel->StaticFriction * body->Centre.StaticFriction;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+88]

; 2482 : 		wheelColl->KineticFriction = wheel->KineticFriction * body->Centre.KineticFriction;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+36]
	fmul	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+92]

; 2483 : 		wheelColl->Restitution = car->Spring[iWheel].Restitution;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+eax+3008]
	mov	DWORD PTR [ecx+96], eax

; 2484 : 		wheelColl->Material = NULL;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+100], 0

; 2485 : 		bodyColl->Grip = wheelColl->Grip;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx

; 2486 : 		bodyColl->StaticFriction = wheelColl->StaticFriction;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx

; 2487 : 		bodyColl->KineticFriction = wheelColl->KineticFriction;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx

; 2488 : 		bodyColl->Restitution = wheelColl->Restitution;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx

; 2489 : 		bodyColl->Material = NULL;

	mov	eax, DWORD PTR _bodyColl$[ebp]
	mov	DWORD PTR [eax+100], 0

; 2490 : 
; 2491 : 		AddBodyColl(body, bodyColl);

	mov	eax, DWORD PTR _bodyColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	push	ecx
	call	?AddBodyColl@@YAPAUBodyCollInfoStruct@@PAUNewBodyStruct@@PAU1@@Z ; AddBodyColl
	add	esp, 8

; 2492 : 		AddWheelColl(car, wheelColl);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ; AddWheelColl
	add	esp, 8

; 2493 : 		nColls++;

	mov	eax, DWORD PTR _nColls$[ebp]
	add	eax, 1
	mov	DWORD PTR _nColls$[ebp], eax

; 2494 : 
; 2495 : 	}

	jmp	$L82509
$L82510:

; 2496 : 
; 2497 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L82500:

; 2498 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectWheelConvexColls@@YAHPAUCarStruct@@HPAUNewBodyStruct@@@Z ENDP ; DetectWheelConvexColls
_TEXT	ENDS
PUBLIC	?DetectWheelWheelColls@@YAHPAUCarStruct@@0@Z	; DetectWheelWheelColls
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectWheelWheelColls@@YAHPAUCarStruct@@0@Z
_TEXT	SEGMENT
tv140 = -112						; size = 4
_nColls$ = -44						; size = 4
_wheel2$ = -40						; size = 4
_wheel1$ = -36						; size = 4
_wheelColl2$ = -32					; size = 4
_wheelColl$ = -28					; size = 4
_dRLen$ = -24						; size = 4
_dR$ = -20						; size = 12
_iWheel2$ = -8						; size = 4
_iWheel1$ = -4						; size = 4
_car1$ = 8						; size = 4
_car2$ = 12						; size = 4
?DetectWheelWheelColls@@YAHPAUCarStruct@@0@Z PROC NEAR	; DetectWheelWheelColls, COMDAT

; 2502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 2503 : 	int iWheel1, iWheel2;
; 2504 : 	VEC	dR;
; 2505 : 	REAL	dRLen;
; 2506 : 	COLLINFO_WHEEL	*wheelColl;
; 2507 : 	COLLINFO_WHEEL	*wheelColl2;
; 2508 : 	WHEEL	*wheel1;
; 2509 : 	WHEEL	*wheel2;
; 2510 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 2511 : 
; 2512 : 
; 2513 : 	for (iWheel1 = 0; iWheel1 < CAR_NWHEELS; iWheel1++) {

	mov	DWORD PTR _iWheel1$[ebp], 0
	jmp	SHORT $L82528
$L82529:
	mov	eax, DWORD PTR _iWheel1$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel1$[ebp], eax
$L82528:
	cmp	DWORD PTR _iWheel1$[ebp], 4
	jge	$L82530

; 2514 : 		wheel1 = &car1->Wheel[iWheel1];

	mov	eax, DWORD PTR _iWheel1$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car1$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel1$[ebp], edx

; 2515 : 		if (!IsWheelPresent(wheel1)) continue;

	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	jne	SHORT $L82531
	jmp	SHORT $L82529
$L82531:

; 2516 : 
; 2517 : 		for (iWheel2 = 0; iWheel2 < CAR_NWHEELS; iWheel2++) {

	mov	DWORD PTR _iWheel2$[ebp], 0
	jmp	SHORT $L82532
$L82533:
	mov	eax, DWORD PTR _iWheel2$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel2$[ebp], eax
$L82532:
	cmp	DWORD PTR _iWheel2$[ebp], 4
	jge	$L82534

; 2518 : 			wheel2 = &car2->Wheel[iWheel2];

	mov	eax, DWORD PTR _iWheel2$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car2$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1560]
	mov	DWORD PTR _wheel2$[ebp], edx

; 2519 : 			if (!IsWheelPresent(wheel2)) continue;

	mov	eax, DWORD PTR _wheel2$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	jne	SHORT $L82535
	jmp	SHORT $L82533
$L82535:

; 2520 : 
; 2521 : 			// Bounding box test
; 2522 : 			if (!BBTestYXZ(&wheel1->BBox, &wheel2->BBox)) continue;

	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+60]
	fcomp	DWORD PTR [ecx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83045
	mov	edx, DWORD PTR _wheel1$[ebp]
	mov	eax, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [edx+64]
	fcomp	DWORD PTR [eax+60]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83045
	mov	ecx, DWORD PTR _wheel1$[ebp]
	mov	edx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [ecx+52]
	fcomp	DWORD PTR [edx+56]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83045
	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+56]
	fcomp	DWORD PTR [ecx+52]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83045
	mov	edx, DWORD PTR _wheel1$[ebp]
	mov	eax, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [edx+68]
	fcomp	DWORD PTR [eax+72]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83045
	mov	ecx, DWORD PTR _wheel1$[ebp]
	mov	edx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [ecx+72]
	fcomp	DWORD PTR [edx+68]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83045
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $L83046
$L83045:
	mov	DWORD PTR tv140[ebp], 0
$L83046:
	cmp	DWORD PTR tv140[ebp], 0
	jne	SHORT $L82536
	jmp	$L82533
$L82536:

; 2523 : 
; 2524 : 			//Get relative position
; 2525 : 			VecMinusVec(&wheel1->CentrePos, &wheel2->CentrePos, &dR);

	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+184]
	fsub	DWORD PTR [ecx+184]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+188]
	fsub	DWORD PTR [ecx+188]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+192]
	fsub	DWORD PTR [ecx+192]
	fstp	DWORD PTR _dR$[ebp+8]

; 2526 : 			dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 2527 : 
; 2528 : 			// Check for collision
; 2529 : 			if (dRLen > wheel1->Radius + wheel2->Radius) continue;

	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+20]
	fcomp	DWORD PTR _dRLen$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82538
	jmp	$L82533
$L82538:

; 2530 : 
; 2531 : 			// Set up the collision info
; 2532 : 			if ((wheelColl = NextWheelCollInfo()) == NULL) return nColls;

	call	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ; NextWheelCollInfo
	mov	DWORD PTR _wheelColl$[ebp], eax
	cmp	DWORD PTR _wheelColl$[ebp], 0
	jne	SHORT $L82539
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L82518
$L82539:

; 2533 : 			AddWheelColl(car1, wheelColl);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car1$[ebp]
	push	ecx
	call	?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ; AddWheelColl
	add	esp, 8

; 2534 : 			if ((wheelColl2 = NextWheelCollInfo()) == NULL) {

	call	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ; NextWheelCollInfo
	mov	DWORD PTR _wheelColl2$[ebp], eax
	cmp	DWORD PTR _wheelColl2$[ebp], 0
	jne	SHORT $L82540

; 2535 : 				RemoveWheelColl(car1, wheelColl);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car1$[ebp]
	push	ecx
	call	?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z ; RemoveWheelColl
	add	esp, 8

; 2536 : 				return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	$L82518
$L82540:

; 2537 : 			}
; 2538 : 			AddWheelColl(car2, wheelColl2);

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car2$[ebp]
	push	ecx
	call	?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ; AddWheelColl
	add	esp, 8

; 2539 : 
; 2540 : 
; 2541 : 			// Collision Occurred
; 2542 : 			wheelColl2->Car = car2;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _car2$[ebp]
	mov	DWORD PTR [eax], ecx

; 2543 : 			wheelColl2->IWheel = iWheel2;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _iWheel2$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2544 : 			wheelColl2->Body2 = car2->Body;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _car2$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	DWORD PTR [eax+8], edx

; 2545 : 			wheelColl->Car = car1;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _car1$[ebp]
	mov	DWORD PTR [eax], ecx

; 2546 : 			wheelColl->IWheel = iWheel1;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _iWheel1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2547 : 			wheelColl->Body2 = car1->Body;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _car1$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	DWORD PTR [eax+8], edx

; 2548 : 			SetVecZero(&wheelColl->WorldPos);	// DODGY....

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+44], 0

; 2549 : 			SetVecZero(&wheelColl2->WorldPos);	// DODGY....

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	DWORD PTR [eax+44], 0

; 2550 : 
; 2551 : 			wheelColl2->Depth = dRLen - wheel1->Radius - wheel2->Radius;

	mov	eax, DWORD PTR _wheel1$[ebp]
	fld	DWORD PTR _dRLen$[ebp]
	fsub	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+76]

; 2552 : 			wheelColl->Depth = wheelColl2->Depth;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx

; 2553 : 
; 2554 : 			// Collision plane
; 2555 : 			if (dRLen > SMALL_REAL) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82541

; 2556 : 				CopyVec(&dR, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp]
	mov	DWORD PTR [eax+60], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp+4]
	mov	DWORD PTR [eax+64], ecx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _dR$[ebp+8]
	mov	DWORD PTR [eax+68], ecx

; 2557 : 				VecDivScalar(PlaneNormal(&wheelColl->Plane), dRLen);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+60]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+64]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+68]
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+68]

; 2558 : 				wheelColl->Time = ONE - (wheelColl->Depth / dRLen);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+76]
	fdiv	DWORD PTR _dRLen$[ebp]
	fsubr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+80]

; 2559 : 			} else {

	jmp	SHORT $L82548
$L82541:

; 2560 : 				SetVec(PlaneNormal(&wheelColl->Plane), ONE, ZERO, ZERO);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+60], 1065353216		; 3f800000H
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+64], 0
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+68], 0

; 2561 : 				wheelColl->Time = ONE;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+80], 1065353216		; 3f800000H
$L82548:

; 2562 : 			}
; 2563 : 			FlipPlane(&wheelColl->Plane, &wheelColl2->Plane);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+60]
	fchs
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+64]
	fchs
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+68]
	fchs
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+72]
	fchs
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [ecx+72]

; 2564 : 			wheelColl2->Time = wheelColl->Time;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx

; 2565 : 
; 2566 : 			// Calculate the collision points for response
; 2567 : 			VecEqScalarVec(&wheelColl->Pos, wheel1->Radius, PlaneNormal(&wheelColl->Plane));

	mov	eax, DWORD PTR _wheel1$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheel1$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheel1$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+20]

; 2568 : 			VecPlusEqVec(&wheelColl->Pos, &wheel1->CentrePos);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel1$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel1$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheel1$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+20]

; 2569 : 			VecMinusEqVec(&wheelColl->Pos, &car1->Body->Centre.Pos);

	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+20]

; 2570 : 
; 2571 : 			VecEqScalarVec(&wheelColl2->Pos, wheel2->Radius, PlaneNormal(&wheelColl2->Plane));

	mov	eax, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+20]

; 2572 : 			VecPlusEqVec(&wheelColl2->Pos, &wheel2->CentrePos);

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+20]

; 2573 : 			VecMinusEqVec(&wheelColl2->Pos, &car2->Body->Centre.Pos);

	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+20]

; 2574 : 
; 2575 : 			VecPlusScalarVec(&wheel1->CentrePos, HALF, &dR, &wheelColl->WorldPos);

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _wheel1$[ebp]
	fadd	DWORD PTR [eax+184]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+36]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _wheel1$[ebp]
	fadd	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+40]
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _wheel1$[ebp]
	fadd	DWORD PTR [eax+192]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+44]

; 2576 : 			CopyVec(&wheelColl->WorldPos, &wheelColl2->WorldPos);

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 2577 : 
; 2578 : 			// Calculate velocity
; 2579 : 			VecCrossVec(&car1->Body->AngVel, &wheelColl->Pos, &wheelColl->Vel);

	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+16]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+20]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2580 : 			VecPlusEqVec(&wheelColl->Vel, &car1->Body->Centre.Vel);

	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+48]
	fadd	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+52]
	fadd	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [edx+56]
	fadd	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [eax+56]

; 2581 : 
; 2582 : 			VecCrossVec(&car2->Body->AngVel, &wheelColl2->Pos, &wheelColl2->Vel);

	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+16]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [ecx+340]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+20]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [ecx+332]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [ecx+336]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+56]

; 2583 : 			VecPlusEqVec(&wheelColl2->Vel, &car2->Body->Centre.Vel);

	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [edx+48]
	fadd	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+48]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [edx+52]
	fadd	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+52]
	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fld	DWORD PTR [edx+56]
	fadd	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [eax+56]

; 2584 : 
; 2585 : 			VecMinusEqVec(&wheelColl2->Vel, &wheelColl->Vel);

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _wheelColl2$[ebp]
	fstp	DWORD PTR [edx+56]

; 2586 : 			CopyVec(&wheelColl2->Vel, &wheelColl->Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 2587 : 			NegateVec(&wheelColl->Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+48]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+52]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fld	DWORD PTR [eax+56]
	fchs
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+56]

; 2588 : 
; 2589 : 			wheelColl->Grip = wheel1->Grip * wheel2->Grip;

	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+84]

; 2590 : 			wheelColl->StaticFriction = wheel1->StaticFriction * wheel2->StaticFriction;

	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+88]

; 2591 : 			wheelColl->KineticFriction = wheel1->KineticFriction * wheel2->KineticFriction;

	mov	eax, DWORD PTR _wheel1$[ebp]
	mov	ecx, DWORD PTR _wheel2$[ebp]
	fld	DWORD PTR [eax+36]
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+92]

; 2592 : 			wheelColl->Restitution = car1->Spring[iWheel1].Restitution;

	mov	eax, DWORD PTR _iWheel1$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR _car1$[ebp]
	mov	eax, DWORD PTR [edx+eax+3008]
	mov	DWORD PTR [ecx+96], eax

; 2593 : 			wheelColl->Material = NULL;

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	DWORD PTR [eax+100], 0

; 2594 : 			wheelColl2->Grip = wheelColl->Grip;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+84], edx

; 2595 : 			wheelColl2->StaticFriction = wheelColl->StaticFriction;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+88], edx

; 2596 : 			wheelColl2->KineticFriction = wheelColl->KineticFriction;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx

; 2597 : 			wheelColl2->Restitution = car2->Spring[iWheel2].Restitution;

	mov	eax, DWORD PTR _iWheel2$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _wheelColl2$[ebp]
	mov	edx, DWORD PTR _car2$[ebp]
	mov	eax, DWORD PTR [edx+eax+3008]
	mov	DWORD PTR [ecx+96], eax

; 2598 : 			wheelColl2->Material = NULL;

	mov	eax, DWORD PTR _wheelColl2$[ebp]
	mov	DWORD PTR [eax+100], 0

; 2599 : 
; 2600 : 			nColls++;

	mov	eax, DWORD PTR _nColls$[ebp]
	add	eax, 1
	mov	DWORD PTR _nColls$[ebp], eax

; 2601 : 		}

	jmp	$L82533
$L82534:

; 2602 : 	}

	jmp	$L82529
$L82530:

; 2603 : 
; 2604 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L82518:

; 2605 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectWheelWheelColls@@YAHPAUCarStruct@@0@Z ENDP	; DetectWheelWheelColls
_TEXT	ENDS
PUBLIC	?DetectCarCarColls@@YAHPAUCarStruct@@0@Z	; DetectCarCarColls
EXTRN	?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z:NEAR ; DetectBodyBodyColls
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectCarCarColls@@YAHPAUCarStruct@@0@Z
_TEXT	SEGMENT
tv94 = -72						; size = 4
_nColls$ = -4						; size = 4
_car1$ = 8						; size = 4
_car2$ = 12						; size = 4
?DetectCarCarColls@@YAHPAUCarStruct@@0@Z PROC NEAR	; DetectCarCarColls, COMDAT

; 2614 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2615 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 2616 : 
; 2617 : 	// Quick bounding-box test
; 2618 : 	if (!BBTestXZY(&car1->BBox, &car2->BBox)) return nColls;

	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR _car2$[ebp]
	fld	DWORD PTR [eax+3148]
	fcomp	DWORD PTR [ecx+3152]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L83049
	mov	edx, DWORD PTR _car1$[ebp]
	mov	eax, DWORD PTR _car2$[ebp]
	fld	DWORD PTR [edx+3152]
	fcomp	DWORD PTR [eax+3148]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83049
	mov	ecx, DWORD PTR _car1$[ebp]
	mov	edx, DWORD PTR _car2$[ebp]
	fld	DWORD PTR [ecx+3164]
	fcomp	DWORD PTR [edx+3168]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83049
	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR _car2$[ebp]
	fld	DWORD PTR [eax+3168]
	fcomp	DWORD PTR [ecx+3164]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83049
	mov	edx, DWORD PTR _car1$[ebp]
	mov	eax, DWORD PTR _car2$[ebp]
	fld	DWORD PTR [edx+3156]
	fcomp	DWORD PTR [eax+3160]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83049
	mov	ecx, DWORD PTR _car1$[ebp]
	mov	edx, DWORD PTR _car2$[ebp]
	fld	DWORD PTR [ecx+3160]
	fcomp	DWORD PTR [edx+3156]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83049
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $L83050
$L83049:
	mov	DWORD PTR tv94[ebp], 0
$L83050:
	cmp	DWORD PTR tv94[ebp], 0
	jne	SHORT $L82563
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	SHORT $L82561
$L82563:

; 2619 : 
; 2620 : 	// Check all car parts against other car's parts
; 2621 : 	nColls += DetectBodyBodyColls(car1->Body, car2->Body);

	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	mov	edx, DWORD PTR _car1$[ebp]
	mov	eax, DWORD PTR [edx+856]
	push	eax
	call	?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z ; DetectBodyBodyColls
	add	esp, 8
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2622 : 	nColls += DetectWheelBodyColls(car1, car2->Body);

	mov	eax, DWORD PTR _car2$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	mov	edx, DWORD PTR _car1$[ebp]
	push	edx
	call	?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectWheelBodyColls
	add	esp, 8
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2623 : 	nColls += DetectWheelBodyColls(car2, car1->Body);

	mov	eax, DWORD PTR _car1$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	mov	edx, DWORD PTR _car2$[ebp]
	push	edx
	call	?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectWheelBodyColls
	add	esp, 8
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2624 : 	nColls += DetectWheelWheelColls(car1, car2);

	mov	eax, DWORD PTR _car2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car1$[ebp]
	push	ecx
	call	?DetectWheelWheelColls@@YAHPAUCarStruct@@0@Z ; DetectWheelWheelColls
	add	esp, 8
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2625 : 
; 2626 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L82561:

; 2627 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectCarCarColls@@YAHPAUCarStruct@@0@Z ENDP		; DetectCarCarColls
_TEXT	ENDS
PUBLIC	?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectCarBodyColls
; Function compile flags: /Odt /ZI
;	COMDAT ?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z
_TEXT	SEGMENT
tv132 = -72						; size = 4
_nColls$ = -4						; size = 4
_car$ = 8						; size = 4
_body$ = 12						; size = 4
?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z PROC NEAR ; DetectCarBodyColls, COMDAT

; 2637 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2638 : 	int nColls = 0;

	mov	DWORD PTR _nColls$[ebp], 0

; 2639 : 
; 2640 : 	// Bounding box test
; 2641 : 	if (!BBTestXZY(&car->BBox, &body->CollSkin.BBox)) return nColls;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+3148]
	fcomp	DWORD PTR [ecx+448]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L83053
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+3152]
	fcomp	DWORD PTR [eax+444]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83053
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+3164]
	fcomp	DWORD PTR [edx+464]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83053
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+3168]
	fcomp	DWORD PTR [ecx+460]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83053
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+3156]
	fcomp	DWORD PTR [eax+456]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83053
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+3160]
	fcomp	DWORD PTR [edx+452]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83053
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $L83054
$L83053:
	mov	DWORD PTR tv132[ebp], 0
$L83054:
	cmp	DWORD PTR tv132[ebp], 0
	jne	SHORT $L82569
	mov	eax, DWORD PTR _nColls$[ebp]
	jmp	SHORT $L82567
$L82569:

; 2642 : 
; 2643 : 	// Check car parts against body
; 2644 : 	nColls += DetectBodyBodyColls(car->Body, body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z ; DetectBodyBodyColls
	add	esp, 8
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2645 : 	nColls += DetectWheelBodyColls(car, body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?DetectWheelBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectWheelBodyColls
	add	esp, 8
	add	eax, DWORD PTR _nColls$[ebp]
	mov	DWORD PTR _nColls$[ebp], eax

; 2646 : 
; 2647 : 	return nColls;

	mov	eax, DWORD PTR _nColls$[ebp]
$L82567:

; 2648 : 
; 2649 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ENDP ; DetectCarBodyColls
_TEXT	ENDS
PUBLIC	?UpdateRemotePlayer@@YAXPAUPlayerStruct@@@Z	; UpdateRemotePlayer
; Function compile flags: /Odt /ZI
;	COMDAT ?UpdateRemotePlayer@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_car$ = -8						; size = 4
_rem$ = -4						; size = 4
_player$ = 8						; size = 4
?UpdateRemotePlayer@@YAXPAUPlayerStruct@@@Z PROC NEAR	; UpdateRemotePlayer, COMDAT

; 2663 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2664 : 	REMOTE_DATA *rem;
; 2665 : 	CAR		*car;
; 2666 : 	
; 2667 : 	car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 2668 : 	rem = &car->RemoteData[car->NewDat];

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3808]
	shl	ecx, 6
	mov	edx, DWORD PTR _car$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3608]
	mov	DWORD PTR _rem$[ebp], eax

; 2669 : 
; 2670 : 	// Make sure there is new data
; 2671 : 	if (!rem->NewData) return;

	mov	eax, DWORD PTR _rem$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $L82577
	jmp	$L82574
$L82577:

; 2672 : 
; 2673 : 	// Update the players structure
; 2674 : 	player->controls.dx = rem->dx;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR _rem$[ebp]
	mov	dl, BYTE PTR [ecx+60]
	mov	BYTE PTR [eax+28], dl

; 2675 : 	player->controls.dy = rem->dy;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR _rem$[ebp]
	mov	dl, BYTE PTR [ecx+61]
	mov	BYTE PTR [eax+29], dl

; 2676 : 
; 2677 : 	// DEBUGGING
; 2678 : 	VecMinusVec(&rem->Pos, &car->Body->Centre.Pos, &DBG_PosDiff);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR ?DBG_PosDiff@@3UVectorStruct@@A
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR ?DBG_PosDiff@@3UVectorStruct@@A+4
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR ?DBG_PosDiff@@3UVectorStruct@@A+8

; 2679 : 	VecMinusVec(&rem->Vel, &car->Body->Centre.Vel, &DBG_VelDiff);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [edx+20]
	fsub	DWORD PTR [ecx+32]
	fstp	DWORD PTR ?DBG_VelDiff@@3UVectorStruct@@A
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [edx+24]
	fsub	DWORD PTR [ecx+36]
	fstp	DWORD PTR ?DBG_VelDiff@@3UVectorStruct@@A+4
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	fld	DWORD PTR [edx+28]
	fsub	DWORD PTR [ecx+40]
	fstp	DWORD PTR ?DBG_VelDiff@@3UVectorStruct@@A+8

; 2680 : 
; 2681 : 
; 2682 : 	CopyVec(&rem->Pos, &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+28], eax

; 2683 : 	CopyVec(&rem->Vel, &car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+40], eax

; 2684 : 	CopyVec(&rem->AngVel, &car->Body->AngVel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+332], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+336], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+340], eax

; 2685 : 	CopyQuat(&rem->Quat, &car->Body->Centre.Quat);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+68], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+72], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+76], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+80], eax

; 2686 : 
; 2687 : 	// Flag data as used
; 2688 : 	rem->NewData = FALSE;

	mov	eax, DWORD PTR _rem$[ebp]
	mov	BYTE PTR [eax+4], 0
$L82574:

; 2689 : 
; 2690 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateRemotePlayer@@YAXPAUPlayerStruct@@@Z ENDP	; UpdateRemotePlayer
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	?LevelInf@@3PAULEVELINFO@@A:DWORD		; LevelInf
EXTRN	?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z:NEAR ; MovePlane
EXTRN	?LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z:NEAR ; LoadConvex
EXTRN	?LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z:NEAR ; LoadSpheres
EXTRN	?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z:NEAR ; MakeTightLocalBBox
EXTRN	?LoadModel@@YAJPADPAUMODEL@@DDDJ@Z:NEAR		; LoadModel
EXTRN	?LoadTextureClever@@YA_NPADDJJJJJ@Z:NEAR	; LoadTextureClever
EXTRN	?CarTextureSet@@3JA:DWORD			; CarTextureSet
EXTRN	_strlen:NEAR
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadOneCarModelSet@@YAXPAUPlayerStruct@@J@Z
_TEXT	SEGMENT
_tPage$ = -37						; size = 1
_iPt$ = -36						; size = 4
_iFace$ = -32						; size = 4
_iSkin$ = -28						; size = 4
_i$ = -24						; size = 4
_fp$ = -20						; size = 4
_pSkin$ = -16						; size = 4
_collinfo$ = -12					; size = 4
_cm$ = -8						; size = 4
_ci$ = -4						; size = 4
_player$ = 8						; size = 4
_car$ = 12						; size = 4
?LoadOneCarModelSet@@YAXPAUPlayerStruct@@J@Z PROC NEAR	; LoadOneCarModelSet, COMDAT

; 2700 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 2701 : 	CAR_INFO *ci;
; 2702 : 	CAR_MODEL *cm = &player->carmodels;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 3864				; 00000f18H
	mov	DWORD PTR _cm$[ebp], eax

; 2703 : 	COLLSKIN_INFO *collinfo = &cm->CollSkin;

	mov	eax, DWORD PTR _cm$[ebp]
	add	eax, 6148				; 00001804H
	mov	DWORD PTR _collinfo$[ebp], eax

; 2704 : 	CONVEX *pSkin;
; 2705 : 	FILE *fp;
; 2706 : 	long i, iSkin, iFace, iPt;
; 2707 : 	char tPage;
; 2708 : 
; 2709 : // get car info
; 2710 : 
; 2711 : 	car %= NCarTypes;

	mov	eax, DWORD PTR _car$[ebp]
	cdq
	idiv	DWORD PTR ?NCarTypes@@3JA		; NCarTypes
	mov	DWORD PTR _car$[ebp], edx

; 2712 : 	ci = &CarInfo[car];

	mov	eax, DWORD PTR _car$[ebp]
	imul	eax, 2220				; 000008acH
	add	eax, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	mov	DWORD PTR _ci$[ebp], eax

; 2713 : 
; 2714 : // set parts flags
; 2715 : 
; 2716 : 	cm->BodyPartsFlag = 0;

	mov	eax, DWORD PTR _cm$[ebp]
	mov	BYTE PTR [eax+4], 0

; 2717 : 	cm->WheelPartsFlag[FL] = cm->WheelPartsFlag[FR] = cm->WheelPartsFlag[BL] = cm->WheelPartsFlag[BR] = 0;

	mov	eax, DWORD PTR _cm$[ebp]
	mov	BYTE PTR [eax+3], 0
	mov	ecx, DWORD PTR _cm$[ebp]
	mov	BYTE PTR [ecx+2], 0
	mov	edx, DWORD PTR _cm$[ebp]
	mov	BYTE PTR [edx+1], 0
	mov	eax, DWORD PTR _cm$[ebp]
	mov	BYTE PTR [eax], 0

; 2718 : 
; 2719 : // Load models
; 2720 : 
; 2721 : 	for (i = 0 ; i < MAX_CAR_MODEL_TYPES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82592
$L82593:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82592:
	cmp	DWORD PTR _i$[ebp], 19			; 00000013H
	jge	$L82594

; 2722 : 	{
; 2723 : 		if (strlen(ci->ModelFile[i]))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _ci$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $L82595

; 2724 : 		{
; 2725 : 			if (i == 17 || i == 18) {

	cmp	DWORD PTR _i$[ebp], 17			; 00000011H
	je	SHORT $L82597
	cmp	DWORD PTR _i$[ebp], 18			; 00000012H
	jne	SHORT $L82596
$L82597:

; 2726 : 				tPage = TPAGE_FX1;

	mov	BYTE PTR _tPage$[ebp], 27		; 0000001bH

; 2727 : 			} else {

	jmp	SHORT $L82598
$L82596:

; 2728 : 				tPage = TPAGE_CAR_START + (char)player->Slot;

	mov	eax, DWORD PTR _player$[ebp]
	movsx	ecx, BYTE PTR [eax]
	add	ecx, 10					; 0000000aH
	mov	BYTE PTR _tPage$[ebp], cl
$L82598:

; 2729 : 			}
; 2730 : 			LoadModel(ci->ModelFile[i], cm->Model[i], tPage, MAX_CAR_LOD, LOADMODEL_FORCE_TPAGE, LevelInf[GameSettings.Level].ModelRGBper);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	mov	ecx, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	mov	edx, DWORD PTR [ecx+eax+208]
	push	edx
	push	1
	push	5
	mov	al, BYTE PTR _tPage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 300				; 0000012cH
	mov	edx, DWORD PTR _cm$[ebp]
	lea	eax, DWORD PTR [edx+ecx+364]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _ci$[ebp]
	push	ecx
	call	?LoadModel@@YAJPADPAUMODEL@@DDDJ@Z	; LoadModel
	add	esp, 24					; 00000018H

; 2731 : 		}
; 2732 : 		else

	jmp	SHORT $L82600
$L82595:

; 2733 : 		{
; 2734 : 			cm->Model[i]->AllocPtr = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 300				; 0000012cH
	mov	ecx, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [ecx+eax+392], 0
$L82600:

; 2735 : 		}
; 2736 : 	}

	jmp	$L82593
$L82594:

; 2737 : 
; 2738 : // Load TPage
; 2739 : 
; 2740 : 	if (strlen(ci->TPageFile))

	mov	eax, DWORD PTR _ci$[ebp]
	add	eax, 1216				; 000004c0H
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $L82601

; 2741 : 	{
; 2742 : 		LoadTextureClever(ci->TPageFile, TPAGE_CAR_START + (char)player->Slot, 256, 256, 0, CarTextureSet, TRUE);

	push	1
	mov	eax, DWORD PTR ?CarTextureSet@@3JA	; CarTextureSet
	push	eax
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	mov	ecx, DWORD PTR _player$[ebp]
	movsx	edx, BYTE PTR [ecx]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _ci$[ebp]
	add	eax, 1216				; 000004c0H
	push	eax
	call	?LoadTextureClever@@YA_NPADDJJJJJ@Z	; LoadTextureClever
	add	esp, 28					; 0000001cH
$L82601:

; 2743 : 	}
; 2744 : 
; 2745 : 
; 2746 : // Set Env map RGB
; 2747 : 
; 2748 : 	cm->EnvRGB = ci->EnvRGB;

	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+1344]
	mov	DWORD PTR [eax+6144], edx

; 2749 : 
; 2750 : // Load Collision Skin
; 2751 : 
; 2752 : 	if (ci->CollFile && ci->CollFile[0])

	mov	eax, DWORD PTR _ci$[ebp]
	add	eax, 1280				; 00000500H
	je	$L82603
	mov	eax, DWORD PTR _ci$[ebp]
	movsx	ecx, BYTE PTR [eax+1280]
	test	ecx, ecx
	je	$L82603

; 2753 : 	{
; 2754 : 		if ((fp = fopen(ci->CollFile, "rb")) != NULL) 

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _ci$[ebp]
	add	eax, 1280				; 00000500H
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	je	$L82604

; 2755 : 		{
; 2756 : 
; 2757 : 			// Load the convex hulls
; 2758 : 			if ((collinfo->Convex = LoadConvex(fp, &collinfo->NConvex, 0)) != NULL)

	push	0
	mov	eax, DWORD PTR _collinfo$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z ; LoadConvex
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _collinfo$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$L82606

; 2759 : 			{
; 2760 : 				collinfo->CollType = BODY_COLL_CONVEX;

	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+92], 0

; 2761 : 
; 2762 : 				// Move the collision skins to centre on CoM
; 2763 : 				for (iSkin = 0; iSkin < collinfo->NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82607
$L82608:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82607:
	mov	eax, DWORD PTR _collinfo$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L82606

; 2764 : 					pSkin = &collinfo->Convex[iSkin];

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collinfo$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pSkin$[ebp], eax

; 2765 : 
; 2766 : 					// offset
; 2767 : 					//VecPlusEqVec(&pSkin->Offset, &ci->CoMOffset);
; 2768 : 
; 2769 : 					// collision planes
; 2770 : 					for (iFace = 0; iFace < pSkin->NFaces; iFace++) {

	mov	DWORD PTR _iFace$[ebp], 0
	jmp	SHORT $L82610
$L82611:
	mov	eax, DWORD PTR _iFace$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFace$[ebp], eax
$L82610:
	mov	eax, DWORD PTR _pSkin$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	DWORD PTR _iFace$[ebp], ecx
	jge	SHORT $L82612

; 2771 : 						MovePlane(&pSkin->Faces[iFace], &ci->CoMOffset);

	mov	eax, DWORD PTR _ci$[ebp]
	add	eax, 1436				; 0000059cH
	push	eax
	mov	ecx, DWORD PTR _iFace$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pSkin$[ebp]
	add	ecx, DWORD PTR [edx+40]
	push	ecx
	call	?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z ; MovePlane
	add	esp, 8

; 2772 : 					}

	jmp	SHORT $L82611
$L82612:

; 2773 : 
; 2774 : 					// vertices
; 2775 : 					for (iPt = 0; iPt < pSkin->NPts; iPt++) {

	mov	DWORD PTR _iPt$[ebp], 0
	jmp	SHORT $L82613
$L82614:
	mov	eax, DWORD PTR _iPt$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPt$[ebp], eax
$L82613:
	mov	eax, DWORD PTR _pSkin$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	DWORD PTR _iPt$[ebp], ecx
	jge	SHORT $L82615

; 2776 : 						VecPlusEqVec(&pSkin->Pts[iPt], &ci->CoMOffset);

	mov	eax, DWORD PTR _iPt$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pSkin$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _ci$[ebp]
	fld	DWORD PTR [edx+eax]
	fadd	DWORD PTR [ecx+1436]
	mov	edx, DWORD PTR _iPt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pSkin$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	fstp	DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _iPt$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pSkin$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _ci$[ebp]
	fld	DWORD PTR [edx+eax+4]
	fadd	DWORD PTR [ecx+1440]
	mov	edx, DWORD PTR _iPt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pSkin$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	fstp	DWORD PTR [ecx+edx+4]
	mov	eax, DWORD PTR _iPt$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pSkin$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _ci$[ebp]
	fld	DWORD PTR [edx+eax+8]
	fadd	DWORD PTR [ecx+1444]
	mov	edx, DWORD PTR _iPt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pSkin$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	fstp	DWORD PTR [ecx+edx+8]

; 2777 : 					}

	jmp	$L82614
$L82615:

; 2778 : 				}

	jmp	$L82608
$L82606:

; 2779 : 
; 2780 : 			}
; 2781 : 
; 2782 : 			// Load the spheres
; 2783 : 			if ((collinfo->Sphere = LoadSpheres(fp, &collinfo->NSpheres)) != NULL)

	mov	eax, DWORD PTR _collinfo$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z ; LoadSpheres
	add	esp, 8
	mov	edx, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _collinfo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$L82616

; 2784 : 			{
; 2785 : 				// Move the spheres to centre on CoM
; 2786 : 				for (iSkin = 0; iSkin < collinfo->NSpheres; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82617
$L82618:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82617:
	mov	eax, DWORD PTR _collinfo$[ebp]
	movsx	ecx, WORD PTR [eax+28]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	SHORT $L82616

; 2787 : 					// Position
; 2788 : 					VecPlusEqVec(&collinfo->Sphere[iSkin].Pos, &ci->CoMOffset);

	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collinfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _ci$[ebp]
	fld	DWORD PTR [edx+eax]
	fadd	DWORD PTR [ecx+1436]
	mov	edx, DWORD PTR _iSkin$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fstp	DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collinfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _ci$[ebp]
	fld	DWORD PTR [edx+eax+4]
	fadd	DWORD PTR [ecx+1440]
	mov	edx, DWORD PTR _iSkin$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fstp	DWORD PTR [ecx+edx+4]
	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collinfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _ci$[ebp]
	fld	DWORD PTR [edx+eax+8]
	fadd	DWORD PTR [ecx+1444]
	mov	edx, DWORD PTR _iSkin$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	fstp	DWORD PTR [ecx+edx+8]

; 2789 : 				}

	jmp	$L82618
$L82616:

; 2790 : 			}
; 2791 : 
; 2792 : 			MakeTightLocalBBox(collinfo);

	mov	eax, DWORD PTR _collinfo$[ebp]
	push	eax
	call	?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z ; MakeTightLocalBBox
	add	esp, 4

; 2793 : 
; 2794 : 			fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L82604:

; 2795 : 		}
; 2796 : 	}
; 2797 : 	else

	jmp	SHORT $L82620
$L82603:

; 2798 : 	{
; 2799 : 		collinfo->NConvex = 0;

	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	WORD PTR [eax+12], 0

; 2800 : 		collinfo->Convex = NULL;

	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax], 0

; 2801 : 		collinfo->NSpheres = 0;

	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	WORD PTR [eax+28], 0

; 2802 : 		collinfo->Sphere = NULL;

	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+16], 0

; 2803 : 		SetBBox(&collinfo->BBox, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO);

	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+64], 0
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+68], 0
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+72], 0
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+76], 0
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+80], 0
	mov	eax, DWORD PTR _collinfo$[ebp]
	mov	DWORD PTR [eax+84], 0
$L82620:

; 2804 : 	}
; 2805 : 
; 2806 : // Setup body
; 2807 : 
; 2808 : 	cm->Body = cm->Model[ci->Body.ModelNum];

	mov	eax, DWORD PTR _ci$[ebp]
	mov	ecx, DWORD PTR [eax+1464]
	imul	ecx, 300				; 0000012cH
	mov	edx, DWORD PTR _cm$[ebp]
	lea	eax, DWORD PTR [edx+ecx+364]
	mov	ecx, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [ecx+6064], eax

; 2809 : 	CopyVec(&ci->Body.Offset, &cm->OffBody);

	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+1468]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+1472]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+1476]
	mov	DWORD PTR [eax+16], edx

; 2810 : 
; 2811 : // Setup wheels
; 2812 : 
; 2813 : 	for (i = 0; i < 4; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82621
$L82622:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82621:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$L82623

; 2814 : 	{
; 2815 : 		cm->Wheel[i] = cm->Model[ci->Wheel[i].ModelNum];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1552]
	imul	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _cm$[ebp]
	lea	ecx, DWORD PTR [eax+edx+364]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [eax+edx*4+6068], ecx

; 2816 : 		CopyVec(&ci->Wheel[i].Offset1, &cm->OffWheel[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1556]
	mov	DWORD PTR [edx+ecx+20], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1560]
	mov	DWORD PTR [edx+ecx+24], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1564]
	mov	DWORD PTR [edx+ecx+28], eax

; 2817 : 		CopyVec(&ci->Wheel[i].Offset2, &cm->OffWheelColl[i])

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1568]
	mov	DWORD PTR [edx+ecx+212], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1572]
	mov	DWORD PTR [edx+ecx+216], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1576]
	mov	DWORD PTR [edx+ecx+220], eax

; 2818 : 		cm->WheelRad[i] = ci->Wheel[i].Radius;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1580]
	mov	DWORD PTR [edx+ecx*4+296], eax

; 2819 : 	}

	jmp	$L82622
$L82623:

; 2820 : 
; 2821 : // Set up spinner
; 2822 : 
; 2823 : 	if (ci->Spinner.ModelNum != CAR_MODEL_NONE)

	mov	eax, DWORD PTR _ci$[ebp]
	cmp	DWORD PTR [eax+2144], -1
	je	SHORT $L82624

; 2824 : 	{
; 2825 : 		cm->BodyPartsFlag |= CAR_MODEL_SPINNER;

	mov	eax, DWORD PTR _cm$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	or	ecx, 1
	mov	edx, DWORD PTR _cm$[ebp]
	mov	BYTE PTR [edx+4], cl

; 2826 : 		cm->Spinner = cm->Model[ci->Spinner.ModelNum];

	mov	eax, DWORD PTR _ci$[ebp]
	mov	ecx, DWORD PTR [eax+2144]
	imul	ecx, 300				; 0000012cH
	mov	edx, DWORD PTR _cm$[ebp]
	lea	eax, DWORD PTR [edx+ecx+364]
	mov	ecx, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [ecx+6132], eax

; 2827 : 		CopyVec(&ci->Spinner.Offset, &cm->OffSpinner);

	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2148]
	mov	DWORD PTR [eax+260], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2152]
	mov	DWORD PTR [eax+264], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2156]
	mov	DWORD PTR [eax+268], edx
$L82624:

; 2828 : 	}
; 2829 : 
; 2830 : // Setup aerial models
; 2831 : 
; 2832 : 	if (ci->Aerial.SecModelNum != CAR_MODEL_NONE && ci->Aerial.TopModelNum != CAR_MODEL_NONE)

	mov	eax, DWORD PTR _ci$[ebp]
	cmp	DWORD PTR [eax+2176], -1
	je	$L82625
	mov	eax, DWORD PTR _ci$[ebp]
	cmp	DWORD PTR [eax+2180], -1
	je	$L82625

; 2833 : 	{
; 2834 : 		cm->BodyPartsFlag |= CAR_MODEL_AERIAL;

	mov	eax, DWORD PTR _cm$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	or	ecx, 2
	mov	edx, DWORD PTR _cm$[ebp]
	mov	BYTE PTR [edx+4], cl

; 2835 : 		cm->Aerial[0] = cm->Model[ci->Aerial.SecModelNum];

	mov	eax, DWORD PTR _ci$[ebp]
	mov	ecx, DWORD PTR [eax+2176]
	imul	ecx, 300				; 0000012cH
	mov	edx, DWORD PTR _cm$[ebp]
	lea	eax, DWORD PTR [edx+ecx+364]
	mov	ecx, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [ecx+6136], eax

; 2836 : 		cm->Aerial[1] = cm->Model[ci->Aerial.TopModelNum];

	mov	eax, DWORD PTR _ci$[ebp]
	mov	ecx, DWORD PTR [eax+2180]
	imul	ecx, 300				; 0000012cH
	mov	edx, DWORD PTR _cm$[ebp]
	lea	eax, DWORD PTR [edx+ecx+364]
	mov	ecx, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [ecx+6140], eax

; 2837 : 		CopyVec(&ci->Aerial.Offset, &cm->OffAerial); 

	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2184]
	mov	DWORD PTR [eax+272], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2188]
	mov	DWORD PTR [eax+276], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2192]
	mov	DWORD PTR [eax+280], edx

; 2838 : 		CopyVec(&ci->Aerial.Direction, &cm->DirAerial); 

	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2196]
	mov	DWORD PTR [eax+284], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2200]
	mov	DWORD PTR [eax+288], edx
	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2204]
	mov	DWORD PTR [eax+292], edx

; 2839 : 		cm->AerialLen = ci->Aerial.SecLen;

	mov	eax, DWORD PTR _cm$[ebp]
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+2208]
	mov	DWORD PTR [eax+360], edx
$L82625:

; 2840 : 	}
; 2841 : 
; 2842 : // setup springs / axles / pins
; 2843 : 
; 2844 : 	for (i = 0; i < 4; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82626
$L82627:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82626:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$L82581

; 2845 : 	{
; 2846 : 
; 2847 : // Setup springs
; 2848 : 
; 2849 : 		if (ci->Spring[i].ModelNum != CAR_MODEL_NONE)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _ci$[ebp]
	cmp	DWORD PTR [ecx+eax+1856], -1
	je	$L82629

; 2850 : 		{
; 2851 : 			cm->Spring[i] = cm->Model[ci->Spring[i].ModelNum];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1856]
	imul	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _cm$[ebp]
	lea	ecx, DWORD PTR [eax+edx+364]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [eax+edx*4+6084], ecx

; 2852 : 			CopyVec(&ci->Spring[i].Offset, &cm->OffSpring[i]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1860]
	mov	DWORD PTR [edx+ecx+68], eax
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1864]
	mov	DWORD PTR [edx+ecx+72], eax
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1868]
	mov	DWORD PTR [edx+ecx+76], eax

; 2853 : 			cm->WheelPartsFlag[i] |= CAR_MODEL_SPRING;

	mov	eax, DWORD PTR _cm$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _cm$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], cl

; 2854 : 			cm->SpringLen[i] = ci->Spring[i].Length;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1872]
	mov	DWORD PTR [edx+ecx*4+312], eax
$L82629:

; 2855 : 		}
; 2856 : 	
; 2857 : // Setup axles
; 2858 : 
; 2859 : 		if (ci->Axle[i].ModelNum != CAR_MODEL_NONE)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _ci$[ebp]
	cmp	DWORD PTR [ecx+eax+1984], -1
	je	$L82630

; 2860 : 		{
; 2861 : 			cm->Axle[i] = cm->Model[ci->Axle[i].ModelNum];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1984]
	imul	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _cm$[ebp]
	lea	ecx, DWORD PTR [eax+edx+364]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [eax+edx*4+6100], ecx

; 2862 : 			CopyVec(&ci->Axle[i].Offset, &cm->OffAxle[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1988]
	mov	DWORD PTR [edx+ecx+116], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1992]
	mov	DWORD PTR [edx+ecx+120], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+1996]
	mov	DWORD PTR [edx+ecx+124], eax

; 2863 : 			cm->AxleLen[i] = ci->Axle[i].Length;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+2000]
	mov	DWORD PTR [edx+ecx*4+328], eax

; 2864 : 			cm->WheelPartsFlag[i] |= CAR_MODEL_AXLE;

	mov	eax, DWORD PTR _cm$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR _cm$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], cl
$L82630:

; 2865 : 		}
; 2866 : 
; 2867 : // Setup pins
; 2868 : 
; 2869 : 		if (ci->Pin[i].ModelNum != CAR_MODEL_NONE)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _ci$[ebp]
	cmp	DWORD PTR [ecx+eax+2064], -1
	je	$L82631

; 2870 : 		{
; 2871 : 			cm->Pin[i] = cm->Model[ci->Pin[i].ModelNum];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _ci$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2064]
	imul	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _cm$[ebp]
	lea	ecx, DWORD PTR [eax+edx+364]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cm$[ebp]
	mov	DWORD PTR [eax+edx*4+6116], ecx

; 2872 : 			CopyVec(&ci->Pin[i].Offset, &cm->OffPin[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+2068]
	mov	DWORD PTR [edx+ecx+164], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+2072]
	mov	DWORD PTR [edx+ecx+168], eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+2076]
	mov	DWORD PTR [edx+ecx+172], eax

; 2873 : 			cm->PinLen[i] = ci->Pin[i].Length;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cm$[ebp]
	mov	esi, DWORD PTR _ci$[ebp]
	mov	eax, DWORD PTR [esi+eax+2080]
	mov	DWORD PTR [edx+ecx*4+344], eax

; 2874 : 			cm->WheelPartsFlag[i] |= CAR_MODEL_PIN;

	mov	eax, DWORD PTR _cm$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	or	ecx, 4
	mov	edx, DWORD PTR _cm$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], cl
$L82631:

; 2875 : 		}
; 2876 : 	}

	jmp	$L82627
$L82581:

; 2877 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadOneCarModelSet@@YAXPAUPlayerStruct@@J@Z ENDP	; LoadOneCarModelSet
_TEXT	ENDS
EXTRN	?FreeModel@@YAXPAUMODEL@@J@Z:NEAR		; FreeModel
EXTRN	?FreeOneTexture@@YAXD@Z:NEAR			; FreeOneTexture
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeOneCarModelSet@@YAXPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_player$ = 8						; size = 4
?FreeOneCarModelSet@@YAXPAUPlayerStruct@@@Z PROC NEAR	; FreeOneCarModelSet, COMDAT

; 3064 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3065 : 	long i;
; 3066 : 
; 3067 : // free models
; 3068 : 
; 3069 : 	for (i = 0 ; i < MAX_CAR_MODEL_TYPES ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82636
$L82637:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82636:
	cmp	DWORD PTR _i$[ebp], 19			; 00000013H
	jge	SHORT $L82638

; 3070 : 	{
; 3071 : 		if (player->carmodels.Model[i]->AllocPtr)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 300				; 0000012cH
	mov	ecx, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [ecx+eax+4256], 0
	je	SHORT $L82639

; 3072 : 		{
; 3073 : 			FreeModel(player->carmodels.Model[i], MAX_CAR_LOD);

	push	5
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 300				; 0000012cH
	mov	ecx, DWORD PTR _player$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4228]
	push	edx
	call	?FreeModel@@YAXPAUMODEL@@J@Z		; FreeModel
	add	esp, 8
$L82639:

; 3074 : 		}
; 3075 : 	}

	jmp	SHORT $L82637
$L82638:

; 3076 : 
; 3077 : // free texture
; 3078 : 
; 3079 : 	FreeOneTexture(TPAGE_CAR_START + (char)player->Slot);

	mov	eax, DWORD PTR _player$[ebp]
	movsx	ecx, BYTE PTR [eax]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	?FreeOneTexture@@YAXD@Z			; FreeOneTexture
	add	esp, 4

; 3080 : 
; 3081 : // free coll skin
; 3082 : 
; 3083 : 	DestroyConvex(player->car.Models->CollSkin.Convex, player->car.Models->CollSkin.NConvex);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	movsx	edx, WORD PTR [ecx+6160]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	edx, DWORD PTR [ecx+6148]
	push	edx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 3084 : 	player->car.Models->CollSkin.Convex = NULL;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	DWORD PTR [ecx+6148], 0

; 3085 : 	player->car.Body->CollSkin.Convex = NULL;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	DWORD PTR [ecx+380], 0

; 3086 : 	player->car.Models->CollSkin.NConvex = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	WORD PTR [ecx+6160], 0

; 3087 : 
; 3088 : 	DestroySpheres(player->car.Models->CollSkin.Sphere);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	edx, DWORD PTR [ecx+6164]
	push	edx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 3089 : 	player->car.Models->CollSkin.Sphere = NULL;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	DWORD PTR [ecx+6164], 0

; 3090 : 	player->car.Body->CollSkin.Sphere = NULL;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	DWORD PTR [ecx+396], 0

; 3091 : 	player->car.Models->CollSkin.NSpheres = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	WORD PTR [ecx+6176], 0

; 3092 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeOneCarModelSet@@YAXPAUPlayerStruct@@@Z ENDP	; FreeOneCarModelSet
_TEXT	ENDS
PUBLIC	__real@3c372c52
PUBLIC	__real@41700000
PUBLIC	__real@41c80000
PUBLIC	?CarAccTimings@@YAXPAUCarStruct@@@Z		; CarAccTimings
;	COMDAT __real@3c372c52
CONST	SEGMENT
__real@3c372c52 DD 03c372c52r			; 0.01118
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CarAccTimings@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_carVel$ = -4						; size = 4
_car$ = 8						; size = 4
?CarAccTimings@@YAXPAUCarStruct@@@Z PROC NEAR		; CarAccTimings, COMDAT

; 3142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3143 : 	REAL carVel;
; 3144 : 
; 3145 : 	carVel = OGU2MPH_SPEED * VecLen(&car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+36]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+40]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fmul	DWORD PTR __real@3c372c52
	fstp	DWORD PTR _carVel$[ebp]

; 3146 : 
; 3147 : 	// See if timing should start
; 3148 : 	if (carVel < Real(0.01)) {

	fld	DWORD PTR _carVel$[ebp]
	fcomp	DWORD PTR __real@3c23d70a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82648

; 3149 : 		car->Timing0to15 = TRUE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3817], 1

; 3150 : 		car->Timing0to25 = TRUE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3818], 1

; 3151 : 		car->Current0to15 = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3484], 0

; 3152 : 		car->Current0to25 = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3492], 0

; 3153 : 		return;

	jmp	$L82643
$L82648:

; 3154 : 	}
; 3155 : 
; 3156 : 	// Update timers
; 3157 : 	if (car->Timing0to15) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3817]
	test	ecx, ecx
	je	SHORT $L82649

; 3158 : 		car->Current0to15 += TimeStep;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+3484]
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+3484]
$L82649:

; 3159 : 	}
; 3160 : 	if (car->Timing0to25) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3818]
	test	ecx, ecx
	je	SHORT $L82650

; 3161 : 		car->Current0to25 += TimeStep;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+3492]
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+3492]
$L82650:

; 3162 : 	}
; 3163 : 
; 3164 : 	// See if the speeds have been reached
; 3165 : 	if (car->Timing0to15 && carVel > 15) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3817]
	test	ecx, ecx
	je	SHORT $L82651
	fld	DWORD PTR _carVel$[ebp]
	fcomp	DWORD PTR __real@41700000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82651

; 3166 : 		if ((car->Current0to15 < car->Best0to15) || (car->Best0to15 < ZERO)) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3484]
	fcomp	DWORD PTR [ecx+3488]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82653
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3488]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82652
$L82653:

; 3167 : 			car->Best0to15 = car->Current0to15;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3484]
	mov	DWORD PTR [eax+3488], edx
$L82652:

; 3168 : 		}
; 3169 : 		car->Timing0to15 = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3817], 0
$L82651:

; 3170 : 	}
; 3171 : 	if (car->Timing0to25 && carVel > 25) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3818]
	test	ecx, ecx
	je	SHORT $L82643
	fld	DWORD PTR _carVel$[ebp]
	fcomp	DWORD PTR __real@41c80000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82643

; 3172 : 		if ((car->Current0to25 < car->Best0to25) || (car->Best0to25 < ZERO)) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3492]
	fcomp	DWORD PTR [ecx+3496]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L82656
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+3496]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82655
$L82656:

; 3173 : 			car->Best0to25 = car->Current0to25;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3492]
	mov	DWORD PTR [eax+3496], edx
$L82655:

; 3174 : 		}
; 3175 : 		car->Timing0to25 = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3818], 0
$L82643:

; 3176 : 	}
; 3177 : 
; 3178 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CarAccTimings@@YAXPAUCarStruct@@@Z ENDP		; CarAccTimings
_TEXT	ENDS
PUBLIC	__real@3fc00000
PUBLIC	?CarDownForce@@YAXPAUCarStruct@@@Z		; CarDownForce
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CarDownForce@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
tv194 = -96						; size = 4
_contact$ = -28						; size = 4
_downForce$ = -24					; size = 12
_mod$ = -12						; size = 4
_vel$ = -8						; size = 4
_ii$ = -4						; size = 4
_car$ = 8						; size = 4
?CarDownForce@@YAXPAUCarStruct@@@Z PROC NEAR		; CarDownForce, COMDAT

; 3198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 3199 : #ifndef _PSX
; 3200 : 	int ii;
; 3201 : 	REAL vel, mod;
; 3202 : 	VEC downForce = {ZERO, ZERO, ZERO};

	mov	DWORD PTR _downForce$[ebp], 0
	mov	DWORD PTR _downForce$[ebp+4], 0
	mov	DWORD PTR _downForce$[ebp+8], 0

; 3203 : 	long contact = 0;

	mov	DWORD PTR _contact$[ebp], 0

; 3204 : 
; 3205 : 	// Set up the wheel contact flags
; 3206 : 	for (ii = 0; ii < CAR_NWHEELS; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82670
$L82671:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82670:
	cmp	DWORD PTR _ii$[ebp], 4
	jge	SHORT $L82672

; 3207 : 		if (IsWheelPresent(&car->Wheel[ii]) && IsWheelInContact(&car->Wheel[ii])) {

	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 1
	je	SHORT $L82673
	mov	eax, DWORD PTR _ii$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 8
	je	SHORT $L82673

; 3208 : 			contact |= 1 << ii;

	mov	eax, 1
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _contact$[ebp]
	mov	DWORD PTR _contact$[ebp], eax
$L82673:

; 3209 : 		}
; 3210 : 	}

	jmp	SHORT $L82671
$L82672:

; 3211 : 
; 3212 : 	// if all wheel in contact, no need to continue
; 3213 : 	if (contact == (WFL_CONTACT | WFR_CONTACT | WBL_CONTACT | WBR_CONTACT)) return;

	cmp	DWORD PTR _contact$[ebp], 15		; 0000000fH
	jne	SHORT $L82674
	jmp	$L82664
$L82674:

; 3214 : 
; 3215 : 	mod = ONE + HALF - abs(VecDotVec(&car->Body->Centre.WMatrix.mv[U], &UpVec));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fmul	DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83071
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fmul	DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv194[ebp]
	jmp	SHORT $L83072
$L83071:
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fmul	DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fmul	DWORD PTR [eax+116]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fmul	DWORD PTR [edx+120]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR tv194[ebp]
$L83072:
	fld	DWORD PTR __real@3fc00000
	fsub	DWORD PTR tv194[ebp]
	fstp	DWORD PTR _mod$[ebp]

; 3216 : 	if (mod > ONE) mod = ONE;

	fld	DWORD PTR _mod$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82675
	mov	DWORD PTR _mod$[ebp], 1065353216	; 3f800000H
$L82675:

; 3217 : 
; 3218 : 	// See if car on two wheel on left side
; 3219 : 	if (contact == (WFL_CONTACT | WBL_CONTACT)) {

	cmp	DWORD PTR _contact$[ebp], 5
	jne	$L82676

; 3220 : 		vel = MulScalar(TimeStep, VecDotVec(&car->Body->Centre.Vel, &car->Body->Centre.WMatrix.mv[L]));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+128]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+132]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _vel$[ebp]

; 3221 : 		vel = MulScalar(vel, mod);

	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR _mod$[ebp]
	fstp	DWORD PTR _vel$[ebp]

; 3222 : 		VecPlusEqScalarVec(&downForce, MulScalar(car->DownForceMod, vel), &car->Body->Centre.WMatrix.mv[U]);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+852]
	fmul	DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+112]
	fadd	DWORD PTR _downForce$[ebp]
	fstp	DWORD PTR _downForce$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+852]
	fmul	DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+116]
	fadd	DWORD PTR _downForce$[ebp+4]
	fstp	DWORD PTR _downForce$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+852]
	fmul	DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+120]
	fadd	DWORD PTR _downForce$[ebp+8]
	fstp	DWORD PTR _downForce$[ebp+8]
$L82676:

; 3223 : 	}
; 3224 : 
; 3225 : 	// See if car on two wheel on right side
; 3226 : 	if (contact == (WFR_CONTACT | WBR_CONTACT)) {

	cmp	DWORD PTR _contact$[ebp], 10		; 0000000aH
	jne	$L82677

; 3227 : 		vel = MulScalar(TimeStep, VecDotVec(&car->Body->Centre.Vel, &car->Body->Centre.WMatrix.mv[L]));

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+128]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+132]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _vel$[ebp]

; 3228 : 		vel = MulScalar(vel, mod);

	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR _mod$[ebp]
	fstp	DWORD PTR _vel$[ebp]

; 3229 : 		VecPlusEqScalarVec(&downForce, MulScalar(car->DownForceMod, vel), &car->Body->Centre.WMatrix.mv[U]);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+852]
	fmul	DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+112]
	fadd	DWORD PTR _downForce$[ebp]
	fstp	DWORD PTR _downForce$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+852]
	fmul	DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+116]
	fadd	DWORD PTR _downForce$[ebp+4]
	fstp	DWORD PTR _downForce$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+852]
	fmul	DWORD PTR _vel$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fmul	DWORD PTR [edx+120]
	fadd	DWORD PTR _downForce$[ebp+8]
	fstp	DWORD PTR _downForce$[ebp+8]
$L82677:

; 3230 : 	}
; 3231 : 
; 3232 : 	VecPlusEqVec(&car->Body->Centre.Impulse, &downForce);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _downForce$[ebp]
	fadd	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+56]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _downForce$[ebp+4]
	fadd	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+60]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR _downForce$[ebp+8]
	fadd	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+64]

; 3233 : 
; 3234 : #if USE_DEBUG_ROUTINES
; 3235 : 	CopyVec(&downForce, &DEBUG_DownForce);

	mov	eax, DWORD PTR _downForce$[ebp]
	mov	DWORD PTR ?DEBUG_DownForce@@3UVectorStruct@@A, eax
	mov	eax, DWORD PTR _downForce$[ebp+4]
	mov	DWORD PTR ?DEBUG_DownForce@@3UVectorStruct@@A+4, eax
	mov	eax, DWORD PTR _downForce$[ebp+8]
	mov	DWORD PTR ?DEBUG_DownForce@@3UVectorStruct@@A+8, eax
$L82664:

; 3236 : #endif
; 3237 : 
; 3238 : #endif
; 3239 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CarDownForce@@YAXPAUCarStruct@@@Z ENDP			; CarDownForce
_TEXT	ENDS
EXTRN	?COL_NWheelColls@@3HA:DWORD			; COL_NWheelColls
; Function compile flags: /Odt /ZI
;	COMDAT ?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z
_TEXT	SEGMENT
_oldHead$ = -4						; size = 4
_car$ = 8						; size = 4
_newHead$ = 12						; size = 4
?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z PROC NEAR ; AddWheelColl, COMDAT

; 3249 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3250 : 	COLLINFO_WHEEL *oldHead = car->WheelCollHead;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3576]
	mov	DWORD PTR _oldHead$[ebp], ecx

; 3251 : 
; 3252 : 	car->WheelCollHead = newHead;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _newHead$[ebp]
	mov	DWORD PTR [eax+3576], ecx

; 3253 : 	newHead->Next = oldHead;

	mov	eax, DWORD PTR _newHead$[ebp]
	mov	ecx, DWORD PTR _oldHead$[ebp]
	mov	DWORD PTR [eax+104], ecx

; 3254 : 	newHead->Prev = NULL;

	mov	eax, DWORD PTR _newHead$[ebp]
	mov	DWORD PTR [eax+108], 0

; 3255 : 
; 3256 : 	if (oldHead != NULL) {

	cmp	DWORD PTR _oldHead$[ebp], 0
	je	SHORT $L82683

; 3257 : 		oldHead->Prev = newHead;

	mov	eax, DWORD PTR _oldHead$[ebp]
	mov	ecx, DWORD PTR _newHead$[ebp]
	mov	DWORD PTR [eax+108], ecx
$L82683:

; 3258 : 	}
; 3259 : 
; 3260 : 	car->NWheelColls++;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3580]
	add	ecx, 1
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3580], ecx

; 3261 : 	COL_NWheelColls++;

	mov	eax, DWORD PTR ?COL_NWheelColls@@3HA	; COL_NWheelColls
	add	eax, 1
	mov	DWORD PTR ?COL_NWheelColls@@3HA, eax	; COL_NWheelColls

; 3262 : 
; 3263 : 	return newHead;

	mov	eax, DWORD PTR _newHead$[ebp]

; 3264 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddWheelColl@@YAPAUWheelCollInfoStruct@@PAUCarStruct@@PAU1@@Z ENDP ; AddWheelColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z@4JA ; `RemoveWheelColl'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z@4JA DD 0cc9H ; `RemoveWheelColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z
_TEXT	SEGMENT
tv129 = -68						; size = 4
_car$ = 8						; size = 4
_collInfo$ = 12						; size = 4
?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z PROC NEAR ; RemoveWheelColl, COMDAT

; 3273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3274 : 	Assert(collInfo != NULL);

	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z@4JA
	add	eax, 1
	push	eax
	cmp	DWORD PTR _collInfo$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 3275 : 
; 3276 : 	if (collInfo->Next != NULL) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $L82689

; 3277 : 		(collInfo->Next)->Prev = collInfo->Prev;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+108], eax
$L82689:

; 3278 : 	}
; 3279 : 
; 3280 : 	if (collInfo->Prev != NULL) {

	mov	eax, DWORD PTR _collInfo$[ebp]
	cmp	DWORD PTR [eax+108], 0
	je	SHORT $L82690

; 3281 : 		(collInfo->Prev)->Next = collInfo->Next;

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR _collInfo$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR [ecx+104], eax

; 3282 : 	} else {

	jmp	SHORT $L82691
$L82690:

; 3283 : 		car->WheelCollHead = collInfo->Next;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _collInfo$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+3576], edx
$L82691:

; 3284 : 	}
; 3285 : 
; 3286 : 	car->NWheelColls--;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3580]
	sub	ecx, 1
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3580], ecx

; 3287 : 
; 3288 : 	Assert((car->NWheelColls == 0)? (car->WheelCollHead == NULL): (car->WheelCollHead != NULL));

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3580], 0
	jne	SHORT $L83079
	mov	ecx, DWORD PTR _car$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+3576], 0
	sete	dl
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $L83080
$L83079:
	mov	eax, DWORD PTR _car$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+3576], 0
	setne	cl
	mov	DWORD PTR tv129[ebp], ecx
$L83080:
	push	OFFSET FLAT:??_C@_0II@DDBJOEPG@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z@4JA
	add	edx, 15					; 0000000fH
	push	edx
	mov	al, BYTE PTR tv129[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 3289 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveWheelColl@@YAXPAUCarStruct@@PAUWheelCollInfoStruct@@@Z ENDP ; RemoveWheelColl
_TEXT	ENDS
END
