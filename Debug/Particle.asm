; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Particle.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParticleMass@@YAXPAUParticleStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateParticle@@YAXPAUParticleStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParticleWorldColls@@YAXPAUParticleStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	__real@3f800000
PUBLIC	?SetParticleMass@@YAXPAUParticleStruct@@M@Z	; SetParticleMass
EXTRN	__fltused:NEAR
;	COMDAT __real@3f800000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\particle.cpp
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SetParticleMass@@YAXPAUParticleStruct@@M@Z
_TEXT	SEGMENT
_particle$ = 8						; size = 4
_newMass$ = 12						; size = 4
?SetParticleMass@@YAXPAUParticleStruct@@M@Z PROC NEAR	; SetParticleMass, COMDAT

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 19   : 	particle->Mass = newMass;

	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _newMass$[ebp]
	mov	DWORD PTR [eax], ecx

; 20   : 	particle->InvMass = DivScalar(ONE, newMass);

	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _newMass$[ebp]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+4]

; 21   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetParticleMass@@YAXPAUParticleStruct@@M@Z ENDP	; SetParticleMass
_TEXT	ENDS
PUBLIC	?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z ; ApplyParticleImpulse
; Function compile flags: /Odt /ZI
;	COMDAT ?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_particle$ = 8						; size = 4
_impulse$ = 12						; size = 4
?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z PROC NEAR ; ApplyParticleImpulse, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	VecPlusEqVec(&particle->Impulse, impulse);

	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax+56]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+56]
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax+60]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+60]
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _impulse$[ebp]
	fld	DWORD PTR [eax+64]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+64]

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ApplyParticleImpulse@@YAXPAUParticleStruct@@PAUVectorStruct@@@Z ENDP ; ApplyParticleImpulse
_TEXT	ENDS
PUBLIC	__real@42f00000
PUBLIC	?UpdateParticle@@YAXPAUParticleStruct@@M@Z	; UpdateParticle
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateParticle@@YAXPAUParticleStruct@@M@Z
_TEXT	SEGMENT
_tReal$ = -16						; size = 4
_oldVel$ = -12						; size = 12
_particle$ = 8						; size = 4
_dt$ = 12						; size = 4
?UpdateParticle@@YAXPAUParticleStruct@@M@Z PROC NEAR	; UpdateParticle, COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 52   : 	VEC	oldVel;
; 53   : 	REAL	tReal;
; 54   : 
; 55   : 	// Shift body out of contacts
; 56   : 	VecPlusEqVec(&particle->Pos, &particle->Shift);

	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+200]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+24]
	fadd	DWORD PTR [ecx+204]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR [ecx+208]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+28]

; 57   : 	SetVecZero(&particle->Shift);

	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [eax+200], 0
	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [eax+204], 0
	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [eax+208], 0

; 58   : 
; 59   : 	// Store the old position and world matrices
; 60   : 	CopyVec(&particle->Pos, &particle->OldPos);

	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+16], edx

; 61   : 	CopyVec(&particle->Vel, &oldVel);

	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _oldVel$[ebp], ecx
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _oldVel$[ebp+4], ecx
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _oldVel$[ebp+8], ecx

; 62   : 
; 63   : 	// Update particle velocity from the acceleration
; 64   : 	VecPlusEqScalarVec(&particle->Vel, particle->InvMass, &particle->Impulse);

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+36]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+40]

; 65   : 
; 66   : 	// Damp the velocity from the air resistance
; 67   : 	tReal = MulScalar(particle->Resistance, MulScalar(FRICTION_TIME_SCALE, dt));

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+176]
	fld	DWORD PTR __real@42f00000
	fmul	DWORD PTR _dt$[ebp]
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR _tReal$[ebp]

; 68   : 	VecMulScalar(&particle->Vel, ONE - tReal);

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _tReal$[ebp]
	mov	eax, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [ecx+32]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _tReal$[ebp]
	mov	eax, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [ecx+36]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _tReal$[ebp]
	mov	eax, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [ecx+40]

; 69   : 
; 70   : 	// Update particle position from the velocity
; 71   : 	VecPlusEqScalarVec(&particle->Pos, dt, &particle->Vel);

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR _dt$[ebp]
	fmul	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+28]

; 72   : 
; 73   : 	// Reset the impulse for the next timestep
; 74   : 	SetVecZero(&particle->Impulse);

	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [eax+60], 0
	mov	eax, DWORD PTR _particle$[ebp]
	mov	DWORD PTR [eax+64], 0

; 75   : 
; 76   : 	// Recalculate acceleration from change in velocity
; 77   : 	VecMinusVec(&particle->Vel, &oldVel, &particle->Acc);

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+32]
	fsub	DWORD PTR _oldVel$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR _oldVel$[ebp+4]
	mov	ecx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+40]
	fsub	DWORD PTR _oldVel$[ebp+8]
	mov	ecx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [ecx+52]

; 78   : 
; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateParticle@@YAXPAUParticleStruct@@M@Z ENDP		; UpdateParticle
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@40000000
PUBLIC	?ParticleWorldColls@@YAXPAUParticleStruct@@@Z	; ParticleWorldColls
EXTRN	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z:NEAR ; PosToCollGrid
EXTRN	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z:NEAR ; PointInCollPolyBounds
EXTRN	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z:NEAR ; LinePlaneIntersect
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ParticleWorldColls@@YAXPAUParticleStruct@@@Z
_TEXT	SEGMENT
tv221 = -140						; size = 4
tv202 = -140						; size = 4
tv186 = -140						; size = 4
tv170 = -140						; size = 4
tv154 = -140						; size = 4
tv138 = -140						; size = 4
tv90 = -140						; size = 4
_grid$ = -72						; size = 4
_collPoly$ = -68					; size = 4
_bBox$ = -64						; size = 24
_wPos$ = -40						; size = 12
_dPos$ = -28						; size = 12
_velDotNorm$ = -16					; size = 4
_depth$ = -12						; size = 4
_time$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_particle$ = 8						; size = 4
?ParticleWorldColls@@YAXPAUParticleStruct@@@Z PROC NEAR	; ParticleWorldColls, COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 90   : 	int iPoly;
; 91   : 	REAL time, depth, velDotNorm;
; 92   : 	VEC dPos, wPos;
; 93   : 	BBOX bBox;
; 94   : 	NEWCOLLPOLY *collPoly;
; 95   : 	COLLGRID *grid;
; 96   : 
; 97   : 	// Get the current collision grid
; 98   : 	grid = PosToCollGrid(&particle->Pos);

	mov	eax, DWORD PTR _particle$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ; PosToCollGrid
	add	esp, 4
	mov	DWORD PTR _grid$[ebp], eax

; 99   : 	if (grid == NULL) return;

	cmp	DWORD PTR _grid$[ebp], 0
	jne	SHORT $L75299
	jmp	$L75289
$L75299:

; 100  : 
; 101  : 	// loop over all polys in the grid
; 102  : 	for (iPoly = 0; iPoly < grid->NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L75300
$L75301:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L75300:
	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR _iPoly$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$L75289

; 103  : #ifndef _PSX
; 104  : 		collPoly = grid->CollPolyPtr[iPoly];

	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iPoly$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _collPoly$[ebp], eax

; 105  : #else
; 106  : 		collPoly = &COL_WorldCollPoly[grid->CollPolyIndices[iPoly]];
; 107  : #endif
; 108  : 
; 109  : 		if (PolyCameraOnly(collPoly)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $L75303
	jmp	SHORT $L75301
$L75303:

; 110  : 
; 111  : 		// Quick bounding-box test
; 112  : 		SetBBox(&bBox, 
; 113  : 			Min(particle->Pos.v[X], particle->OldPos.v[X]),
; 114  : 			Max(particle->Pos.v[X], particle->OldPos.v[X]),
; 115  : 			Min(particle->Pos.v[Y], particle->OldPos.v[Y]),
; 116  : 			Max(particle->Pos.v[Y], particle->OldPos.v[Y]),
; 117  : 			Min(particle->Pos.v[Z], particle->OldPos.v[Z]),
; 118  : 			Max(particle->Pos.v[Z], particle->OldPos.v[Z]));

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L75436
	mov	edx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $L75437
$L75436:
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv90[ebp], edx
$L75437:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR _bBox$[ebp], eax
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L75438
	mov	edx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $L75439
$L75438:
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv138[ebp], edx
$L75439:
	mov	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _bBox$[ebp+4], eax
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L75440
	mov	edx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv154[ebp], eax
	jmp	SHORT $L75441
$L75440:
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv154[ebp], edx
$L75441:
	mov	eax, DWORD PTR tv154[ebp]
	mov	DWORD PTR _bBox$[ebp+8], eax
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L75442
	mov	edx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $L75443
$L75442:
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv170[ebp], edx
$L75443:
	mov	eax, DWORD PTR tv170[ebp]
	mov	DWORD PTR _bBox$[ebp+12], eax
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L75444
	mov	edx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $L75445
$L75444:
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv186[ebp], edx
$L75445:
	mov	eax, DWORD PTR tv186[ebp]
	mov	DWORD PTR _bBox$[ebp+16], eax
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L75446
	mov	edx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv202[ebp], eax
	jmp	SHORT $L75447
$L75446:
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv202[ebp], edx
$L75447:
	mov	eax, DWORD PTR tv202[ebp]
	mov	DWORD PTR _bBox$[ebp+20], eax

; 119  : 		if(!BBTestYXZ(&bBox, &collPoly->BBox)) continue;

	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+8]
	fcomp	DWORD PTR [eax+100]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L75448
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+12]
	fcomp	DWORD PTR [ecx+96]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L75448
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp]
	fcomp	DWORD PTR [edx+92]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L75448
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+4]
	fcomp	DWORD PTR [eax+88]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L75448
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+16]
	fcomp	DWORD PTR [ecx+108]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L75448
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR _bBox$[ebp+20]
	fcomp	DWORD PTR [edx+104]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L75448
	mov	DWORD PTR tv221[ebp], 1
	jmp	SHORT $L75449
$L75448:
	mov	DWORD PTR tv221[ebp], 0
$L75449:
	cmp	DWORD PTR tv221[ebp], 0
	jne	SHORT $L75304
	jmp	$L75301
$L75304:

; 120  : 
; 121  : 		// Check for point passing through collision polygon
; 122  : 		if (!LinePlaneIntersect(&particle->OldPos, &particle->Pos, &collPoly->Plane, &time, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _collPoly$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _particle$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _particle$[ebp]
	add	ecx, 8
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L75305

; 123  : 			continue;

	jmp	$L75301
$L75305:

; 124  : 		}
; 125  : 
; 126  : 		// Calculate the intersection point
; 127  : 		VecMinusVec(&particle->Pos, &particle->OldPos, &dPos);

	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dPos$[ebp]
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dPos$[ebp+4]
	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _particle$[ebp]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR [ecx+16]
	fstp	DWORD PTR _dPos$[ebp+8]

; 128  : 		VecPlusScalarVec(&particle->OldPos, time, &dPos, &wPos);

	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp]
	mov	eax, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _wPos$[ebp]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+4]
	mov	eax, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _wPos$[ebp+4]
	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR _dPos$[ebp+8]
	mov	eax, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [eax+16]
	fstp	DWORD PTR _wPos$[ebp+8]

; 129  : 
; 130  : 		// Make sure the particle is travelling towards the poly
; 131  : 		velDotNorm = VecDotVec(&particle->Vel, PlaneNormal(&collPoly->Plane));

	mov	eax, DWORD PTR _particle$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _particle$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _particle$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+40]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDotNorm$[ebp]

; 132  : 		if (velDotNorm > ZERO) continue;

	fld	DWORD PTR _velDotNorm$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L75309
	jmp	$L75301
$L75309:

; 133  : 
; 134  : 
; 135  : 		// Check intersection point is within the polygon boundary
; 136  : 		if (!PointInCollPolyBounds(&wPos, collPoly)) {

	mov	eax, DWORD PTR _collPoly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wPos$[ebp]
	push	ecx
	call	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ; PointInCollPolyBounds
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L75310

; 137  : 			continue;

	jmp	$L75301
$L75310:

; 138  : 		}
; 139  : 
; 140  : 		// Keep particle on inside of the poly
; 141  : 		VecPlusEqScalarVec(&particle->Pos, -depth + COLL_EPSILON, PlaneNormal(&collPoly->Plane));

	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+20]
	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+24]
	fld	DWORD PTR _depth$[ebp]
	fchs
	fadd	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+28]

; 142  : 
; 143  : 		// Rebound
; 144  : 		VecPlusEqScalarVec(&particle->Vel, -velDotNorm, PlaneNormal(&collPoly->Plane));

	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+32]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+36]
	fld	DWORD PTR _velDotNorm$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+40]

; 145  : 		VecMulScalar(&particle->Vel, (ONE - particle->KineticFriction));

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR [eax+188]
	mov	ecx, DWORD PTR _particle$[ebp]
	fmul	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [edx+40]

; 146  : 		VecPlusEqScalarVec(&particle->Vel, -(particle->Hardness * velDotNorm), PlaneNormal(&collPoly->Plane));

	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [eax+172]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+32]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [eax+172]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+36]
	mov	eax, DWORD PTR _particle$[ebp]
	fld	DWORD PTR _velDotNorm$[ebp]
	fmul	DWORD PTR [eax+172]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _particle$[ebp]
	fadd	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+40]

; 147  : 
; 148  : 
; 149  : 	}

	jmp	$L75301
$L75289:

; 150  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ParticleWorldColls@@YAXPAUParticleStruct@@@Z ENDP	; ParticleWorldColls
_TEXT	ENDS
END
