; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Debug.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CH@CBAEPAF@Could?5not?5Allocate?5RAM?5for?5memor@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@DBGPFNEG@Attempt?5to?5free?5null?5memory?5stor@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BJDPPPKN@Could?5not?5Allocate?5RAM?6Line?3?5?$CFd?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DP@JMEOMHLA@Attempt?5to?5free?5non?9allocated?5RA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FK@IGDGLFCD@Too?5much?5memory?5is?5being?5dealloc@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@GGIDFJDI@Still?5have?5RAM?5allocated?6Printin@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PAGJHDGA@Check?5Log?5file?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@FFBNDHMB@Mail?5log?5file?5?$CC?$CFs?$CC?5to?5Chris?5plea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NHDFDKCG@Mysterious?5Warning?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DDDCCGCH@Could?5not?5open?5log?5file?5?$CC?$CFs?$CC?5for@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@HKNMGFDE@?6Max?5Impulse?5Magnitude?3?5?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@DONCIOGO@?6Max?5Ang?5Imp?5Magnitude?3?5?5?$CFf?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JJIOEOHO@Max?5RAM?5?5allocated?3?5?5?5?5?5?$CFld?5byte@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@GEHFDLPF@RAM?5still?5allocated?3?5?5?5?5?$CFld?5byte@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@CFAIOBIH@Blocks?5still?5allocated?3?5?$CFld?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PJMBNNFG@Block?5?$CF5d?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@DALNCJPK@?7Size?3?5?$CFld?5bytes?6?7File?3?5?$CFs?6?7Line@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@BMNBDENO@ReVolt?5Error?5Log?5File?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PFILLFIL@Feb?514?52021?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IBCLGHOJ@13?338?309?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@FOBGGEGJ@Compilation?5date?5?$CFs?0?5?$CFs?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@ECJLPDFE@Assertion?5Failed?6Line?3?5?$CFd?6File?3?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@OLCABPAK@ERROR?5?$CI?$CFd?$CJ?5in?5?$CFs?5?9?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMemStore@@YA_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteMemStore@@YAXPAUMemStorageStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextMemStore@@YAPAUMemStorageStruct@@PAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DebugMalloc@@YAPAXIHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DebugFree@@YAXPAXHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckMemoryAllocation@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteLogEntry@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitLogFile@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DebugAssert@@YAX_NHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Error@@YAXPAD00J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?DBG_NAllocations@@3IA				; DBG_NAllocations
PUBLIC	?DBG_AllocatedRAM@@3IA				; DBG_AllocatedRAM
PUBLIC	?DBG_LogFile@@3PADA				; DBG_LogFile
PUBLIC	?TellChris@@3_NA				; TellChris
_BSS	SEGMENT
?DBG_NAllocations@@3IA DD 01H DUP (?)			; DBG_NAllocations
_MemStoreHead DD 01H DUP (?)
_MaxAllocatedRAM DD 01H DUP (?)
_AlreadyWarned DB 01H DUP (?)
	ALIGN	4

_AlreadyAsserted DB 01H DUP (?)
	ALIGN	4

?DBG_AllocatedRAM@@3IA DD 01H DUP (?)			; DBG_AllocatedRAM
?DBG_LogFile@@3PADA DD 01H DUP (?)			; DBG_LogFile
?TellChris@@3_NA DB 01H DUP (?)				; TellChris
_BSS	ENDS
PUBLIC	?AddMemStore@@YA_NXZ				; AddMemStore
PUBLIC	??_C@_0CH@CBAEPAF@Could?5not?5Allocate?5RAM?5for?5memor@ ; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
EXTRN	__imp__LocalAlloc@8:NEAR
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	__imp__wsprintfA:NEAR
_BSS	SEGMENT
	ALIGN	4

_ErrorMessage DB 0400H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CH@CBAEPAF@Could?5not?5Allocate?5RAM?5for?5memor@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\debug.cpp
CONST	SEGMENT
??_C@_0CH@CBAEPAF@Could?5not?5Allocate?5RAM?5for?5memor@ DB 'Could not Al'
	DB	'locate RAM for memory list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AddMemStore@@YA_NXZ
_TEXT	SEGMENT
_oldHead$ = -4						; size = 4
?AddMemStore@@YA_NXZ PROC NEAR				; AddMemStore, COMDAT

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 33   : 	MEMSTORE *oldHead;
; 34   : 	
; 35   : 	oldHead = MemStoreHead;

	mov	eax, DWORD PTR _MemStoreHead
	mov	DWORD PTR _oldHead$[ebp], eax

; 36   : 
; 37   : 	// create new memory info store
; 38   : 	MemStoreHead = (MEMSTORE *)ReleaseMalloc(sizeof(MEMSTORE));

	push	24					; 00000018H
	push	0
	call	DWORD PTR __imp__LocalAlloc@8
	mov	DWORD PTR _MemStoreHead, eax

; 39   : 	if (MemStoreHead == NULL) {

	cmp	DWORD PTR _MemStoreHead, 0
	jne	SHORT $L75923

; 40   : 		wsprintf(ErrorMessage, "Could not Allocate RAM for memory list");

	push	OFFSET FLAT:??_C@_0CH@CBAEPAF@Could?5not?5Allocate?5RAM?5for?5memor@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 41   : 		Box("Error", ErrorMessage, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 42   : 		return FALSE;

	xor	al, al
	jmp	SHORT $L75918
$L75923:

; 43   : 	}
; 44   : 
; 45   : 	MemStoreHead->Next = oldHead;

	mov	eax, DWORD PTR _MemStoreHead
	mov	ecx, DWORD PTR _oldHead$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 46   : 	MemStoreHead->Prev = NULL;

	mov	eax, DWORD PTR _MemStoreHead
	mov	DWORD PTR [eax+16], 0

; 47   : 	if (oldHead != NULL) {

	cmp	DWORD PTR _oldHead$[ebp], 0
	je	SHORT $L75926

; 48   : 		oldHead->Prev = MemStoreHead;

	mov	eax, DWORD PTR _oldHead$[ebp]
	mov	ecx, DWORD PTR _MemStoreHead
	mov	DWORD PTR [eax+16], ecx
$L75926:

; 49   : 	}
; 50   : 	return TRUE;

	mov	al, 1
$L75918:

; 51   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddMemStore@@YA_NXZ ENDP				; AddMemStore
_TEXT	ENDS
PUBLIC	?DeleteMemStore@@YAXPAUMemStorageStruct@@@Z	; DeleteMemStore
PUBLIC	??_C@_0CC@DBGPFNEG@Attempt?5to?5free?5null?5memory?5stor@ ; `string'
EXTRN	__imp__LocalFree@4:NEAR
;	COMDAT ??_C@_0CC@DBGPFNEG@Attempt?5to?5free?5null?5memory?5stor@
CONST	SEGMENT
??_C@_0CC@DBGPFNEG@Attempt?5to?5free?5null?5memory?5stor@ DB 'Attempt to '
	DB	'free null memory store', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DeleteMemStore@@YAXPAUMemStorageStruct@@@Z
_TEXT	SEGMENT
_memStore$ = 8						; size = 4
?DeleteMemStore@@YAXPAUMemStorageStruct@@@Z PROC NEAR	; DeleteMemStore, COMDAT

; 59   : void DeleteMemStore(MEMSTORE *memStore) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 60   : 
; 61   : 	if (memStore == NULL) {

	cmp	DWORD PTR _memStore$[ebp], 0
	jne	SHORT $L75930

; 62   : 		wsprintf(ErrorMessage, "Attempt to free null memory store");

	push	OFFSET FLAT:??_C@_0CC@DBGPFNEG@Attempt?5to?5free?5null?5memory?5stor@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 63   : 		Box("Error", ErrorMessage, MB_OK | MB_ICONEXCLAMATION);

	push	48					; 00000030H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 64   : 		return;

	jmp	SHORT $L75929
$L75930:

; 65   : 	}
; 66   : 
; 67   : 	// Set up the pointers on the adjacent list elements
; 68   : 	if (memStore->Prev != NULL) {

	mov	eax, DWORD PTR _memStore$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L75932

; 69   : 		(memStore->Prev)->Next = memStore->Next;

	mov	eax, DWORD PTR _memStore$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _memStore$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax

; 70   : 	} else {

	jmp	SHORT $L75933
$L75932:

; 71   : 		MemStoreHead = memStore->Next;

	mov	eax, DWORD PTR _memStore$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _MemStoreHead, ecx
$L75933:

; 72   : 	}
; 73   : 	if (memStore->Next != NULL) {

	mov	eax, DWORD PTR _memStore$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $L75934

; 74   : 		(memStore->Next)->Prev = memStore->Prev;

	mov	eax, DWORD PTR _memStore$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _memStore$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
$L75934:

; 75   : 	}
; 76   : 
; 77   : 	// delete the item
; 78   : 	ReleaseFree(memStore);

	mov	eax, DWORD PTR _memStore$[ebp]
	push	eax
	call	DWORD PTR __imp__LocalFree@4
$L75929:

; 79   : 
; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteMemStore@@YAXPAUMemStorageStruct@@@Z ENDP	; DeleteMemStore
_TEXT	ENDS
PUBLIC	?NextMemStore@@YAPAUMemStorageStruct@@PAU1@@Z	; NextMemStore
; Function compile flags: /Odt /ZI
;	COMDAT ?NextMemStore@@YAPAUMemStorageStruct@@PAU1@@Z
_TEXT	SEGMENT
_memStore$ = 8						; size = 4
?NextMemStore@@YAPAUMemStorageStruct@@PAU1@@Z PROC NEAR	; NextMemStore, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 91   : 	if (memStore == NULL) {

	cmp	DWORD PTR _memStore$[ebp], 0
	jne	SHORT $L75939

; 92   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75938
$L75939:

; 93   : 	}
; 94   : 
; 95   : 	return memStore->Next;

	mov	eax, DWORD PTR _memStore$[ebp]
	mov	eax, DWORD PTR [eax+20]
$L75938:

; 96   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextMemStore@@YAPAUMemStorageStruct@@PAU1@@Z ENDP	; NextMemStore
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BJDPPPKN@Could?5not?5Allocate?5RAM?6Line?3?5?$CFd?6@ ; `string'
PUBLIC	?DebugMalloc@@YAPAXIHPAD@Z			; DebugMalloc
PUBLIC	?WriteLogEntry@@YAXPAD@Z			; WriteLogEntry
;	COMDAT ??_C@_0CJ@BJDPPPKN@Could?5not?5Allocate?5RAM?6Line?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0CJ@BJDPPPKN@Could?5not?5Allocate?5RAM?6Line?3?5?$CFd?6@ DB 'Could '
	DB	'not Allocate RAM', 0aH, 'Line: %d', 0aH, 'File: %s', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DebugMalloc@@YAPAXIHPAD@Z
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
_size$ = 8						; size = 4
_line$ = 12						; size = 4
_file$ = 16						; size = 4
?DebugMalloc@@YAPAXIHPAD@Z PROC NEAR			; DebugMalloc, COMDAT

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 107  : 	void *ptr;
; 108  : 
; 109  : 	// Attempt to allocate the RAM as usual
; 110  : 	ptr = ReleaseMalloc(size + DEBUG_MEMGUARD_SIZE);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__LocalAlloc@8
	mov	DWORD PTR _ptr$[ebp], eax

; 111  : 	if (ptr == NULL) {

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $L75947

; 112  : 		// allocation failed
; 113  : 		wsprintf(ErrorMessage, "Could not Allocate RAM\nLine: %d\nFile: %s", line, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CJ@BJDPPPKN@Could?5not?5Allocate?5RAM?6Line?3?5?$CFd?6@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 114  : 		if (!AlreadyWarned) {

	movzx	eax, BYTE PTR _AlreadyWarned
	test	eax, eax
	jne	SHORT $L75949

; 115  : 			Box("Error", ErrorMessage, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 116  : 			AlreadyWarned = TRUE;

	mov	BYTE PTR _AlreadyWarned, 1
$L75949:

; 117  : 		}
; 118  : 		WriteLogEntry(ErrorMessage);

	push	OFFSET FLAT:_ErrorMessage
	call	?WriteLogEntry@@YAXPAD@Z		; WriteLogEntry
	add	esp, 4

; 119  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75944
$L75947:

; 120  : 	}
; 121  : 
; 122  : 	// Create a new item on the allocation list
; 123  : 	AddMemStore();

	call	?AddMemStore@@YA_NXZ			; AddMemStore

; 124  : 
; 125  : 	// Fill it with information
; 126  : 	MemStoreHead->Ptr = ptr;

	mov	eax, DWORD PTR _MemStoreHead
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 127  : 	MemStoreHead->Size = size;

	mov	eax, DWORD PTR _MemStoreHead
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 128  : 	MemStoreHead->Line = line;

	mov	eax, DWORD PTR _MemStoreHead
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 129  : 	MemStoreHead->File = file;

	mov	eax, DWORD PTR _MemStoreHead
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 130  : 
; 131  : 	// Set the guard byte
; 132  : #if DEBUG_USE_MEMGUARD
; 133  : 	*((char *)MemStoreHead->Ptr + MemStoreHead->Size) = (DEBUG_GUARD_TYPE)DEBUG_MEMGUARD_CONTENTS;
; 134  : #endif
; 135  : 
; 136  : 	// Keep track of allocated RAM
; 137  : 	DBG_AllocatedRAM += size;

	mov	eax, DWORD PTR ?DBG_AllocatedRAM@@3IA	; DBG_AllocatedRAM
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR ?DBG_AllocatedRAM@@3IA, eax	; DBG_AllocatedRAM

; 138  : 	DBG_NAllocations++;

	mov	eax, DWORD PTR ?DBG_NAllocations@@3IA	; DBG_NAllocations
	add	eax, 1
	mov	DWORD PTR ?DBG_NAllocations@@3IA, eax	; DBG_NAllocations

; 139  : 	if (DBG_AllocatedRAM > MaxAllocatedRAM) MaxAllocatedRAM = DBG_AllocatedRAM;

	mov	eax, DWORD PTR ?DBG_AllocatedRAM@@3IA	; DBG_AllocatedRAM
	cmp	eax, DWORD PTR _MaxAllocatedRAM
	jbe	SHORT $L75950
	mov	eax, DWORD PTR ?DBG_AllocatedRAM@@3IA	; DBG_AllocatedRAM
	mov	DWORD PTR _MaxAllocatedRAM, eax
$L75950:

; 140  : 
; 141  : 	return ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
$L75944:

; 142  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DebugMalloc@@YAPAXIHPAD@Z ENDP				; DebugMalloc
_TEXT	ENDS
PUBLIC	??_C@_0DP@JMEOMHLA@Attempt?5to?5free?5non?9allocated?5RA@ ; `string'
PUBLIC	??_C@_0FK@IGDGLFCD@Too?5much?5memory?5is?5being?5dealloc@ ; `string'
PUBLIC	?DebugFree@@YAXPAXHPAD@Z			; DebugFree
;	COMDAT ??_C@_0DP@JMEOMHLA@Attempt?5to?5free?5non?9allocated?5RA@
CONST	SEGMENT
??_C@_0DP@JMEOMHLA@Attempt?5to?5free?5non?9allocated?5RA@ DB 'Attempt to '
	DB	'free non-allocated RAM', 0aH, 'Freed at', 0aH, 09H, 'Line: %d'
	DB	0aH, 09H, 'File %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@IGDGLFCD@Too?5much?5memory?5is?5being?5dealloc@
CONST	SEGMENT
??_C@_0FK@IGDGLFCD@Too?5much?5memory?5is?5being?5dealloc@ DB 'Too much me'
	DB	'mory is being deallocated', 0aH, 09H, 'Line: %d', 0aH, 09H, 'F'
	DB	'ile %s', 0aH, '(Should never get this message!!)', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DebugFree@@YAXPAXHPAD@Z
_TEXT	SEGMENT
_nextMem$ = -12						; size = 4
_ptrStore$ = -8						; size = 4
_foundPtr$ = -1						; size = 1
_ptr$ = 8						; size = 4
_line$ = 12						; size = 4
_file$ = 16						; size = 4
?DebugFree@@YAXPAXHPAD@Z PROC NEAR			; DebugFree, COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 153  : 	bool foundPtr;
; 154  : 	MEMSTORE *ptrStore, *nextMem;
; 155  : 
; 156  : 	// do nothing for a null pointer
; 157  : 	if (ptr == NULL) {

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $L75959

; 158  : 		return;

	jmp	$L75955
$L75959:

; 159  : 	}
; 160  : 
; 161  : 	// locate the pointer in the allocated list
; 162  : 	foundPtr = FALSE;

	mov	BYTE PTR _foundPtr$[ebp], 0

; 163  : 	for (nextMem = MemStoreHead; nextMem != NULL; nextMem = NextMemStore(nextMem)) {

	mov	eax, DWORD PTR _MemStoreHead
	mov	DWORD PTR _nextMem$[ebp], eax
	jmp	SHORT $L75960
$L75961:
	mov	eax, DWORD PTR _nextMem$[ebp]
	push	eax
	call	?NextMemStore@@YAPAUMemStorageStruct@@PAU1@@Z ; NextMemStore
	add	esp, 4
	mov	DWORD PTR _nextMem$[ebp], eax
$L75960:
	cmp	DWORD PTR _nextMem$[ebp], 0
	je	SHORT $L75962

; 164  : 		if (nextMem->Ptr == ptr) {

	mov	eax, DWORD PTR _nextMem$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _ptr$[ebp]
	jne	SHORT $L75963

; 165  : 			ptrStore = nextMem;

	mov	eax, DWORD PTR _nextMem$[ebp]
	mov	DWORD PTR _ptrStore$[ebp], eax

; 166  : 			foundPtr = TRUE;

	mov	BYTE PTR _foundPtr$[ebp], 1

; 167  : 			break;

	jmp	SHORT $L75962
$L75963:

; 168  : 		}
; 169  : 	}

	jmp	SHORT $L75961
$L75962:

; 170  : 
; 171  : 	// make sure the memory has already been allocated
; 172  : 	if (!foundPtr) {

	movzx	eax, BYTE PTR _foundPtr$[ebp]
	test	eax, eax
	jne	SHORT $L75964

; 173  : 		wsprintf(ErrorMessage, "Attempt to free non-allocated RAM\nFreed at\n\tLine: %d\n\tFile %s\n", line, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DP@JMEOMHLA@Attempt?5to?5free?5non?9allocated?5RA@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 174  : 		if (!AlreadyWarned) {

	movzx	eax, BYTE PTR _AlreadyWarned
	test	eax, eax
	jne	SHORT $L75966

; 175  : 			Box("Error", ErrorMessage, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 176  : 			AlreadyWarned = TRUE;

	mov	BYTE PTR _AlreadyWarned, 1
$L75966:

; 177  : 		}
; 178  : 		WriteLogEntry(ErrorMessage);

	push	OFFSET FLAT:_ErrorMessage
	call	?WriteLogEntry@@YAXPAD@Z		; WriteLogEntry
	add	esp, 4

; 179  : 		return;

	jmp	$L75955
$L75964:

; 180  : 	}
; 181  : 
; 182  : 	// Check to see if the Guard byte has been modified
; 183  : #if DEBUG_USE_MEMGUARD
; 184  : 	if (*(DEBUG_MEMGUARD_TYPE *)((char *)ptrStore->Ptr + ptrStore->Size) != DEBUG_MEMGUARD_CONTENTS) {
; 185  : 		wsprintf(ErrorMessage, "Guard byte overwritten\nAllocated at\n\tLine: %d\n\tFile %s\nFreed at\n\tLine: %d\n\tFile %s\n", ptrStore->Line, ptrStore->File, line, file);
; 186  : 		if (!AlreadyWarned) {
; 187  : 			Box("Warning", ErrorMessage, MB_OK | MB_ICONEXCLAMATION);
; 188  : 			AlreadyWarned = TRUE;
; 189  : 		}
; 190  : 		WriteLogEntry(ErrorMessage);
; 191  : 	}
; 192  : #endif
; 193  : 
; 194  : 	// free the memory
; 195  : 	ReleaseFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	DWORD PTR __imp__LocalFree@4

; 196  : 
; 197  : 	// Update the allocated RAM amount
; 198  : 	DBG_AllocatedRAM -= ptrStore->Size;

	mov	eax, DWORD PTR _ptrStore$[ebp]
	mov	ecx, DWORD PTR ?DBG_AllocatedRAM@@3IA	; DBG_AllocatedRAM
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR ?DBG_AllocatedRAM@@3IA, ecx	; DBG_AllocatedRAM

; 199  : 	DBG_NAllocations --;

	mov	eax, DWORD PTR ?DBG_NAllocations@@3IA	; DBG_NAllocations
	sub	eax, 1
	mov	DWORD PTR ?DBG_NAllocations@@3IA, eax	; DBG_NAllocations

; 200  : 	if (DBG_AllocatedRAM < 0 || DBG_NAllocations < 0) {

	cmp	DWORD PTR ?DBG_AllocatedRAM@@3IA, 0	; DBG_AllocatedRAM
	jb	SHORT $L75969
	cmp	DWORD PTR ?DBG_NAllocations@@3IA, 0	; DBG_NAllocations
	jae	SHORT $L75968
$L75969:

; 201  : 		wsprintf(ErrorMessage, "Too much memory is being deallocated\n\tLine: %d\n\tFile %s\n(Should never get this message!!)", line, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0FK@IGDGLFCD@Too?5much?5memory?5is?5being?5dealloc@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 202  : 		if (!AlreadyWarned) {

	movzx	eax, BYTE PTR _AlreadyWarned
	test	eax, eax
	jne	SHORT $L75971

; 203  : 			Box("Error", ErrorMessage, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 204  : 			AlreadyWarned = TRUE;

	mov	BYTE PTR _AlreadyWarned, 1
$L75971:

; 205  : 		}
; 206  : 		WriteLogEntry(ErrorMessage);

	push	OFFSET FLAT:_ErrorMessage
	call	?WriteLogEntry@@YAXPAD@Z		; WriteLogEntry
	add	esp, 4

; 207  : 		return;

	jmp	SHORT $L75955
$L75968:

; 208  : 	}
; 209  : 
; 210  : 
; 211  : 	// free the memory store
; 212  : 	DeleteMemStore(ptrStore);

	mov	eax, DWORD PTR _ptrStore$[ebp]
	push	eax
	call	?DeleteMemStore@@YAXPAUMemStorageStruct@@@Z ; DeleteMemStore
	add	esp, 4
$L75955:

; 213  : 
; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DebugFree@@YAXPAXHPAD@Z ENDP				; DebugFree
_TEXT	ENDS
PUBLIC	??_C@_0CM@GGIDFJDI@Still?5have?5RAM?5allocated?6Printin@ ; `string'
PUBLIC	??_C@_0BE@PAGJHDGA@Check?5Log?5file?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0CE@FFBNDHMB@Mail?5log?5file?5?$CC?$CFs?$CC?5to?5Chris?5plea@ ; `string'
PUBLIC	??_C@_0BD@NHDFDKCG@Mysterious?5Warning?$AA@	; `string'
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_0CJ@DDDCCGCH@Could?5not?5open?5log?5file?5?$CC?$CFs?$CC?5for@ ; `string'
PUBLIC	??_C@_0BN@HKNMGFDE@?6Max?5Impulse?5Magnitude?3?5?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@DONCIOGO@?6Max?5Ang?5Imp?5Magnitude?3?5?5?$CFf?6?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@JJIOEOHO@Max?5RAM?5?5allocated?3?5?5?5?5?5?$CFld?5byte@ ; `string'
PUBLIC	??_C@_0CD@GEHFDLPF@RAM?5still?5allocated?3?5?5?5?5?$CFld?5byte@ ; `string'
PUBLIC	??_C@_0BO@CFAIOBIH@Blocks?5still?5allocated?3?5?$CFld?6?6?$AA@ ; `string'
PUBLIC	??_C@_0L@PJMBNNFG@Block?5?$CF5d?6?$AA@		; `string'
PUBLIC	??_C@_0CG@DALNCJPK@?7Size?3?5?$CFld?5bytes?6?7File?3?5?$CFs?6?7Line@ ; `string'
PUBLIC	?CheckMemoryAllocation@@YAXXZ			; CheckMemoryAllocation
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fprintf:NEAR
EXTRN	?DEBUG_MaxImpulseMag@@3MA:DWORD			; DEBUG_MaxImpulseMag
EXTRN	?DEBUG_MaxAngImpulseMag@@3MA:DWORD		; DEBUG_MaxAngImpulseMag
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0CM@GGIDFJDI@Still?5have?5RAM?5allocated?6Printin@
CONST	SEGMENT
??_C@_0CM@GGIDFJDI@Still?5have?5RAM?5allocated?6Printin@ DB 'Still have R'
	DB	'AM allocated', 0aH, 'Printing log to %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PAGJHDGA@Check?5Log?5file?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BE@PAGJHDGA@Check?5Log?5file?5?$CC?$CFs?$CC?$AA@ DB 'Check Log fil'
	DB	'e "%s"', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FFBNDHMB@Mail?5log?5file?5?$CC?$CFs?$CC?5to?5Chris?5plea@
CONST	SEGMENT
??_C@_0CE@FFBNDHMB@Mail?5log?5file?5?$CC?$CFs?$CC?5to?5Chris?5plea@ DB 'M'
	DB	'ail log file "%s" to Chris please!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NHDFDKCG@Mysterious?5Warning?$AA@
CONST	SEGMENT
??_C@_0BD@NHDFDKCG@Mysterious?5Warning?$AA@ DB 'Mysterious Warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DDDCCGCH@Could?5not?5open?5log?5file?5?$CC?$CFs?$CC?5for@
CONST	SEGMENT
??_C@_0CJ@DDDCCGCH@Could?5not?5open?5log?5file?5?$CC?$CFs?$CC?5for@ DB 'C'
	DB	'ould not open log file "%s" for writing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HKNMGFDE@?6Max?5Impulse?5Magnitude?3?5?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BN@HKNMGFDE@?6Max?5Impulse?5Magnitude?3?5?5?$CFf?6?$AA@ DB 0aH, 'M'
	DB	'ax Impulse Magnitude:  %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DONCIOGO@?6Max?5Ang?5Imp?5Magnitude?3?5?5?$CFf?6?6?$AA@
CONST	SEGMENT
??_C@_0BO@DONCIOGO@?6Max?5Ang?5Imp?5Magnitude?3?5?5?$CFf?6?6?$AA@ DB 0aH, 'M'
	DB	'ax Ang Imp Magnitude:  %f', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JJIOEOHO@Max?5RAM?5?5allocated?3?5?5?5?5?5?$CFld?5byte@
CONST	SEGMENT
??_C@_0CD@JJIOEOHO@Max?5RAM?5?5allocated?3?5?5?5?5?5?$CFld?5byte@ DB 'Max'
	DB	' RAM  allocated:     %ld bytes', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GEHFDLPF@RAM?5still?5allocated?3?5?5?5?5?$CFld?5byte@
CONST	SEGMENT
??_C@_0CD@GEHFDLPF@RAM?5still?5allocated?3?5?5?5?5?$CFld?5byte@ DB 'RAM s'
	DB	'till allocated:    %ld bytes', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CFAIOBIH@Blocks?5still?5allocated?3?5?$CFld?6?6?$AA@
CONST	SEGMENT
??_C@_0BO@CFAIOBIH@Blocks?5still?5allocated?3?5?$CFld?6?6?$AA@ DB 'Blocks'
	DB	' still allocated: %ld', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJMBNNFG@Block?5?$CF5d?6?$AA@
CONST	SEGMENT
??_C@_0L@PJMBNNFG@Block?5?$CF5d?6?$AA@ DB 'Block %5d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DALNCJPK@?7Size?3?5?$CFld?5bytes?6?7File?3?5?$CFs?6?7Line@
CONST	SEGMENT
??_C@_0CG@DALNCJPK@?7Size?3?5?$CFld?5bytes?6?7File?3?5?$CFs?6?7Line@ DB 09H
	DB	'Size: %ld bytes', 0aH, 09H, 'File: %s', 0aH, 09H, 'Line: %d', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CheckMemoryAllocation@@YAXXZ
_TEXT	SEGMENT
tv152 = -80						; size = 4
_fp$ = -12						; size = 4
_memStore$ = -8						; size = 4
_iMem$ = -4						; size = 4
?CheckMemoryAllocation@@YAXXZ PROC NEAR			; CheckMemoryAllocation, COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 230  : 	int iMem;
; 231  : 	MEMSTORE *memStore;
; 232  : 	FILE *fp;
; 233  : 
; 234  : 	if (DBG_AllocatedRAM != 0 || DBG_NAllocations != 0) {

	cmp	DWORD PTR ?DBG_AllocatedRAM@@3IA, 0	; DBG_AllocatedRAM
	jne	SHORT $L75980
	cmp	DWORD PTR ?DBG_NAllocations@@3IA, 0	; DBG_NAllocations
	je	SHORT $L75979
$L75980:

; 235  : 		wsprintf(ErrorMessage, "Still have RAM allocated\nPrinting log to %s", DBG_LogFile);

	mov	eax, DWORD PTR ?DBG_LogFile@@3PADA	; DBG_LogFile
	push	eax
	push	OFFSET FLAT:??_C@_0CM@GGIDFJDI@Still?5have?5RAM?5allocated?6Printin@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 236  : 		Box("Error", ErrorMessage, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH
$L75979:

; 237  : 	}
; 238  : 	if (AlreadyWarned) {

	movzx	eax, BYTE PTR _AlreadyWarned
	test	eax, eax
	je	SHORT $L75982

; 239  : 		wsprintf(ErrorMessage, "Check Log file \"%s\"", DBG_LogFile);

	mov	eax, DWORD PTR ?DBG_LogFile@@3PADA	; DBG_LogFile
	push	eax
	push	OFFSET FLAT:??_C@_0BE@PAGJHDGA@Check?5Log?5file?5?$CC?$CFs?$CC?$AA@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 240  : 		Box("Error", ErrorMessage, MB_OK | MB_ICONEXCLAMATION);

	push	48					; 00000030H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH
$L75982:

; 241  : 	}
; 242  : 	if (TellChris) {

	movzx	eax, BYTE PTR ?TellChris@@3_NA		; TellChris
	test	eax, eax
	je	SHORT $L75984

; 243  : 		wsprintf(ErrorMessage, "Mail log file \"%s\" to Chris please!", DBG_LogFile);

	mov	eax, DWORD PTR ?DBG_LogFile@@3PADA	; DBG_LogFile
	push	eax
	push	OFFSET FLAT:??_C@_0CE@FFBNDHMB@Mail?5log?5file?5?$CC?$CFs?$CC?5to?5Chris?5plea@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 244  : 		Box("Mysterious Warning", ErrorMessage, MB_OK | MB_ICONEXCLAMATION);

	push	48					; 00000030H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_0BD@NHDFDKCG@Mysterious?5Warning?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH
$L75984:

; 245  : 	}
; 246  : 
; 247  : 	fp = fopen(DBG_LogFile, "a");

	push	OFFSET FLAT:??_C@_01MCMALHOG@a?$AA@
	mov	eax, DWORD PTR ?DBG_LogFile@@3PADA	; DBG_LogFile
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 248  : 	if (fp == NULL) {

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L75988

; 249  : 		wsprintf(ErrorMessage, "Could not open log file \"%s\" for writing", DBG_LogFile);

	mov	eax, DWORD PTR ?DBG_LogFile@@3PADA	; DBG_LogFile
	push	eax
	push	OFFSET FLAT:??_C@_0CJ@DDDCCGCH@Could?5not?5open?5log?5file?5?$CC?$CFs?$CC?5for@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 250  : 		Box("Error", ErrorMessage, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 251  : 		return;

	jmp	$L75975
$L75988:

; 252  : 	}
; 253  : 
; 254  : 	// Write out error log file
; 255  : #if USE_DEBUG_ROUTINES
; 256  : 	fprintf(fp, "\nMax Impulse Magnitude:  %f\n", DEBUG_MaxImpulseMag);

	fld	DWORD PTR ?DEBUG_MaxImpulseMag@@3MA	; DEBUG_MaxImpulseMag
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BN@HKNMGFDE@?6Max?5Impulse?5Magnitude?3?5?5?$CFf?6?$AA@
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 257  : 	fprintf(fp, "\nMax Ang Imp Magnitude:  %f\n\n", DEBUG_MaxAngImpulseMag);

	fld	DWORD PTR ?DEBUG_MaxAngImpulseMag@@3MA	; DEBUG_MaxAngImpulseMag
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BO@DONCIOGO@?6Max?5Ang?5Imp?5Magnitude?3?5?5?$CFf?6?6?$AA@
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 258  : #endif
; 259  : 	fprintf(fp, "Max RAM  allocated:     %ld bytes\n", MaxAllocatedRAM);

	mov	eax, DWORD PTR _MaxAllocatedRAM
	push	eax
	push	OFFSET FLAT:??_C@_0CD@JJIOEOHO@Max?5RAM?5?5allocated?3?5?5?5?5?5?$CFld?5byte@
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 260  : 	fprintf(fp, "RAM still allocated:    %ld bytes\n", DBG_AllocatedRAM);

	mov	eax, DWORD PTR ?DBG_AllocatedRAM@@3IA	; DBG_AllocatedRAM
	push	eax
	push	OFFSET FLAT:??_C@_0CD@GEHFDLPF@RAM?5still?5allocated?3?5?5?5?5?$CFld?5byte@
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 261  : 	fprintf(fp, "Blocks still allocated: %ld\n\n", DBG_NAllocations);

	mov	eax, DWORD PTR ?DBG_NAllocations@@3IA	; DBG_NAllocations
	push	eax
	push	OFFSET FLAT:??_C@_0BO@CFAIOBIH@Blocks?5still?5allocated?3?5?$CFld?6?6?$AA@
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 262  : 
; 263  : 	iMem = 0;

	mov	DWORD PTR _iMem$[ebp], 0

; 264  : 	for (memStore = MemStoreHead; memStore != NULL; memStore = NextMemStore(memStore)) {

	mov	eax, DWORD PTR _MemStoreHead
	mov	DWORD PTR _memStore$[ebp], eax
	jmp	SHORT $L75995
$L75996:
	mov	eax, DWORD PTR _memStore$[ebp]
	push	eax
	call	?NextMemStore@@YAPAUMemStorageStruct@@PAU1@@Z ; NextMemStore
	add	esp, 4
	mov	DWORD PTR _memStore$[ebp], eax
$L75995:
	cmp	DWORD PTR _memStore$[ebp], 0
	je	SHORT $L75997

; 265  : 
; 266  : 		fprintf(fp, "Block %5d\n", iMem++);

	mov	eax, DWORD PTR _iMem$[ebp]
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR tv152[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@PJMBNNFG@Block?5?$CF5d?6?$AA@
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _iMem$[ebp]
	add	eax, 1
	mov	DWORD PTR _iMem$[ebp], eax

; 267  : 		fprintf(fp, "\tSize: %ld bytes\n\tFile: %s\n\tLine: %d\n", 
; 268  : 			memStore->Size, memStore->File, memStore->Line);

	mov	eax, DWORD PTR _memStore$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _memStore$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _memStore$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET FLAT:??_C@_0CG@DALNCJPK@?7Size?3?5?$CFld?5bytes?6?7File?3?5?$CFs?6?7Line@
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H

; 269  : 	}

	jmp	SHORT $L75996
$L75997:

; 270  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L75975:

; 271  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckMemoryAllocation@@YAXXZ ENDP			; CheckMemoryAllocation
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?WriteLogEntry@@YAXPAD@Z
_TEXT	SEGMENT
_fp$ = -4						; size = 4
_s$ = 8							; size = 4
?WriteLogEntry@@YAXPAD@Z PROC NEAR			; WriteLogEntry, COMDAT

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 275  : 	FILE *fp;
; 276  : 
; 277  : 	fp = fopen(DBG_LogFile, "a");

	push	OFFSET FLAT:??_C@_01MCMALHOG@a?$AA@
	mov	eax, DWORD PTR ?DBG_LogFile@@3PADA	; DBG_LogFile
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 278  : 	if (fp == NULL) {

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L76004

; 279  : 		return;

	jmp	SHORT $L76002
$L76004:

; 280  : 	}
; 281  : 	fprintf(fp, "%s", s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 282  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L76002:

; 283  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteLogEntry@@YAXPAD@Z ENDP				; WriteLogEntry
_TEXT	ENDS
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BH@BMNBDENO@ReVolt?5Error?5Log?5File?6?$AA@ ; `string'
PUBLIC	??_C@_0M@PFILLFIL@Feb?514?52021?$AA@		; `string'
PUBLIC	??_C@_08IBCLGHOJ@13?338?309?$AA@		; `string'
PUBLIC	??_C@_0BK@FOBGGEGJ@Compilation?5date?5?$CFs?0?5?$CFs?6?6?$AA@ ; `string'
PUBLIC	?InitLogFile@@YAXXZ				; InitLogFile
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BMNBDENO@ReVolt?5Error?5Log?5File?6?$AA@
CONST	SEGMENT
??_C@_0BH@BMNBDENO@ReVolt?5Error?5Log?5File?6?$AA@ DB 'ReVolt Error Log F'
	DB	'ile', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PFILLFIL@Feb?514?52021?$AA@
CONST	SEGMENT
??_C@_0M@PFILLFIL@Feb?514?52021?$AA@ DB 'Feb 14 2021', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBCLGHOJ@13?338?309?$AA@
CONST	SEGMENT
??_C@_08IBCLGHOJ@13?338?309?$AA@ DB '13:38:09', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FOBGGEGJ@Compilation?5date?5?$CFs?0?5?$CFs?6?6?$AA@
CONST	SEGMENT
??_C@_0BK@FOBGGEGJ@Compilation?5date?5?$CFs?0?5?$CFs?6?6?$AA@ DB 'Compila'
	DB	'tion date %s, %s', 0aH, 0aH, 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitLogFile@@YAXXZ
_TEXT	SEGMENT
_fp$ = -4						; size = 4
?InitLogFile@@YAXXZ PROC NEAR				; InitLogFile, COMDAT

; 286  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 287  : 	FILE *fp;
; 288  : 
; 289  : 	fp = fopen(DBG_LogFile, "w");

	push	OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
	mov	eax, DWORD PTR ?DBG_LogFile@@3PADA	; DBG_LogFile
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 290  : 	if (fp == NULL) {

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L76010

; 291  : 		return;

	jmp	SHORT $L76007
$L76010:

; 292  : 	}
; 293  : 
; 294  : 	fprintf(fp, "ReVolt Error Log File\n");

	push	OFFSET FLAT:??_C@_0BH@BMNBDENO@ReVolt?5Error?5Log?5File?6?$AA@
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 295  : 	fprintf(fp, "Compilation date %s, %s\n\n", __TIME__, __DATE__);

	push	OFFSET FLAT:??_C@_0M@PFILLFIL@Feb?514?52021?$AA@
	push	OFFSET FLAT:??_C@_08IBCLGHOJ@13?338?309?$AA@
	push	OFFSET FLAT:??_C@_0BK@FOBGGEGJ@Compilation?5date?5?$CFs?0?5?$CFs?6?6?$AA@
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 296  : 
; 297  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L76007:

; 298  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitLogFile@@YAXXZ ENDP				; InitLogFile
_TEXT	ENDS
PUBLIC	??_C@_0CE@ECJLPDFE@Assertion?5Failed?6Line?3?5?$CFd?6File?3?5@ ; `string'
PUBLIC	?DebugAssert@@YAX_NHPAD@Z			; DebugAssert
;	COMDAT ??_C@_0CE@ECJLPDFE@Assertion?5Failed?6Line?3?5?$CFd?6File?3?5@
CONST	SEGMENT
??_C@_0CE@ECJLPDFE@Assertion?5Failed?6Line?3?5?$CFd?6File?3?5@ DB 'Assert'
	DB	'ion Failed', 0aH, 'Line: %d', 0aH, 'File: %s', 0aH, 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DebugAssert@@YAX_NHPAD@Z
_TEXT	SEGMENT
_result$ = 8						; size = 1
_line$ = 12						; size = 4
_file$ = 16						; size = 4
?DebugAssert@@YAX_NHPAD@Z PROC NEAR			; DebugAssert, COMDAT

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 309  : 	if (result) return;

	movzx	eax, BYTE PTR _result$[ebp]
	test	eax, eax
	je	SHORT $L76020
	jmp	SHORT $L76019
$L76020:

; 310  : 
; 311  : 	wsprintf(ErrorMessage, "Assertion Failed\nLine: %d\nFile: %s\n", line, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CE@ECJLPDFE@Assertion?5Failed?6Line?3?5?$CFd?6File?3?5@
	push	OFFSET FLAT:_ErrorMessage
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 312  : 	if (!AlreadyAsserted) {

	movzx	eax, BYTE PTR _AlreadyAsserted
	test	eax, eax
	jne	SHORT $L76022

; 313  : 		Box("Error", ErrorMessage, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	push	OFFSET FLAT:_ErrorMessage
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 314  : 		AlreadyAsserted = TRUE;

	mov	BYTE PTR _AlreadyAsserted, 1
$L76022:

; 315  : 	}
; 316  : 	WriteLogEntry(ErrorMessage);

	push	OFFSET FLAT:_ErrorMessage
	call	?WriteLogEntry@@YAXPAD@Z		; WriteLogEntry
	add	esp, 4
$L76019:

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DebugAssert@@YAX_NHPAD@Z ENDP				; DebugAssert
_TEXT	ENDS
PUBLIC	??_C@_0BG@OLCABPAK@ERROR?5?$CI?$CFd?$CJ?5in?5?$CFs?5?9?5?$CFs?$AA@ ; `string'
PUBLIC	?Error@@YAXPAD00J@Z				; Error
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
;	COMDAT ??_C@_0BG@OLCABPAK@ERROR?5?$CI?$CFd?$CJ?5in?5?$CFs?5?9?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@OLCABPAK@ERROR?5?$CI?$CFd?$CJ?5in?5?$CFs?5?9?5?$CFs?$AA@ DB 'ER'
	DB	'ROR (%d) in %s - %s', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?Error@@YAXPAD00J@Z
_TEXT	SEGMENT
_buf$ = -256						; size = 256
_mod$ = 8						; size = 4
_func$ = 12						; size = 4
_mess$ = 16						; size = 4
_errno$ = 20						; size = 4
?Error@@YAXPAD00J@Z PROC NEAR				; Error, COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi

; 328  : 	char buf[256];
; 329  : 
; 330  : 	wsprintf(buf, "ERROR (%d) in %s - %s", errno, mod, func);

	mov	eax, DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	mov	edx, DWORD PTR _errno$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BG@OLCABPAK@ERROR?5?$CI?$CFd?$CJ?5in?5?$CFs?5?9?5?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 331  : 	Box(buf, mess, MB_OK | MB_ICONERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _mess$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 332  : 	WriteLogEntry(ErrorMessage);

	push	OFFSET FLAT:_ErrorMessage
	call	?WriteLogEntry@@YAXPAD@Z		; WriteLogEntry
	add	esp, 4

; 333  : 	QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 334  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Error@@YAXPAD00J@Z ENDP				; Error
_TEXT	ENDS
END
