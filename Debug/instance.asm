; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\instance.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_03IDDGKHFD@X?5Y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KIBLPEJA@X?5Z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CJDPGPNI@Z?5Y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01MMEEDKFM@X?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NFFPALBN@Y?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01POHCFINO@Z?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JCBBMBIP@Camera?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MFLOHCHP@World?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KHNKCCHM@fi?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBIFAMNI@Saved?5Instance?5File?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HMIODOLK@fin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CCLAEDDF@Yes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@IODMHEDJ@High?5priority?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KKGKAABK@Env?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HGDKAEGB@LOD?5Bias?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HECBGFIE@Env?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NMOCHNCE@Model?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NFIJOKEG@Model?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EJFNLALG@Env?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@EFBILDOC@RGB?5Type?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JOFJLKIO@Mirror?5Hide?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NOFFHJBO@Mirror?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@JHBOJFOO@Fixed?5lights?3?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@COEMJPKP@levels?2?$CFs?2?$CK?4prm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@ELAKCFHA@Can?8t?5alloc?5memory?5for?5instance?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@OKBMNBKA@levels?2?$CFs?2?$CFs?4prm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIFCFEFH@levels?2?$CFs?2?$CFs?4ncp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@IPMFNNCA@Can?8t?5alloc?5memory?5for?5Instance?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadInstances@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveInstances@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EditInstances@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocInstance@@YAPAUINSTANCE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeInstance@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawInstances@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisplayInstanceInfo@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadInstanceModels@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeInstanceModels@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeInstanceRGBs@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildInstanceCollPolys@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??FreeInstanceModels@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadInstanceModels@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?InstanceNum@@3JA				; InstanceNum
PUBLIC	?CurrentInstance@@3PAUINSTANCE@@A		; CurrentInstance
PUBLIC	?Instances@@3PAUINSTANCE@@A			; Instances
PUBLIC	?InstanceModelNum@@3JA				; InstanceModelNum
PUBLIC	?InstanceModels@@3PAUINSTANCE_MODELS@@A		; InstanceModels
PUBLIC	??_C@_03IDDGKHFD@X?5Y?$AA@			; `string'
PUBLIC	??_C@_03KIBLPEJA@X?5Z?$AA@			; `string'
PUBLIC	??_C@_03CJDPGPNI@Z?5Y?$AA@			; `string'
PUBLIC	??_C@_01MMEEDKFM@X?$AA@				; `string'
PUBLIC	??_C@_01NFFPALBN@Y?$AA@				; `string'
PUBLIC	??_C@_01POHCFINO@Z?$AA@				; `string'
PUBLIC	??_C@_06JCBBMBIP@Camera?$AA@			; `string'
PUBLIC	??_C@_05MFLOHCHP@World?$AA@			; `string'
_BSS	SEGMENT
?InstanceNum@@3JA DD 01H DUP (?)			; InstanceNum
?CurrentInstance@@3PAUINSTANCE@@A DD 01H DUP (?)	; CurrentInstance
?Instances@@3PAUINSTANCE@@A DB 06a40H DUP (?)		; Instances
?InstanceModelNum@@3JA DD 01H DUP (?)			; InstanceModelNum
?InstanceModels@@3PAUINSTANCE_MODELS@@A DD 01H DUP (?)	; InstanceModels
_InstanceAxis DB 01H DUP (?)
	ALIGN	4

_InstanceAxisType DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_InstanceRgbType DB 01H
_DATA	ENDS
;	COMDAT ??_C@_03IDDGKHFD@X?5Y?$AA@
CONST	SEGMENT
??_C@_03IDDGKHFD@X?5Y?$AA@ DB 'X Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KIBLPEJA@X?5Z?$AA@
CONST	SEGMENT
??_C@_03KIBLPEJA@X?5Z?$AA@ DB 'X Z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJDPGPNI@Z?5Y?$AA@
CONST	SEGMENT
??_C@_03CJDPGPNI@Z?5Y?$AA@ DB 'Z Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MMEEDKFM@X?$AA@
CONST	SEGMENT
??_C@_01MMEEDKFM@X?$AA@ DB 'X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NFFPALBN@Y?$AA@
CONST	SEGMENT
??_C@_01NFFPALBN@Y?$AA@ DB 'Y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01POHCFINO@Z?$AA@
CONST	SEGMENT
??_C@_01POHCFINO@Z?$AA@ DB 'Z', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
_InstanceAxisNames DD FLAT:??_C@_03IDDGKHFD@X?5Y?$AA@
	DD	FLAT:??_C@_03KIBLPEJA@X?5Z?$AA@
	DD	FLAT:??_C@_03CJDPGPNI@Z?5Y?$AA@
	DD	FLAT:??_C@_01MMEEDKFM@X?$AA@
	DD	FLAT:??_C@_01NFFPALBN@Y?$AA@
	DD	FLAT:??_C@_01POHCFINO@Z?$AA@
_DATA	ENDS
;	COMDAT ??_C@_06JCBBMBIP@Camera?$AA@
CONST	SEGMENT
??_C@_06JCBBMBIP@Camera?$AA@ DB 'Camera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFLOHCHP@World?$AA@
CONST	SEGMENT
??_C@_05MFLOHCHP@World?$AA@ DB 'World', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_InstanceAxisTypeNames DD FLAT:??_C@_06JCBBMBIP@Camera?$AA@
	DD	FLAT:??_C@_05MFLOHCHP@World?$AA@
_DATA	ENDS
PUBLIC	?LoadInstances@@YAXPAD@Z			; LoadInstances
PUBLIC	?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z	; AllocOneInstanceRGB
PUBLIC	?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z	; SetInstanceBoundingBoxes
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	__fltused:NEAR
EXTRN	_fread:NEAR
EXTRN	_fwrite:NEAR
EXTRN	?EditMode@@3JA:DWORD				; EditMode
EXTRN	?EditScale@@3MA:DWORD				; EditScale
EXTRN	?GetMirrorPlane@@YAJPAUVectorStruct@@@Z:NEAR	; GetMirrorPlane
EXTRN	?MirrorHeight@@3MA:DWORD			; MirrorHeight
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_02JDPG@rb?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\instance.cpp
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadInstances@@YAXPAD@Z
_TEXT	SEGMENT
_fin$ = -84						; size = 72
_fp$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?LoadInstances@@YAXPAD@Z PROC NEAR			; LoadInstances, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 51   : 	long i, j;
; 52   : 	FILE *fp;
; 53   : 	FILE_INSTANCE fin;
; 54   : 
; 55   : // open instance file
; 56   : 
; 57   : 	fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 58   : 
; 59   : // if not there create empty one
; 60   : 
; 61   : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81485

; 62   : 	{
; 63   : 		fp = fopen(file, "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 64   : 		if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81487
	jmp	$L81479
$L81487:

; 65   : 		i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 66   : 		fwrite(&i, sizeof(i), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 67   : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 68   : 		fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 69   : 		if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81485
	jmp	$L81479
$L81485:

; 70   : 	}
; 71   : 
; 72   : // loop thru all instances
; 73   : 
; 74   : 	fread(&InstanceNum, sizeof(InstanceNum), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	push	OFFSET FLAT:?InstanceNum@@3JA		; InstanceNum
	call	_fread
	add	esp, 16					; 00000010H

; 75   : 
; 76   : 	for (i = 0 ; i < InstanceNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81489
$L81490:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81489:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	$L81491

; 77   : 	{
; 78   : 
; 79   : // load one file instance
; 80   : 
; 81   : 		fread(&fin, sizeof(fin), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	72					; 00000048H
	lea	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 82   : 
; 83   : 		if (EditMode == EDIT_INSTANCES)

	cmp	DWORD PTR ?EditMode@@3JA, 4		; EditMode
	jne	SHORT $L81492

; 84   : 		{
; 85   : 			VecMulScalar(&fin.WorldPos, EditScale);

	fld	DWORD PTR _fin$[ebp+24]
	fmul	DWORD PTR ?EditScale@@3MA		; EditScale
	fstp	DWORD PTR _fin$[ebp+24]
	fld	DWORD PTR _fin$[ebp+28]
	fmul	DWORD PTR ?EditScale@@3MA		; EditScale
	fstp	DWORD PTR _fin$[ebp+28]
	fld	DWORD PTR _fin$[ebp+32]
	fmul	DWORD PTR ?EditScale@@3MA		; EditScale
	fstp	DWORD PTR _fin$[ebp+32]
$L81492:

; 86   : 		}
; 87   : 
; 88   : // find it's model set
; 89   : 
; 90   : 		fin.Name[MAX_INSTANCE_FILENAME - 1] = 0;

	mov	BYTE PTR _fin$[ebp+8], 0

; 91   : 		for (j = 0 ; j < InstanceModelNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81493
$L81494:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81493:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	jge	SHORT $L81495

; 92   : 		{
; 93   : 			if (!strcmp(fin.Name, InstanceModels[j].Name))

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	lea	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L81496

; 94   : 			{
; 95   : 				Instances[i].Model = (char)j;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	cl, BYTE PTR _j$[ebp]
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax], cl

; 96   : 				break;

	jmp	SHORT $L81495
$L81496:

; 97   : 			}
; 98   : 		}

	jmp	SHORT $L81494
$L81495:

; 99   : 
; 100  : // ignore if can't find model set
; 101  : 
; 102  : 		if (j == InstanceModelNum)

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	jne	SHORT $L81498

; 103  : 		{
; 104  : 			i--;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 105  : 			InstanceNum--;

	mov	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	sub	eax, 1
	mov	DWORD PTR ?InstanceNum@@3JA, eax	; InstanceNum

; 106  : 			continue;

	jmp	$L81490
$L81498:

; 107  : 		}
; 108  : 
; 109  : // setup misc from file
; 110  : 
; 111  : 		Instances[i].r = fin.r;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	cl, BYTE PTR _fin$[ebp+9]
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+4], cl

; 112  : 		Instances[i].g = fin.g;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	cl, BYTE PTR _fin$[ebp+10]
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+5], cl

; 113  : 		Instances[i].b = fin.b;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	cl, BYTE PTR _fin$[ebp+11]
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+6], cl

; 114  : 		Instances[i].Priority = fin.Priority;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	cl, BYTE PTR _fin$[ebp+16]
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+1], cl

; 115  : 		Instances[i].Flag = fin.Flag;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	cl, BYTE PTR _fin$[ebp+17]
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+2], cl

; 116  : 		Instances[i].EnvRGB = fin.EnvRGB;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	ecx, DWORD PTR _fin$[ebp+12]
	mov	DWORD PTR ?Instances@@3PAUINSTANCE@@A[eax+8], ecx

; 117  : 		Instances[i].LodBias = fin.LodBias;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	ecx, DWORD PTR _fin$[ebp+20]
	mov	DWORD PTR ?Instances@@3PAUINSTANCE@@A[eax+16], ecx

; 118  : 		Instances[i].WorldPos = fin.WorldPos;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A+32
	mov	ecx, DWORD PTR _fin$[ebp+24]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _fin$[ebp+28]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _fin$[ebp+32]
	mov	DWORD PTR [eax+8], ecx

; 119  : 		Instances[i].WorldMatrix = fin.WorldMatrix;

	mov	edi, DWORD PTR _i$[ebp]
	imul	edi, 136				; 00000088H
	add	edi, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A+44
	mov	ecx, 9
	lea	esi, DWORD PTR _fin$[ebp+36]
	rep movsd

; 120  : 
; 121  : // zero model rgb?
; 122  : 
; 123  : 		if (!(Instances[i].Flag & INSTANCE_SET_MODEL_RGB))

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	movzx	ecx, BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+2]
	and	ecx, 16					; 00000010H
	jne	SHORT $L81499

; 124  : 		{
; 125  : 			Instances[i].r = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+4], 0

; 126  : 			Instances[i].g = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+5], 0

; 127  : 			Instances[i].b = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+6], 0

; 128  : 			Instances[i].Flag |= INSTANCE_SET_MODEL_RGB;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	movzx	ecx, BYTE PTR ?Instances@@3PAUINSTANCE@@A[eax+2]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 136				; 00000088H
	mov	BYTE PTR ?Instances@@3PAUINSTANCE@@A[edx+2], cl
$L81499:

; 129  : 		}
; 130  : 
; 131  : // set bounding boxes + rgb's
; 132  : 
; 133  : 		SetInstanceBoundingBoxes(&Instances[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	push	eax
	call	?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z ; SetInstanceBoundingBoxes
	add	esp, 4

; 134  : 		AllocOneInstanceRGB(&Instances[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	push	eax
	call	?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z ; AllocOneInstanceRGB
	add	esp, 4

; 135  : 
; 136  : // set mirror flags
; 137  : 
; 138  : 		if ((Instances[i].MirrorFlag = GetMirrorPlane(&Instances[i].WorldPos)))

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A+32
	push	eax
	call	?GetMirrorPlane@@YAJPAUVectorStruct@@@Z	; GetMirrorPlane
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 136				; 00000088H
	mov	DWORD PTR ?Instances@@3PAUINSTANCE@@A[ecx+12], eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 136				; 00000088H
	cmp	DWORD PTR ?Instances@@3PAUINSTANCE@@A[edx+12], 0
	je	SHORT $L81500

; 139  : 			Instances[i].MirrorHeight = MirrorHeight;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	mov	ecx, DWORD PTR ?MirrorHeight@@3MA
	mov	DWORD PTR ?Instances@@3PAUINSTANCE@@A[eax+20], ecx
$L81500:

; 140  : 	}

	jmp	$L81490
$L81491:

; 141  : 
; 142  : // close instance file
; 143  : 
; 144  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L81479:

; 145  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadInstances@@YAXPAD@Z ENDP				; LoadInstances
_TEXT	ENDS
PUBLIC	?SaveInstances@@YAXPAD@Z			; SaveInstances
PUBLIC	??_C@_03KHNKCCHM@fi?9?$AA@			; `string'
PUBLIC	??_C@_0BF@CBIFAMNI@Saved?5Instance?5File?3?$AA@	; `string'
EXTRN	_remove:NEAR
EXTRN	_rename:NEAR
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	_memcpy:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp__wsprintfA:NEAR
;	COMDAT ??_C@_03KHNKCCHM@fi?9?$AA@
CONST	SEGMENT
??_C@_03KHNKCCHM@fi?9?$AA@ DB 'fi-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBIFAMNI@Saved?5Instance?5File?3?$AA@
CONST	SEGMENT
??_C@_0BF@CBIFAMNI@Saved?5Instance?5File?3?$AA@ DB 'Saved Instance File:', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SaveInstances@@YAXPAD@Z
_TEXT	SEGMENT
_bak$ = -340						; size = 256
_inst$ = -84						; size = 4
_finst$ = -80						; size = 72
_fp$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?SaveInstances@@YAXPAD@Z PROC NEAR			; SaveInstances, COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 404				; 00000194H
	push	ebx
	push	esi
	push	edi

; 153  : 	long i;
; 154  : 	FILE *fp;
; 155  : 	FILE_INSTANCE finst;
; 156  : 	INSTANCE *inst;
; 157  : 	char bak[256];
; 158  : 
; 159  : // backup old file
; 160  : 
; 161  : 	memcpy(bak, file, strlen(file) - 3);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, 3
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bak$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 162  : 	wsprintf(bak + strlen(file) - 3, "fi-");

	push	OFFSET FLAT:??_C@_03KHNKCCHM@fi?9?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _bak$[ebp+eax-3]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 163  : 	remove(bak);

	lea	eax, DWORD PTR _bak$[ebp]
	push	eax
	call	_remove
	add	esp, 4

; 164  : 	rename(file, bak);

	lea	eax, DWORD PTR _bak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_rename
	add	esp, 8

; 165  : 
; 166  : // open object file
; 167  : 
; 168  : 	fp = fopen(file, "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 169  : 	if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81510
	jmp	$L81503
$L81510:

; 170  : 
; 171  : // write num
; 172  : 
; 173  : 	fwrite(&InstanceNum, sizeof(InstanceNum), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	push	OFFSET FLAT:?InstanceNum@@3JA		; InstanceNum
	call	_fwrite
	add	esp, 16					; 00000010H

; 174  : 
; 175  : // write out each instance
; 176  : 
; 177  : 	inst = Instances;

	mov	DWORD PTR _inst$[ebp], OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances

; 178  : 	for (i = 0 ; i < InstanceNum ; i++, inst++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81511
$L81512:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 136				; 00000088H
	mov	DWORD PTR _inst$[ebp], ecx
$L81511:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	$L81513

; 179  : 	{
; 180  : 
; 181  : // set file instance
; 182  : 
; 183  : 		memcpy(finst.Name, InstanceModels[inst->Model].Name, MAX_INSTANCE_FILENAME);

	push	9
	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	lea	ecx, DWORD PTR _finst$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 184  : 
; 185  : 		finst.r = inst->r;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _finst$[ebp+9], cl

; 186  : 		finst.g = inst->g;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	cl, BYTE PTR [eax+5]
	mov	BYTE PTR _finst$[ebp+10], cl

; 187  : 		finst.b = inst->b;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	cl, BYTE PTR [eax+6]
	mov	BYTE PTR _finst$[ebp+11], cl

; 188  : 		finst.Priority = inst->Priority;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _finst$[ebp+16], cl

; 189  : 		finst.Flag = inst->Flag;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _finst$[ebp+17], cl

; 190  : 		finst.EnvRGB = inst->EnvRGB;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _finst$[ebp+12], ecx

; 191  : 		finst.LodBias = inst->LodBias;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _finst$[ebp+20], ecx

; 192  : 		finst.WorldPos = inst->WorldPos;

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _finst$[ebp+24], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _finst$[ebp+28], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _finst$[ebp+32], eax

; 193  : 		finst.WorldMatrix = inst->WorldMatrix;

	mov	esi, DWORD PTR _inst$[ebp]
	add	esi, 44					; 0000002cH
	mov	ecx, 9
	lea	edi, DWORD PTR _finst$[ebp+36]
	rep movsd

; 194  : 
; 195  : // write it
; 196  : 
; 197  : 		fwrite(&finst, sizeof(finst), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	72					; 00000048H
	lea	ecx, DWORD PTR _finst$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 198  : 	}

	jmp	$L81512
$L81513:

; 199  : 
; 200  : // close file
; 201  : 
; 202  : 	Box("Saved Instance File:", file, MB_OK);

	push	0
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@CBIFAMNI@Saved?5Instance?5File?3?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 203  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L81503:

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SaveInstances@@YAXPAD@Z ENDP				; SaveInstances
_TEXT	ENDS
PUBLIC	__real@45400000
PUBLIC	__real@3f800000
PUBLIC	__real@43a00000
PUBLIC	__real@43700000
PUBLIC	__real@40800000
PUBLIC	__real@42800000
PUBLIC	__real@46000000
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3e800000
PUBLIC	__real@00000000
PUBLIC	?EditInstances@@YAXXZ				; EditInstances
PUBLIC	?AllocInstance@@YAPAUINSTANCE@@XZ		; AllocInstance
PUBLIC	?FreeInstance@@YAXPAUINSTANCE@@@Z		; FreeInstance
PUBLIC	?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z		; FreeOneInstanceRGB
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	??_C@_03HMIODOLK@fin?$AA@			; `string'
EXTRN	?GetLevelFilename@@YAPADPADJ@Z:NEAR		; GetLevelFilename
EXTRN	?IdentityMatrix@@3TMatrixUnion@@A:BYTE		; IdentityMatrix
EXTRN	?TimeFactor@@3MA:DWORD				; TimeFactor
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
EXTRN	?ViewMatrix@@3TMatrixUnion@@A:BYTE		; ViewMatrix
EXTRN	?ViewTrans@@3UVectorStruct@@A:BYTE		; ViewTrans
EXTRN	?MouseXpos@@3MA:DWORD				; MouseXpos
EXTRN	?MouseYpos@@3MA:DWORD				; MouseYpos
EXTRN	?MouseXrel@@3MA:DWORD				; MouseXrel
EXTRN	?MouseYrel@@3MA:DWORD				; MouseYrel
EXTRN	?CameraEditXrel@@3MA:DWORD			; CameraEditXrel
EXTRN	?CameraEditYrel@@3MA:DWORD			; CameraEditYrel
EXTRN	?CameraEditZrel@@3MA:DWORD			; CameraEditZrel
EXTRN	?MouseLeft@@3DA:BYTE				; MouseLeft
EXTRN	?MouseRight@@3DA:BYTE				; MouseRight
EXTRN	?MouseLastLeft@@3DA:BYTE			; MouseLastLeft
EXTRN	?CAM_MainCamera@@3PAUCameraStruct@@A:DWORD	; CAM_MainCamera
EXTRN	?Keys@@3PADA:BYTE				; Keys
EXTRN	?LastKeys@@3PADA:BYTE				; LastKeys
EXTRN	?Mouse@@3U_DIMOUSESTATE@@A:BYTE			; Mouse
EXTRN	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z:NEAR	; RotMatrixZYX
EXTRN	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z:NEAR ; RotVector
EXTRN	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z:NEAR ; RotTransVector
EXTRN	?MulMatrix@@YAXPATMatrixUnion@@00@Z:NEAR	; MulMatrix
EXTRN	?CopyMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; CopyMatrix
_BSS	SEGMENT
	ALIGN	4

_LastModel DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@45400000
CONST	SEGMENT
__real@45400000 DD 045400000r			; 3072
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_03HMIODOLK@fin?$AA@
CONST	SEGMENT
??_C@_03HMIODOLK@fin?$AA@ DB 'fin', 00H			; `string'
CONST	ENDS
;	COMDAT __real@43a00000
CONST	SEGMENT
__real@43a00000 DD 043a00000r			; 320
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?EditInstances@@YAXXZ
_TEXT	SEGMENT
tv1813 = -304						; size = 4
tv962 = -304						; size = 4
__mul$81639 = -236					; size = 4
__mul$81637 = -232					; size = 4
__mul$81632 = -228					; size = 4
__mul$81630 = -224					; size = 4
__mul$81545 = -220					; size = 4
__mul$81543 = -216					; size = 4
_dist$ = -212						; size = 4
_ndist$ = -208						; size = 4
_sy$ = -204						; size = 4
_sx$ = -200						; size = 4
_yrad$ = -196						; size = 4
_xrad$ = -192						; size = 4
_rgb$ = -188						; size = 4
_l2$ = -184						; size = 12
_u2$ = -172						; size = 12
_r2$ = -160						; size = 12
_l$ = -148						; size = 12
_u$ = -136						; size = 12
_r$ = -124						; size = 12
_mat2$ = -112						; size = 36
_mat$ = -76						; size = 36
_vec2$ = -40						; size = 12
_vec$ = -28						; size = 12
_ninst$ = -16						; size = 4
_inst$ = -12						; size = 4
_flag$ = -8						; size = 4
_i$ = -4						; size = 4
?EditInstances@@YAXXZ PROC NEAR				; EditInstances, COMDAT

; 211  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi

; 212  : 	long i, flag;
; 213  : 	INSTANCE *inst, *ninst;
; 214  : 	VEC vec, vec2;
; 215  : 	MAT mat, mat2;
; 216  : 	VEC r, u, l, r2, u2, l2;
; 217  : 	MODEL_RGB *rgb;
; 218  : 	float xrad, yrad, sx, sy, ndist, dist;
; 219  : 
; 220  : // quit if not in edit mode
; 221  : 
; 222  : 	if (CAM_MainCamera->Type != CAM_EDIT)

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	cmp	DWORD PTR [eax], 5
	je	SHORT $L81539

; 223  : 	{
; 224  : 		CurrentInstance = NULL;

	mov	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, 0 ; CurrentInstance

; 225  : 		return;

	jmp	$L81517
$L81539:

; 226  : 	}
; 227  : 
; 228  : // rotate camera?
; 229  : 
; 230  : 	if (MouseRight)

	movsx	eax, BYTE PTR ?MouseRight@@3DA		; MouseRight
	test	eax, eax
	je	$L81540

; 231  : 	{
; 232  : 		RotMatrixZYX(&mat, (float)-Mouse.lY / 3072, -(float)Mouse.lX / 3072, 0);

	push	0
	fild	DWORD PTR ?Mouse@@3U_DIMOUSESTATE@@A
	fchs
	fdiv	DWORD PTR __real@45400000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR ?Mouse@@3U_DIMOUSESTATE@@A+4
	neg	eax
	mov	DWORD PTR tv1813[ebp], eax
	fild	DWORD PTR tv1813[ebp]
	fdiv	DWORD PTR __real@45400000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 233  : 		MulMatrix(&CAM_MainCamera->WMatrix, &mat, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 234  : 		CopyMatrix(&mat2, &CAM_MainCamera->WMatrix);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 235  : 
; 236  : 		CAM_MainCamera->WMatrix.m[RY] = 0;

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	DWORD PTR [eax+20], 0

; 237  : 		NormalizeVector(&CAM_MainCamera->WMatrix.mv[X]);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+16]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [ecx+24]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81543[ebp]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR __mul$81543[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR __mul$81543[ebp]
	fmul	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR __mul$81543[ebp]
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+24]

; 238  : 		CrossProduct(&CAM_MainCamera->WMatrix.mv[Z], &CAM_MainCamera->WMatrix.mv[X], &CAM_MainCamera->WMatrix.mv[Y]);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+48]
	fmul	DWORD PTR [eax+20]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+40]
	fmul	DWORD PTR [eax+24]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+44]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+36]

; 239  : 		NormalizeVector(&CAM_MainCamera->WMatrix.mv[Y]);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+32]
	fmul	DWORD PTR [eax+32]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [ecx+36]
	fmul	DWORD PTR [edx+36]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81545[ebp]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR __mul$81545[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR __mul$81545[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR __mul$81545[ebp]
	fmul	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+36]

; 240  : 		CrossProduct(&CAM_MainCamera->WMatrix.mv[X], &CAM_MainCamera->WMatrix.mv[Y], &CAM_MainCamera->WMatrix.mv[Z]);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [eax+32]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+36]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+16]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+28]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fstp	DWORD PTR [ecx+48]
$L81540:

; 241  : 	}
; 242  : 
; 243  : // save instances?
; 244  : 
; 245  : 	if (Keys[DIK_LCONTROL] && Keys[DIK_F4] && !LastKeys[DIK_F4])

	movsx	eax, BYTE PTR ?Keys@@3PADA+29
	test	eax, eax
	je	SHORT $L81547
	movsx	eax, BYTE PTR ?Keys@@3PADA+62
	test	eax, eax
	je	SHORT $L81547
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+62
	test	eax, eax
	jne	SHORT $L81547

; 246  : 	{
; 247  : 		SaveInstances(GetLevelFilename("fin", FILENAME_MAKE_BODY | FILENAME_GAME_SETTINGS));

	push	3
	push	OFFSET FLAT:??_C@_03HMIODOLK@fin?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	?SaveInstances@@YAXPAD@Z		; SaveInstances
	add	esp, 4
$L81547:

; 248  : 	}
; 249  : 
; 250  : // get a current instance?
; 251  : 
; 252  : 	if (!CurrentInstance && Keys[DIK_RETURN] && !LastKeys[DIK_RETURN])

	cmp	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, 0 ; CurrentInstance
	jne	$L81549
	movsx	eax, BYTE PTR ?Keys@@3PADA+28
	test	eax, eax
	je	$L81549
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+28
	test	eax, eax
	jne	$L81549

; 253  : 	{
; 254  : 		ninst = NULL;

	mov	DWORD PTR _ninst$[ebp], 0

; 255  : 		ndist = 99999;

	mov	DWORD PTR _ndist$[ebp], 1203982208	; 47c34f80H

; 256  : 
; 257  : 		inst = Instances;

	mov	DWORD PTR _inst$[ebp], OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances

; 258  : 		for (i = 0 ; i < InstanceNum ; i++, inst++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81550
$L81551:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 136				; 00000088H
	mov	DWORD PTR _inst$[ebp], ecx
$L81550:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	$L81552

; 259  : 		{
; 260  : 			RotTransVector(&ViewMatrix, &ViewTrans, &inst->WorldPos, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET FLAT:?ViewTrans@@3UVectorStruct@@A ; ViewTrans
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 261  : 
; 262  : 			if (vec.v[Z] < RenderSettings.NearClip || vec.v[Z] >= RenderSettings.FarClip) continue;

	fld	DWORD PTR _vec$[ebp+8]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L81554
	fld	DWORD PTR _vec$[ebp+8]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+32
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L81553
$L81554:
	jmp	SHORT $L81551
$L81553:

; 263  : 
; 264  : 			sx = vec.v[X] * RenderSettings.GeomPers / vec.v[Z] + REAL_SCREEN_XHALF;

	fld	DWORD PTR _vec$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fdiv	DWORD PTR _vec$[ebp+8]
	fadd	DWORD PTR __real@43a00000
	fstp	DWORD PTR _sx$[ebp]

; 265  : 			sy = vec.v[Y] * RenderSettings.GeomPers / vec.v[Z] + REAL_SCREEN_YHALF;

	fld	DWORD PTR _vec$[ebp+4]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fdiv	DWORD PTR _vec$[ebp+8]
	fadd	DWORD PTR __real@43700000
	fstp	DWORD PTR _sy$[ebp]

; 266  : 
; 267  : 			xrad = (InstanceModels[inst->Model].Models[0].Radius * RenderSettings.GeomPers) / vec.v[Z];

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fmul	DWORD PTR [edx+ecx+16]
	fdiv	DWORD PTR _vec$[ebp+8]
	fstp	DWORD PTR _xrad$[ebp]

; 268  : 			yrad = (InstanceModels[inst->Model].Models[0].Radius * RenderSettings.GeomPers) / vec.v[Z];

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fmul	DWORD PTR [edx+ecx+16]
	fdiv	DWORD PTR _vec$[ebp+8]
	fstp	DWORD PTR _yrad$[ebp]

; 269  : 
; 270  : 			if (MouseXpos > sx - xrad && MouseXpos < sx + xrad && MouseYpos > sy - yrad && MouseYpos < sy + yrad)

	fld	DWORD PTR _sx$[ebp]
	fsub	DWORD PTR _xrad$[ebp]
	fcomp	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fnstsw	ax
	test	ah, 5
	jp	$L81555
	fld	DWORD PTR _sx$[ebp]
	fadd	DWORD PTR _xrad$[ebp]
	fcomp	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81555
	fld	DWORD PTR _sy$[ebp]
	fsub	DWORD PTR _yrad$[ebp]
	fcomp	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fnstsw	ax
	test	ah, 5
	jp	$L81555
	fld	DWORD PTR _sy$[ebp]
	fadd	DWORD PTR _yrad$[ebp]
	fcomp	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81555

; 271  : 			{
; 272  : 				dist = (float)sqrt((sx - MouseXpos) * (sx - MouseXpos) + (sy - MouseYpos) * (sy - MouseYpos));

	fld	DWORD PTR _sx$[ebp]
	fsub	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fld	DWORD PTR _sx$[ebp]
	fsub	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fmulp	ST(1), ST(0)
	fld	DWORD PTR _sy$[ebp]
	fsub	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fld	DWORD PTR _sy$[ebp]
	fsub	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 273  : 				if (dist < ndist)

	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _ndist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81555

; 274  : 				{
; 275  : 					ninst = inst;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR _ninst$[ebp], eax

; 276  : 					ndist = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _ndist$[ebp], eax
$L81555:

; 277  : 				}
; 278  : 			}
; 279  : 		}

	jmp	$L81551
$L81552:

; 280  : 		if (ninst)

	cmp	DWORD PTR _ninst$[ebp], 0
	je	SHORT $L81549

; 281  : 		{
; 282  : 			CurrentInstance = ninst;

	mov	eax, DWORD PTR _ninst$[ebp]
	mov	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, eax ; CurrentInstance

; 283  : 			return;

	jmp	$L81517
$L81549:

; 284  : 		}
; 285  : 	}
; 286  : 
; 287  : // new instance?
; 288  : 
; 289  : 	if (Keys[DIK_INSERT] && !LastKeys[DIK_INSERT])

	movsx	eax, BYTE PTR ?Keys@@3PADA+210
	test	eax, eax
	je	$L81559
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+210
	test	eax, eax
	jne	$L81559

; 290  : 	{
; 291  : 		if ((inst = AllocInstance()))

	call	?AllocInstance@@YAPAUINSTANCE@@XZ	; AllocInstance
	mov	DWORD PTR _inst$[ebp], eax
	cmp	DWORD PTR _inst$[ebp], 0
	je	$L81559

; 292  : 		{
; 293  : 			vec.v[X] = 0;

	mov	DWORD PTR _vec$[ebp], 0

; 294  : 			vec.v[Y] = 0;

	mov	DWORD PTR _vec$[ebp+4], 0

; 295  : 			vec.v[Z] = 256;

	mov	DWORD PTR _vec$[ebp+8], 1132462080	; 43800000H

; 296  : 			RotVector(&CAM_MainCamera->WMatrix, &vec, &vec2);

	lea	eax, DWORD PTR _vec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 297  : 			AddVector(&CAM_MainCamera->WPos, &vec2, &inst->WorldPos);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _vec2$[ebp]
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _inst$[ebp]
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _vec2$[ebp+4]
	fadd	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _inst$[ebp]
	fstp	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _vec2$[ebp+8]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _inst$[ebp]
	fstp	DWORD PTR [ecx+40]

; 298  : 
; 299  : 			RotMatrixZYX(&inst->WorldMatrix, 0, 0, 0);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 300  : 
; 301  : 			inst->r = 0;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	BYTE PTR [eax+4], 0

; 302  : 			inst->g = 0;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	BYTE PTR [eax+5], 0

; 303  : 			inst->b = 0;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	BYTE PTR [eax+6], 0

; 304  : 			inst->EnvRGB = 0x808080;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [eax+8], 8421504		; 00808080H

; 305  : 			inst->Model = LastModel;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	cl, BYTE PTR _LastModel
	mov	BYTE PTR [eax], cl

; 306  : 			inst->Priority = FALSE;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	BYTE PTR [eax+1], 0

; 307  : 			inst->LodBias = 1024;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [eax+16], 1149239296		; 44800000H

; 308  : 			inst->Flag = INSTANCE_SET_MODEL_RGB;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	BYTE PTR [eax+2], 16			; 00000010H

; 309  : 
; 310  : 			SetInstanceBoundingBoxes(inst);

	mov	eax, DWORD PTR _inst$[ebp]
	push	eax
	call	?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z ; SetInstanceBoundingBoxes
	add	esp, 4

; 311  : 			AllocOneInstanceRGB(inst);

	mov	eax, DWORD PTR _inst$[ebp]
	push	eax
	call	?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z ; AllocOneInstanceRGB
	add	esp, 4

; 312  : 
; 313  : 			CurrentInstance = inst;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, eax ; CurrentInstance
$L81559:

; 314  : 		}
; 315  : 	}
; 316  : 
; 317  : // quit now if no current instance
; 318  : 
; 319  : 	if (!CurrentInstance) return;

	cmp	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, 0 ; CurrentInstance
	jne	SHORT $L81561
	jmp	$L81517
$L81561:

; 320  : 
; 321  : // set last mode
; 322  : 
; 323  : 	LastModel = CurrentInstance->Model;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _LastModel, cl

; 324  : 
; 325  : // set mirror flags
; 326  : 
; 327  : 	if ((CurrentInstance->MirrorFlag = GetMirrorPlane(&CurrentInstance->WorldPos)))

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 32					; 00000020H
	push	eax
	call	?GetMirrorPlane@@YAJPAUVectorStruct@@@Z	; GetMirrorPlane
	add	esp, 4
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $L81562

; 328  : 		CurrentInstance->MirrorHeight = MirrorHeight;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?MirrorHeight@@3MA
	mov	DWORD PTR [eax+20], ecx
$L81562:

; 329  : 
; 330  : // exit current instance edit?
; 331  : 
; 332  : 	if (Keys[DIK_RETURN] && !LastKeys[DIK_RETURN])

	movsx	eax, BYTE PTR ?Keys@@3PADA+28
	test	eax, eax
	je	SHORT $L81563
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+28
	test	eax, eax
	jne	SHORT $L81563

; 333  : 	{
; 334  : 		CurrentInstance = NULL;

	mov	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, 0 ; CurrentInstance

; 335  : 		return;

	jmp	$L81517
$L81563:

; 336  : 	}
; 337  : 
; 338  : // update bounding box and VisiMask
; 339  : 
; 340  : 	SetInstanceBoundingBoxes(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z ; SetInstanceBoundingBoxes
	add	esp, 4

; 341  : 
; 342  : // delete current instance?
; 343  : 
; 344  : 	if (Keys[DIK_DELETE] && !LastKeys[DIK_DELETE])

	movsx	eax, BYTE PTR ?Keys@@3PADA+211
	test	eax, eax
	je	SHORT $L81564
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+211
	test	eax, eax
	jne	SHORT $L81564

; 345  : 	{
; 346  : 		FreeOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z	; FreeOneInstanceRGB
	add	esp, 4

; 347  : 		FreeInstance(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?FreeInstance@@YAXPAUINSTANCE@@@Z	; FreeInstance
	add	esp, 4

; 348  : 		CurrentInstance = NULL;

	mov	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, 0 ; CurrentInstance

; 349  : 		return;

	jmp	$L81517
$L81564:

; 350  : 	}
; 351  : 
; 352  : // change axis?
; 353  : 
; 354  : 	if (Keys[DIK_TAB] && !LastKeys[DIK_TAB])

	movsx	eax, BYTE PTR ?Keys@@3PADA+15
	test	eax, eax
	je	SHORT $L81565
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+15
	test	eax, eax
	jne	SHORT $L81565

; 355  : 	{
; 356  : 		if (Keys[DIK_LSHIFT]) InstanceAxis--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L81566
	mov	al, BYTE PTR _InstanceAxis
	sub	al, 1
	mov	BYTE PTR _InstanceAxis, al

; 357  : 		else InstanceAxis++;

	jmp	SHORT $L81567
$L81566:
	mov	al, BYTE PTR _InstanceAxis
	add	al, 1
	mov	BYTE PTR _InstanceAxis, al
$L81567:

; 358  : 		if (InstanceAxis == -1) InstanceAxis = 5;

	movsx	eax, BYTE PTR _InstanceAxis
	cmp	eax, -1
	jne	SHORT $L81568
	mov	BYTE PTR _InstanceAxis, 5
$L81568:

; 359  : 		if (InstanceAxis == 6) InstanceAxis = 0;

	movsx	eax, BYTE PTR _InstanceAxis
	cmp	eax, 6
	jne	SHORT $L81565
	mov	BYTE PTR _InstanceAxis, 0
$L81565:

; 360  : 	}
; 361  : 
; 362  : // change axis type?
; 363  : 
; 364  : 	if (Keys[DIK_LALT] && !LastKeys[DIK_LALT])

	movsx	eax, BYTE PTR ?Keys@@3PADA+56
	test	eax, eax
	je	SHORT $L81570
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+56
	test	eax, eax
	jne	SHORT $L81570

; 365  : 		InstanceAxisType ^= 1;

	movsx	eax, BYTE PTR _InstanceAxisType
	xor	eax, 1
	mov	BYTE PTR _InstanceAxisType, al
$L81570:

; 366  : 
; 367  : // change model?
; 368  : 
; 369  : 	if (Keys[DIK_LSHIFT]) LastKeys[DIK_NUMPADMINUS] = LastKeys[DIK_NUMPADPLUS] = 0;

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L81571
	mov	BYTE PTR ?LastKeys@@3PADA+78, 0
	mov	al, BYTE PTR ?LastKeys@@3PADA+78
	mov	BYTE PTR ?LastKeys@@3PADA+74, al
$L81571:

; 370  : 
; 371  : 	if (Keys[DIK_NUMPADMINUS] && !LastKeys[DIK_NUMPADMINUS] && CurrentInstance->Model)

	movsx	eax, BYTE PTR ?Keys@@3PADA+74
	test	eax, eax
	je	SHORT $L81572
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+74
	test	eax, eax
	jne	SHORT $L81572
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L81572

; 372  : 	{
; 373  : 		FreeOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z	; FreeOneInstanceRGB
	add	esp, 4

; 374  : 		CurrentInstance->Model--;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax]
	sub	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx], cl

; 375  : 		AllocOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z ; AllocOneInstanceRGB
	add	esp, 4
$L81572:

; 376  : 	}
; 377  : 
; 378  : 	if (Keys[DIK_NUMPADPLUS] && !LastKeys[DIK_NUMPADPLUS] && CurrentInstance->Model < InstanceModelNum - 1)

	movsx	eax, BYTE PTR ?Keys@@3PADA+78
	test	eax, eax
	je	SHORT $L81573
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+78
	test	eax, eax
	jne	SHORT $L81573
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	sub	edx, 1
	cmp	ecx, edx
	jge	SHORT $L81573

; 379  : 	{
; 380  : 		FreeOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z	; FreeOneInstanceRGB
	add	esp, 4

; 381  : 		CurrentInstance->Model++;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax]
	add	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx], cl

; 382  : 		AllocOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z ; AllocOneInstanceRGB
	add	esp, 4
$L81573:

; 383  : 	}
; 384  : 
; 385  : // change priority?
; 386  : 
; 387  : 	if (Keys[DIK_NUMPADSLASH] && !LastKeys[DIK_NUMPADSLASH]) CurrentInstance->Priority = FALSE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+181
	test	eax, eax
	je	SHORT $L81574
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+181
	test	eax, eax
	jne	SHORT $L81574
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [eax+1], 0
$L81574:

; 388  : 	if (Keys[DIK_NUMPADSTAR] && !LastKeys[DIK_NUMPADSTAR]) CurrentInstance->Priority = TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+55
	test	eax, eax
	je	SHORT $L81575
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+55
	test	eax, eax
	jne	SHORT $L81575
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [eax+1], 1
$L81575:

; 389  : 
; 390  : // toggle env?
; 391  : 
; 392  : 	if (Keys[DIK_NUMPADENTER] && !LastKeys[DIK_NUMPADENTER]) CurrentInstance->Flag ^= INSTANCE_ENV;

	movsx	eax, BYTE PTR ?Keys@@3PADA+156
	test	eax, eax
	je	SHORT $L81576
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+156
	test	eax, eax
	jne	SHORT $L81576
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movzx	ecx, BYTE PTR [eax+2]
	xor	ecx, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+2], cl
$L81576:

; 393  : 
; 394  : // toggle hide?
; 395  : 
; 396  : 	if (Keys[DIK_H] && !LastKeys[DIK_H])

	movsx	eax, BYTE PTR ?Keys@@3PADA+35
	test	eax, eax
	je	SHORT $L81577
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+35
	test	eax, eax
	jne	SHORT $L81577

; 397  : 	{
; 398  : 		FreeOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z	; FreeOneInstanceRGB
	add	esp, 4

; 399  : 		CurrentInstance->Flag ^= INSTANCE_HIDE;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movzx	ecx, BYTE PTR [eax+2]
	xor	ecx, 2
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+2], cl

; 400  : 		AllocOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z ; AllocOneInstanceRGB
	add	esp, 4
$L81577:

; 401  : 	}
; 402  : 
; 403  : // toggle mirror?
; 404  : 
; 405  : 	if (Keys[DIK_M] && !LastKeys[DIK_M]) CurrentInstance->Flag ^= INSTANCE_NO_MIRROR;

	movsx	eax, BYTE PTR ?Keys@@3PADA+50
	test	eax, eax
	je	SHORT $L81578
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+50
	test	eax, eax
	jne	SHORT $L81578
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movzx	ecx, BYTE PTR [eax+2]
	xor	ecx, 4
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+2], cl
$L81578:

; 406  : 
; 407  : // toggle rgb type?
; 408  : 
; 409  : 	if (Keys[DIK_SPACE] && !LastKeys[DIK_SPACE]) InstanceRgbType ^= TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+57
	test	eax, eax
	je	SHORT $L81579
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+57
	test	eax, eax
	jne	SHORT $L81579
	movsx	eax, BYTE PTR _InstanceRgbType
	xor	eax, 1
	mov	BYTE PTR _InstanceRgbType, al
$L81579:

; 410  : 
; 411  : // toggle lit
; 412  : 
; 413  : 	if (Keys[DIK_L] && !LastKeys[DIK_L]) CurrentInstance->Flag ^= INSTANCE_NO_FILE_LIGHTS;

	movsx	eax, BYTE PTR ?Keys@@3PADA+38
	test	eax, eax
	je	SHORT $L81580
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+38
	test	eax, eax
	jne	SHORT $L81580
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movzx	ecx, BYTE PTR [eax+2]
	xor	ecx, 8
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+2], cl
$L81580:

; 414  : 
; 415  : // change env rgb?
; 416  : 
; 417  : 	if (!InstanceRgbType)

	movsx	eax, BYTE PTR _InstanceRgbType
	test	eax, eax
	jne	$L81581

; 418  : 	{
; 419  : 		rgb = (MODEL_RGB*)&CurrentInstance->EnvRGB;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 8
	mov	DWORD PTR _rgb$[ebp], eax

; 420  : 
; 421  : 		if (Keys[DIK_LSHIFT]) LastKeys[DIK_P] = LastKeys[DIK_SEMICOLON] = LastKeys[DIK_LBRACKET] = LastKeys[DIK_APOSTROPHE] = LastKeys[DIK_RBRACKET] = LastKeys[DIK_BACKSLASH] = 0;

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L81583
	mov	BYTE PTR ?LastKeys@@3PADA+43, 0
	mov	al, BYTE PTR ?LastKeys@@3PADA+43
	mov	BYTE PTR ?LastKeys@@3PADA+27, al
	mov	cl, BYTE PTR ?LastKeys@@3PADA+27
	mov	BYTE PTR ?LastKeys@@3PADA+40, cl
	mov	dl, BYTE PTR ?LastKeys@@3PADA+40
	mov	BYTE PTR ?LastKeys@@3PADA+26, dl
	mov	al, BYTE PTR ?LastKeys@@3PADA+26
	mov	BYTE PTR ?LastKeys@@3PADA+39, al
	mov	cl, BYTE PTR ?LastKeys@@3PADA+39
	mov	BYTE PTR ?LastKeys@@3PADA+25, cl
$L81583:

; 422  : 
; 423  : 		if (Keys[DIK_P] && !LastKeys[DIK_P] && rgb->r < 255) rgb->r++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+25
	test	eax, eax
	je	SHORT $L81584
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+25
	test	eax, eax
	jne	SHORT $L81584
	mov	eax, DWORD PTR _rgb$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 255				; 000000ffH
	jge	SHORT $L81584
	mov	eax, DWORD PTR _rgb$[ebp]
	mov	cl, BYTE PTR [eax+2]
	add	cl, 1
	mov	edx, DWORD PTR _rgb$[ebp]
	mov	BYTE PTR [edx+2], cl
$L81584:

; 424  : 		if (Keys[DIK_SEMICOLON] && !LastKeys[DIK_SEMICOLON] && rgb->r) rgb->r--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+39
	test	eax, eax
	je	SHORT $L81585
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+39
	test	eax, eax
	jne	SHORT $L81585
	mov	eax, DWORD PTR _rgb$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	test	ecx, ecx
	je	SHORT $L81585
	mov	eax, DWORD PTR _rgb$[ebp]
	mov	cl, BYTE PTR [eax+2]
	sub	cl, 1
	mov	edx, DWORD PTR _rgb$[ebp]
	mov	BYTE PTR [edx+2], cl
$L81585:

; 425  : 
; 426  : 		if (Keys[DIK_LBRACKET] && !LastKeys[DIK_LBRACKET] && rgb->g < 255) rgb->g++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+26
	test	eax, eax
	je	SHORT $L81586
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+26
	test	eax, eax
	jne	SHORT $L81586
	mov	eax, DWORD PTR _rgb$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 255				; 000000ffH
	jge	SHORT $L81586
	mov	eax, DWORD PTR _rgb$[ebp]
	mov	cl, BYTE PTR [eax+1]
	add	cl, 1
	mov	edx, DWORD PTR _rgb$[ebp]
	mov	BYTE PTR [edx+1], cl
$L81586:

; 427  : 		if (Keys[DIK_APOSTROPHE] && !LastKeys[DIK_APOSTROPHE] && rgb->g) rgb->g--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+40
	test	eax, eax
	je	SHORT $L81587
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+40
	test	eax, eax
	jne	SHORT $L81587
	mov	eax, DWORD PTR _rgb$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $L81587
	mov	eax, DWORD PTR _rgb$[ebp]
	mov	cl, BYTE PTR [eax+1]
	sub	cl, 1
	mov	edx, DWORD PTR _rgb$[ebp]
	mov	BYTE PTR [edx+1], cl
$L81587:

; 428  : 
; 429  : 		if (Keys[DIK_RBRACKET] && !LastKeys[DIK_RBRACKET] && rgb->b < 255) rgb->b++;

	movsx	eax, BYTE PTR ?Keys@@3PADA+27
	test	eax, eax
	je	SHORT $L81588
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+27
	test	eax, eax
	jne	SHORT $L81588
	mov	eax, DWORD PTR _rgb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jge	SHORT $L81588
	mov	eax, DWORD PTR _rgb$[ebp]
	mov	cl, BYTE PTR [eax]
	add	cl, 1
	mov	edx, DWORD PTR _rgb$[ebp]
	mov	BYTE PTR [edx], cl
$L81588:

; 430  : 		if (Keys[DIK_BACKSLASH] && !LastKeys[DIK_BACKSLASH] && rgb->b) rgb->b--;

	movsx	eax, BYTE PTR ?Keys@@3PADA+43
	test	eax, eax
	je	SHORT $L81581
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+43
	test	eax, eax
	jne	SHORT $L81581
	mov	eax, DWORD PTR _rgb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L81581
	mov	eax, DWORD PTR _rgb$[ebp]
	mov	cl, BYTE PTR [eax]
	sub	cl, 1
	mov	edx, DWORD PTR _rgb$[ebp]
	mov	BYTE PTR [edx], cl
$L81581:

; 431  : 	}
; 432  : 
; 433  : // change model rgb?
; 434  : 
; 435  : 	if (InstanceRgbType)

	movsx	eax, BYTE PTR _InstanceRgbType
	test	eax, eax
	je	$L81590

; 436  : 	{
; 437  : 		flag = FALSE;

	mov	DWORD PTR _flag$[ebp], 0

; 438  : 
; 439  : 		if (Keys[DIK_LSHIFT]) LastKeys[DIK_P] = LastKeys[DIK_SEMICOLON] = LastKeys[DIK_LBRACKET] = LastKeys[DIK_APOSTROPHE] = LastKeys[DIK_RBRACKET] = LastKeys[DIK_BACKSLASH] = 0;

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L81591
	mov	BYTE PTR ?LastKeys@@3PADA+43, 0
	mov	al, BYTE PTR ?LastKeys@@3PADA+43
	mov	BYTE PTR ?LastKeys@@3PADA+27, al
	mov	cl, BYTE PTR ?LastKeys@@3PADA+27
	mov	BYTE PTR ?LastKeys@@3PADA+40, cl
	mov	dl, BYTE PTR ?LastKeys@@3PADA+40
	mov	BYTE PTR ?LastKeys@@3PADA+26, dl
	mov	al, BYTE PTR ?LastKeys@@3PADA+26
	mov	BYTE PTR ?LastKeys@@3PADA+39, al
	mov	cl, BYTE PTR ?LastKeys@@3PADA+39
	mov	BYTE PTR ?LastKeys@@3PADA+25, cl
$L81591:

; 440  : 
; 441  : 		if (Keys[DIK_P] && !LastKeys[DIK_P] && CurrentInstance->r < 127) CurrentInstance->r++, flag = TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+25
	test	eax, eax
	je	SHORT $L81592
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+25
	test	eax, eax
	jne	SHORT $L81592
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 127				; 0000007fH
	jge	SHORT $L81592
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax+4]
	add	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+4], cl
	mov	DWORD PTR _flag$[ebp], 1
$L81592:

; 442  : 		if (Keys[DIK_SEMICOLON] && !LastKeys[DIK_SEMICOLON] && CurrentInstance->r > -128) CurrentInstance->r--, flag = TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+39
	test	eax, eax
	je	SHORT $L81593
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+39
	test	eax, eax
	jne	SHORT $L81593
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -128				; ffffff80H
	jle	SHORT $L81593
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax+4]
	sub	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+4], cl
	mov	DWORD PTR _flag$[ebp], 1
$L81593:

; 443  : 
; 444  : 		if (Keys[DIK_LBRACKET] && !LastKeys[DIK_LBRACKET] && CurrentInstance->g < 127) CurrentInstance->g++, flag = TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+26
	test	eax, eax
	je	SHORT $L81594
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+26
	test	eax, eax
	jne	SHORT $L81594
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movsx	ecx, BYTE PTR [eax+5]
	cmp	ecx, 127				; 0000007fH
	jge	SHORT $L81594
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax+5]
	add	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+5], cl
	mov	DWORD PTR _flag$[ebp], 1
$L81594:

; 445  : 		if (Keys[DIK_APOSTROPHE] && !LastKeys[DIK_APOSTROPHE] && CurrentInstance->g > -128) CurrentInstance->g--, flag = TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+40
	test	eax, eax
	je	SHORT $L81595
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+40
	test	eax, eax
	jne	SHORT $L81595
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movsx	ecx, BYTE PTR [eax+5]
	cmp	ecx, -128				; ffffff80H
	jle	SHORT $L81595
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax+5]
	sub	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+5], cl
	mov	DWORD PTR _flag$[ebp], 1
$L81595:

; 446  : 
; 447  : 		if (Keys[DIK_RBRACKET] && !LastKeys[DIK_RBRACKET] && CurrentInstance->b < 127) CurrentInstance->b++, flag = TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+27
	test	eax, eax
	je	SHORT $L81596
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+27
	test	eax, eax
	jne	SHORT $L81596
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movsx	ecx, BYTE PTR [eax+6]
	cmp	ecx, 127				; 0000007fH
	jge	SHORT $L81596
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax+6]
	add	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+6], cl
	mov	DWORD PTR _flag$[ebp], 1
$L81596:

; 448  : 		if (Keys[DIK_BACKSLASH] && !LastKeys[DIK_BACKSLASH] && CurrentInstance->b > -128) CurrentInstance->b--, flag = TRUE;

	movsx	eax, BYTE PTR ?Keys@@3PADA+43
	test	eax, eax
	je	SHORT $L81597
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+43
	test	eax, eax
	jne	SHORT $L81597
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	movsx	ecx, BYTE PTR [eax+6]
	cmp	ecx, -128				; ffffff80H
	jle	SHORT $L81597
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	cl, BYTE PTR [eax+6]
	sub	cl, 1
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	BYTE PTR [edx+6], cl
	mov	DWORD PTR _flag$[ebp], 1
$L81597:

; 449  : 
; 450  : 		if (flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $L81590

; 451  : 		{
; 452  : 			FreeOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z	; FreeOneInstanceRGB
	add	esp, 4

; 453  : 			AllocOneInstanceRGB(CurrentInstance);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	call	?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z ; AllocOneInstanceRGB
	add	esp, 4
$L81590:

; 454  : 		}
; 455  : 	}
; 456  : 
; 457  : // change LOD bias?
; 458  : 
; 459  : 	if (Keys[DIK_MINUS]) CurrentInstance->LodBias -= TimeFactor * 4;

	movsx	eax, BYTE PTR ?Keys@@3PADA+12
	test	eax, eax
	je	SHORT $L81599
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR __real@40800000
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fsubr	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+16]
$L81599:

; 460  : 	if (Keys[DIK_EQUALS]) CurrentInstance->LodBias += TimeFactor * 4;

	movsx	eax, BYTE PTR ?Keys@@3PADA+13
	test	eax, eax
	je	SHORT $L81600
	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fmul	DWORD PTR __real@40800000
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fadd	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+16]
$L81600:

; 461  : 
; 462  : 	if (CurrentInstance->LodBias < 64) CurrentInstance->LodBias = 64;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR __real@42800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81601
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	DWORD PTR [eax+16], 1115684864		; 42800000H
$L81601:

; 463  : 	if (CurrentInstance->LodBias > 8192) CurrentInstance->LodBias = 8192;

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR __real@46000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81602
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	DWORD PTR [eax+16], 1174405120		; 46000000H
$L81602:

; 464  : 
; 465  : // copy instance?
; 466  : 
; 467  : 	if (MouseLeft && !MouseLastLeft && Keys[DIK_LSHIFT])

	movsx	eax, BYTE PTR ?MouseLeft@@3DA		; MouseLeft
	test	eax, eax
	je	SHORT $L81603
	movsx	eax, BYTE PTR ?MouseLastLeft@@3DA	; MouseLastLeft
	test	eax, eax
	jne	SHORT $L81603
	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L81603

; 468  : 	{
; 469  : 		if ((inst = AllocInstance()))

	call	?AllocInstance@@YAPAUINSTANCE@@XZ	; AllocInstance
	mov	DWORD PTR _inst$[ebp], eax
	cmp	DWORD PTR _inst$[ebp], 0
	je	SHORT $L81603

; 470  : 		{
; 471  : 			memcpy(inst, CurrentInstance, sizeof(INSTANCE));

	push	136					; 00000088H
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 472  : 			CurrentInstance = inst;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A, eax ; CurrentInstance

; 473  : 			return;

	jmp	$L81517
$L81603:

; 474  : 		}
; 475  : 	}
; 476  : 
; 477  : // move instance?
; 478  : 
; 479  : 	if (MouseLeft)

	movsx	eax, BYTE PTR ?MouseLeft@@3DA		; MouseLeft
	test	eax, eax
	je	$L81606

; 480  : 	{
; 481  : 		RotTransVector(&ViewMatrix, &ViewTrans, &CurrentInstance->WorldPos, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET FLAT:?ViewTrans@@3UVectorStruct@@A ; ViewTrans
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 482  : 
; 483  : 		switch (InstanceAxis)

	movsx	eax, BYTE PTR _InstanceAxis
	mov	DWORD PTR tv962[ebp], eax
	cmp	DWORD PTR tv962[ebp], 5
	ja	$L81608
	mov	ecx, DWORD PTR tv962[ebp]
	jmp	DWORD PTR $L82038[ecx*4]
$L81611:

; 484  : 		{
; 485  : 			case INSTANCE_AXIS_XY:
; 486  : 				vec.v[X] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditXrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditXrel@@3MA		; CameraEditXrel
	fstp	DWORD PTR _vec$[ebp]

; 487  : 				vec.v[Y] = MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditYrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditYrel@@3MA		; CameraEditYrel
	fstp	DWORD PTR _vec$[ebp+4]

; 488  : 				vec.v[Z] = CameraEditZrel;

	mov	eax, DWORD PTR ?CameraEditZrel@@3MA
	mov	DWORD PTR _vec$[ebp+8], eax

; 489  : 				break;

	jmp	$L81608
$L81612:

; 490  : 			case INSTANCE_AXIS_XZ:
; 491  : 				vec.v[X] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditXrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditXrel@@3MA		; CameraEditXrel
	fstp	DWORD PTR _vec$[ebp]

; 492  : 				vec.v[Y] = CameraEditYrel;

	mov	eax, DWORD PTR ?CameraEditYrel@@3MA
	mov	DWORD PTR _vec$[ebp+4], eax

; 493  : 				vec.v[Z] = -MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditZrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fchs
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditZrel@@3MA		; CameraEditZrel
	fstp	DWORD PTR _vec$[ebp+8]

; 494  : 				break;

	jmp	$L81608
$L81613:

; 495  : 			case INSTANCE_AXIS_ZY:
; 496  : 				vec.v[X] = CameraEditXrel;

	mov	eax, DWORD PTR ?CameraEditXrel@@3MA
	mov	DWORD PTR _vec$[ebp], eax

; 497  : 				vec.v[Y] = MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditYrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditYrel@@3MA		; CameraEditYrel
	fstp	DWORD PTR _vec$[ebp+4]

; 498  : 				vec.v[Z] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditZrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditZrel@@3MA		; CameraEditZrel
	fstp	DWORD PTR _vec$[ebp+8]

; 499  : 				break;

	jmp	SHORT $L81608
$L81614:

; 500  : 			case INSTANCE_AXIS_X:
; 501  : 				vec.v[X] = MouseXrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditXrel;

	fld	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditXrel@@3MA		; CameraEditXrel
	fstp	DWORD PTR _vec$[ebp]

; 502  : 				vec.v[Y] = CameraEditYrel;

	mov	eax, DWORD PTR ?CameraEditYrel@@3MA
	mov	DWORD PTR _vec$[ebp+4], eax

; 503  : 				vec.v[Z] = CameraEditZrel;

	mov	eax, DWORD PTR ?CameraEditZrel@@3MA
	mov	DWORD PTR _vec$[ebp+8], eax

; 504  : 				break;

	jmp	SHORT $L81608
$L81615:

; 505  : 			case INSTANCE_AXIS_Y:
; 506  : 				vec.v[X] = CameraEditXrel;

	mov	eax, DWORD PTR ?CameraEditXrel@@3MA
	mov	DWORD PTR _vec$[ebp], eax

; 507  : 				vec.v[Y] = MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditYrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditYrel@@3MA		; CameraEditYrel
	fstp	DWORD PTR _vec$[ebp+4]

; 508  : 				vec.v[Z] = CameraEditZrel;

	mov	eax, DWORD PTR ?CameraEditZrel@@3MA
	mov	DWORD PTR _vec$[ebp+8], eax

; 509  : 				break;

	jmp	SHORT $L81608
$L81616:

; 510  : 			case INSTANCE_AXIS_Z:
; 511  : 				vec.v[X] = CameraEditXrel;

	mov	eax, DWORD PTR ?CameraEditXrel@@3MA
	mov	DWORD PTR _vec$[ebp], eax

; 512  : 				vec.v[Y] = CameraEditYrel;

	mov	eax, DWORD PTR ?CameraEditYrel@@3MA
	mov	DWORD PTR _vec$[ebp+4], eax

; 513  : 				vec.v[Z] = -MouseYrel * vec.v[Z] / RenderSettings.GeomPers + CameraEditZrel;

	fld	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fchs
	fmul	DWORD PTR _vec$[ebp+8]
	fdiv	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fadd	DWORD PTR ?CameraEditZrel@@3MA		; CameraEditZrel
	fstp	DWORD PTR _vec$[ebp+8]
$L81608:

; 514  : 				break;
; 515  : 		}
; 516  : 
; 517  : 		if (InstanceAxisType == 1) 

	movsx	eax, BYTE PTR _InstanceAxisType
	cmp	eax, 1
	jne	SHORT $L81617

; 518  : 		{
; 519  : 			SetVector(&vec2, vec.v[X], vec.v[Y], vec.v[Z]);

	mov	eax, DWORD PTR _vec$[ebp]
	mov	DWORD PTR _vec2$[ebp], eax
	mov	eax, DWORD PTR _vec$[ebp+4]
	mov	DWORD PTR _vec2$[ebp+4], eax
	mov	eax, DWORD PTR _vec$[ebp+8]
	mov	DWORD PTR _vec2$[ebp+8], eax

; 520  : 		}
; 521  : 		else

	jmp	SHORT $L81618
$L81617:

; 522  : 		{
; 523  : 			RotVector(&CAM_MainCamera->WMatrix, &vec, &vec2);

	lea	eax, DWORD PTR _vec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH
$L81618:

; 524  : 		}
; 525  : 
; 526  : 		CurrentInstance->WorldPos.v[X] += vec2.v[X];

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR _vec2$[ebp]
	fadd	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+32]

; 527  : 		CurrentInstance->WorldPos.v[Y] += vec2.v[Y];

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR _vec2$[ebp+4]
	fadd	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+36]

; 528  : 		CurrentInstance->WorldPos.v[Z] += vec2.v[Z];

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR _vec2$[ebp+8]
	fadd	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+40]
$L81606:

; 529  : 	}
; 530  : 
; 531  : // rotate instance?
; 532  : 
; 533  : 	vec.v[X] = vec.v[Y] = vec.v[Z] = 0;

	mov	DWORD PTR _vec$[ebp+8], 0
	mov	eax, DWORD PTR _vec$[ebp+8]
	mov	DWORD PTR _vec$[ebp+4], eax
	mov	ecx, DWORD PTR _vec$[ebp+4]
	mov	DWORD PTR _vec$[ebp], ecx

; 534  : 
; 535  : 	if (Keys[DIK_NUMPAD7]) vec.v[X] -= 0.005f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+71
	test	eax, eax
	je	SHORT $L81619
	fld	DWORD PTR _vec$[ebp]
	fsub	DWORD PTR __real@3ba3d70a
	fstp	DWORD PTR _vec$[ebp]
$L81619:

; 536  : 	if (Keys[DIK_NUMPAD4]) vec.v[X] += 0.005f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+75
	test	eax, eax
	je	SHORT $L81620
	fld	DWORD PTR _vec$[ebp]
	fadd	DWORD PTR __real@3ba3d70a
	fstp	DWORD PTR _vec$[ebp]
$L81620:

; 537  : 	if (Keys[DIK_NUMPAD8]) vec.v[Y] -= 0.005f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+72
	test	eax, eax
	je	SHORT $L81621
	fld	DWORD PTR _vec$[ebp+4]
	fsub	DWORD PTR __real@3ba3d70a
	fstp	DWORD PTR _vec$[ebp+4]
$L81621:

; 538  : 	if (Keys[DIK_NUMPAD5]) vec.v[Y] += 0.005f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+76
	test	eax, eax
	je	SHORT $L81622
	fld	DWORD PTR _vec$[ebp+4]
	fadd	DWORD PTR __real@3ba3d70a
	fstp	DWORD PTR _vec$[ebp+4]
$L81622:

; 539  : 	if (Keys[DIK_NUMPAD9]) vec.v[Z] -= 0.005f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+73
	test	eax, eax
	je	SHORT $L81623
	fld	DWORD PTR _vec$[ebp+8]
	fsub	DWORD PTR __real@3ba3d70a
	fstp	DWORD PTR _vec$[ebp+8]
$L81623:

; 540  : 	if (Keys[DIK_NUMPAD6]) vec.v[Z] += 0.005f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+77
	test	eax, eax
	je	SHORT $L81624
	fld	DWORD PTR _vec$[ebp+8]
	fadd	DWORD PTR __real@3ba3d70a
	fstp	DWORD PTR _vec$[ebp+8]
$L81624:

; 541  : 
; 542  : 	if (Keys[DIK_NUMPAD1] && !LastKeys[DIK_NUMPAD1]) vec.v[X] += 0.25f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+79
	test	eax, eax
	je	SHORT $L81625
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+79
	test	eax, eax
	jne	SHORT $L81625
	fld	DWORD PTR _vec$[ebp]
	fadd	DWORD PTR __real@3e800000
	fstp	DWORD PTR _vec$[ebp]
$L81625:

; 543  : 	if (Keys[DIK_NUMPAD2] && !LastKeys[DIK_NUMPAD2]) vec.v[Y] += 0.25f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+80
	test	eax, eax
	je	SHORT $L81626
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+80
	test	eax, eax
	jne	SHORT $L81626
	fld	DWORD PTR _vec$[ebp+4]
	fadd	DWORD PTR __real@3e800000
	fstp	DWORD PTR _vec$[ebp+4]
$L81626:

; 544  : 	if (Keys[DIK_NUMPAD3] && !LastKeys[DIK_NUMPAD3]) vec.v[Z] += 0.25f;

	movsx	eax, BYTE PTR ?Keys@@3PADA+81
	test	eax, eax
	je	SHORT $L81627
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+81
	test	eax, eax
	jne	SHORT $L81627
	fld	DWORD PTR _vec$[ebp+8]
	fadd	DWORD PTR __real@3e800000
	fstp	DWORD PTR _vec$[ebp+8]
$L81627:

; 545  : 
; 546  : 	if (Keys[DIK_NUMPAD0]) CopyMatrix(&IdentityMatrix, &CurrentInstance->WorldMatrix);

	movsx	eax, BYTE PTR ?Keys@@3PADA+82
	test	eax, eax
	je	SHORT $L81628
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET FLAT:?IdentityMatrix@@3TMatrixUnion@@A ; IdentityMatrix
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8
$L81628:

; 547  : 
; 548  : 	RotMatrixZYX(&mat, vec.v[X], vec.v[Y], vec.v[Z]);

	mov	eax, DWORD PTR _vec$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _vec$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _vec$[ebp]
	push	edx
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 549  : 
; 550  : 	if (InstanceAxisType)

	movsx	eax, BYTE PTR _InstanceAxisType
	test	eax, eax
	je	$L81629

; 551  : 	{
; 552  : 		MulMatrix(&mat, &CurrentInstance->WorldMatrix, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	ecx, 44					; 0000002cH
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 553  : 		CopyMatrix(&mat2, &CurrentInstance->WorldMatrix);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 44					; 0000002cH
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 554  : 		NormalizeMatrix(&CurrentInstance->WorldMatrix);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+60]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR [edx+64]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81630[ebp]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81630[ebp]
	fmul	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81630[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81630[ebp]
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [ecx+76]
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81632[ebp]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81632[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81632[ebp]
	fmul	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81632[ebp]
	fmul	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+76]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+76]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+72]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+56]
	fmul	DWORD PTR [eax+76]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+68]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+76]
	fmul	DWORD PTR [eax+48]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [eax+52]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+44]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+64]

; 555  : 	}
; 556  : 	else if (vec.v[X] || vec.v[Y] || vec.v[Z])

	jmp	$L81517
$L81629:
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _vec$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81636
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _vec$[ebp+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81636
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _vec$[ebp+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$L81517
$L81636:

; 557  : 	{
; 558  : 		RotVector(&ViewMatrix, &CurrentInstance->WorldMatrix.mv[X], &r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	ecx, 44					; 0000002cH
	push	ecx
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 559  : 		RotVector(&ViewMatrix, &CurrentInstance->WorldMatrix.mv[Y], &u);

	lea	eax, DWORD PTR _u$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	ecx, 56					; 00000038H
	push	ecx
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 560  : 		RotVector(&ViewMatrix, &CurrentInstance->WorldMatrix.mv[Z], &l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	ecx, 68					; 00000044H
	push	ecx
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 561  : 
; 562  : 		RotVector(&mat, &r, &r2);

	lea	eax, DWORD PTR _r2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 563  : 		RotVector(&mat, &u, &u2);

	lea	eax, DWORD PTR _u2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _u$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 564  : 		RotVector(&mat, &l, &l2);

	lea	eax, DWORD PTR _l2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 565  : 
; 566  : 		RotVector(&CAM_MainCamera->WMatrix, &r2, &CurrentInstance->WorldMatrix.mv[X]);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 44					; 0000002cH
	push	eax
	lea	ecx, DWORD PTR _r2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 567  : 		RotVector(&CAM_MainCamera->WMatrix, &u2, &CurrentInstance->WorldMatrix.mv[Y]);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 56					; 00000038H
	push	eax
	lea	ecx, DWORD PTR _u2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 568  : 		RotVector(&CAM_MainCamera->WMatrix, &l2, &CurrentInstance->WorldMatrix.mv[Z]);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _l2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 569  : 
; 570  : 		NormalizeMatrix(&CurrentInstance->WorldMatrix);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+60]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [ecx+64]
	fmul	DWORD PTR [edx+64]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81637[ebp]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81637[ebp]
	fmul	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81637[ebp]
	fmul	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81637[ebp]
	fmul	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+64]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+72]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [ecx+76]
	fmul	DWORD PTR [edx+76]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81639[ebp]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81639[ebp]
	fmul	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81639[ebp]
	fmul	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR __mul$81639[ebp]
	fmul	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+76]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+60]
	fmul	DWORD PTR [ecx+76]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+64]
	fmul	DWORD PTR [eax+72]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+64]
	fmul	DWORD PTR [ecx+68]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+56]
	fmul	DWORD PTR [eax+76]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+56]
	fmul	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+60]
	fmul	DWORD PTR [eax+68]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+76]
	fmul	DWORD PTR [eax+48]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+76]
	fmul	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+68]
	fmul	DWORD PTR [eax+52]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fld	DWORD PTR [edx+72]
	fmul	DWORD PTR [eax+44]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	fstp	DWORD PTR [ecx+64]
$L81517:

; 571  : 	}
; 572  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L82038:
	DD	$L81611
	DD	$L81612
	DD	$L81613
	DD	$L81614
	DD	$L81615
	DD	$L81616
?EditInstances@@YAXXZ ENDP				; EditInstances
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\instance.cpp
_TEXT	ENDS
;	COMDAT ?AllocInstance@@YAPAUINSTANCE@@XZ
_TEXT	SEGMENT
tv68 = -68						; size = 4
?AllocInstance@@YAPAUINSTANCE@@XZ PROC NEAR		; AllocInstance, COMDAT

; 579  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 580  : 
; 581  : // full?
; 582  : 
; 583  : 	if (InstanceNum >= MAX_INSTANCES)

	cmp	DWORD PTR ?InstanceNum@@3JA, 200	; InstanceNum, 000000c8H
	jl	SHORT $L81644

; 584  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L81643
$L81644:

; 585  : 
; 586  : // inc counter, return slot
; 587  : 
; 588  : 	return &Instances[InstanceNum++];

	mov	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	add	ecx, 1
	mov	DWORD PTR ?InstanceNum@@3JA, ecx	; InstanceNum
	mov	eax, DWORD PTR tv68[ebp]
$L81643:

; 589  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocInstance@@YAPAUINSTANCE@@XZ ENDP			; AllocInstance
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?FreeInstance@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_idx$ = -4						; size = 4
_inst$ = 8						; size = 4
?FreeInstance@@YAXPAUINSTANCE@@@Z PROC NEAR		; FreeInstance, COMDAT

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 597  : 	long idx, i;
; 598  : 
; 599  : // find index into list
; 600  : 
; 601  : 	idx = (long)(inst - Instances);

	mov	eax, DWORD PTR _inst$[ebp]
	sub	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	cdq
	mov	ecx, 136				; 00000088H
	idiv	ecx
	mov	DWORD PTR _idx$[ebp], eax

; 602  : 
; 603  : // copy all higher instances down one
; 604  : 
; 605  : 	for (i = idx ; i < InstanceNum - 1; i++)

	mov	eax, DWORD PTR _idx$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L81651
$L81652:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81651:
	mov	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L81653

; 606  : 	{
; 607  : 		Instances[i] = Instances[i + 1];

	mov	esi, DWORD PTR _i$[ebp]
	add	esi, 1
	imul	esi, 136				; 00000088H
	add	esi, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	mov	edi, DWORD PTR _i$[ebp]
	imul	edi, 136				; 00000088H
	add	edi, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	mov	ecx, 34					; 00000022H
	rep movsd

; 608  : 	}

	jmp	SHORT $L81652
$L81653:

; 609  : 
; 610  : // dec num
; 611  : 
; 612  : 	InstanceNum--;

	mov	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	sub	eax, 1
	mov	DWORD PTR ?InstanceNum@@3JA, eax	; InstanceNum

; 613  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeInstance@@YAXPAUINSTANCE@@@Z ENDP			; FreeInstance
_TEXT	ENDS
PUBLIC	__real@4b000000
PUBLIC	__real@437f0000
PUBLIC	?DrawInstances@@YAXXZ				; DrawInstances
EXTRN	?DxState@@3UDX_STATE@@A:BYTE			; DxState
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
EXTRN	?RenderStateChange@@3JA:DWORD			; RenderStateChange
EXTRN	?CheckInstanceLight@@YAFPAUINSTANCE@@M@Z:NEAR	; CheckInstanceLight
EXTRN	?CheckInstanceLightEdit@@YAFPAUINSTANCE@@M@Z:NEAR ; CheckInstanceLightEdit
EXTRN	?RenderFog@@3FA:WORD				; RenderFog
EXTRN	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; AddModelLight
EXTRN	?CamVisiMask@@3_KA:QWORD			; CamVisiMask
EXTRN	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z:NEAR ; TestSphereToFrustum
EXTRN	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z:NEAR ; DrawModel
EXTRN	?SetEnvStatic@@YAXPAUVectorStruct@@PATMatrixUnion@@JMMM@Z:NEAR ; SetEnvStatic
EXTRN	?CheckModelMeshFx@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@PAF@Z:NEAR ; CheckModelMeshFx
EXTRN	?ModelVertFog@@3MA:DWORD			; ModelVertFog
EXTRN	?ViewCameraPos@@3UVectorStruct@@A:BYTE		; ViewCameraPos
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DrawInstances@@YAXXZ
_TEXT	SEGMENT
tv268 = -116						; size = 8
__temp$81676 = -44					; size = 4
_savergb$ = -40						; size = 4
_inst$ = -36						; size = 4
_model$ = -32						; size = 4
_flod$ = -28						; size = 4
_z$ = -24						; size = 4
_lit$ = -20						; size = 4
_visflag$ = -16						; size = 4
_lod$ = -12						; size = 4
_i$ = -8						; size = 4
_flag$ = -4						; size = 2
?DrawInstances@@YAXXZ PROC NEAR				; DrawInstances, COMDAT

; 620  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 621  : 	short flag;
; 622  : 	long i, lod, visflag, lit;
; 623  : 	float z, flod;
; 624  : 	MODEL *model;
; 625  : 	INSTANCE *inst;
; 626  : 	POLY_RGB *savergb;
; 627  : 
; 628  : // loop thru all instances
; 629  : 
; 630  : 	inst = Instances;

	mov	DWORD PTR _inst$[ebp], OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances

; 631  : 	for (i = 0 ; i < InstanceNum ; i++, inst++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81667
$L81668:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 136				; 00000088H
	mov	DWORD PTR _inst$[ebp], ecx
$L81667:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	$L81656

; 632  : 	{
; 633  : 
; 634  : // skip if mirror hide and mirrors off
; 635  : 
; 636  : 		if ((inst->Flag & INSTANCE_HIDE) && !RenderSettings.Mirror)

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 2
	je	SHORT $L81670
	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+80, 0
	jne	SHORT $L81670

; 637  : 			continue;

	jmp	SHORT $L81668
$L81670:

; 638  : 
; 639  : // skip if turned off
; 640  : 
; 641  : 		if (!RenderSettings.Instance && !inst->Priority && !(inst->Flag & INSTANCE_HIDE))

	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+92, 0
	jne	SHORT $L81671
	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	jne	SHORT $L81671
	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 2
	jne	SHORT $L81671

; 642  : 			continue;

	jmp	SHORT $L81668
$L81671:

; 643  : 
; 644  : // visicube reject?
; 645  : 
; 646  : 		if (inst->VisiMask & CamVisiMask)

	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, DWORD PTR ?CamVisiMask@@3_KA
	mov	edx, DWORD PTR [eax+28]
	and	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	mov	DWORD PTR tv268[ebp], ecx
	mov	DWORD PTR tv268[ebp+4], edx
	mov	eax, DWORD PTR tv268[ebp]
	or	eax, DWORD PTR tv268[ebp+4]
	je	SHORT $L81672

; 647  : 			continue;

	jmp	$L81668
$L81672:

; 648  : 
; 649  : // reset draw flag
; 650  : 
; 651  : 		flag = MODEL_PLAIN;

	mov	WORD PTR _flag$[ebp], 0

; 652  : 
; 653  : // skip if offscreen
; 654  : 
; 655  : 		model = InstanceModels[inst->Model].Models;

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _model$[ebp], eax

; 656  : 
; 657  : 		visflag = TestSphereToFrustum(&inst->WorldPos, model->Radius, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	?TestSphereToFrustum@@YAJPAUVectorStruct@@MPAM@Z ; TestSphereToFrustum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _visflag$[ebp], eax

; 658  : 		if (visflag == SPHERE_OUT) continue;

	cmp	DWORD PTR _visflag$[ebp], 0
	jne	SHORT $L81673
	jmp	$L81668
$L81673:

; 659  : 		if (visflag == SPHERE_IN) flag |= MODEL_DONOTCLIP;

	cmp	DWORD PTR _visflag$[ebp], 2
	jne	SHORT $L81674
	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 8
	mov	WORD PTR _flag$[ebp], ax
$L81674:

; 660  : 
; 661  : // calc lod
; 662  : 
; 663  : 		flod = z / inst->LodBias - 1;

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR _z$[ebp]
	fdiv	DWORD PTR [eax+16]
	fsub	DWORD PTR __real@3f800000
	fstp	DWORD PTR _flod$[ebp]

; 664  : 		if (flod < 0) flod = 0;

	fld	DWORD PTR _flod$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81675
	mov	DWORD PTR _flod$[ebp], 0
$L81675:

; 665  : 		FTOL(flod, lod);

	fld	DWORD PTR _flod$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81676[ebp]
	mov	eax, DWORD PTR __temp$81676[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _lod$[ebp], eax

; 666  : 		if (lod > InstanceModels[inst->Model].Count - 1) lod = InstanceModels[inst->Model].Count - 1;

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	eax, DWORD PTR [edx+ecx]
	sub	eax, 1
	cmp	DWORD PTR _lod$[ebp], eax
	jle	SHORT $L81679
	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	eax, DWORD PTR [edx+ecx]
	sub	eax, 1
	mov	DWORD PTR _lod$[ebp], eax
$L81679:

; 667  : 		
; 668  : // calc model
; 669  : 
; 670  : 		model += lod;

	mov	eax, DWORD PTR _lod$[ebp]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR _model$[ebp]
	mov	DWORD PTR _model$[ebp], eax

; 671  : 
; 672  : // re-point model rgb
; 673  : 
; 674  : 		savergb = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _savergb$[ebp], ecx

; 675  : 		model->PolyRGB = inst->rgb[lod];

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR _lod$[ebp]
	mov	edx, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+80]
	mov	DWORD PTR [eax+44], ecx

; 676  : 
; 677  : // in fog?
; 678  : 
; 679  : 		if (z + model->Radius > RenderSettings.FogStart && DxState.Fog)

	mov	eax, DWORD PTR _model$[ebp]
	fld	DWORD PTR _z$[ebp]
	fadd	DWORD PTR [eax]
	fcomp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+48
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81680
	cmp	DWORD PTR ?DxState@@3UDX_STATE@@A+36, 0
	je	$L81680

; 680  : 		{
; 681  : 			ModelVertFog = (inst->WorldPos.v[1] - RenderSettings.VertFogStart) * RenderSettings.VertFogMul;

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR [eax+36]
	fsub	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+60
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+72
	fstp	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog

; 682  : 			if (ModelVertFog < 0) ModelVertFog = 0;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81681
	mov	DWORD PTR ?ModelVertFog@@3MA, 0
$L81681:

; 683  : 			if (ModelVertFog > 255) ModelVertFog = 255;

	fld	DWORD PTR ?ModelVertFog@@3MA		; ModelVertFog
	fcomp	DWORD PTR __real@437f0000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81682
	mov	DWORD PTR ?ModelVertFog@@3MA, 1132396544 ; 437f0000H
$L81682:

; 684  : 
; 685  : 			flag |= MODEL_FOG;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 1
	mov	WORD PTR _flag$[ebp], ax

; 686  : 			FOG_ON();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	jne	SHORT $L81680
	mov	WORD PTR ?RenderFog@@3FA, 1		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81680:

; 687  : 		}
; 688  : 
; 689  : // in light?
; 690  : 
; 691  : 		if (!(inst->Flag & INSTANCE_HIDE))

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 2
	jne	SHORT $L81684

; 692  : 		{
; 693  : 			if (EditMode == EDIT_LIGHTS || EditMode == EDIT_INSTANCES)

	cmp	DWORD PTR ?EditMode@@3JA, 1		; EditMode
	je	SHORT $L81686
	cmp	DWORD PTR ?EditMode@@3JA, 4		; EditMode
	jne	SHORT $L81685
$L81686:

; 694  : 				lit = CheckInstanceLightEdit(inst, model->Radius);

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	push	edx
	call	?CheckInstanceLightEdit@@YAFPAUINSTANCE@@M@Z ; CheckInstanceLightEdit
	add	esp, 8
	movsx	eax, ax
	mov	DWORD PTR _lit$[ebp], eax

; 695  : 			else

	jmp	SHORT $L81687
$L81685:

; 696  : 				lit = CheckInstanceLight(inst, model->Radius);

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	push	edx
	call	?CheckInstanceLight@@YAFPAUINSTANCE@@M@Z ; CheckInstanceLight
	add	esp, 8
	movsx	eax, ax
	mov	DWORD PTR _lit$[ebp], eax
$L81687:

; 697  : 
; 698  : 			if (lit)

	cmp	DWORD PTR _lit$[ebp], 0
	je	SHORT $L81684

; 699  : 			{
; 700  : 				flag |= MODEL_LIT;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 2
	mov	WORD PTR _flag$[ebp], ax

; 701  : 				AddModelLight(model, &inst->WorldPos, &inst->WorldMatrix);

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?AddModelLight@@YAXPAUMODEL@@PAUVectorStruct@@PATMatrixUnion@@@Z ; AddModelLight
	add	esp, 12					; 0000000cH
$L81684:

; 702  : 			}
; 703  : 		}
; 704  : 
; 705  : // env map?
; 706  : 
; 707  : 		if (inst->Flag & INSTANCE_ENV)

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 1
	je	SHORT $L81689

; 708  : 		{
; 709  : 			flag |= MODEL_ENV;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 4
	mov	WORD PTR _flag$[ebp], ax

; 710  : 			SetEnvStatic(&inst->WorldPos, &inst->WorldMatrix, inst->EnvRGB, 0.0f, 0.0f, 1.0f);

	push	1065353216				; 3f800000H
	push	0
	push	0
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	?SetEnvStatic@@YAXPAUVectorStruct@@PATMatrixUnion@@JMMM@Z ; SetEnvStatic
	add	esp, 24					; 00000018H
$L81689:

; 711  : 		}
; 712  : 
; 713  : // reflect?
; 714  : 
; 715  : 		if (!(inst->Flag & INSTANCE_NO_MIRROR) && inst->MirrorFlag && RenderSettings.Mirror)

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 4
	jne	SHORT $L81690
	mov	eax, DWORD PTR _inst$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L81690
	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+80, 0
	je	SHORT $L81690

; 716  : 		{
; 717  : 			if (ViewCameraPos.v[Y] < inst->MirrorHeight)

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR ?ViewCameraPos@@3UVectorStruct@@A+4
	fcomp	DWORD PTR [eax+20]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81690

; 718  : 			{
; 719  : 				MirrorHeight = inst->MirrorHeight;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR ?MirrorHeight@@3MA, ecx

; 720  : 				flag |= MODEL_MIRROR;

	movsx	eax, WORD PTR _flag$[ebp]
	or	eax, 16					; 00000010H
	mov	WORD PTR _flag$[ebp], ax
$L81690:

; 721  : 			}
; 722  : 		}
; 723  : 
; 724  : // mesh fx?
; 725  : 
; 726  : 		CheckModelMeshFx(model, &inst->WorldMatrix, &inst->WorldPos, &flag);

	lea	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?CheckModelMeshFx@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@PAF@Z ; CheckModelMeshFx
	add	esp, 16					; 00000010H

; 727  : 
; 728  : // draw
; 729  : 
; 730  : 		DrawModel(model, &inst->WorldMatrix, &inst->WorldPos, flag);

	mov	ax, WORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	?DrawModel@@YAXPAUMODEL@@PATMatrixUnion@@PAUVectorStruct@@F@Z ; DrawModel
	add	esp, 16					; 00000010H

; 731  : 
; 732  : // reset render states?
; 733  : 
; 734  : 		if (flag & MODEL_FOG)

	movsx	eax, WORD PTR _flag$[ebp]
	and	eax, 1
	je	SHORT $L81692

; 735  : 			FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L81692
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81692:

; 736  : 
; 737  : // restore model rgb
; 738  : 
; 739  : 		model->PolyRGB = savergb;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR _savergb$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 740  : 	}

	jmp	$L81668
$L81656:

; 741  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawInstances@@YAXXZ ENDP				; DrawInstances
_TEXT	ENDS
PUBLIC	?DisplayInstanceInfo@@YAXPAUINSTANCE@@@Z	; DisplayInstanceInfo
PUBLIC	??_C@_03CCLAEDDF@Yes?$AA@			; `string'
PUBLIC	??_C@_02JINPPBEP@No?$AA@			; `string'
PUBLIC	??_C@_0BC@IODMHEDJ@High?5priority?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_02IAAGKKDJ@On?$AA@			; `string'
PUBLIC	??_C@_03GCDBBDDL@Off?$AA@			; `string'
PUBLIC	??_C@_06KKGKAABK@Env?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0M@HGDKAEGB@LOD?5Bias?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BB@HECBGFIE@Env?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BD@NMOCHNCE@Model?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_05NFIJOKEG@Model?$AA@			; `string'
PUBLIC	??_C@_03EJFNLALG@Env?$AA@			; `string'
PUBLIC	??_C@_0N@EFBILDOC@RGB?5Type?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BA@JOFJLKIO@Mirror?5Hide?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0L@NOFFHJBO@Mirror?3?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BB@JHBOJFOO@Fixed?5lights?3?5?$CFs?$AA@	; `string'
EXTRN	__ftol2:NEAR
EXTRN	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z:NEAR ; DrawAxis
EXTRN	?BeginTextState@@YAXXZ:NEAR			; BeginTextState
EXTRN	?DumpText@@YAXFFFFJPAD@Z:NEAR			; DumpText
EXTRN	?RenderZwrite@@3FA:WORD				; RenderZwrite
EXTRN	?RenderZbuffer@@3FA:WORD			; RenderZbuffer
;	COMDAT ??_C@_03CCLAEDDF@Yes?$AA@
CONST	SEGMENT
??_C@_03CCLAEDDF@Yes?$AA@ DB 'Yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No?$AA@
CONST	SEGMENT
??_C@_02JINPPBEP@No?$AA@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IODMHEDJ@High?5priority?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BC@IODMHEDJ@High?5priority?3?5?$CFs?$AA@ DB 'High priority: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On?$AA@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On?$AA@ DB 'On', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off?$AA@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off?$AA@ DB 'Off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKGKAABK@Env?5?$CFs?$AA@
CONST	SEGMENT
??_C@_06KKGKAABK@Env?5?$CFs?$AA@ DB 'Env %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HGDKAEGB@LOD?5Bias?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@HGDKAEGB@LOD?5Bias?5?$CFd?$AA@ DB 'LOD Bias %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HECBGFIE@Env?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@HECBGFIE@Env?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'Env RGB %d %d %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NMOCHNCE@Model?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@NMOCHNCE@Model?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'Model RGB %d '
	DB	'%d %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@ DB 'Axis %s - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFIJOKEG@Model?$AA@
CONST	SEGMENT
??_C@_05NFIJOKEG@Model?$AA@ DB 'Model', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EJFNLALG@Env?$AA@
CONST	SEGMENT
??_C@_03EJFNLALG@Env?$AA@ DB 'Env', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EFBILDOC@RGB?5Type?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@EFBILDOC@RGB?5Type?3?5?$CFs?$AA@ DB 'RGB Type: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JOFJLKIO@Mirror?5Hide?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@JOFJLKIO@Mirror?5Hide?3?5?$CFs?$AA@ DB 'Mirror Hide: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NOFFHJBO@Mirror?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@NOFFHJBO@Mirror?3?5?$CFs?$AA@ DB 'Mirror: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JHBOJFOO@Fixed?5lights?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BB@JHBOJFOO@Fixed?5lights?3?5?$CFs?$AA@ DB 'Fixed lights: %s', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DisplayInstanceInfo@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT
tv251 = -196						; size = 4
tv242 = -196						; size = 4
tv228 = -196						; size = 4
tv214 = -196						; size = 4
tv200 = -196						; size = 4
tv92 = -196						; size = 4
tv78 = -196						; size = 4
_buf$ = -128						; size = 128
_inst$ = 8						; size = 4
?DisplayInstanceInfo@@YAXPAUINSTANCE@@@Z PROC NEAR	; DisplayInstanceInfo, COMDAT

; 748  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 749  : 	char buf[128];
; 750  : 
; 751  : // model
; 752  : 
; 753  : 	DumpText(450, 0, 8, 16, 0xffff00, InstanceModels[inst->Model].Name);

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	push	16776960				; 00ffff00H
	push	16					; 00000010H
	push	8
	push	0
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 754  : 
; 755  : // priority
; 756  : 
; 757  : 	wsprintf(buf, "High priority: %s", inst->Priority ? "Yes" : "No");

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $L82055
	mov	DWORD PTR tv78[ebp], OFFSET FLAT:??_C@_03CCLAEDDF@Yes?$AA@
	jmp	SHORT $L82056
$L82055:
	mov	DWORD PTR tv78[ebp], OFFSET FLAT:??_C@_02JINPPBEP@No?$AA@
$L82056:
	mov	edx, DWORD PTR tv78[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BC@IODMHEDJ@High?5priority?3?5?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 758  : 	DumpText(450, 24, 8, 16, 0x00ffff, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	65535					; 0000ffffH
	push	16					; 00000010H
	push	8
	push	24					; 00000018H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 759  : 
; 760  : // env
; 761  : 
; 762  : 	wsprintf(buf, "Env %s", inst->Flag & INSTANCE_ENV ? "On" : "Off");

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 1
	je	SHORT $L82057
	mov	DWORD PTR tv92[ebp], OFFSET FLAT:??_C@_02IAAGKKDJ@On?$AA@
	jmp	SHORT $L82058
$L82057:
	mov	DWORD PTR tv92[ebp], OFFSET FLAT:??_C@_03GCDBBDDL@Off?$AA@
$L82058:
	mov	edx, DWORD PTR tv92[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_06KKGKAABK@Env?5?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 763  : 	DumpText(450, 48, 8, 16, 0xff00ff, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16711935				; 00ff00ffH
	push	16					; 00000010H
	push	8
	push	48					; 00000030H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 764  : 
; 765  : // LOD bias
; 766  : 
; 767  : 	wsprintf(buf, "LOD Bias %d", (long)inst->LodBias);

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR [eax+16]
	call	__ftol2
	push	eax
	push	OFFSET FLAT:??_C@_0M@HGDKAEGB@LOD?5Bias?5?$CFd?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 768  : 	DumpText(450, 72, 8, 16, 0xffff00, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16776960				; 00ffff00H
	push	16					; 00000010H
	push	8
	push	72					; 00000048H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 769  : 
; 770  : // env rgb
; 771  : 
; 772  : 	wsprintf(buf, "Env RGB %d %d %d", ((MODEL_RGB*)&inst->EnvRGB)->r, ((MODEL_RGB*)&inst->EnvRGB)->g, ((MODEL_RGB*)&inst->EnvRGB)->b);

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	movzx	eax, BYTE PTR [edx+9]
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	movzx	edx, BYTE PTR [ecx+10]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@HECBGFIE@Env?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 773  : 	DumpText(450, 96, 8, 16, 0x00ff00, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	65280					; 0000ff00H
	push	16					; 00000010H
	push	8
	push	96					; 00000060H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 774  : 
; 775  : // model rgb
; 776  : 
; 777  : 	wsprintf(buf, "Model RGB %d %d %d", inst->r, inst->g, inst->b);

	mov	eax, DWORD PTR _inst$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	push	ecx
	mov	edx, DWORD PTR _inst$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@NMOCHNCE@Model?5RGB?5?$CFd?5?$CFd?5?$CFd?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 778  : 	DumpText(450, 120, 8, 16, 0x00ffff, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	65535					; 0000ffffH
	push	16					; 00000010H
	push	8
	push	120					; 00000078H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 779  : 
; 780  : // axis
; 781  : 
; 782  : 	wsprintf(buf, "Axis %s - %s", InstanceAxisNames[InstanceAxis], InstanceAxisTypeNames[InstanceAxisType]);

	movsx	eax, BYTE PTR _InstanceAxisType
	mov	ecx, DWORD PTR _InstanceAxisTypeNames[eax*4]
	push	ecx
	movsx	edx, BYTE PTR _InstanceAxis
	mov	eax, DWORD PTR _InstanceAxisNames[edx*4]
	push	eax
	push	OFFSET FLAT:??_C@_0N@MOINFLNL@Axis?5?$CFs?5?9?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 783  : 	DumpText(450, 144, 8, 16, 0xff0000, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	push	144					; 00000090H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 784  : 
; 785  : // rgb type
; 786  : 
; 787  : 	wsprintf(buf, "RGB Type: %s", InstanceRgbType? "Model" : "Env");

	movsx	eax, BYTE PTR _InstanceRgbType
	test	eax, eax
	je	SHORT $L82059
	mov	DWORD PTR tv200[ebp], OFFSET FLAT:??_C@_05NFIJOKEG@Model?$AA@
	jmp	SHORT $L82060
$L82059:
	mov	DWORD PTR tv200[ebp], OFFSET FLAT:??_C@_03EJFNLALG@Env?$AA@
$L82060:
	mov	ecx, DWORD PTR tv200[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0N@EFBILDOC@RGB?5Type?3?5?$CFs?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 788  : 	DumpText(450, 168, 8, 16, 0xffff00, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16776960				; 00ffff00H
	push	16					; 00000010H
	push	8
	push	168					; 000000a8H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 789  : 
; 790  : // hide
; 791  : 
; 792  : 	wsprintf(buf, "Mirror Hide: %s", inst->Flag & INSTANCE_HIDE? "Yes" : "No");

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 2
	je	SHORT $L82061
	mov	DWORD PTR tv214[ebp], OFFSET FLAT:??_C@_03CCLAEDDF@Yes?$AA@
	jmp	SHORT $L82062
$L82061:
	mov	DWORD PTR tv214[ebp], OFFSET FLAT:??_C@_02JINPPBEP@No?$AA@
$L82062:
	mov	edx, DWORD PTR tv214[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@JOFJLKIO@Mirror?5Hide?3?5?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 793  : 	DumpText(450, 192, 8, 16, 0x00ff00, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	65280					; 0000ff00H
	push	16					; 00000010H
	push	8
	push	192					; 000000c0H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 794  : 
; 795  : // mirror
; 796  : 
; 797  : 	wsprintf(buf, "Mirror: %s", inst->Flag & INSTANCE_NO_MIRROR? "No" : "Yes");

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 4
	je	SHORT $L82063
	mov	DWORD PTR tv228[ebp], OFFSET FLAT:??_C@_02JINPPBEP@No?$AA@
	jmp	SHORT $L82064
$L82063:
	mov	DWORD PTR tv228[ebp], OFFSET FLAT:??_C@_03CCLAEDDF@Yes?$AA@
$L82064:
	mov	edx, DWORD PTR tv228[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@NOFFHJBO@Mirror?3?5?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 798  : 	DumpText(450, 216, 8, 16, 0x00ffff, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	65535					; 0000ffffH
	push	16					; 00000010H
	push	8
	push	216					; 000000d8H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 799  : 
; 800  : // lit
; 801  : 
; 802  : 	wsprintf(buf, "Fixed lights: %s", inst->Flag & INSTANCE_NO_FILE_LIGHTS? "No" : "Yes");

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 8
	je	SHORT $L82065
	mov	DWORD PTR tv242[ebp], OFFSET FLAT:??_C@_02JINPPBEP@No?$AA@
	jmp	SHORT $L82066
$L82065:
	mov	DWORD PTR tv242[ebp], OFFSET FLAT:??_C@_03CCLAEDDF@Yes?$AA@
$L82066:
	mov	edx, DWORD PTR tv242[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@JHBOJFOO@Fixed?5lights?3?5?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 803  : 	DumpText(450, 240, 8, 16, 0xff0000, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	16711680				; 00ff0000H
	push	16					; 00000010H
	push	8
	push	240					; 000000f0H
	push	450					; 000001c2H
	call	?DumpText@@YAXFFFFJPAD@Z		; DumpText
	add	esp, 24					; 00000018H

; 804  : 
; 805  : // draw axis
; 806  : 
; 807  : 	TEXTUREFILTER_ON();

	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+20
	mov	DWORD PTR tv251[ebp], eax
	cmp	DWORD PTR tv251[ebp], 0
	je	SHORT $L81722
	cmp	DWORD PTR tv251[ebp], 1
	je	$L81723
	cmp	DWORD PTR tv251[ebp], 2
	je	$L81724
	jmp	$L81719
$L81722:
	push	1
	push	17					; 00000011H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	1
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	1
	push	17					; 00000011H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	1
	push	16					; 00000010H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	jmp	$L81719
$L81723:
	push	2
	push	17					; 00000011H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	2
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	2
	push	17					; 00000011H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	2
	push	16					; 00000010H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	jmp	$L81719
$L81724:
	push	3
	push	17					; 00000011H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	5
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	3
	push	17					; 00000011H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	5
	push	16					; 00000010H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81719:

; 808  : 	ZBUFFER_ON();

	movsx	eax, WORD PTR ?RenderZbuffer@@3FA	; RenderZbuffer
	cmp	eax, 1
	je	SHORT $L81725
	mov	WORD PTR ?RenderZbuffer@@3FA, 1		; RenderZbuffer
	movsx	eax, WORD PTR ?RenderZbuffer@@3FA	; RenderZbuffer
	push	eax
	push	7
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81725:

; 809  : 	ZWRITE_ON();

	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	test	eax, eax
	jne	SHORT $L81726
	mov	WORD PTR ?RenderZwrite@@3FA, 1		; RenderZwrite
	movsx	eax, WORD PTR ?RenderZwrite@@3FA	; RenderZwrite
	push	eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81726:

; 810  : 
; 811  : 	if (InstanceAxisType)

	movsx	eax, BYTE PTR _InstanceAxisType
	test	eax, eax
	je	SHORT $L81727

; 812  : 		DrawAxis(&IdentityMatrix, &CurrentInstance->WorldPos);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET FLAT:?IdentityMatrix@@3TMatrixUnion@@A ; IdentityMatrix
	call	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ; DrawAxis
	add	esp, 8

; 813  : 	else

	jmp	SHORT $L81728
$L81727:

; 814  : 		DrawAxis(&CAM_MainCamera->WMatrix, &CurrentInstance->WorldPos);

	mov	eax, DWORD PTR ?CurrentInstance@@3PAUINSTANCE@@A ; CurrentInstance
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	ecx, 16					; 00000010H
	push	ecx
	call	?DrawAxis@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ; DrawAxis
	add	esp, 8
$L81728:

; 815  : 
; 816  : 	BeginTextState();

	call	?BeginTextState@@YAXXZ			; BeginTextState

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayInstanceInfo@@YAXPAUINSTANCE@@@Z ENDP		; DisplayInstanceInfo
_TEXT	ENDS
PUBLIC	?LoadInstanceModels@@YAXXZ			; LoadInstanceModels
PUBLIC	??_C@_0BA@COEMJPKP@levels?2?$CFs?2?$CK?4prm?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??LoadInstanceModels@@YAXXZ@4JA	; `LoadInstanceModels'::`2'::__LINE__Var
PUBLIC	??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	??_C@_0CI@ELAKCFHA@Can?8t?5alloc?5memory?5for?5instance?5@ ; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR?$AA@			; `string'
PUBLIC	??_C@_0BB@OKBMNBKA@levels?2?$CFs?2?$CFs?4prm?$AA@ ; `string'
PUBLIC	??_C@_0BB@LIFCFEFH@levels?2?$CFs?2?$CFs?4ncp?$AA@ ; `string'
EXTRN	?LevelInf@@3PAULEVELINFO@@A:DWORD		; LevelInf
EXTRN	__imp__FindFirstFileA@8:NEAR
EXTRN	__imp__FindNextFileA@8:NEAR
EXTRN	_toupper:NEAR
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
EXTRN	?GameSettings@@3UGAME_SETTINGS@@A:BYTE		; GameSettings
EXTRN	?LoadModel@@YAJPADPAUMODEL@@DDDJ@Z:NEAR		; LoadModel
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
EXTRN	__imp__FindClose@4:NEAR
EXTRN	?LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z:NEAR ; LoadNewCollPolys
;	COMDAT ??_C@_0BA@COEMJPKP@levels?2?$CFs?2?$CK?4prm?$AA@
CONST	SEGMENT
??_C@_0BA@COEMJPKP@levels?2?$CFs?2?$CK?4prm?$AA@ DB 'levels\%s\*.prm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\insta'
	DB	'nce.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??LoadInstanceModels@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadInstanceModels@@YAXXZ@4JA DD 0338H	; `LoadInstanceModels'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@ELAKCFHA@Can?8t?5alloc?5memory?5for?5instance?5@
CONST	SEGMENT
??_C@_0CI@ELAKCFHA@Can?8t?5alloc?5memory?5for?5instance?5@ DB 'Can''t all'
	DB	'oc memory for instance models!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR?$AA@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR?$AA@ DB 'ERROR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OKBMNBKA@levels?2?$CFs?2?$CFs?4prm?$AA@
CONST	SEGMENT
??_C@_0BB@OKBMNBKA@levels?2?$CFs?2?$CFs?4prm?$AA@ DB 'levels\%s\%s.prm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIFCFEFH@levels?2?$CFs?2?$CFs?4ncp?$AA@
CONST	SEGMENT
??_C@_0BB@LIFCFEFH@levels?2?$CFs?2?$CFs?4ncp?$AA@ DB 'levels\%s\%s.ncp', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadInstanceModels@@YAXXZ
_TEXT	SEGMENT
_names$ = -1612						; size = 1024
_buf$ = -588						; size = 256
_fp$ = -332						; size = 4
_handle$ = -328						; size = 4
_data$ = -324						; size = 320
_i$ = -4						; size = 4
?LoadInstanceModels@@YAXXZ PROC NEAR			; LoadInstanceModels, COMDAT

; 824  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1676				; 0000068cH
	push	ebx
	push	esi
	push	edi

; 825  : 	long i;
; 826  : 	WIN32_FIND_DATA data;
; 827  : 	HANDLE handle;
; 828  : 	FILE *fp;
; 829  : 	char buf[256];
; 830  : 	char names[MAX_INSTANCE_MODELS][16];
; 831  : 
; 832  : // zero num / ptr
; 833  : 
; 834  : 	InstanceModelNum = 0;

	mov	DWORD PTR ?InstanceModelNum@@3JA, 0	; InstanceModelNum

; 835  : 	InstanceModels = NULL;

	mov	DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A, 0 ; InstanceModels

; 836  : 
; 837  : // get first prm
; 838  : 
; 839  : 	wsprintf(buf, "levels\\%s\\*.prm", LevelInf[GameSettings.Level].Dir);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	push	OFFSET FLAT:??_C@_0BA@COEMJPKP@levels?2?$CFs?2?$CK?4prm?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 840  : 	handle = FindFirstFile(buf, &data);

	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__FindFirstFileA@8
	mov	DWORD PTR _handle$[ebp], eax

; 841  : 	if (handle == INVALID_HANDLE_VALUE)

	cmp	DWORD PTR _handle$[ebp], -1
	jne	SHORT $L81743

; 842  : 		return;

	jmp	$L81731
$L81743:

; 843  : 
; 844  : // loop thru each prm
; 845  : 
; 846  : 	while (TRUE)

	mov	eax, 1
	test	eax, eax
	je	$L81744

; 847  : 	{
; 848  : 
; 849  : // add to list?
; 850  : 
; 851  : 		if (!(data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && InstanceModelNum < MAX_INSTANCE_MODELS)

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 16					; 00000010H
	jne	$L81745
	cmp	DWORD PTR ?InstanceModelNum@@3JA, 64	; InstanceModelNum, 00000040H
	jge	$L81745

; 852  : 		{
; 853  : 			for (i = 0 ; i < (long)strlen(data.cFileName) - 4 ; i++) data.cFileName[i] = toupper(data.cFileName[i]);

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81747
$L81748:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81747:
	lea	eax, DWORD PTR _data$[ebp+44]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, 4
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L81749
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _data$[ebp+eax+44]
	push	ecx
	call	_toupper
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _data$[ebp+edx+44], al
	jmp	SHORT $L81748
$L81749:

; 854  : 			data.cFileName[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _data$[ebp+eax+44], 0

; 855  : 			memcpy(names[InstanceModelNum], data.cFileName, 16);

	push	16					; 00000010H
	lea	eax, DWORD PTR _data$[ebp+44]
	push	eax
	mov	ecx, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	shl	ecx, 4
	lea	edx, DWORD PTR _names$[ebp+ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 856  : 			InstanceModelNum++;

	mov	eax, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	add	eax, 1
	mov	DWORD PTR ?InstanceModelNum@@3JA, eax	; InstanceModelNum
$L81745:

; 857  : 		}
; 858  : 
; 859  : // get next
; 860  : 
; 861  : 		if (!FindNextFile(handle, &data))

	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	DWORD PTR __imp__FindNextFileA@8
	test	eax, eax
	jne	SHORT $L81750

; 862  : 			break;

	jmp	SHORT $L81744
$L81750:

; 863  : 	}

	jmp	$L81743
$L81744:

; 864  : 
; 865  : // close search handle
; 866  : 
; 867  : 	FindClose(handle);

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	DWORD PTR __imp__FindClose@4

; 868  : 
; 869  : // alloc ram for instance models structure
; 870  : 
; 871  : 	InstanceModels = (INSTANCE_MODELS*)malloc(sizeof(INSTANCE_MODELS) * InstanceModelNum);

	push	OFFSET FLAT:??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadInstanceModels@@YAXXZ@4JA
	add	eax, 47					; 0000002fH
	push	eax
	mov	ecx, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	imul	ecx, 324				; 00000144H
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A, eax ; InstanceModels

; 872  : 	if (!InstanceModels)

	cmp	DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A, 0 ; InstanceModels
	jne	SHORT $L81755

; 873  : 	{
; 874  : 		Box("ERROR", "Can't alloc memory for instance models!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CI@ELAKCFHA@Can?8t?5alloc?5memory?5for?5instance?5@
	push	OFFSET FLAT:??_C@_05MBDEGLCK@ERROR?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 875  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 876  : 		return;

	jmp	$L81731
$L81755:

; 877  : 	}
; 878  : 
; 879  : // fill instance model structure
; 880  : 
; 881  : 	for (i = 0 ; i < InstanceModelNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81758
$L81759:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81758:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	jge	$L81731

; 882  : 	{
; 883  : 		memcpy(InstanceModels[i].Name, names[i], MAX_INSTANCE_FILENAME);

	push	9
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _names$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 324				; 00000144H
	mov	eax, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 884  : 		InstanceModels[i].Name[MAX_INSTANCE_FILENAME - 1] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	BYTE PTR [ecx+eax+12], 0

; 885  : 		wsprintf(buf, "levels\\%s\\%s.prm", LevelInf[GameSettings.Level].Dir, names[i]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _names$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	edx, 232				; 000000e8H
	add	edx, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	edx
	push	OFFSET FLAT:??_C@_0BB@OKBMNBKA@levels?2?$CFs?2?$CFs?4prm?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 886  : 		InstanceModels[i].Count = LoadModel(buf, InstanceModels[i].Models, 0, MAX_INSTANCE_LOD, LOADMODEL_OFFSET_TPAGE, LevelInf[GameSettings.Level].InstanceRGBper);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	mov	ecx, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	mov	edx, DWORD PTR [ecx+eax+212]
	push	edx
	push	2
	push	5
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	edx, DWORD PTR [ecx+eax+16]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?LoadModel@@YAJPADPAUMODEL@@DDDJ@Z	; LoadModel
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	DWORD PTR [edx+ecx], eax

; 887  : 		
; 888  : 		// Load collision skin if it exists
; 889  : 		wsprintf(buf, "levels\\%s\\%s.ncp", LevelInf[GameSettings.Level].Dir, names[i]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _names$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	edx, 232				; 000000e8H
	add	edx, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	edx
	push	OFFSET FLAT:??_C@_0BB@LIFCFEFH@levels?2?$CFs?2?$CFs?4ncp?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 890  : 		if ((fp = fopen(buf, "rb")) != NULL) {

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $L81763

; 891  : 			InstanceModels[i].CollPoly = LoadNewCollPolys(fp, &InstanceModels[i].NCollPolys);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	edx, DWORD PTR [ecx+eax+320]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z ; LoadNewCollPolys
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	DWORD PTR [edx+ecx+316], eax

; 892  : 			fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 893  : 		} else {

	jmp	SHORT $L81764
$L81763:

; 894  : 			InstanceModels[i].CollPoly = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	DWORD PTR [ecx+eax+316], 0

; 895  : 			InstanceModels[i].NCollPolys = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	WORD PTR [ecx+eax+320], 0
$L81764:

; 896  : 		}
; 897  : 
; 898  : 	}

	jmp	$L81759
$L81731:

; 899  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadInstanceModels@@YAXXZ ENDP				; LoadInstanceModels
_TEXT	ENDS
PUBLIC	?FreeInstanceModels@@YAXXZ			; FreeInstanceModels
PUBLIC	?__LINE__Var@?1??FreeInstanceModels@@YAXXZ@4JA	; `FreeInstanceModels'::`2'::__LINE__Var
EXTRN	?FreeModel@@YAXPAUMODEL@@J@Z:NEAR		; FreeModel
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
EXTRN	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z:NEAR ; DestroyCollPolys
;	COMDAT ?__LINE__Var@?1??FreeInstanceModels@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??FreeInstanceModels@@YAXXZ@4JA DD 038aH	; `FreeInstanceModels'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?FreeInstanceModels@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?FreeInstanceModels@@YAXXZ PROC NEAR			; FreeInstanceModels, COMDAT

; 906  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 907  : 	long i;
; 908  : 
; 909  : 	for (i = 0 ; i < InstanceModelNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81769
$L81770:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81769:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceModelNum@@3JA	; InstanceModelNum
	jge	$L81771

; 910  : 	{
; 911  : 		DestroyCollPolys(InstanceModels[i].CollPoly);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	edx, DWORD PTR [ecx+eax+316]
	push	edx
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 912  : 		InstanceModels[i].CollPoly = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	DWORD PTR [ecx+eax+316], 0

; 913  : 		InstanceModels[i].NCollPolys = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	WORD PTR [ecx+eax+320], 0

; 914  : 		FreeModel(InstanceModels[i].Models, InstanceModels[i].Count);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 324				; 00000144H
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	edx, DWORD PTR [ecx+eax+16]
	push	edx
	call	?FreeModel@@YAXPAUMODEL@@J@Z		; FreeModel
	add	esp, 8

; 915  : 	}

	jmp	$L81770
$L81771:

; 916  : 
; 917  : 	free(InstanceModels);

	push	OFFSET FLAT:??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeInstanceModels@@YAXXZ@4JA
	add	eax, 11					; 0000000bH
	push	eax
	mov	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 918  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeInstanceModels@@YAXXZ ENDP				; FreeInstanceModels
_TEXT	ENDS
PUBLIC	?FreeInstanceRGBs@@YAXXZ			; FreeInstanceRGBs
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeInstanceRGBs@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?FreeInstanceRGBs@@YAXXZ PROC NEAR			; FreeInstanceRGBs, COMDAT

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 926  : 	long i;
; 927  : 
; 928  : 	for (i = 0 ; i < InstanceNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81777
$L81778:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81777:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	SHORT $L81775

; 929  : 	{
; 930  : 		FreeOneInstanceRGB(&Instances[i]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	push	eax
	call	?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z	; FreeOneInstanceRGB
	add	esp, 4

; 931  : 	}

	jmp	SHORT $L81778
$L81775:

; 932  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeInstanceRGBs@@YAXXZ ENDP				; FreeInstanceRGBs
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA ; `FreeOneInstanceRGB'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA DD 03abH ; `FreeOneInstanceRGB'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_inst$ = 8						; size = 4
?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z PROC NEAR	; FreeOneInstanceRGB, COMDAT

; 939  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 940  : 	long i;
; 941  : 
; 942  : 	for (i = 0 ; i < InstanceModels[inst->Model].Count ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81784
$L81785:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81784:
	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+ecx]
	jge	SHORT $L81782

; 943  : 	{
; 944  : 		free(inst->rgb[i]);

	push	OFFSET FLAT:??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA
	add	eax, 5
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _inst$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+80]
	push	eax
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 945  : 	}

	jmp	SHORT $L81785
$L81782:

; 946  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeOneInstanceRGB@@YAXPAUINSTANCE@@@Z ENDP		; FreeOneInstanceRGB
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA ; `AllocOneInstanceRGB'::`2'::__LINE__Var
PUBLIC	??_C@_0CE@IPMFNNCA@Can?8t?5alloc?5memory?5for?5Instance?5@ ; `string'
;	COMDAT ?__LINE__Var@?1??AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA DD 03b9H ; `AllocOneInstanceRGB'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@IPMFNNCA@Can?8t?5alloc?5memory?5for?5Instance?5@
CONST	SEGMENT
??_C@_0CE@IPMFNNCA@Can?8t?5alloc?5memory?5for?5Instance?5@ DB 'Can''t all'
	DB	'oc memory for Instance RGB', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT
_model$ = -20						; size = 4
_col$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_inst$ = 8						; size = 4
?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z PROC NEAR	; AllocOneInstanceRGB, COMDAT

; 953  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 954  : 	long i, j, k, col;
; 955  : 	MODEL *model;
; 956  : 
; 957  : // step through each LOD
; 958  : 
; 959  : 	for (i = 0 ; i < InstanceModels[inst->Model].Count ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81796
$L81797:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81796:
	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+ecx]
	jge	$L81790

; 960  : 	{
; 961  : 
; 962  : // alloc RGB space
; 963  : 
; 964  : 		model = &InstanceModels[inst->Model].Models[i];

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	add	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 60					; 0000003cH
	lea	eax, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _model$[ebp], eax

; 965  : 		inst->rgb[i] = (POLY_RGB*)malloc(sizeof(POLY_RGB) * model->PolyNum);

	push	OFFSET FLAT:??_C@_0IN@DLOCHFEA@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z@4JA
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+32]
	shl	edx, 4
	push	edx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [edx+ecx*4+80], eax

; 966  : 		if (!inst->rgb[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _inst$[ebp]
	cmp	DWORD PTR [ecx+eax*4+80], 0
	jne	SHORT $L81802

; 967  : 		{
; 968  : 			Box("ERROR", "Can't alloc memory for Instance RGB", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CE@IPMFNNCA@Can?8t?5alloc?5memory?5for?5Instance?5@
	push	OFFSET FLAT:??_C@_05MBDEGLCK@ERROR?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 969  : 			QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 970  : 			return;

	jmp	$L81790
$L81802:

; 971  : 		}
; 972  : 
; 973  : // get model RGB
; 974  : 
; 975  : 		for (j = 0 ; j < model->PolyNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81804
$L81805:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81804:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+32]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$L81806

; 976  : 		{
; 977  : 			for (k = 0 ; k < 4 ; k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L81807
$L81808:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L81807:
	cmp	DWORD PTR _k$[ebp], 4
	jge	$L81809

; 978  : 			{
; 979  : 				if (inst->Flag & INSTANCE_HIDE)

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 2
	je	SHORT $L81810

; 980  : 				{
; 981  : 					*(long*)&inst->rgb[i][j].rgb[k] = LevelInf[GameSettings.Level].FogColor;

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _inst$[ebp]
	add	ecx, DWORD PTR [esi+edx*4+80]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	mov	eax, DWORD PTR [esi+eax+192]
	mov	DWORD PTR [ecx+edx*4], eax

; 982  : 				}
; 983  : 				else

	jmp	$L81812
$L81810:

; 984  : 				{
; 985  : 					inst->rgb[i][j].rgb[k].a = model->PolyRGB[j].rgb[k].a;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	add	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _inst$[ebp]
	add	edx, DWORD PTR [esi+ecx*4+80]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _k$[ebp]
	mov	al, BYTE PTR [eax+esi*4+3]
	mov	BYTE PTR [edx+ecx*4+3], al

; 986  : 
; 987  : 					col = model->PolyRGB[j].rgb[k].r * (inst->r + 128) / 128;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, eax
	mov	eax, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx+eax*4+2]
	mov	ecx, DWORD PTR _inst$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	add	edx, 128				; 00000080H
	imul	eax, edx
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	mov	DWORD PTR _col$[ebp], eax

; 988  : 					if (col > 255) col = 255;

	cmp	DWORD PTR _col$[ebp], 255		; 000000ffH
	jle	SHORT $L81813
	mov	DWORD PTR _col$[ebp], 255		; 000000ffH
$L81813:

; 989  : 					inst->rgb[i][j].rgb[k].r = (unsigned char)col;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _inst$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+80]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR _col$[ebp]
	mov	BYTE PTR [eax+ecx*4+2], dl

; 990  : 
; 991  : 					col = model->PolyRGB[j].rgb[k].g * (inst->g + 128) / 128;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, eax
	mov	eax, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx+eax*4+1]
	mov	ecx, DWORD PTR _inst$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	add	edx, 128				; 00000080H
	imul	eax, edx
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	mov	DWORD PTR _col$[ebp], eax

; 992  : 					if (col > 255) col = 255;

	cmp	DWORD PTR _col$[ebp], 255		; 000000ffH
	jle	SHORT $L81815
	mov	DWORD PTR _col$[ebp], 255		; 000000ffH
$L81815:

; 993  : 					inst->rgb[i][j].rgb[k].g = (unsigned char)col;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _inst$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+80]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR _col$[ebp]
	mov	BYTE PTR [eax+ecx*4+1], dl

; 994  : 
; 995  : 					col = model->PolyRGB[j].rgb[k].b * (inst->b + 128) / 128;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, eax
	mov	eax, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [edx+eax*4]
	mov	ecx, DWORD PTR _inst$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	add	edx, 128				; 00000080H
	imul	eax, edx
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	mov	DWORD PTR _col$[ebp], eax

; 996  : 					if (col > 255) col = 255;

	cmp	DWORD PTR _col$[ebp], 255		; 000000ffH
	jle	SHORT $L81817
	mov	DWORD PTR _col$[ebp], 255		; 000000ffH
$L81817:

; 997  : 					inst->rgb[i][j].rgb[k].b = (unsigned char)col;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _inst$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+80]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR _col$[ebp]
	mov	BYTE PTR [eax+ecx*4], dl
$L81812:

; 998  : 				}
; 999  : 			}

	jmp	$L81808
$L81809:

; 1000 : 		}

	jmp	$L81805
$L81806:

; 1001 : 	}

	jmp	$L81797
$L81790:

; 1002 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocOneInstanceRGB@@YAXPAUINSTANCE@@@Z ENDP		; AllocOneInstanceRGB
_TEXT	ENDS
EXTRN	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z:NEAR ; SetObjectVisiMask
; Function compile flags: /Odt /ZI
;	COMDAT ?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z
_TEXT	SEGMENT
_vec$ = -20						; size = 12
_model$ = -8						; size = 4
_j$ = -4						; size = 4
_inst$ = 8						; size = 4
?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z PROC NEAR	; SetInstanceBoundingBoxes, COMDAT

; 1009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1010 : 	long j;
; 1011 : 	MODEL *model;
; 1012 : 	VEC vec;
; 1013 : 
; 1014 : // get model
; 1015 : 
; 1016 : 	model = InstanceModels[inst->Model].Models;

	mov	eax, DWORD PTR _inst$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _model$[ebp], eax

; 1017 : 
; 1018 : // transform all model verts to find bounding box
; 1019 : 
; 1020 : 	inst->Box.Xmin = inst->Box.Ymin = inst->Box.Zmin = 999999;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [eax+116], 1232348144		; 497423f0H
	mov	ecx, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [ecx+108], 1232348144		; 497423f0H
	mov	edx, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [edx+100], 1232348144		; 497423f0H

; 1021 : 	inst->Box.Xmax = inst->Box.Ymax = inst->Box.Zmax = -999999;

	mov	eax, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [eax+120], -915135504		; c97423f0H
	mov	ecx, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [ecx+112], -915135504		; c97423f0H
	mov	edx, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [edx+104], -915135504		; c97423f0H

; 1022 : 
; 1023 : 	for (j = 0 ; j < model->VertNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81825
$L81826:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81825:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+34]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$L81827

; 1024 : 	{
; 1025 : 		RotTransVector(&inst->WorldMatrix, &inst->WorldPos, (VEC*)&model->VertPtr[j].x, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _model$[ebp]
	add	ecx, DWORD PTR [edx+52]
	push	ecx
	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _inst$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1026 : 
; 1027 : 		if (vec.v[X] < inst->Box.Xmin) inst->Box.Xmin = vec.v[X];

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR _vec$[ebp]
	fcomp	DWORD PTR [eax+100]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81829
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	DWORD PTR [eax+100], ecx
$L81829:

; 1028 : 		if (vec.v[X] > inst->Box.Xmax) inst->Box.Xmax = vec.v[X];

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR _vec$[ebp]
	fcomp	DWORD PTR [eax+104]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81830
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	DWORD PTR [eax+104], ecx
$L81830:

; 1029 : 		if (vec.v[Y] < inst->Box.Ymin) inst->Box.Ymin = vec.v[Y];

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR _vec$[ebp+4]
	fcomp	DWORD PTR [eax+108]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81831
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp+4]
	mov	DWORD PTR [eax+108], ecx
$L81831:

; 1030 : 		if (vec.v[Y] > inst->Box.Ymax) inst->Box.Ymax = vec.v[Y];

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR _vec$[ebp+4]
	fcomp	DWORD PTR [eax+112]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81832
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp+4]
	mov	DWORD PTR [eax+112], ecx
$L81832:

; 1031 : 		if (vec.v[Z] < inst->Box.Zmin) inst->Box.Zmin = vec.v[Z];

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR _vec$[ebp+8]
	fcomp	DWORD PTR [eax+116]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81833
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp+8]
	mov	DWORD PTR [eax+116], ecx
$L81833:

; 1032 : 		if (vec.v[Z] > inst->Box.Zmax) inst->Box.Zmax = vec.v[Z];

	mov	eax, DWORD PTR _inst$[ebp]
	fld	DWORD PTR _vec$[ebp+8]
	fcomp	DWORD PTR [eax+120]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81834
	mov	eax, DWORD PTR _inst$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp+8]
	mov	DWORD PTR [eax+120], ecx
$L81834:

; 1033 : 	}

	jmp	$L81826
$L81827:

; 1034 : 
; 1035 : // set visi mask
; 1036 : 
; 1037 : 	inst->VisiMask = SetObjectVisiMask(&inst->Box);

	mov	eax, DWORD PTR _inst$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z ; SetObjectVisiMask
	add	esp, 4
	mov	ecx, DWORD PTR _inst$[ebp]
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], edx

; 1038 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetInstanceBoundingBoxes@@YAXPAUINSTANCE@@@Z ENDP	; SetInstanceBoundingBoxes
_TEXT	ENDS
PUBLIC	?BuildInstanceCollPolys@@YAXXZ			; BuildInstanceCollPolys
EXTRN	?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z:NEAR ; RotTransBBox
EXTRN	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z:NEAR ; RotTransPlane
EXTRN	?COL_InstanceCollPoly@@3PAUCollPolyStruct@@A:DWORD ; COL_InstanceCollPoly
EXTRN	?COL_NInstanceCollPolys@@3FA:WORD		; COL_NInstanceCollPolys
EXTRN	?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z:NEAR	; CreateCollPolys
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildInstanceCollPolys@@YAXXZ
_TEXT	SEGMENT
_instModelPoly$ = -28					; size = 4
_worldPoly$ = -24					; size = 4
_instModel$ = -20					; size = 4
_instance$ = -16					; size = 4
_nInstCollPolys$ = -12					; size = 4
_iPoly$ = -8						; size = 4
_iInst$ = -4						; size = 4
?BuildInstanceCollPolys@@YAXXZ PROC NEAR		; BuildInstanceCollPolys, COMDAT

; 1049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1050 : 	int			iInst, iPoly, nInstCollPolys;
; 1051 : 	INSTANCE	*instance;
; 1052 : 	INSTANCE_MODELS *instModel;
; 1053 : 	NEWCOLLPOLY *worldPoly, *instModelPoly;
; 1054 : 
; 1055 : 	COL_NInstanceCollPolys = 0;

	mov	WORD PTR ?COL_NInstanceCollPolys@@3FA, 0 ; COL_NInstanceCollPolys

; 1056 : 	// Count number of collision polys needed for instances
; 1057 : 	for (iInst = 0; iInst < InstanceNum; iInst++) {

	mov	DWORD PTR _iInst$[ebp], 0
	jmp	SHORT $L81844
$L81845:
	mov	eax, DWORD PTR _iInst$[ebp]
	add	eax, 1
	mov	DWORD PTR _iInst$[ebp], eax
$L81844:
	mov	eax, DWORD PTR _iInst$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	SHORT $L81846

; 1058 : 		instance = &Instances[iInst];

	mov	eax, DWORD PTR _iInst$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	mov	DWORD PTR _instance$[ebp], eax

; 1059 : 
; 1060 : 		if (!instance->Priority && !RenderSettings.Instance)

	mov	eax, DWORD PTR _instance$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	jne	SHORT $L81847
	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+92, 0
	jne	SHORT $L81847

; 1061 : 			continue;	// skip if turned off

	jmp	SHORT $L81845
$L81847:

; 1062 : 
; 1063 : 		COL_NInstanceCollPolys += InstanceModels[instance->Model].NCollPolys;

	mov	eax, DWORD PTR _instance$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	mov	edx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	movsx	eax, WORD PTR [edx+ecx+320]
	movsx	ecx, WORD PTR ?COL_NInstanceCollPolys@@3FA ; COL_NInstanceCollPolys
	add	ecx, eax
	mov	WORD PTR ?COL_NInstanceCollPolys@@3FA, cx ; COL_NInstanceCollPolys

; 1064 : 
; 1065 : 	}

	jmp	SHORT $L81845
$L81846:

; 1066 : 
; 1067 : 	// Allocate space for the instance polys
; 1068 : 	COL_InstanceCollPoly = CreateCollPolys(COL_NInstanceCollPolys);

	mov	ax, WORD PTR ?COL_NInstanceCollPolys@@3FA ; COL_NInstanceCollPolys
	push	eax
	call	?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z ; CreateCollPolys
	add	esp, 4
	mov	DWORD PTR ?COL_InstanceCollPoly@@3PAUCollPolyStruct@@A, eax ; COL_InstanceCollPoly

; 1069 : 
; 1070 : 	// Transform models collision polys into world coords and store in array
; 1071 : 	nInstCollPolys = 0;

	mov	DWORD PTR _nInstCollPolys$[ebp], 0

; 1072 : 	for (iInst = 0; iInst < InstanceNum; iInst++) {

	mov	DWORD PTR _iInst$[ebp], 0
	jmp	SHORT $L81848
$L81849:
	mov	eax, DWORD PTR _iInst$[ebp]
	add	eax, 1
	mov	DWORD PTR _iInst$[ebp], eax
$L81848:
	mov	eax, DWORD PTR _iInst$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	$L81836

; 1073 : 		instance = &Instances[iInst];

	mov	eax, DWORD PTR _iInst$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	mov	DWORD PTR _instance$[ebp], eax

; 1074 : 
; 1075 : 		if (!instance->Priority && !RenderSettings.Instance)

	mov	eax, DWORD PTR _instance$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	jne	SHORT $L81851
	cmp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+92, 0
	jne	SHORT $L81851

; 1076 : 			continue;	// skip if turned off

	jmp	SHORT $L81849
$L81851:

; 1077 : 
; 1078 : 		instModel = &InstanceModels[instance->Model];

	mov	eax, DWORD PTR _instance$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	ecx, 324				; 00000144H
	add	ecx, DWORD PTR ?InstanceModels@@3PAUINSTANCE_MODELS@@A ; InstanceModels
	mov	DWORD PTR _instModel$[ebp], ecx

; 1079 : 
; 1080 : 		// Store pointer for the world collision polys for this instance
; 1081 : 		instance->CollPoly = &COL_InstanceCollPoly[nInstCollPolys];

	mov	eax, DWORD PTR _nInstCollPolys$[ebp]
	imul	eax, 112				; 00000070H
	add	eax, DWORD PTR ?COL_InstanceCollPoly@@3PAUCollPolyStruct@@A ; COL_InstanceCollPoly
	mov	ecx, DWORD PTR _instance$[ebp]
	mov	DWORD PTR [ecx+124], eax

; 1082 : 		instance->NCollPolys = instModel->NCollPolys;

	mov	eax, DWORD PTR _instance$[ebp]
	mov	ecx, DWORD PTR _instModel$[ebp]
	mov	dx, WORD PTR [ecx+320]
	mov	WORD PTR [eax+128], dx

; 1083 : 
; 1084 : 
; 1085 : 		// Do the actual copying and transformation
; 1086 : 		for (iPoly = 0; iPoly < instModel->NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L81852
$L81853:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L81852:
	mov	eax, DWORD PTR _instModel$[ebp]
	movsx	ecx, WORD PTR [eax+320]
	cmp	DWORD PTR _iPoly$[ebp], ecx
	jge	$L81854

; 1087 : 			worldPoly = &COL_InstanceCollPoly[nInstCollPolys++];

	mov	eax, DWORD PTR _nInstCollPolys$[ebp]
	imul	eax, 112				; 00000070H
	add	eax, DWORD PTR ?COL_InstanceCollPoly@@3PAUCollPolyStruct@@A ; COL_InstanceCollPoly
	mov	DWORD PTR _worldPoly$[ebp], eax
	mov	ecx, DWORD PTR _nInstCollPolys$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nInstCollPolys$[ebp], ecx

; 1088 : 			instModelPoly = &instModel->CollPoly[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _instModel$[ebp]
	add	eax, DWORD PTR [ecx+316]
	mov	DWORD PTR _instModelPoly$[ebp], eax

; 1089 : 
; 1090 : 			worldPoly->Type = instModelPoly->Type;

	mov	eax, DWORD PTR _worldPoly$[ebp]
	mov	ecx, DWORD PTR _instModelPoly$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1091 : 			worldPoly->Material = instModelPoly->Material;

	mov	eax, DWORD PTR _worldPoly$[ebp]
	mov	ecx, DWORD PTR _instModelPoly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1092 : 			RotTransPlane(&instModelPoly->Plane, &instance->WorldMatrix, &instance->WorldPos, &worldPoly->Plane);

	mov	eax, DWORD PTR _worldPoly$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _instance$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _instance$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _instModelPoly$[ebp]
	add	eax, 8
	push	eax
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H

; 1093 : 			RotTransPlane(&instModelPoly->EdgePlane[0], &instance->WorldMatrix, &instance->WorldPos, &worldPoly->EdgePlane[0]);

	mov	eax, DWORD PTR _worldPoly$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _instance$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _instance$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _instModelPoly$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H

; 1094 : 			RotTransPlane(&instModelPoly->EdgePlane[1], &instance->WorldMatrix, &instance->WorldPos, &worldPoly->EdgePlane[1]);

	mov	eax, DWORD PTR _worldPoly$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _instance$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _instance$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _instModelPoly$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H

; 1095 : 			RotTransPlane(&instModelPoly->EdgePlane[2], &instance->WorldMatrix, &instance->WorldPos, &worldPoly->EdgePlane[2]);

	mov	eax, DWORD PTR _worldPoly$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _instance$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _instance$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _instModelPoly$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H

; 1096 : 			if (instModelPoly->Type == QUAD) {

	mov	eax, DWORD PTR _instModelPoly$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $L81855

; 1097 : 				RotTransPlane(&instModelPoly->EdgePlane[3], &instance->WorldMatrix, &instance->WorldPos, &worldPoly->EdgePlane[3]);

	mov	eax, DWORD PTR _worldPoly$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	mov	ecx, DWORD PTR _instance$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _instance$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _instModelPoly$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H
$L81855:

; 1098 : 			}
; 1099 : 
; 1100 : 			RotTransBBox(&instModelPoly->BBox, &instance->WorldMatrix, &instance->WorldPos, &worldPoly->BBox);

	mov	eax, DWORD PTR _worldPoly$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _instance$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _instance$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _instModelPoly$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	call	?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransBBox
	add	esp, 16					; 00000010H

; 1101 : 
; 1102 : 		}

	jmp	$L81853
$L81854:

; 1103 : 	}

	jmp	$L81849
$L81836:

; 1104 : 
; 1105 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildInstanceCollPolys@@YAXXZ ENDP			; BuildInstanceCollPolys
_TEXT	ENDS
END
