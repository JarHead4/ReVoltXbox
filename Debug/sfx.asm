; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\sfx.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0O@IABHABDC@wavs?2moto?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JAGBODKF@wavs?2honkgood?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFFAIFKE@wavs?2scrape1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MELGIHOC@wavs?2screech?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KNOIIEKL@wavs?2woohoo?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NAFIGGFG@wavs?2pickup?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@NGLBKADL@wavs?2pickup2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MMIIILJ@wavs?2shock?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOLOEOFE@wavs?2electro?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEAACBOA@wavs?2firework?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAGBACCN@wavs?2firebang?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JIIBHMNG@wavs?2ball?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@NFMCBAMP@wavs?2ballhit?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@OHDNIIMI@wavs?2wbomb?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBHNEFNE@wavs?2wbombhit?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HNEIPLMC@wavs?2puttbang?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ILAFKPOE@wavs?2fuse?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@BPEIBGBN@wavs?2piano?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PEEEHADE@wavs?2plane?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAJCNECN@wavs?2copter?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCBCDGKC@wavs?2dragon?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@BENHMMFP@wavs?2creak?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DGMNIHOA@wavs?2train?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BOMCCILP@wavs?2whistle?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EPNHBONG@TOYLITE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LJCEGIMM@TOY2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@DABDJMFI@Failed?5to?5init?5sound?5system?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@NOCJCOAO@Failed?5to?5set?5sound?5format?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@MBPNGAJB@Can?8t?5load?5?8?$CFs?8?5into?5slot?5?$CFd?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitSound@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseSound@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadSfx@@YAJPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeSfx@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaySfx@@YAXJJJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSfx@@YAXPAUSAMPLE_SFX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PauseAllSfx@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResumeAllSfx@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSfxSettings3D@@YAXPAJ00PAUVectorStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeSfxSample3D@@YAXPAUSAMPLE_3D@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MaintainAllSfx@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayMP3@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopMP3@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@IABHABDC@wavs?2moto?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@JAGBODKF@wavs?2honkgood?4wav?$AA@	; `string'
PUBLIC	??_C@_0BB@OFFAIFKE@wavs?2scrape1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BB@MELGIHOC@wavs?2screech?4wav?$AA@	; `string'
PUBLIC	??_C@_0BA@KNOIIEKL@wavs?2woohoo?4wav?$AA@	; `string'
PUBLIC	??_C@_0BA@NAFIGGFG@wavs?2pickup?4wav?$AA@	; `string'
PUBLIC	??_C@_0BB@NGLBKADL@wavs?2pickup2?4wav?$AA@	; `string'
PUBLIC	??_C@_0P@MMIIILJ@wavs?2shock?4wav?$AA@		; `string'
PUBLIC	??_C@_0BB@GOLOEOFE@wavs?2electro?4wav?$AA@	; `string'
PUBLIC	??_C@_0BC@GEAACBOA@wavs?2firework?4wav?$AA@	; `string'
PUBLIC	??_C@_0BC@EAGBACCN@wavs?2firebang?4wav?$AA@	; `string'
PUBLIC	??_C@_0O@JIIBHMNG@wavs?2ball?4wav?$AA@		; `string'
PUBLIC	??_C@_0BB@NFMCBAMP@wavs?2ballhit?4wav?$AA@	; `string'
PUBLIC	??_C@_0P@OHDNIIMI@wavs?2wbomb?4wav?$AA@		; `string'
PUBLIC	??_C@_0BC@HBHNEFNE@wavs?2wbombhit?4wav?$AA@	; `string'
PUBLIC	??_C@_0BC@HNEIPLMC@wavs?2puttbang?4wav?$AA@	; `string'
PUBLIC	??_C@_0O@ILAFKPOE@wavs?2fuse?4wav?$AA@		; `string'
PUBLIC	??_C@_0P@BPEIBGBN@wavs?2piano?4wav?$AA@		; `string'
PUBLIC	??_C@_0P@PEEEHADE@wavs?2plane?4wav?$AA@		; `string'
PUBLIC	??_C@_0BA@PAJCNECN@wavs?2copter?4wav?$AA@	; `string'
PUBLIC	??_C@_0BA@JCBCDGKC@wavs?2dragon?4wav?$AA@	; `string'
PUBLIC	??_C@_0P@BENHMMFP@wavs?2creak?4wav?$AA@		; `string'
PUBLIC	??_C@_0P@DGMNIHOA@wavs?2train?4wav?$AA@		; `string'
PUBLIC	??_C@_0BB@BOMCCILP@wavs?2whistle?4wav?$AA@	; `string'
PUBLIC	?SfxLevel@@3PAULEVEL_SFX@@A			; SfxLevel
PUBLIC	??_C@_07EPNHBONG@TOYLITE?$AA@			; `string'
PUBLIC	??_C@_04LJCEGIMM@TOY2?$AA@			; `string'
PUBLIC	?SoundOff@@3JA					; SoundOff
_BSS	SEGMENT
?SoundOff@@3JA DD 01H DUP (?)				; SoundOff
_BSS	ENDS
;	COMDAT ??_C@_0O@IABHABDC@wavs?2moto?4wav?$AA@
CONST	SEGMENT
??_C@_0O@IABHABDC@wavs?2moto?4wav?$AA@ DB 'wavs\moto.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JAGBODKF@wavs?2honkgood?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@JAGBODKF@wavs?2honkgood?4wav?$AA@ DB 'wavs\honkgood.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFFAIFKE@wavs?2scrape1?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@OFFAIFKE@wavs?2scrape1?4wav?$AA@ DB 'wavs\scrape1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MELGIHOC@wavs?2screech?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@MELGIHOC@wavs?2screech?4wav?$AA@ DB 'wavs\screech.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KNOIIEKL@wavs?2woohoo?4wav?$AA@
CONST	SEGMENT
??_C@_0BA@KNOIIEKL@wavs?2woohoo?4wav?$AA@ DB 'wavs\woohoo.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NAFIGGFG@wavs?2pickup?4wav?$AA@
CONST	SEGMENT
??_C@_0BA@NAFIGGFG@wavs?2pickup?4wav?$AA@ DB 'wavs\pickup.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NGLBKADL@wavs?2pickup2?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@NGLBKADL@wavs?2pickup2?4wav?$AA@ DB 'wavs\pickup2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MMIIILJ@wavs?2shock?4wav?$AA@
CONST	SEGMENT
??_C@_0P@MMIIILJ@wavs?2shock?4wav?$AA@ DB 'wavs\shock.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOLOEOFE@wavs?2electro?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@GOLOEOFE@wavs?2electro?4wav?$AA@ DB 'wavs\electro.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEAACBOA@wavs?2firework?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@GEAACBOA@wavs?2firework?4wav?$AA@ DB 'wavs\firework.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAGBACCN@wavs?2firebang?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@EAGBACCN@wavs?2firebang?4wav?$AA@ DB 'wavs\firebang.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIIBHMNG@wavs?2ball?4wav?$AA@
CONST	SEGMENT
??_C@_0O@JIIBHMNG@wavs?2ball?4wav?$AA@ DB 'wavs\ball.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NFMCBAMP@wavs?2ballhit?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@NFMCBAMP@wavs?2ballhit?4wav?$AA@ DB 'wavs\ballhit.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OHDNIIMI@wavs?2wbomb?4wav?$AA@
CONST	SEGMENT
??_C@_0P@OHDNIIMI@wavs?2wbomb?4wav?$AA@ DB 'wavs\wbomb.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBHNEFNE@wavs?2wbombhit?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@HBHNEFNE@wavs?2wbombhit?4wav?$AA@ DB 'wavs\wbombhit.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HNEIPLMC@wavs?2puttbang?4wav?$AA@
CONST	SEGMENT
??_C@_0BC@HNEIPLMC@wavs?2puttbang?4wav?$AA@ DB 'wavs\puttbang.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILAFKPOE@wavs?2fuse?4wav?$AA@
CONST	SEGMENT
??_C@_0O@ILAFKPOE@wavs?2fuse?4wav?$AA@ DB 'wavs\fuse.wav', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_SfxGeneric DD	FLAT:??_C@_0O@IABHABDC@wavs?2moto?4wav?$AA@
	DD	FLAT:??_C@_0BC@JAGBODKF@wavs?2honkgood?4wav?$AA@
	DD	FLAT:??_C@_0BB@OFFAIFKE@wavs?2scrape1?4wav?$AA@
	DD	FLAT:??_C@_0BB@MELGIHOC@wavs?2screech?4wav?$AA@
	DD	FLAT:??_C@_0BA@KNOIIEKL@wavs?2woohoo?4wav?$AA@
	DD	FLAT:??_C@_0BA@NAFIGGFG@wavs?2pickup?4wav?$AA@
	DD	FLAT:??_C@_0BB@NGLBKADL@wavs?2pickup2?4wav?$AA@
	DD	FLAT:??_C@_0P@MMIIILJ@wavs?2shock?4wav?$AA@
	DD	FLAT:??_C@_0BB@GOLOEOFE@wavs?2electro?4wav?$AA@
	DD	FLAT:??_C@_0BC@GEAACBOA@wavs?2firework?4wav?$AA@
	DD	FLAT:??_C@_0BC@EAGBACCN@wavs?2firebang?4wav?$AA@
	DD	FLAT:??_C@_0O@JIIBHMNG@wavs?2ball?4wav?$AA@
	DD	FLAT:??_C@_0BB@NFMCBAMP@wavs?2ballhit?4wav?$AA@
	DD	FLAT:??_C@_0P@OHDNIIMI@wavs?2wbomb?4wav?$AA@
	DD	FLAT:??_C@_0BC@HBHNEFNE@wavs?2wbombhit?4wav?$AA@
	DD	FLAT:??_C@_0BC@HNEIPLMC@wavs?2puttbang?4wav?$AA@
	DD	FLAT:??_C@_0O@ILAFKPOE@wavs?2fuse?4wav?$AA@
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0P@BPEIBGBN@wavs?2piano?4wav?$AA@
CONST	SEGMENT
??_C@_0P@BPEIBGBN@wavs?2piano?4wav?$AA@ DB 'wavs\piano.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PEEEHADE@wavs?2plane?4wav?$AA@
CONST	SEGMENT
??_C@_0P@PEEEHADE@wavs?2plane?4wav?$AA@ DB 'wavs\plane.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAJCNECN@wavs?2copter?4wav?$AA@
CONST	SEGMENT
??_C@_0BA@PAJCNECN@wavs?2copter?4wav?$AA@ DB 'wavs\copter.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCBCDGKC@wavs?2dragon?4wav?$AA@
CONST	SEGMENT
??_C@_0BA@JCBCDGKC@wavs?2dragon?4wav?$AA@ DB 'wavs\dragon.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BENHMMFP@wavs?2creak?4wav?$AA@
CONST	SEGMENT
??_C@_0P@BENHMMFP@wavs?2creak?4wav?$AA@ DB 'wavs\creak.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGMNIHOA@wavs?2train?4wav?$AA@
CONST	SEGMENT
??_C@_0P@DGMNIHOA@wavs?2train?4wav?$AA@ DB 'wavs\train.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BOMCCILP@wavs?2whistle?4wav?$AA@
CONST	SEGMENT
??_C@_0BB@BOMCCILP@wavs?2whistle?4wav?$AA@ DB 'wavs\whistle.wav', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_SfxToy	DD	FLAT:??_C@_0P@BPEIBGBN@wavs?2piano?4wav?$AA@
	DD	FLAT:??_C@_0P@PEEEHADE@wavs?2plane?4wav?$AA@
	DD	FLAT:??_C@_0BA@PAJCNECN@wavs?2copter?4wav?$AA@
	DD	FLAT:??_C@_0BA@JCBCDGKC@wavs?2dragon?4wav?$AA@
	DD	FLAT:??_C@_0P@BENHMMFP@wavs?2creak?4wav?$AA@
	DD	FLAT:??_C@_0P@DGMNIHOA@wavs?2train?4wav?$AA@
	DD	FLAT:??_C@_0BB@BOMCCILP@wavs?2whistle?4wav?$AA@
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_07EPNHBONG@TOYLITE?$AA@
CONST	SEGMENT
??_C@_07EPNHBONG@TOYLITE?$AA@ DB 'TOYLITE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJCEGIMM@TOY2?$AA@
CONST	SEGMENT
??_C@_04LJCEGIMM@TOY2?$AA@ DB 'TOY2', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?SfxLevel@@3PAULEVEL_SFX@@A DD FLAT:??_C@_07EPNHBONG@TOYLITE?$AA@ ; SfxLevel
	DD	FLAT:_SfxToy
	DD	FLAT:??_C@_04LJCEGIMM@TOY2?$AA@
	DD	FLAT:_SfxToy
	DD	00H
	ORG $+4
_DATA	ENDS
PUBLIC	??_C@_0BN@DABDJMFI@Failed?5to?5init?5sound?5system?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BM@NOCJCOAO@Failed?5to?5set?5sound?5format?$CB?$AA@ ; `string'
PUBLIC	?InitSound@@YAJXZ				; InitSound
EXTRN	__imp__AIL_startup@0:NEAR
EXTRN	__imp__AIL_set_preference@8:NEAR
EXTRN	__imp__AIL_waveOutOpen@16:NEAR
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
_BSS	SEGMENT
_DigDriver DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BN@DABDJMFI@Failed?5to?5init?5sound?5system?$CB?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\sfx.cpp
CONST	SEGMENT
??_C@_0BN@DABDJMFI@Failed?5to?5init?5sound?5system?$CB?$AA@ DB 'Failed to'
	DB	' init sound system!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NOCJCOAO@Failed?5to?5set?5sound?5format?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@NOCJCOAO@Failed?5to?5set?5sound?5format?$CB?$AA@ DB 'Failed to '
	DB	'set sound format!', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitSound@@YAJXZ
_TEXT	SEGMENT
_format$ = -24						; size = 18
_r$ = -4						; size = 4
?InitSound@@YAJXZ PROC NEAR				; InitSound, COMDAT

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 75   : 	long r;
; 76   : 	WAVEFORMATEX format;
; 77   : 
; 78   : // quit if sound off
; 79   : 
; 80   : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81111

; 81   : 		return TRUE;

	mov	eax, 1
	jmp	$L81108
$L81111:

; 82   : 
; 83   : // startup
; 84   : 
; 85   : 	r = AIL_startup();

	call	DWORD PTR __imp__AIL_startup@0
	mov	DWORD PTR _r$[ebp], eax

; 86   : 	if (!r)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $L81112

; 87   : 	{
; 88   : 		Box(NULL, "Failed to init sound system!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0BN@DABDJMFI@Failed?5to?5init?5sound?5system?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 89   : 		SoundOff = TRUE;

	mov	DWORD PTR ?SoundOff@@3JA, 1		; SoundOff

; 90   : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L81108
$L81112:

; 91   : 	}
; 92   : 
; 93   : // use direct sound
; 94   : 
; 95   :    AIL_set_preference(DIG_USE_WAVEOUT, NO);

	push	0
	push	15					; 0000000fH
	call	DWORD PTR __imp__AIL_set_preference@8

; 96   : 
; 97   : // set format
; 98   : 
; 99   :    format.wFormatTag = WAVE_FORMAT_PCM;

	mov	WORD PTR _format$[ebp], 1

; 100  :    format.nChannels = SFX_NUM_CHANNELS;

	mov	WORD PTR _format$[ebp+2], 2

; 101  :    format.nSamplesPerSec = SFX_SAMPLE_RATE;

	mov	DWORD PTR _format$[ebp+4], 22050	; 00005622H

; 102  :    format.nAvgBytesPerSec = SFX_SAMPLE_RATE * (SFX_BITS_PER_SAMPLE / 8) * SFX_NUM_CHANNELS;

	mov	DWORD PTR _format$[ebp+8], 88200	; 00015888H

; 103  :    format.nBlockAlign = (SFX_BITS_PER_SAMPLE / 8) * SFX_NUM_CHANNELS;

	mov	WORD PTR _format$[ebp+12], 4

; 104  :    format.wBitsPerSample = SFX_BITS_PER_SAMPLE;

	mov	WORD PTR _format$[ebp+14], 16		; 00000010H

; 105  : 
; 106  : 	r = AIL_waveOutOpen(&DigDriver, NULL, NULL, (WAVEFORMAT*)&format);

	lea	eax, DWORD PTR _format$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET FLAT:_DigDriver
	call	DWORD PTR __imp__AIL_waveOutOpen@16
	mov	DWORD PTR _r$[ebp], eax

; 107  : 	if (r)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L81115

; 108  : 	{
; 109  : 		Box(NULL, "Failed to set sound format!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0BM@NOCJCOAO@Failed?5to?5set?5sound?5format?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 110  : 		SoundOff = TRUE;

	mov	DWORD PTR ?SoundOff@@3JA, 1		; SoundOff

; 111  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L81108
$L81115:

; 112  : 	}
; 113  : 
; 114  : /*HREDBOOK hr;
; 115  : hr = AIL_redbook_open(0);
; 116  : unsigned long start, end;
; 117  : 
; 118  : AIL_redbook_track_info(hr, 12, &start, &end);
; 119  : AIL_redbook_play(hr, start - 30000, end);*/
; 120  : 
; 121  : // return OK
; 122  : 
; 123  : 	return TRUE;

	mov	eax, 1
$L81108:

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSound@@YAJXZ ENDP					; InitSound
_TEXT	ENDS
PUBLIC	?ReleaseSound@@YAXXZ				; ReleaseSound
EXTRN	__imp__AIL_shutdown@0:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?ReleaseSound@@YAXXZ
_TEXT	SEGMENT
?ReleaseSound@@YAXXZ PROC NEAR				; ReleaseSound, COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 132  : 
; 133  : // quit if sound off
; 134  : 
; 135  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81120

; 136  : 		return;

	jmp	SHORT $L81119
$L81120:

; 137  : 
; 138  : // shutdown sound
; 139  : 
; 140  : 	AIL_shutdown();

	call	DWORD PTR __imp__AIL_shutdown@0
$L81119:

; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReleaseSound@@YAXXZ ENDP				; ReleaseSound
_TEXT	ENDS
PUBLIC	??_C@_0BO@MBPNGAJB@Can?8t?5load?5?8?$CFs?8?5into?5slot?5?$CFd?$CB?$AA@ ; `string'
PUBLIC	?LoadSfx@@YAJPAD@Z				; LoadSfx
EXTRN	__imp__AIL_file_size@4:NEAR
EXTRN	__imp__AIL_file_read@8:NEAR
EXTRN	__imp__AIL_allocate_sample_handle@4:NEAR
EXTRN	__imp__AIL_init_sample@4:NEAR
EXTRN	_strcmp:NEAR
EXTRN	__imp__wsprintfA:NEAR
_BSS	SEGMENT
_SfxLoad DQ	0100H DUP (?)
_Sample	DD	010H DUP (?)
_Sample3D DB	0a00H DUP (?)
_SfxSampleNum DD 01H DUP (?)
_SfxLoadNum DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BO@MBPNGAJB@Can?8t?5load?5?8?$CFs?8?5into?5slot?5?$CFd?$CB?$AA@
CONST	SEGMENT
??_C@_0BO@MBPNGAJB@Can?8t?5load?5?8?$CFs?8?5into?5slot?5?$CFd?$CB?$AA@ DB 'C'
	DB	'an''t load ''%s'' into slot %d!', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadSfx@@YAJPAD@Z
_TEXT	SEGMENT
_wavs$ = -136						; size = 4
_buf$ = -132						; size = 128
_i$ = -4						; size = 4
_levelname$ = 8						; size = 4
?LoadSfx@@YAJPAD@Z PROC NEAR				; LoadSfx, COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi

; 149  : 	long i;
; 150  : 	char buf[128];
; 151  : 	char **wavs;
; 152  : 
; 153  : // quit if sound off
; 154  : 
; 155  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81127

; 156  : 		return TRUE;

	mov	eax, 1
	jmp	$L81123
$L81127:

; 157  : 
; 158  : // load generic wavs
; 159  : 
; 160  : 	wavs = SfxGeneric;

	mov	DWORD PTR _wavs$[ebp], OFFSET FLAT:_SfxGeneric

; 161  : 
; 162  : 	for (i = 0 ; i < SFX_MAX_LOAD ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81128
$L81129:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81128:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$L81130

; 163  : 	{
; 164  : 
; 165  : // end of list?
; 166  : 
; 167  : 		if (!wavs[i]) break;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _wavs$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L81131
	jmp	$L81130
$L81131:

; 168  : 
; 169  : // nope, load next wav
; 170  : 
; 171  : 		SfxLoad[i].Pos = AIL_file_read(wavs[i], NULL);

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _wavs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__AIL_file_read@8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _SfxLoad[ecx*8], eax

; 172  : 		if (!SfxLoad[i].Pos)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _SfxLoad[eax*8], 0
	jne	SHORT $L81132

; 173  : 		{
; 174  : 			wsprintf(buf, "Can't load '%s' into slot %d!", wavs[i], i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _wavs$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MBPNGAJB@Can?8t?5load?5?8?$CFs?8?5into?5slot?5?$CFd?$CB?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 175  : 			Box(NULL, buf, MB_OK);

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 176  : 		}
; 177  : 		else

	jmp	SHORT $L81134
$L81132:

; 178  : 		{
; 179  : 			SfxLoad[i].Size = AIL_file_size(wavs[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _wavs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__AIL_file_size@4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _SfxLoad[ecx*8+4], eax
$L81134:

; 180  : 		}
; 181  : 	}

	jmp	$L81129
$L81130:

; 182  : 
; 183  : 	SfxLoadNum = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _SfxLoadNum, eax

; 184  : 
; 185  : // load level wavs
; 186  : 
; 187  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L81136:

; 188  : 	while (SfxLevel[i].Name && strcmp(SfxLevel[i].Name, levelname)) i++;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?SfxLevel@@3PAULEVEL_SFX@@A[eax*8], 0
	je	SHORT $L81137
	mov	eax, DWORD PTR _levelname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?SfxLevel@@3PAULEVEL_SFX@@A[ecx*8]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L81137
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L81136
$L81137:

; 189  : 
; 190  : 	if (SfxLevel[i].Name)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?SfxLevel@@3PAULEVEL_SFX@@A[eax*8], 0
	je	$L81138

; 191  : 	{
; 192  : 		wavs = SfxLevel[i].Files;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?SfxLevel@@3PAULEVEL_SFX@@A[eax*8+4]
	mov	DWORD PTR _wavs$[ebp], ecx

; 193  : 
; 194  : 		for (i = SfxLoadNum ; i < SFX_MAX_LOAD ; i++)

	mov	eax, DWORD PTR _SfxLoadNum
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L81139
$L81140:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81139:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$L81141

; 195  : 		{
; 196  : 
; 197  : // end of list?
; 198  : 
; 199  : 			if (!wavs[i - SfxLoadNum]) break;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, DWORD PTR _SfxLoadNum
	mov	ecx, DWORD PTR _wavs$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L81142
	jmp	$L81141
$L81142:

; 200  : 
; 201  : // nope, load next wav
; 202  : 
; 203  : 			SfxLoad[i].Pos = AIL_file_read(wavs[i - SfxLoadNum], NULL);

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, DWORD PTR _SfxLoadNum
	mov	ecx, DWORD PTR _wavs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__AIL_file_read@8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _SfxLoad[ecx*8], eax

; 204  : 			if (!SfxLoad[i].Pos)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _SfxLoad[eax*8], 0
	jne	SHORT $L81143

; 205  : 			{
; 206  : 				wsprintf(buf, "Can't load '%s' into slot %d!", wavs[i - SfxLoadNum], i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, DWORD PTR _SfxLoadNum
	mov	edx, DWORD PTR _wavs$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MBPNGAJB@Can?8t?5load?5?8?$CFs?8?5into?5slot?5?$CFd?$CB?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 207  : 				Box(NULL, buf, MB_OK);

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 208  : 			}
; 209  : 			else

	jmp	SHORT $L81144
$L81143:

; 210  : 			{
; 211  : 				SfxLoad[i].Size = AIL_file_size(wavs[i - SfxLoadNum]);

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, DWORD PTR _SfxLoadNum
	mov	ecx, DWORD PTR _wavs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__AIL_file_size@4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _SfxLoad[ecx*8+4], eax
$L81144:

; 212  : 			}
; 213  : 		}

	jmp	$L81140
$L81141:

; 214  : 
; 215  : 		SfxLoadNum = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _SfxLoadNum, eax
$L81138:

; 216  : 	}
; 217  : 
; 218  : // allocate sample handles
; 219  : 
; 220  : 	for (i = 0 ; i < SFX_MAX_SAMPLES ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81145
$L81146:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81145:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $L81147

; 221  : 	{
; 222  : 		Sample[i].Handle = AIL_allocate_sample_handle(DigDriver);

	mov	eax, DWORD PTR _DigDriver
	push	eax
	call	DWORD PTR __imp__AIL_allocate_sample_handle@4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _Sample[ecx*4], eax

; 223  : 		if (!Sample[i].Handle) break;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _Sample[eax*4], 0
	jne	SHORT $L81148
	jmp	SHORT $L81147
$L81148:

; 224  : 		AIL_init_sample(Sample[i].Handle);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_init_sample@4

; 225  : 	}

	jmp	SHORT $L81146
$L81147:

; 226  : 
; 227  : 	SfxSampleNum = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _SfxSampleNum, eax

; 228  : 
; 229  : // init 3D samples
; 230  : 
; 231  : 	for (i = 0 ; i < SFX_MAX_SAMPLES_3D ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81149
$L81150:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81149:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $L81151

; 232  : 	{
; 233  : 		Sample3D[i].Alive = FALSE;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	DWORD PTR _Sample3D[eax], 0

; 234  : 	}

	jmp	SHORT $L81150
$L81151:

; 235  : 
; 236  : // return OK
; 237  : 
; 238  : 	return TRUE;

	mov	eax, 1
$L81123:

; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadSfx@@YAJPAD@Z ENDP					; LoadSfx
_TEXT	ENDS
PUBLIC	?FreeSfx@@YAXXZ					; FreeSfx
EXTRN	__imp__AIL_mem_free_lock@4:NEAR
EXTRN	__imp__AIL_release_sample_handle@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeSfx@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?FreeSfx@@YAXXZ PROC NEAR				; FreeSfx, COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 247  : 	long i;
; 248  : 
; 249  : // quit if sound off
; 250  : 
; 251  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81156

; 252  : 		return;

	jmp	SHORT $L81154
$L81156:

; 253  : 
; 254  : // free all mem
; 255  : 
; 256  : 	for (i = 0 ; i < SfxLoadNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81157
$L81158:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81157:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SfxLoadNum
	jge	SHORT $L81159

; 257  : 	{
; 258  : 		if (SfxLoad[i].Pos)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _SfxLoad[eax*8], 0
	je	SHORT $L81160

; 259  : 			AIL_mem_free_lock(SfxLoad[i].Pos);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _SfxLoad[eax*8]
	push	ecx
	call	DWORD PTR __imp__AIL_mem_free_lock@4
$L81160:

; 260  : 	}

	jmp	SHORT $L81158
$L81159:

; 261  : 
; 262  : // release samples
; 263  : 
; 264  : 	for (i = 0 ; i <SfxSampleNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81161
$L81162:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81161:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SfxSampleNum
	jge	SHORT $L81154

; 265  : 	{
; 266  : 		AIL_release_sample_handle(Sample[i].Handle);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_release_sample_handle@4

; 267  : 	}

	jmp	SHORT $L81162
$L81154:

; 268  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeSfx@@YAXXZ ENDP					; FreeSfx
_TEXT	ENDS
PUBLIC	?PlaySfx@@YAXJJJJ@Z				; PlaySfx
EXTRN	__imp__AIL_set_sample_file@12:NEAR
EXTRN	__imp__AIL_start_sample@4:NEAR
EXTRN	__imp__AIL_set_sample_playback_rate@8:NEAR
EXTRN	__imp__AIL_set_sample_volume@8:NEAR
EXTRN	__imp__AIL_set_sample_pan@8:NEAR
EXTRN	__imp__AIL_sample_status@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?PlaySfx@@YAXJJJJ@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_num$ = 8						; size = 4
_vol$ = 12						; size = 4
_pan$ = 16						; size = 4
_freq$ = 20						; size = 4
?PlaySfx@@YAXJJJJ@Z PROC NEAR				; PlaySfx, COMDAT

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 276  : 	long i;
; 277  : 
; 278  : // quit if sound off
; 279  : 
; 280  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81171

; 281  : 		return;

	jmp	$L81169
$L81171:

; 282  : 
; 283  : // quit if NULL sound
; 284  : 
; 285  : 	if (!SfxLoad[num].Pos)

	mov	eax, DWORD PTR _num$[ebp]
	cmp	DWORD PTR _SfxLoad[eax*8], 0
	jne	SHORT $L81172

; 286  : 		return;

	jmp	$L81169
$L81172:

; 287  : 
; 288  : // find a free sample
; 289  : 
; 290  : 	for (i = 0 ; i < SfxSampleNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81173
$L81174:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81173:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SfxSampleNum
	jge	$L81169

; 291  : 	{
; 292  : 		if (AIL_sample_status(Sample[i].Handle) == SMP_DONE)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_sample_status@4
	cmp	eax, 2
	jne	$L81176

; 293  : 		{
; 294  : 
; 295  : // set up and play
; 296  : 
; 297  : 			AIL_init_sample(Sample[i].Handle);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_init_sample@4

; 298  : 			AIL_set_sample_file(Sample[i].Handle, SfxLoad[num].Pos, -1);

	push	-1
	mov	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _SfxLoad[eax*8]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _Sample[edx*4]
	push	eax
	call	DWORD PTR __imp__AIL_set_sample_file@12

; 299  : 
; 300  : 			if (vol != -1) AIL_set_sample_volume(Sample[i].Handle, vol);

	cmp	DWORD PTR _vol$[ebp], -1
	je	SHORT $L81177
	mov	eax, DWORD PTR _vol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _Sample[ecx*4]
	push	edx
	call	DWORD PTR __imp__AIL_set_sample_volume@8
$L81177:

; 301  : 			if (pan != -1) AIL_set_sample_pan(Sample[i].Handle, pan);

	cmp	DWORD PTR _pan$[ebp], -1
	je	SHORT $L81178
	mov	eax, DWORD PTR _pan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _Sample[ecx*4]
	push	edx
	call	DWORD PTR __imp__AIL_set_sample_pan@8
$L81178:

; 302  : 			if (freq != -1) AIL_set_sample_playback_rate(Sample[i].Handle, freq);

	cmp	DWORD PTR _freq$[ebp], -1
	je	SHORT $L81179
	mov	eax, DWORD PTR _freq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _Sample[ecx*4]
	push	edx
	call	DWORD PTR __imp__AIL_set_sample_playback_rate@8
$L81179:

; 303  : 
; 304  : 			AIL_start_sample(Sample[i].Handle);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_start_sample@4

; 305  : 			break;

	jmp	SHORT $L81169
$L81176:

; 306  : 		}
; 307  : 	}

	jmp	$L81174
$L81169:

; 308  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlaySfx@@YAXJJJJ@Z ENDP				; PlaySfx
_TEXT	ENDS
PUBLIC	?StopSfx@@YAXPAUSAMPLE_SFX@@@Z			; StopSfx
EXTRN	__imp__AIL_end_sample@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?StopSfx@@YAXPAUSAMPLE_SFX@@@Z
_TEXT	SEGMENT
_sample$ = 8						; size = 4
?StopSfx@@YAXPAUSAMPLE_SFX@@@Z PROC NEAR		; StopSfx, COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 316  : // quit if sound off
; 317  : 
; 318  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81183

; 319  : 		return;

	jmp	SHORT $L81182
$L81183:

; 320  : 
; 321  : // stop sfx
; 322  : 
; 323  : 	AIL_end_sample(sample->Handle);

	mov	eax, DWORD PTR _sample$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__AIL_end_sample@4
$L81182:

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSfx@@YAXPAUSAMPLE_SFX@@@Z ENDP			; StopSfx
_TEXT	ENDS
PUBLIC	?PauseAllSfx@@YAXXZ				; PauseAllSfx
EXTRN	__imp__AIL_stop_sample@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?PauseAllSfx@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?PauseAllSfx@@YAXXZ PROC NEAR				; PauseAllSfx, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 332  : 	long i;
; 333  : 
; 334  : 	for (i = 0 ; i < SfxSampleNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81187
$L81188:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81187:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SfxSampleNum
	jge	SHORT $L81185

; 335  : 	{
; 336  : 		if (AIL_sample_status(Sample[i].Handle) == SMP_PLAYING)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_sample_status@4
	cmp	eax, 4
	jne	SHORT $L81190

; 337  : 		{
; 338  : 			AIL_stop_sample(Sample[i].Handle);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_stop_sample@4
$L81190:

; 339  : 		}
; 340  : 	}

	jmp	SHORT $L81188
$L81185:

; 341  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PauseAllSfx@@YAXXZ ENDP				; PauseAllSfx
_TEXT	ENDS
PUBLIC	?ResumeAllSfx@@YAXXZ				; ResumeAllSfx
EXTRN	__imp__AIL_resume_sample@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?ResumeAllSfx@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?ResumeAllSfx@@YAXXZ PROC NEAR				; ResumeAllSfx, COMDAT

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 349  : 	long i;
; 350  : 
; 351  : 	for (i = 0 ; i < SfxSampleNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81194
$L81195:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81194:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SfxSampleNum
	jge	SHORT $L81192

; 352  : 	{
; 353  : 		if (AIL_sample_status(Sample[i].Handle) == SMP_STOPPED)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_sample_status@4
	cmp	eax, 8
	jne	SHORT $L81197

; 354  : 		{
; 355  : 			AIL_resume_sample(Sample[i].Handle);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_resume_sample@4
$L81197:

; 356  : 		}
; 357  : 	}

	jmp	SHORT $L81195
$L81192:

; 358  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResumeAllSfx@@YAXXZ ENDP				; ResumeAllSfx
_TEXT	ENDS
PUBLIC	?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z		; PlaySfx3D
PUBLIC	?GetSfxSettings3D@@YAXPAJ00PAUVectorStruct@@M@Z	; GetSfxSettings3D
EXTRN	__fltused:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z
_TEXT	SEGMENT
_pan$ = -4						; size = 4
_num$ = 8						; size = 4
_vol$ = 12						; size = 4
_freq$ = 16						; size = 4
_pos$ = 20						; size = 4
?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z PROC NEAR		; PlaySfx3D, COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 366  : 	long pan;
; 367  : 
; 368  : // quit if sound off
; 369  : 
; 370  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81205

; 371  : 		return;

	jmp	SHORT $L81203
$L81205:

; 372  : 
; 373  : // get 3D settings
; 374  : 
; 375  : 	GetSfxSettings3D(&vol, &freq, &pan, pos, 0);

	push	0
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pan$[ebp]
	push	ecx
	lea	edx, DWORD PTR _freq$[ebp]
	push	edx
	lea	eax, DWORD PTR _vol$[ebp]
	push	eax
	call	?GetSfxSettings3D@@YAXPAJ00PAUVectorStruct@@M@Z ; GetSfxSettings3D
	add	esp, 20					; 00000014H

; 376  : 
; 377  : // play sfx
; 378  : 
; 379  : 	PlaySfx(num, vol, pan, freq);

	mov	eax, DWORD PTR _freq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pan$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vol$[ebp]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	call	?PlaySfx@@YAXJJJJ@Z			; PlaySfx
	add	esp, 16					; 00000010H
$L81203:

; 380  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlaySfx3D@@YAXJJJPAUVectorStruct@@@Z ENDP		; PlaySfx3D
_TEXT	ENDS
PUBLIC	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ; CreateSfx3D
EXTRN	__imp__AIL_set_sample_loop_count@8:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_num$ = 8						; size = 4
_vol$ = 12						; size = 4
_freq$ = 16						; size = 4
_loop$ = 20						; size = 4
_pos$ = 24						; size = 4
?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z PROC NEAR ; CreateSfx3D, COMDAT

; 387  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 388  : 	long i, j;
; 389  : 
; 390  : // quit if sound off
; 391  : 
; 392  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81215

; 393  : 		return NULL;

	xor	eax, eax
	jmp	$L81212
$L81215:

; 394  : 
; 395  : // find free slot
; 396  : 
; 397  : 	for (i = 0 ; i < SFX_MAX_SAMPLES_3D ; i++) if (!Sample3D[i].Alive)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81216
$L81217:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81216:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$L81218
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax], 0
	jne	$L81219

; 398  : 	{
; 399  : 
; 400  : // got one, set misc
; 401  : 
; 402  : 		Sample3D[i].Num = num;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _Sample3D[eax+4], ecx

; 403  : 		Sample3D[i].Vol = vol;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR _Sample3D[eax+8], ecx

; 404  : 		Sample3D[i].Freq = freq;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _freq$[ebp]
	mov	DWORD PTR _Sample3D[eax+12], ecx

; 405  : 		Sample3D[i].Loop = loop;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _loop$[ebp]
	mov	DWORD PTR _Sample3D[eax+16], ecx

; 406  : 		Sample3D[i].LastDist = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	DWORD PTR _Sample3D[eax+20], 0

; 407  : 		Sample3D[i].Pos = *pos;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:_Sample3D+28
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 408  : 
; 409  : // return now if looping
; 410  : 
; 411  : 		if (loop)

	cmp	DWORD PTR _loop$[ebp], 0
	je	SHORT $L81220

; 412  : 		{
; 413  : 			Sample3D[i].Sample = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	DWORD PTR _Sample3D[eax+24], 0

; 414  : 			Sample3D[i].Alive = TRUE;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	DWORD PTR _Sample3D[eax], 1

; 415  : 			return &Sample3D[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	add	eax, OFFSET FLAT:_Sample3D
	jmp	$L81212
$L81220:

; 416  : 		}
; 417  : 
; 418  : // quit if NULL sound
; 419  : 
; 420  : 		if (!SfxLoad[num].Pos)

	mov	eax, DWORD PTR _num$[ebp]
	cmp	DWORD PTR _SfxLoad[eax*8], 0
	jne	SHORT $L81221

; 421  : 			return NULL;

	xor	eax, eax
	jmp	$L81212
$L81221:

; 422  : 
; 423  : // else start sample now
; 424  : 
; 425  : 		for (j = 0 ; j < SfxSampleNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81222
$L81223:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81222:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _SfxSampleNum
	jge	$L81224

; 426  : 		{
; 427  : 			if (AIL_sample_status(Sample[j].Handle) == SMP_DONE)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_sample_status@4
	cmp	eax, 2
	jne	$L81225

; 428  : 			{
; 429  : 				AIL_init_sample(Sample[j].Handle);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_init_sample@4

; 430  : 				AIL_set_sample_file(Sample[j].Handle, SfxLoad[Sample3D[i].Num].Pos, -1);

	push	-1
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _Sample3D[eax+4]
	mov	edx, DWORD PTR _SfxLoad[ecx*8]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_set_sample_file@12

; 431  : 				AIL_set_sample_loop_count(Sample[j].Handle, 1);

	push	1
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_set_sample_loop_count@8

; 432  : 				AIL_set_sample_volume(Sample[j].Handle, SFX_MIN_VOL);

	push	0
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_set_sample_volume@8

; 433  : 				AIL_start_sample(Sample[j].Handle);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_start_sample@4

; 434  : 
; 435  : 				Sample3D[i].Sample = &Sample[j];

	mov	eax, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR _Sample[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	DWORD PTR _Sample3D[edx+24], ecx

; 436  : 				Sample3D[i].Alive = TRUE;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	DWORD PTR _Sample3D[eax], 1

; 437  : 				return &Sample3D[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	add	eax, OFFSET FLAT:_Sample3D
	jmp	SHORT $L81212
$L81225:

; 438  : 			}
; 439  : 		}

	jmp	$L81223
$L81224:

; 440  : 
; 441  : // no free sample return NULL
; 442  : 
; 443  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L81212
$L81219:

; 444  : 	}
; 445  : 
; 446  : // return no
; 447  : 
; 448  : 	return NULL;

	jmp	$L81217
$L81218:
	xor	eax, eax
$L81212:

; 449  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ENDP ; CreateSfx3D
_TEXT	ENDS
PUBLIC	?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z			; FreeSfx3D
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z
_TEXT	SEGMENT
_sample3d$ = 8						; size = 4
?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z PROC NEAR		; FreeSfx3D, COMDAT

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 457  : 
; 458  : // quit if sound off
; 459  : 
; 460  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81229

; 461  : 		return;

	jmp	SHORT $L81228
$L81229:

; 462  : 
; 463  : // kill playing sample
; 464  : 
; 465  : 	if (sample3d->Sample)

	mov	eax, DWORD PTR _sample3d$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L81230

; 466  : 	{
; 467  : 		StopSfx(sample3d->Sample);

	mov	eax, DWORD PTR _sample3d$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?StopSfx@@YAXPAUSAMPLE_SFX@@@Z		; StopSfx
	add	esp, 4
$L81230:

; 468  : 	}
; 469  : 
; 470  : // kill 3d sample
; 471  : 
; 472  : 	sample3d->Alive = FALSE;

	mov	eax, DWORD PTR _sample3d$[ebp]
	mov	DWORD PTR [eax], 0
$L81228:

; 473  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeSfx3D@@YAXPAUSAMPLE_3D@@@Z ENDP			; FreeSfx3D
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	__real@44160000
PUBLIC	__real@3d810204
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@43800000
PUBLIC	__real@4b000000
PUBLIC	__real@42800000
PUBLIC	__real@44200000
PUBLIC	__real@42fc0000
PUBLIC	__real@44800000
EXTRN	?CAM_MainCamera@@3PAUCameraStruct@@A:DWORD	; CAM_MainCamera
EXTRN	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z:NEAR ; TransposeRotVector
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@3d810204
CONST	SEGMENT
__real@3d810204 DD 03d810204r			; 0.0629921
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@44200000
CONST	SEGMENT
__real@44200000 DD 044200000r			; 640
CONST	ENDS
;	COMDAT __real@42fc0000
CONST	SEGMENT
__real@42fc0000 DD 042fc0000r			; 126
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?GetSfxSettings3D@@YAXPAJ00PAUVectorStruct@@M@Z
_TEXT	SEGMENT
tv145 = -116						; size = 4
__temp$81258 = -48					; size = 4
__temp$81255 = -44					; size = 4
__temp$81249 = -40					; size = 4
_vec2$ = -36						; size = 12
_vec1$ = -24						; size = 12
_f$ = -12						; size = 4
_x$ = -8						; size = 4
_per$ = -4						; size = 4
_vol$ = 8						; size = 4
_freq$ = 12						; size = 4
_pan$ = 16						; size = 4
_pos$ = 20						; size = 4
_vel$ = 24						; size = 4
?GetSfxSettings3D@@YAXPAJ00PAUVectorStruct@@M@Z PROC NEAR ; GetSfxSettings3D, COMDAT

; 480  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 481  : 	long per;
; 482  : 	float x, f;
; 483  : 	VEC vec1, vec2;
; 484  : 
; 485  : // quit if sound off
; 486  : 
; 487  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81243

; 488  : 		return;

	jmp	$L81237
$L81243:

; 489  : 
; 490  : // get camera space vector
; 491  : 
; 492  : 	SubVector(pos, &CAM_MainCamera->WPos, &vec1);

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+68]
	fstp	DWORD PTR _vec1$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+72]
	fstp	DWORD PTR _vec1$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+76]
	fstp	DWORD PTR _vec1$[ebp+8]

; 493  : 	TransposeRotVector(&CAM_MainCamera->WMatrix, &vec1, &vec2);

	lea	eax, DWORD PTR _vec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 16					; 00000010H
	push	edx
	call	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
	add	esp, 12					; 0000000cH

; 494  : 
; 495  : // calc vol
; 496  : 
; 497  : 	f = SFX_3D_MIN_DIST / Length(&vec2) - SFX_3D_SUB_DIST;

	fld	DWORD PTR _vec2$[ebp]
	fmul	DWORD PTR _vec2$[ebp]
	fld	DWORD PTR _vec2$[ebp+4]
	fmul	DWORD PTR _vec2$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vec2$[ebp+8]
	fmul	DWORD PTR _vec2$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@44160000
	fsub	DWORD PTR __real@3d810204
	fstp	DWORD PTR _f$[ebp]

; 498  : 	if (f < 0) f = 0;

	fld	DWORD PTR _f$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81246
	mov	DWORD PTR _f$[ebp], 0

; 499  : 	else if (f > 1) f = 1;

	jmp	SHORT $L81247
$L81246:
	fld	DWORD PTR _f$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81247
	mov	DWORD PTR _f$[ebp], 1065353216		; 3f800000H
$L81247:

; 500  : 
; 501  : 	FTOL(f * 256, per);

	fld	DWORD PTR _f$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81249[ebp]
	mov	eax, DWORD PTR __temp$81249[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _per$[ebp], eax

; 502  : 	*vol = *vol * per / 256;

	mov	eax, DWORD PTR _vol$[ebp]
	mov	eax, DWORD PTR [eax]
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [ecx], eax

; 503  : 	
; 504  : // calc pan
; 505  : 
; 506  : 	x = vec2.v[X] * RenderSettings.GeomPers / abs(vec2.v[Z]);

	fld	DWORD PTR _vec2$[ebp+8]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81496
	mov	eax, DWORD PTR _vec2$[ebp+8]
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $L81497
$L81496:
	fld	DWORD PTR _vec2$[ebp+8]
	fchs
	fstp	DWORD PTR tv145[ebp]
$L81497:
	fld	DWORD PTR _vec2$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fdiv	DWORD PTR tv145[ebp]
	fstp	DWORD PTR _x$[ebp]

; 507  : 	x = (x * SFX_3D_PAN_MUL / REAL_SCREEN_XSIZE) + SFX_CENTRE_PAN;

	fld	DWORD PTR _x$[ebp]
	fmul	DWORD PTR __real@42800000
	fdiv	DWORD PTR __real@44200000
	fadd	DWORD PTR __real@42800000
	fstp	DWORD PTR _x$[ebp]

; 508  : 	if (x < SFX_LEFT_PAN + 1) x = SFX_LEFT_PAN + 1;

	fld	DWORD PTR _x$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81252
	mov	DWORD PTR _x$[ebp], 1065353216		; 3f800000H

; 509  : 	else if (x > SFX_RIGHT_PAN - 1) x = SFX_RIGHT_PAN - 1;

	jmp	SHORT $L81253
$L81252:
	fld	DWORD PTR _x$[ebp]
	fcomp	DWORD PTR __real@42fc0000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81253
	mov	DWORD PTR _x$[ebp], 1123811328		; 42fc0000H
$L81253:

; 510  : 
; 511  : 	FTOL(x, *pan);

	fld	DWORD PTR _x$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81255[ebp]
	mov	eax, DWORD PTR __temp$81255[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR _pan$[ebp]
	mov	DWORD PTR [ecx], eax

; 512  : 
; 513  : // calc freq
; 514  : 
; 515  : 	f = SFX_3D_SOS / (vel + SFX_3D_SOS);

	fld	DWORD PTR _vel$[ebp]
	fadd	DWORD PTR __real@44800000
	fdivr	DWORD PTR __real@44800000
	fstp	DWORD PTR _f$[ebp]

; 516  : 
; 517  : 	FTOL(f * 256, per);

	fld	DWORD PTR _f$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81258[ebp]
	mov	eax, DWORD PTR __temp$81258[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _per$[ebp], eax

; 518  : 	*freq = *freq * per / 256;

	mov	eax, DWORD PTR _freq$[ebp]
	mov	eax, DWORD PTR [eax]
	imul	eax, DWORD PTR _per$[ebp]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _freq$[ebp]
	mov	DWORD PTR [ecx], eax
$L81237:

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSfxSettings3D@@YAXPAJ00PAUVectorStruct@@M@Z ENDP	; GetSfxSettings3D
_TEXT	ENDS
PUBLIC	?ChangeSfxSample3D@@YAXPAUSAMPLE_3D@@J@Z	; ChangeSfxSample3D
; Function compile flags: /Odt /ZI
;	COMDAT ?ChangeSfxSample3D@@YAXPAUSAMPLE_3D@@J@Z
_TEXT	SEGMENT
_sample3d$ = 8						; size = 4
_sfx$ = 12						; size = 4
?ChangeSfxSample3D@@YAXPAUSAMPLE_3D@@J@Z PROC NEAR	; ChangeSfxSample3D, COMDAT

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 527  : 	if (sample3d->Sample)

	mov	eax, DWORD PTR _sample3d$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L81265

; 528  : 	{
; 529  : 		StopSfx(sample3d->Sample);

	mov	eax, DWORD PTR _sample3d$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?StopSfx@@YAXPAUSAMPLE_SFX@@@Z		; StopSfx
	add	esp, 4

; 530  : 		sample3d->Sample = NULL;

	mov	eax, DWORD PTR _sample3d$[ebp]
	mov	DWORD PTR [eax+24], 0
$L81265:

; 531  : 	}
; 532  : 
; 533  : 	sample3d->Num = sfx;

	mov	eax, DWORD PTR _sample3d$[ebp]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 534  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ChangeSfxSample3D@@YAXPAUSAMPLE_3D@@J@Z ENDP		; ChangeSfxSample3D
_TEXT	ENDS
PUBLIC	__real@42c80000
PUBLIC	?MaintainAllSfx@@YAXXZ				; MaintainAllSfx
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?TimerFreq@@3KA:DWORD				; TimerFreq
_BSS	SEGMENT
_SfxTimerLast DD 01H DUP (?)
_SfxTimerCurrent DD 01H DUP (?)
_SfxTimeMul DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?MaintainAllSfx@@YAXXZ
_TEXT	SEGMENT
tv292 = -120						; size = 8
tv288 = -112						; size = 8
_vec$ = -40						; size = 12
_vel$ = -28						; size = 4
_dist$ = -24						; size = 4
_pan$ = -20						; size = 4
_freq$ = -16						; size = 4
_vol$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
?MaintainAllSfx@@YAXXZ PROC NEAR			; MaintainAllSfx, COMDAT

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 542  : 	long i, j, vol, freq, pan;
; 543  : 	float dist, vel;
; 544  : 	VEC vec;
; 545  : 
; 546  : // quit if sound off
; 547  : 
; 548  : 	if (SoundOff)

	cmp	DWORD PTR ?SoundOff@@3JA, 0		; SoundOff
	je	SHORT $L81277

; 549  : 		return;

	jmp	$L81268
$L81277:

; 550  : 
; 551  : // get sfx time mul
; 552  : 
; 553  : 	SfxTimerLast = SfxTimerCurrent;

	mov	eax, DWORD PTR _SfxTimerCurrent
	mov	DWORD PTR _SfxTimerLast, eax

; 554  : 	SfxTimerCurrent = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR _SfxTimerCurrent, eax

; 555  : 	SfxTimeMul = ((float)TimerFreq / 100) / (float)(SfxTimerCurrent - SfxTimerLast);

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	mov	DWORD PTR tv288[ebp], eax
	mov	DWORD PTR tv288[ebp+4], 0
	fild	QWORD PTR tv288[ebp]
	fdiv	DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _SfxTimerCurrent
	sub	ecx, DWORD PTR _SfxTimerLast
	mov	DWORD PTR tv292[ebp], ecx
	mov	DWORD PTR tv292[ebp+4], 0
	fild	QWORD PTR tv292[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _SfxTimeMul

; 556  : 
; 557  : // maintain all 3D sfx
; 558  : 
; 559  : 	for (i = 0 ; i < SFX_MAX_SAMPLES_3D ; i++) if (Sample3D[i].Alive)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81280
$L81281:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81280:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$L81268
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax], 0
	je	$L81283

; 560  : 	{
; 561  : 
; 562  : // non-looping sfx finished?
; 563  : 
; 564  : 		if (!Sample3D[i].Loop)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+16], 0
	jne	SHORT $L81284

; 565  : 		{
; 566  : 			if (Sample3D[i].Sample)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+24], 0
	je	SHORT $L81285

; 567  : 			{
; 568  : 				 if (AIL_sample_status(Sample3D[i].Sample->Handle) == SMP_DONE)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _Sample3D[eax+24]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__AIL_sample_status@4
	cmp	eax, 2
	jne	SHORT $L81285

; 569  : 					Sample3D[i].Sample = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	DWORD PTR _Sample3D[eax+24], 0
$L81285:

; 570  : 			}
; 571  : 			if (!Sample3D[i].Sample)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+24], 0
	jne	SHORT $L81284

; 572  : 				continue;

	jmp	SHORT $L81281
$L81284:

; 573  : 		}
; 574  : 
; 575  : // get 3d sound settings
; 576  : 
; 577  : 		SubVector(&Sample3D[i].Pos, &CAM_MainCamera->WPos, &vec);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _Sample3D[eax+28]
	fsub	DWORD PTR [ecx+68]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _Sample3D[eax+32]
	fsub	DWORD PTR [ecx+72]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	fld	DWORD PTR _Sample3D[eax+36]
	fsub	DWORD PTR [ecx+76]
	fstp	DWORD PTR _vec$[ebp+8]

; 578  : 		dist = Length(&vec);

	fld	DWORD PTR _vec$[ebp]
	fmul	DWORD PTR _vec$[ebp]
	fld	DWORD PTR _vec$[ebp+4]
	fmul	DWORD PTR _vec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vec$[ebp+8]
	fmul	DWORD PTR _vec$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 579  : 		vel = (dist - Sample3D[i].LastDist) * SfxTimeMul;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	fld	DWORD PTR _dist$[ebp]
	fsub	DWORD PTR _Sample3D[eax+20]
	fmul	DWORD PTR _SfxTimeMul
	fstp	DWORD PTR _vel$[ebp]

; 580  : 		Sample3D[i].LastDist = dist;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _Sample3D[eax+20], ecx

; 581  : 
; 582  : 		vol = Sample3D[i].Vol;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _Sample3D[eax+8]
	mov	DWORD PTR _vol$[ebp], ecx

; 583  : 		freq = Sample3D[i].Freq;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _Sample3D[eax+12]
	mov	DWORD PTR _freq$[ebp], ecx

; 584  : 
; 585  : 		GetSfxSettings3D(&vol, &freq, &pan, &Sample3D[i].Pos, vel);

	mov	eax, DWORD PTR _vel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:_Sample3D+28
	push	ecx
	lea	edx, DWORD PTR _pan$[ebp]
	push	edx
	lea	eax, DWORD PTR _freq$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vol$[ebp]
	push	ecx
	call	?GetSfxSettings3D@@YAXPAJ00PAUVectorStruct@@M@Z ; GetSfxSettings3D
	add	esp, 20					; 00000014H

; 586  : 
; 587  : // stop sample if outside range?
; 588  : 
; 589  : 		if (Sample3D[i].Loop && !vol)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+16], 0
	je	SHORT $L81289
	cmp	DWORD PTR _vol$[ebp], 0
	jne	SHORT $L81289

; 590  : 		{
; 591  : 			if (Sample3D[i].Sample)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+24], 0
	je	SHORT $L81290

; 592  : 			{
; 593  : 				StopSfx(Sample3D[i].Sample);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _Sample3D[eax+24]
	push	ecx
	call	?StopSfx@@YAXPAUSAMPLE_SFX@@@Z		; StopSfx
	add	esp, 4

; 594  : 				Sample3D[i].Sample = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	DWORD PTR _Sample3D[eax+24], 0
$L81290:

; 595  : 			}
; 596  : 
; 597  : 			continue;

	jmp	$L81281
$L81289:

; 598  : 		}
; 599  : 
; 600  : // start sample if in range?
; 601  : 
; 602  : 		if (Sample3D[i].Loop && !Sample3D[i].Sample && SfxLoad[Sample3D[i].Num].Pos)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+16], 0
	je	$L81291
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+24], 0
	jne	$L81291
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _Sample3D[eax+4]
	cmp	DWORD PTR _SfxLoad[ecx*8], 0
	je	$L81291

; 603  : 		{
; 604  : 			for (j = 0 ; j < SfxSampleNum ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81292
$L81293:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81292:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _SfxSampleNum
	jge	$L81291

; 605  : 			{
; 606  : 				if (AIL_sample_status(Sample[j].Handle) == SMP_DONE)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_sample_status@4
	cmp	eax, 2
	jne	$L81295

; 607  : 				{
; 608  : 					AIL_init_sample(Sample[j].Handle);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_init_sample@4

; 609  : 					AIL_set_sample_file(Sample[j].Handle, SfxLoad[Sample3D[i].Num].Pos, -1);

	push	-1
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _Sample3D[eax+4]
	mov	edx, DWORD PTR _SfxLoad[ecx*8]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_set_sample_file@12

; 610  : 					AIL_set_sample_loop_count(Sample[j].Handle, 0);

	push	0
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_set_sample_loop_count@8

; 611  : 					AIL_set_sample_volume(Sample[j].Handle, SFX_MIN_VOL);

	push	0
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_set_sample_volume@8

; 612  : 					AIL_start_sample(Sample[j].Handle);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _Sample[eax*4]
	push	ecx
	call	DWORD PTR __imp__AIL_start_sample@4

; 613  : 
; 614  : 					Sample3D[i].Sample = &Sample[j];

	mov	eax, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR _Sample[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	DWORD PTR _Sample3D[edx+24], ecx

; 615  : 					break;

	jmp	SHORT $L81291
$L81295:

; 616  : 				}
; 617  : 			}

	jmp	$L81293
$L81291:

; 618  : 		}
; 619  : 
; 620  : // skip if still no sample
; 621  : 
; 622  : 		if (!Sample3D[i].Sample)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	cmp	DWORD PTR _Sample3D[eax+24], 0
	jne	SHORT $L81296

; 623  : 			continue;

	jmp	$L81281
$L81296:

; 624  : 
; 625  : // set vol / pan / freq
; 626  : 
; 627  : 		AIL_set_sample_volume(Sample3D[i].Sample->Handle, vol);

	mov	eax, DWORD PTR _vol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _Sample3D[ecx+24]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__AIL_set_sample_volume@8

; 628  : 		AIL_set_sample_pan(Sample3D[i].Sample->Handle, pan);

	mov	eax, DWORD PTR _pan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _Sample3D[ecx+24]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__AIL_set_sample_pan@8

; 629  : 		AIL_set_sample_playback_rate(Sample3D[i].Sample->Handle, freq);

	mov	eax, DWORD PTR _freq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _Sample3D[ecx+24]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__AIL_set_sample_playback_rate@8
$L81283:

; 630  : 	}
; 631  : }

	jmp	$L81281
$L81268:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MaintainAllSfx@@YAXXZ ENDP				; MaintainAllSfx
_TEXT	ENDS
PUBLIC	?PlayMP3@@YAXPAD@Z				; PlayMP3
EXTRN	__imp__AIL_open_stream@12:NEAR
EXTRN	__imp__AIL_start_stream@4:NEAR
EXTRN	__imp__AIL_set_stream_volume@8:NEAR
EXTRN	__imp__AIL_set_stream_playback_rate@8:NEAR
EXTRN	__imp__AIL_set_stream_loop_count@8:NEAR
_BSS	SEGMENT
_StreamMP3 DD	01H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?PlayMP3@@YAXPAD@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?PlayMP3@@YAXPAD@Z PROC NEAR				; PlayMP3, COMDAT

; 638  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 639  : 	StreamMP3 = AIL_open_stream(DigDriver, file, 0);

	push	0
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DigDriver
	push	ecx
	call	DWORD PTR __imp__AIL_open_stream@12
	mov	DWORD PTR _StreamMP3, eax

; 640  : 	AIL_set_stream_loop_count(StreamMP3, 0);

	push	0
	mov	eax, DWORD PTR _StreamMP3
	push	eax
	call	DWORD PTR __imp__AIL_set_stream_loop_count@8

; 641  : 	AIL_set_stream_volume(StreamMP3, SFX_MAX_VOL);

	push	127					; 0000007fH
	mov	eax, DWORD PTR _StreamMP3
	push	eax
	call	DWORD PTR __imp__AIL_set_stream_volume@8

; 642  : 	AIL_set_stream_playback_rate(StreamMP3, 44100);

	push	44100					; 0000ac44H
	mov	eax, DWORD PTR _StreamMP3
	push	eax
	call	DWORD PTR __imp__AIL_set_stream_playback_rate@8

; 643  : 	AIL_start_stream(StreamMP3);

	mov	eax, DWORD PTR _StreamMP3
	push	eax
	call	DWORD PTR __imp__AIL_start_stream@4

; 644  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayMP3@@YAXPAD@Z ENDP					; PlayMP3
_TEXT	ENDS
PUBLIC	?StopMP3@@YAXXZ					; StopMP3
EXTRN	__imp__AIL_close_stream@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?StopMP3@@YAXXZ
_TEXT	SEGMENT
?StopMP3@@YAXXZ PROC NEAR				; StopMP3, COMDAT

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 652  : 	AIL_close_stream(StreamMP3);

	mov	eax, DWORD PTR _StreamMP3
	push	eax
	call	DWORD PTR __imp__AIL_close_stream@4

; 653  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopMP3@@YAXXZ ENDP					; StopMP3
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
END
