; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\obj_init.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BB@KGOOAJPL@models?2dragon2?4m?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BOFCGOJO@models?2dragon3?4m?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OLBPDICD@levels?2muse2?2sun?4bmp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BCFGIBPO@levels?2toylite?2water?4bmp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@PGGGICOM@Laser?5goes?5on?5for?5ever?4?4?4?4?4?4?4?4?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadObjects@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBarrel@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitFootball@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBeachball@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlanet@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPlane@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitCopter@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitDragon@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitWater@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTrolley@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeTrolley@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBoat@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitRadar@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitSpeedup@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitBalloon@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHorse@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTrain@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitStrobe@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitSparkGen@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitSpaceman@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPickup@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitDissolveModel@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitFlap@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitLaser@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitSplash@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??InitDissolveModel@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??InitPickup@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??InitWater@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??InitPlanet@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??InitBeachball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??InitFootball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@KGOOAJPL@models?2dragon2?4m?$AA@	; `string'
PUBLIC	??_C@_0BB@BOFCGOJO@models?2dragon3?4m?$AA@	; `string'
PUBLIC	?StrobeTable@@3PAUSTROBE_TABLE@@A		; StrobeTable
EXTRN	?InitShockwave@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitShockwave
EXTRN	?InitFirework@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitFirework
EXTRN	?InitPuttyBomb@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitPuttyBomb
EXTRN	?InitWaterBomb@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitWaterBomb
EXTRN	?InitElectroPulse@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitElectroPulse
EXTRN	?InitOilSlick@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitOilSlick
EXTRN	?InitOilSlickDropper@@YAJPAUobject_def@@PAJ@Z:NEAR ; InitOilSlickDropper
EXTRN	?InitChromeBall@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitChromeBall
EXTRN	?InitClone@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitClone
EXTRN	?InitTurbo2@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitTurbo2
EXTRN	?InitSpring@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitSpring
EXTRN	?InitElectroZapped@@YAJPAUobject_def@@PAJ@Z:NEAR ; InitElectroZapped
EXTRN	?InitBombGlow@@YAJPAUobject_def@@PAJ@Z:NEAR	; InitBombGlow
;	COMDAT ??_C@_0BB@KGOOAJPL@models?2dragon2?4m?$AA@
CONST	SEGMENT
??_C@_0BB@KGOOAJPL@models?2dragon2?4m?$AA@ DB 'models\dragon2.m', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BOFCGOJO@models?2dragon3?4m?$AA@
CONST	SEGMENT
??_C@_0BB@BOFCGOJO@models?2dragon3?4m?$AA@ DB 'models\dragon3.m', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_DragonMorphFrames DD FLAT:??_C@_0BB@KGOOAJPL@models?2dragon2?4m?$AA@
	DD	FLAT:??_C@_0BB@BOFCGOJO@models?2dragon3?4m?$AA@
_DragonFireOffset DD 0c3f7199ar			; -494.2
	DD	043500000r			; 208
	DD	042c00000r			; 96
_DragonFireDir DD 0bee66666r			; -0.45
	DD	040000000r			; 2
	DD	040c00000r			; 6
?StrobeTable@@3PAUSTROBE_TABLE@@A DD 05H		; StrobeTable
	DD	0aH
	DD	044800000r			; 1024
	DB	0c0H
	DB	0c0H
	DB	00H
	ORG $+1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	05H
	DD	0aH
	DD	044800000r			; 1024
	DB	00H
	DB	00H
	DB	080H
	ORG $+1
	DD	000000000r			; 0
	DD	041400000r			; 12
	DD	000000000r			; 0
_ObjInitData DD	FLAT:?InitBarrel@@YAJPAUobject_def@@PAJ@Z
	DD	04H
	DD	FLAT:?InitBeachball@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitPlanet@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitPlane@@YAJPAUobject_def@@PAJ@Z
	DD	078H
	DD	FLAT:?InitCopter@@YAJPAUobject_def@@PAJ@Z
	DD	0d8H
	DD	FLAT:?InitDragon@@YAJPAUobject_def@@PAJ@Z
	DD	0e38H
	DD	FLAT:?InitWater@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitTrolley@@YAJPAUobject_def@@PAJ@Z
	DD	02850H
	DD	FLAT:?InitBoat@@YAJPAUobject_def@@PAJ@Z
	DD	044H
	DD	FLAT:?InitSpeedup@@YAJPAUobject_def@@PAJ@Z
	DD	0acH
	DD	FLAT:?InitRadar@@YAJPAUobject_def@@PAJ@Z
	DD	0cH
	DD	FLAT:?InitBalloon@@YAJPAUobject_def@@PAJ@Z
	DD	08H
	DD	FLAT:?InitHorse@@YAJPAUobject_def@@PAJ@Z
	DD	02cH
	DD	FLAT:?InitTrain@@YAJPAUobject_def@@PAJ@Z
	DD	048H
	DD	FLAT:?InitStrobe@@YAJPAUobject_def@@PAJ@Z
	DD	030H
	DD	FLAT:?InitFootball@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitSparkGen@@YAJPAUobject_def@@PAJ@Z
	DD	030H
	DD	FLAT:?InitSpaceman@@YAJPAUobject_def@@PAJ@Z
	DD	01H
	DD	FLAT:?InitShockwave@@YAJPAUobject_def@@PAJ@Z
	DD	030H
	DD	FLAT:?InitFirework@@YAJPAUobject_def@@PAJ@Z
	DD	01cH
	DD	FLAT:?InitPuttyBomb@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitWaterBomb@@YAJPAUobject_def@@PAJ@Z
	DD	010H
	DD	FLAT:?InitElectroPulse@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitOilSlick@@YAJPAUobject_def@@PAJ@Z
	DD	07cH
	DD	FLAT:?InitOilSlickDropper@@YAJPAUobject_def@@PAJ@Z
	DD	014H
	DD	FLAT:?InitChromeBall@@YAJPAUobject_def@@PAJ@Z
	DD	08H
	DD	FLAT:?InitClone@@YAJPAUobject_def@@PAJ@Z
	DD	01H
	DD	FLAT:?InitTurbo2@@YAJPAUobject_def@@PAJ@Z
	DD	08H
	DD	FLAT:?InitElectroZapped@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitSpring@@YAJPAUobject_def@@PAJ@Z
	DD	01H
	DD	FLAT:?InitPickup@@YAJPAUobject_def@@PAJ@Z
	DD	024H
	DD	FLAT:?InitDissolveModel@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitFlap@@YAJPAUobject_def@@PAJ@Z
	DD	00H
	DD	FLAT:?InitLaser@@YAJPAUobject_def@@PAJ@Z
	DD	038H
	DD	FLAT:?InitSplash@@YAJPAUobject_def@@PAJ@Z
	DD	03cf4H
	DD	FLAT:?InitBombGlow@@YAJPAUobject_def@@PAJ@Z
	DD	00H
_DATA	ENDS
PUBLIC	?LoadObjects@@YAXPAD@Z				; LoadObjects
PUBLIC	?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z ; CreateObject
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	__fltused:NEAR
EXTRN	?EditMode@@3JA:DWORD				; EditMode
;	COMDAT ??_C@_02JDPG@rb?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\obj_init.cpp
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadObjects@@YAXPAD@Z
_TEXT	SEGMENT
_mat$ = -100						; size = 36
_fileobj$ = -64						; size = 56
_fp$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?LoadObjects@@YAXPAD@Z PROC NEAR			; LoadObjects, COMDAT

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi

; 152  : 	long i;
; 153  : 	FILE *fp;
; 154  : 	FILE_OBJECT fileobj;
; 155  : 	MAT mat;
; 156  : 
; 157  : // quit if in object edit mode
; 158  : 
; 159  : 	if (EditMode == EDIT_OBJECTS)

	cmp	DWORD PTR ?EditMode@@3JA, 3		; EditMode
	jne	SHORT $L82825

; 160  : 		return;

	jmp	$L82820
$L82825:

; 161  : 
; 162  : // open object file
; 163  : 
; 164  : 	fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 165  : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L82827

; 166  : 		return;

	jmp	$L82820
$L82827:

; 167  : 
; 168  : // loop thru all objects
; 169  : 
; 170  : 	fread(&i, sizeof(i), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 171  : 
; 172  : 	for ( ; i ; i--)

	jmp	SHORT $L82828
$L82829:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82828:
	cmp	DWORD PTR _i$[ebp], 0
	je	$L82830

; 173  : 	{
; 174  : 
; 175  : // read file obj
; 176  : 
; 177  : 		fread(&fileobj, sizeof(fileobj), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	56					; 00000038H
	lea	ecx, DWORD PTR _fileobj$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 178  : 
; 179  : // init object
; 180  : 
; 181  : 		CopyVec(&fileobj.Up, &mat.mv[U]);

	mov	eax, DWORD PTR _fileobj$[ebp+32]
	mov	DWORD PTR _mat$[ebp+12], eax
	mov	eax, DWORD PTR _fileobj$[ebp+36]
	mov	DWORD PTR _mat$[ebp+16], eax
	mov	eax, DWORD PTR _fileobj$[ebp+40]
	mov	DWORD PTR _mat$[ebp+20], eax

; 182  : 		CopyVec(&fileobj.Look, &mat.mv[L]);

	mov	eax, DWORD PTR _fileobj$[ebp+44]
	mov	DWORD PTR _mat$[ebp+24], eax
	mov	eax, DWORD PTR _fileobj$[ebp+48]
	mov	DWORD PTR _mat$[ebp+28], eax
	mov	eax, DWORD PTR _fileobj$[ebp+52]
	mov	DWORD PTR _mat$[ebp+32], eax

; 183  : 		CrossProduct(&mat.mv[U], &mat.mv[L], &mat.mv[R]);

	fld	DWORD PTR _mat$[ebp+16]
	fmul	DWORD PTR _mat$[ebp+32]
	fld	DWORD PTR _mat$[ebp+20]
	fmul	DWORD PTR _mat$[ebp+28]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+20]
	fmul	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+12]
	fmul	DWORD PTR _mat$[ebp+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+4]
	fld	DWORD PTR _mat$[ebp+12]
	fmul	DWORD PTR _mat$[ebp+28]
	fld	DWORD PTR _mat$[ebp+16]
	fmul	DWORD PTR _mat$[ebp+24]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+8]

; 184  : 
; 185  : 		CreateObject(&fileobj.Pos, &mat, fileobj.ID, fileobj.Flag);

	lea	eax, DWORD PTR _fileobj$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _fileobj$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	lea	eax, DWORD PTR _fileobj$[ebp+20]
	push	eax
	call	?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z ; CreateObject
	add	esp, 16					; 00000010H

; 186  : 	}

	jmp	$L82829
$L82830:

; 187  : 
; 188  : // close file
; 189  : 
; 190  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L82820:

; 191  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadObjects@@YAXPAD@Z ENDP				; LoadObjects
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z@4JA ; `CreateObject'::`2'::__LINE__Var
PUBLIC	??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@ ; `string'
EXTRN	?RenderObject@@YAXPAUobject_def@@@Z:NEAR	; RenderObject
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
EXTRN	?OBJ_AllocObject@@YAPAUobject_def@@XZ:NEAR	; OBJ_AllocObject
EXTRN	?OBJ_FreeObject@@YAJPAUobject_def@@@Z:NEAR	; OBJ_FreeObject
EXTRN	?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z:NEAR	; InitBodyDefault
EXTRN	?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; SetBodyPos
;	COMDAT ??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\obj_i'
	DB	'nit.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z@4JA DD 0104H ; `CreateObject'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z
_TEXT	SEGMENT
_obj$ = -4						; size = 4
_pos$ = 8						; size = 4
_mat$ = 12						; size = 4
_ID$ = 16						; size = 4
_flags$ = 20						; size = 4
?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z PROC NEAR ; CreateObject, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 261  : 	OBJECT *obj;
; 262  : 
; 263  : // legal object?
; 264  : 
; 265  : #ifdef _N64
; 266  : 	if (ID > OBJECT_TYPE_WATER) return NULL;
; 267  : #else
; 268  : 	if (ID >= OBJECT_TYPE_MAX)

	cmp	DWORD PTR _ID$[ebp], 36			; 00000024H
	jl	SHORT $L82838

; 269  : 		return NULL;

	xor	eax, eax
	jmp	$L82836
$L82838:

; 270  : #endif
; 271  : // get object slot
; 272  : 
; 273  : 	obj = OBJ_AllocObject();

	call	?OBJ_AllocObject@@YAPAUobject_def@@XZ	; OBJ_AllocObject
	mov	DWORD PTR _obj$[ebp], eax

; 274  : 	if (!obj) return NULL;

	cmp	DWORD PTR _obj$[ebp], 0
	jne	SHORT $L82839
	xor	eax, eax
	jmp	$L82836
$L82839:

; 275  : 
; 276  : // set defaults
; 277  : 
; 278  : 	obj->flag.Draw = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	or	ecx, 1
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+580], ecx

; 279  : 	obj->flag.Move = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	or	ecx, 2
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+580], ecx

; 280  : 
; 281  : 	obj->renderflag.envmap = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 1
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 282  : 	obj->renderflag.envonly = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 283  : 	obj->renderflag.light = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 4
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 284  : 	obj->renderflag.litsimple = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 285  : 	obj->renderflag.reflect = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 286  : 	obj->renderflag.fog = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 287  : 	obj->renderflag.glare = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 288  : 	obj->renderflag.meshfx = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 289  : 
; 290  : 	obj->objref = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+592], 0

; 291  : 	obj->priority = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+572], 0

; 292  : 	obj->Type = ID;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [eax+568], ecx

; 293  : 	obj->EnvRGB = 0x808080;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+652], 8421504		; 00808080H

; 294  : 	obj->DefaultModel = -1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+656], -1

; 295  : 	obj->CollType = COLL_TYPE_NONE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 0

; 296  : 	obj->Light = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+672], 0

; 297  : 	obj->Field = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+664], 0

; 298  : #ifdef _PC
; 299  : 	obj->Sfx3D = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+680], 0

; 300  : #endif
; 301  : 
; 302  : 	obj->aihandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], 0

; 303  : 	obj->collhandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+692], 0

; 304  : 	obj->movehandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+688], 0

; 305  : 	obj->renderhandler = (RENDER_HANDLER)RenderObject;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderObject@@YAXPAUobject_def@@@Z ; RenderObject

; 306  : 	obj->freehandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+704], 0

; 307  : 
; 308  : // Set up safe default values for the body
; 309  : 
; 310  : 	InitBodyDefault(&obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?InitBodyDefault@@YAXPAUNewBodyStruct@@@Z ; InitBodyDefault
	add	esp, 4

; 311  : 
; 312  : // initialise position and orientation from mapped object
; 313  : 
; 314  : 	SetBodyPos(&obj->body, pos, mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	push	edx
	call	?SetBodyPos@@YAXPAUNewBodyStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; SetBodyPos
	add	esp, 12					; 0000000cH

; 315  : 
; 316  : // alloc required data
; 317  : 
; 318  : 	obj->Data = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+684], 0

; 319  : 	if (ObjInitData[ID].AllocSize)

	mov	eax, DWORD PTR _ID$[ebp]
	cmp	DWORD PTR _ObjInitData[eax*8+4], 0
	je	SHORT $L82841

; 320  : 	{
; 321  : 		obj->Data = malloc(ObjInitData[ID].AllocSize);

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z@4JA
	add	eax, 61					; 0000003dH
	push	eax
	mov	ecx, DWORD PTR _ID$[ebp]
	mov	edx, DWORD PTR _ObjInitData[ecx*8+4]
	push	edx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+684], eax

; 322  : 		if (!obj->Data)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+684], 0
	jne	SHORT $L82841

; 323  : 		{
; 324  : 			OBJ_FreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?OBJ_FreeObject@@YAJPAUobject_def@@@Z	; OBJ_FreeObject
	add	esp, 4

; 325  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L82836
$L82841:

; 326  : 		}
; 327  : 	}
; 328  : 
; 329  : // call setup function
; 330  : 
; 331  : 	if (ObjInitData[ID].InitFunc)

	mov	eax, DWORD PTR _ID$[ebp]
	cmp	DWORD PTR _ObjInitData[eax*8], 0
	je	SHORT $L82845

; 332  : 	{
; 333  : 		if (!ObjInitData[ID].InitFunc(obj, flags))

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ID$[ebp]
	call	DWORD PTR _ObjInitData[edx*8]
	add	esp, 8
	test	eax, eax
	jne	SHORT $L82845

; 334  : 		{
; 335  : 			OBJ_FreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?OBJ_FreeObject@@YAJPAUobject_def@@@Z	; OBJ_FreeObject
	add	esp, 4

; 336  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L82836
$L82845:

; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : // return created object
; 341  : 
; 342  : 	return obj;

	mov	eax, DWORD PTR _obj$[ebp]
$L82836:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z ENDP ; CreateObject
_TEXT	ENDS
PUBLIC	__real@47000000
EXTRN	?AI_BarrelHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_BarrelHandler
EXTRN	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z:NEAR	; LoadOneLevelModel
;	COMDAT __real@47000000
CONST	SEGMENT
__real@47000000 DD 047000000r			; 32768
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitBarrel@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_barrel$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitBarrel@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitBarrel, COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 352  : 	BARREL_OBJ *barrel = (BARREL_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _barrel$[ebp], ecx

; 353  : 
; 354  : // set render flags
; 355  : 
; 356  : 	obj->renderflag.envmap = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 357  : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 358  : 
; 359  : // set spin speed
; 360  : 
; 361  : 	barrel->SpinSpeed = (REAL)flags[0] / 32768.0f;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax]
	fdiv	DWORD PTR __real@47000000
	mov	ecx, DWORD PTR _barrel$[ebp]
	fstp	DWORD PTR [ecx]

; 362  : 
; 363  : // set ai handler
; 364  : 
; 365  : 	obj->aihandler = (AI_HANDLER)AI_BarrelHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_BarrelHandler@@YAXPAUobject_def@@@Z ; AI_BarrelHandler

; 366  : 
; 367  : // set default model
; 368  : 
; 369  : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_BARREL, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	0
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 370  : 
; 371  : // return OK
; 372  : 
; 373  : 	return TRUE;

	mov	eax, 1

; 374  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitBarrel@@YAJPAUobject_def@@PAJ@Z ENDP		; InitBarrel
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??InitFootball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba ; `InitFootball'::`2'::__LINE__Var
EXTRN	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z:NEAR	; SetMat
EXTRN	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z:NEAR ; CreateCopyCollSkin
EXTRN	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; BuildWorldSkin
EXTRN	?MOV_MoveBody@@YAXPAUobject_def@@@Z:NEAR	; MOV_MoveBody
EXTRN	?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z:NEAR ; MakeTightLocalBBox
EXTRN	?COL_BodyCollHandler@@YAXPAUobject_def@@@Z:NEAR	; COL_BodyCollHandler
;	COMDAT ?__LINE__Var@?1??InitFootball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT
?__LINE__Var@?1??InitFootball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba DD 017fH ; `InitFootball'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?InitFootball@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitFootball@@YAJPAUobject_def@@PAJ@Z PROC NEAR	; InitFootball, COMDAT

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 384  : 
; 385  : 	// set default model
; 386  : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_FOOTBALL, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	32					; 00000020H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 387  : 
; 388  : 	// set collision handler and type
; 389  : 	obj->CollType = COLL_TYPE_BODY;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 1

; 390  : 	obj->collhandler = (COLL_HANDLER)COL_BodyCollHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+692], OFFSET FLAT:?COL_BodyCollHandler@@YAXPAUobject_def@@@Z ; COL_BodyCollHandler

; 391  : 
; 392  : 	// set move handler
; 393  : 	obj->movehandler = (MOVE_HANDLER)MOV_MoveBody;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+688], OFFSET FLAT:?MOV_MoveBody@@YAXPAUobject_def@@@Z ; MOV_MoveBody

; 394  : 
; 395  : 	// Physical properties
; 396  : 	obj->body.Centre.Mass = Real(0.2f);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax], 1045220557		; 3e4ccccdH

; 397  : 	obj->body.Centre.InvMass = ONE / Real(0.2f);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+4], 1084227584		; 40a00000H

; 398  : 	SetMat(&obj->body.BodyInertia, Real(100), ZERO, ZERO, ZERO, Real(100), ZERO, ZERO, ZERO, Real(100));

	push	1120403456				; 42c80000H
	push	0
	push	0
	push	0
	push	1120403456				; 42c80000H
	push	0
	push	0
	push	0
	push	1120403456				; 42c80000H
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 399  : 	SetMat(&obj->body.BodyInvInertia, ONE / Real(100), ZERO, ZERO, ZERO, ONE / Real(100), ZERO, ZERO, ZERO, ONE / Real(100));

	push	1008981770				; 3c23d70aH
	push	0
	push	0
	push	0
	push	1008981770				; 3c23d70aH
	push	0
	push	0
	push	0
	push	1008981770				; 3c23d70aH
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 400  : 
; 401  : 	obj->body.Centre.Hardness = Real(0.6);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+172], 1058642330		; 3f19999aH

; 402  : 	obj->body.Centre.Resistance = Real(0.001);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+176], 981668463		; 3a83126fH

; 403  : 	obj->body.DefaultAngRes = Real(0.005);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+368], 1000593162		; 3ba3d70aH

; 404  : 	obj->body.AngResistance = Real(0.005);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+376], 1000593162		; 3ba3d70aH

; 405  : 	obj->body.AngResMod = Real(1.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+372], 1065353216		; 3f800000H

; 406  : 	obj->body.Centre.Grip = Real(0.005);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+180], 1000593162		; 3ba3d70aH

; 407  : 	obj->body.Centre.StaticFriction = Real(1.3);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+184], 1067869798		; 3fa66666H

; 408  : 	obj->body.Centre.KineticFriction = Real(0.8);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+188], 1061997773		; 3f4ccccdH

; 409  : 
; 410  : 	// Collision skin
; 411  : 	SetBodySphere(&obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+472], 1

; 412  : 	obj->body.CollSkin.Sphere = (SPHERE *)malloc(sizeof(SPHERE));

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitFootball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
	add	eax, 29					; 0000001dH
	push	eax
	push	16					; 00000010H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+396], eax

; 413  : 	SetVecZero(&obj->body.CollSkin.Sphere[0].Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+8], 0

; 414  : 	obj->body.CollSkin.Sphere[0].Radius = Real(30);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+12], 1106247680		; 41f00000H

; 415  : 	obj->body.CollSkin.NSpheres = 1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	WORD PTR [eax+408], 1

; 416  : 	CreateCopyCollSkin(&obj->body.CollSkin);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 380				; 0000017cH
	push	eax
	call	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z ; CreateCopyCollSkin
	add	esp, 4

; 417  : 	MakeTightLocalBBox(&obj->body.CollSkin);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 380				; 0000017cH
	push	eax
	call	?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z ; MakeTightLocalBBox
	add	esp, 4

; 418  : 	BuildWorldSkin(&obj->body.CollSkin, &obj->body.Centre.Pos, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	call	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
	add	esp, 12					; 0000000cH

; 419  : 
; 420  : 	return TRUE;

	mov	eax, 1

; 421  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitFootball@@YAJPAUobject_def@@PAJ@Z ENDP		; InitFootball
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??InitBeachball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba ; `InitBeachball'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??InitBeachball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT
?__LINE__Var@?1??InitBeachball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba DD 01adH ; `InitBeachball'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?InitBeachball@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitBeachball@@YAJPAUobject_def@@PAJ@Z PROC NEAR	; InitBeachball, COMDAT

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 430  : 
; 431  : 	// set env rgb
; 432  : 	obj->EnvRGB = 0x202000;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+652], 2105344		; 00202000H

; 433  : 
; 434  : 	// set default model
; 435  : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_BEACHBALL, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	1
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 436  : 
; 437  : 	// set collision handler and type
; 438  : 	obj->CollType = COLL_TYPE_BODY;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 1

; 439  : 	obj->collhandler = (COLL_HANDLER)COL_BodyCollHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+692], OFFSET FLAT:?COL_BodyCollHandler@@YAXPAUobject_def@@@Z ; COL_BodyCollHandler

; 440  : 
; 441  : 	// set move handler
; 442  : 	obj->movehandler = (MOVE_HANDLER)MOV_MoveBody;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+688], OFFSET FLAT:?MOV_MoveBody@@YAXPAUobject_def@@@Z ; MOV_MoveBody

; 443  : 
; 444  : 	// Physical properties
; 445  : 	obj->body.Centre.Mass = Real(0.1f);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax], 1036831949		; 3dcccccdH

; 446  : 	obj->body.Centre.InvMass = ONE / Real(0.1f);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+4], 1092616192		; 41200000H

; 447  : 	SetMat(&obj->body.BodyInertia, Real(100), ZERO, ZERO, ZERO, Real(100), ZERO, ZERO, ZERO, Real(100));

	push	1120403456				; 42c80000H
	push	0
	push	0
	push	0
	push	1120403456				; 42c80000H
	push	0
	push	0
	push	0
	push	1120403456				; 42c80000H
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 448  : 	SetMat(&obj->body.BodyInvInertia, ONE / Real(100), ZERO, ZERO, ZERO, ONE / Real(100), ZERO, ZERO, ZERO, ONE / Real(100));

	push	1008981770				; 3c23d70aH
	push	0
	push	0
	push	0
	push	1008981770				; 3c23d70aH
	push	0
	push	0
	push	0
	push	1008981770				; 3c23d70aH
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 449  : 
; 450  : 	obj->body.Centre.Hardness = Real(0.6);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+172], 1058642330		; 3f19999aH

; 451  : 	obj->body.Centre.Resistance = Real(0.005);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+176], 1000593162		; 3ba3d70aH

; 452  : 	obj->body.DefaultAngRes = Real(0.005);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+368], 1000593162		; 3ba3d70aH

; 453  : 	obj->body.AngResistance = Real(0.005);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+376], 1000593162		; 3ba3d70aH

; 454  : 	obj->body.AngResMod = Real(1.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+372], 1065353216		; 3f800000H

; 455  : 	obj->body.Centre.Grip = Real(0.005);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+180], 1000593162		; 3ba3d70aH

; 456  : 	obj->body.Centre.StaticFriction = Real(1.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+184], 1065353216		; 3f800000H

; 457  : 	obj->body.Centre.KineticFriction = Real(0.5);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+188], 1056964608		; 3f000000H

; 458  : 	obj->body.Centre.Boost = ZERO;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+196], 0

; 459  : 
; 460  : 	// Collision skin
; 461  : 	SetBodySphere(&obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+472], 1

; 462  : 	obj->body.CollSkin.Sphere = (SPHERE *)malloc(sizeof(SPHERE));

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitBeachball@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
	add	eax, 33					; 00000021H
	push	eax
	push	16					; 00000010H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+396], eax

; 463  : 	SetVecZero(&obj->body.CollSkin.Sphere[0].Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+8], 0

; 464  : 	obj->body.CollSkin.Sphere[0].Radius = Real(100);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+12], 1120403456		; 42c80000H

; 465  : 	obj->body.CollSkin.NSpheres = 1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	WORD PTR [eax+408], 1

; 466  : 	CreateCopyCollSkin(&obj->body.CollSkin);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 380				; 0000017cH
	push	eax
	call	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z ; CreateCopyCollSkin
	add	esp, 4

; 467  : 	MakeTightLocalBBox(&obj->body.CollSkin);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 380				; 0000017cH
	push	eax
	call	?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z ; MakeTightLocalBBox
	add	esp, 4

; 468  : 	BuildWorldSkin(&obj->body.CollSkin, &obj->body.Centre.Pos, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	call	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
	add	esp, 12					; 0000000cH

; 469  : 
; 470  : 	return TRUE;

	mov	eax, 1

; 471  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitBeachball@@YAJPAUobject_def@@PAJ@Z ENDP		; InitBeachball
_TEXT	ENDS
PUBLIC	__real@45800000
PUBLIC	__real@46fffe00
PUBLIC	__real@3f800000
PUBLIC	__real@3a83126f
PUBLIC	__real@3a03126f
PUBLIC	__real@3f000000
PUBLIC	__real@3e800000
PUBLIC	__real@45400000
PUBLIC	?__LINE__Var@?1??InitPlanet@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba ; `InitPlanet'::`2'::__LINE__Var
PUBLIC	??_C@_0BF@OLBPDICD@levels?2muse2?2sun?4bmp?$AA@	; `string'
EXTRN	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z:NEAR	; RotMatrixZYX
EXTRN	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z:NEAR ; RotVector
EXTRN	?AI_PlanetHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_PlanetHandler
EXTRN	_rand:NEAR
EXTRN	?AllocLight@@YAPAULIGHT@@XZ:NEAR		; AllocLight
EXTRN	?RenderPlanet@@YAXPAUobject_def@@@Z:NEAR	; RenderPlanet
EXTRN	?RenderSun@@YAXPAUobject_def@@@Z:NEAR		; RenderSun
EXTRN	?SunFacingPoly@@3UFACING_POLY@@A:BYTE		; SunFacingPoly
EXTRN	?LoadTextureClever@@YA_NPADDJJJJJ@Z:NEAR	; LoadTextureClever
EXTRN	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z:NEAR ; SetObjectVisiMask
EXTRN	?FxTextureSet@@3JA:DWORD			; FxTextureSet
;	COMDAT ?__LINE__Var@?1??InitPlanet@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT
?__LINE__Var@?1??InitPlanet@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba DD 01dfH ; `InitPlanet'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT ??_C@_0BF@OLBPDICD@levels?2muse2?2sun?4bmp?$AA@
CONST	SEGMENT
??_C@_0BF@OLBPDICD@levels?2muse2?2sun?4bmp?$AA@ DB 'levels\muse2\sun.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@3a03126f
CONST	SEGMENT
__real@3a03126f DD 03a03126fr			; 0.0005
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@45400000
CONST	SEGMENT
__real@45400000 DD 045400000r			; 3072
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitPlanet@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv360 = -156						; size = 4
tv358 = -152						; size = 4
tv352 = -152						; size = 4
tv348 = -152						; size = 4
tv129 = -152						; size = 4
_box$ = -84						; size = 24
_sun$ = -60						; size = 4
_planet$ = -56						; size = 4
_mat$ = -52						; size = 36
_vec$ = -16						; size = 12
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitPlanet@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitPlanet, COMDAT

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi

; 480  : 	long i;
; 481  : 	VEC vec;
; 482  : 	MAT mat;
; 483  : 	PLANET_OBJ *planet;
; 484  : 	SUN_OBJ *sun;
; 485  : 	BOUNDING_BOX box;
; 486  : 
; 487  : // alloc memory
; 488  : 
; 489  : 	if (flags[0] != PLANET_SUN)

	mov	eax, DWORD PTR _flags$[ebp]
	cmp	DWORD PTR [eax], 11			; 0000000bH
	je	SHORT $L82917

; 490  : 		obj->Data = malloc(sizeof(PLANET_OBJ));

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitPlanet@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
	add	eax, 11					; 0000000bH
	push	eax
	push	72					; 00000048H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+684], eax

; 491  : 	else

	jmp	SHORT $L82920
$L82917:

; 492  : 		obj->Data = malloc(sizeof(SUN_OBJ));

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitPlanet@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
	add	eax, 13					; 0000000dH
	push	eax
	push	82096					; 000140b0H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+684], eax
$L82920:

; 493  : 
; 494  : 	if (!obj->Data)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+684], 0
	jne	SHORT $L82922

; 495  : 		return FALSE;

	xor	eax, eax
	jmp	$L82910
$L82922:

; 496  : 
; 497  : 	planet = (PLANET_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _planet$[ebp], ecx

; 498  : 	sun = (SUN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _sun$[ebp], ecx

; 499  : 
; 500  : // set render flags
; 501  : 
; 502  : 	obj->renderflag.envmap = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 503  : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 504  : 
; 505  : // set me / orbit planets
; 506  : 
; 507  : 	planet->OwnPlanet = flags[0];

	mov	eax, DWORD PTR _planet$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 508  : 	planet->OrbitPlanet = flags[1];

	mov	eax, DWORD PTR _planet$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 509  : 
; 510  : // set orbit speed
; 511  : 
; 512  : 	planet->OrbitSpeed = (REAL)abs(flags[2]) / 32768.0f;

	mov	eax, DWORD PTR _flags$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jle	SHORT $L83494
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $L83495
$L83494:
	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	neg	ecx
	mov	DWORD PTR tv129[ebp], ecx
$L83495:
	fild	DWORD PTR tv129[ebp]
	fdiv	DWORD PTR __real@47000000
	mov	edx, DWORD PTR _planet$[ebp]
	fstp	DWORD PTR [edx+8]

; 513  : 
; 514  : // set spin speed
; 515  : 
; 516  : 	planet->SpinSpeed = (REAL)flags[3] / 4096.0f;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+12]
	fdiv	DWORD PTR __real@45800000
	mov	ecx, DWORD PTR _planet$[ebp]
	fstp	DWORD PTR [ecx+12]

; 517  : 
; 518  : // set ai handler
; 519  : 
; 520  : 	obj->aihandler = (AI_HANDLER)AI_PlanetHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_PlanetHandler@@YAXPAUobject_def@@@Z ; AI_PlanetHandler

; 521  : 
; 522  : // set default model?
; 523  : 
; 524  : 	if (planet->OwnPlanet != PLANET_SUN)

	mov	eax, DWORD PTR _planet$[ebp]
	cmp	DWORD PTR [eax], 11			; 0000000bH
	je	SHORT $L82928

; 525  : 	{
; 526  : 		obj->renderhandler = (RENDER_HANDLER)RenderPlanet;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderPlanet@@YAXPAUobject_def@@@Z ; RenderPlanet

; 527  : 		obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_MERCURY + planet->OwnPlanet, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	mov	edx, DWORD PTR _planet$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	push	eax
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 528  : 	}
; 529  : 
; 530  : // setup sun?
; 531  : 
; 532  : 	else

	jmp	$L82930
$L82928:

; 533  : 	{
; 534  : 		obj->renderhandler = (RENDER_HANDLER)RenderSun;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderSun@@YAXPAUobject_def@@@Z ; RenderSun

; 535  : 		obj->Light = AllocLight();

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 536  : 		if (obj->Light)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	$L82932

; 537  : 		{
; 538  : 			obj->Light->x = obj->body.Centre.Pos.v[X];

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx], eax

; 539  : 			obj->Light->y = obj->body.Centre.Pos.v[Y];

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+4], eax

; 540  : 			obj->Light->z = obj->body.Centre.Pos.v[Z];

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+8], eax

; 541  : 			obj->Light->Reach = 12000;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+12], 1178304512		; 463b8000H

; 542  : 			obj->Light->Flag = LIGHT_MOVING;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+100], 2

; 543  : 			obj->Light->Type= LIGHT_OMNINORMAL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	BYTE PTR [ecx+101], 1

; 544  : 			obj->Light->r = 256;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+88], 256			; 00000100H

; 545  : 			obj->Light->g = 256;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+92], 256			; 00000100H

; 546  : 			obj->Light->b = 256;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [ecx+96], 256			; 00000100H
$L82932:

; 547  : 		}
; 548  : 
; 549  : #ifdef _PC
; 550  : 		SunFacingPoly.Xsize = 1750;

	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A, 1155186688 ; 44dac000H

; 551  : 		SunFacingPoly.Ysize = 1750;

	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+4, 1155186688 ; 44dac000H

; 552  : 		SunFacingPoly.U = 0.0f;

	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+8, 0

; 553  : 		SunFacingPoly.V = 0.0f;

	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+12, 0

; 554  : 		SunFacingPoly.Usize = 1.0f;

	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+16, 1065353216 ; 3f800000H

; 555  : 		SunFacingPoly.Vsize = 1.0f;

	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+20, 1065353216 ; 3f800000H

; 556  : 		SunFacingPoly.Tpage = TPAGE_MISC1;

	mov	WORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+24, 30 ; 0000001eH

; 557  : 		SunFacingPoly.RGB = 0xffffff;

	mov	DWORD PTR ?SunFacingPoly@@3UFACING_POLY@@A+28, 16777215 ; 00ffffffH

; 558  : 
; 559  : 		LoadTextureClever("levels\\muse2\\sun.bmp", TPAGE_MISC1, 256, 256, 0, FxTextureSet, FALSE);

	push	0
	mov	eax, DWORD PTR ?FxTextureSet@@3JA	; FxTextureSet
	push	eax
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	push	30					; 0000001eH
	push	OFFSET FLAT:??_C@_0BF@OLBPDICD@levels?2muse2?2sun?4bmp?$AA@
	call	?LoadTextureClever@@YA_NPADDJJJJJ@Z	; LoadTextureClever
	add	esp, 28					; 0000001cH

; 560  : #endif
; 561  : 		for (i = 0 ; i < SUN_OVERLAY_NUM ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82934
$L82935:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82934:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L82936

; 562  : 		{
; 563  : 			sun->Overlay[i].Rot = frand(1.0f);

	call	_rand
	mov	DWORD PTR tv348[ebp], eax
	fild	DWORD PTR tv348[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	fstp	DWORD PTR [ecx+eax+88]

; 564  : 			sun->Overlay[i].RotVel = frand(0.001f) - 0.0005f;

	call	_rand
	mov	DWORD PTR tv352[ebp], eax
	fild	DWORD PTR tv352[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3a83126f
	fsub	DWORD PTR __real@3a03126f
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sun$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 565  : 		}

	jmp	SHORT $L82935
$L82936:

; 566  : 
; 567  : 		for (i = 0 ; i < SUN_STAR_NUM ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82939
$L82940:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82939:
	cmp	DWORD PTR _i$[ebp], 2048		; 00000800H
	jge	$L82941

; 568  : 		{
; 569  : 			SetVector(&vec, 0, 0, 6144);

	mov	DWORD PTR _vec$[ebp], 0
	mov	DWORD PTR _vec$[ebp+4], 0
	mov	DWORD PTR _vec$[ebp+8], 1170210816	; 45c00000H

; 570  : 			RotMatrixZYX(&mat, frand(0.5f) - 0.25f, frand(1.0f), 0);

	push	0
	call	_rand
	mov	DWORD PTR tv358[ebp], eax
	fild	DWORD PTR tv358[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	call	_rand
	mov	DWORD PTR tv360[ebp], eax
	fild	DWORD PTR tv360[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f000000
	fsub	DWORD PTR __real@3e800000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 571  : 			RotVector(&mat, &vec, &sun->Star[i].Pos);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _sun$[ebp]
	lea	edx, DWORD PTR [ecx+eax+168]
	push	edx
	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 572  : 			sun->Star[i].rgb = ((rand() & 127) + 128) | ((rand() & 127) + 128) << 8 | ((rand() & 127) + 128) << 16;

	call	_rand
	mov	esi, eax
	and	esi, 127				; 0000007fH
	add	esi, 128				; 00000080H
	call	_rand
	and	eax, 127				; 0000007fH
	add	eax, 128				; 00000080H
	shl	eax, 8
	or	esi, eax
	call	_rand
	and	eax, 127				; 0000007fH
	add	eax, 128				; 00000080H
	shl	eax, 16					; 00000010H
	or	esi, eax
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+eax+180], esi

; 573  : 		}

	jmp	$L82940
$L82941:

; 574  : 
; 575  : 		box.Xmin = obj->body.Centre.Pos.v[X] - 3072;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR __real@45400000
	fstp	DWORD PTR _box$[ebp]

; 576  : 		box.Xmax = obj->body.Centre.Pos.v[X] + 3072;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR __real@45400000
	fstp	DWORD PTR _box$[ebp+4]

; 577  : 		box.Ymin = obj->body.Centre.Pos.v[Y] - 3072;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR __real@45400000
	fstp	DWORD PTR _box$[ebp+8]

; 578  : 		box.Ymax = obj->body.Centre.Pos.v[Y] + 3072;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+24]
	fadd	DWORD PTR __real@45400000
	fstp	DWORD PTR _box$[ebp+12]

; 579  : 		box.Zmin = obj->body.Centre.Pos.v[Z] - 3072;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR __real@45400000
	fstp	DWORD PTR _box$[ebp+16]

; 580  : 		box.Zmax = obj->body.Centre.Pos.v[Z] + 3072;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR __real@45400000
	fstp	DWORD PTR _box$[ebp+20]

; 581  : 
; 582  : 		sun->VisiMask = SetObjectVisiMask(&box);

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	call	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z ; SetObjectVisiMask
	add	esp, 4
	mov	ecx, DWORD PTR _sun$[ebp]
	mov	DWORD PTR [ecx+82088], eax
	mov	DWORD PTR [ecx+82092], edx
$L82930:

; 583  : 	}
; 584  : 
; 585  : // return OK
; 586  : 
; 587  : 	return TRUE;

	mov	eax, 1
$L82910:

; 588  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlanet@@YAJPAUobject_def@@PAJ@Z ENDP		; InitPlanet
_TEXT	ENDS
PUBLIC	__real@46800000
PUBLIC	__real@00000000
PUBLIC	__real@44000000
EXTRN	?RotMatrixY@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixY
EXTRN	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z:NEAR	; RotMatrixZ
EXTRN	?MulMatrix@@YAXPATMatrixUnion@@00@Z:NEAR	; MulMatrix
EXTRN	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z:NEAR ; CreateSfx3D
EXTRN	?AI_PlaneHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_PlaneHandler
EXTRN	?RenderPlane@@YAXPAUobject_def@@@Z:NEAR		; RenderPlane
;	COMDAT __real@46800000
CONST	SEGMENT
__real@46800000 DD 046800000r			; 16384
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitPlane@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_plane$ = -76						; size = 4
_mat2$ = -72						; size = 36
_mat$ = -36						; size = 36
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitPlane@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitPlane, COMDAT

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 597  : 	MAT mat, mat2;
; 598  : 	PLANE_OBJ *plane = (PLANE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _plane$[ebp], ecx

; 599  : 
; 600  : // set render flags
; 601  : 
; 602  : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 603  : 
; 604  : // save pos
; 605  : 
; 606  : 	CopyVec(&obj->body.Centre.Pos, &plane->GenPos);

	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+20], edx

; 607  : 
; 608  : // set speed
; 609  : 
; 610  : 	plane->Speed = (REAL)flags[0] / 16384.0f;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax]
	fdiv	DWORD PTR __real@46800000
	mov	ecx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [ecx+8]

; 611  : 	plane->Rot = 0;

	mov	eax, DWORD PTR _plane$[ebp]
	mov	DWORD PTR [eax+4], 0

; 612  : 
; 613  : // set radius
; 614  : 
; 615  : 	SetVector(&plane->Offset, 0, 0, (REAL)flags[1]);

	mov	eax, DWORD PTR _plane$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR _plane$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [ecx+32]

; 616  : 
; 617  : // set bank
; 618  : 
; 619  : 	if (plane->Speed > 0)

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82954

; 620  : 		RotMatrixY(&mat2, 0.25f);

	push	1048576000				; 3e800000H
	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 621  : 	else

	jmp	SHORT $L82955
$L82954:

; 622  : 		RotMatrixY(&mat2, 0.75f);

	push	1061158912				; 3f400000H
	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8
$L82955:

; 623  : 
; 624  : 	RotMatrixZ(&mat, (REAL)flags[2] / 512.0f);

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+8]
	fdiv	DWORD PTR __real@44000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z	; RotMatrixZ
	add	esp, 8

; 625  : 	MulMatrix(&mat2, &mat, &plane->BankMatrix);

	mov	eax, DWORD PTR _plane$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mat2$[ebp]
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 626  : 	
; 627  : // set ai handler
; 628  : 
; 629  : 	obj->aihandler = (AI_HANDLER)AI_PlaneHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_PlaneHandler@@YAXPAUobject_def@@@Z ; AI_PlaneHandler

; 630  : 
; 631  : // set render handler
; 632  : 
; 633  : 	obj->renderhandler = (RENDER_HANDLER)RenderPlane;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderPlane@@YAXPAUobject_def@@@Z ; RenderPlane

; 634  : 
; 635  : // set default model
; 636  : 
; 637  : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_PLANE, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	13					; 0000000dH
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 638  : 
; 639  : // load propellor model
; 640  : 
; 641  : 	plane->PropModel = LoadOneLevelModel(LEVEL_MODEL_PLANE_PROPELLOR, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	14					; 0000000eH
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _plane$[ebp]
	mov	DWORD PTR [edx], eax

; 642  : 
; 643  : // create 3D sfx
; 644  : #ifdef _PC
; 645  : 	obj->Sfx3D = CreateSfx3D(SFX_TOY_PLANE, SFX_MAX_VOL, flags[0] * 100 + 11025, TRUE, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	1
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 100				; 00000064H
	add	edx, 11025				; 00002b11H
	push	edx
	push	127					; 0000007fH
	push	18					; 00000012H
	call	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ; CreateSfx3D
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+680], eax

; 646  : #endif
; 647  : // return OK
; 648  : 
; 649  : 	return TRUE;

	mov	eax, 1

; 650  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlane@@YAJPAUobject_def@@PAJ@Z ENDP		; InitPlane
_TEXT	ENDS
PUBLIC	__real@41200000
PUBLIC	__real@42480000
EXTRN	?AddLocalField@@YAPAUForceFieldStruct@@JJPAUVectorStruct@@PATMatrixUnion@@PAUBBOX@@00MM@Z:NEAR ; AddLocalField
EXTRN	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z:NEAR ; MatToQuat
EXTRN	?AI_CopterHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_CopterHandler
EXTRN	?RenderCopter@@YAXPAUobject_def@@@Z:NEAR	; RenderCopter
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitCopter@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_copter$ = -40						; size = 4
_size$ = -36						; size = 12
_bBox$ = -24						; size = 24
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitCopter@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitCopter, COMDAT

; 657  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 658  : 	BBOX	bBox = {-200, 200, -1000, 1000, -200, 200};

	mov	DWORD PTR _bBox$[ebp], -1018691584	; c3480000H
	mov	DWORD PTR _bBox$[ebp+4], 1128792064	; 43480000H
	mov	DWORD PTR _bBox$[ebp+8], -998637568	; c47a0000H
	mov	DWORD PTR _bBox$[ebp+12], 1148846080	; 447a0000H
	mov	DWORD PTR _bBox$[ebp+16], -1018691584	; c3480000H
	mov	DWORD PTR _bBox$[ebp+20], 1128792064	; 43480000H

; 659  : 	VEC	size = {200, 2000, 200};

	mov	DWORD PTR _size$[ebp], 1128792064	; 43480000H
	mov	DWORD PTR _size$[ebp+4], 1157234688	; 44fa0000H
	mov	DWORD PTR _size$[ebp+8], 1128792064	; 43480000H

; 660  : 
; 661  : 	COPTER_OBJ *copter = (COPTER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _copter$[ebp], ecx

; 662  : 
; 663  : // set render flags
; 664  : 
; 665  : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 666  : 
; 667  : // set ai handler
; 668  : 
; 669  : 	obj->aihandler = (AI_HANDLER)AI_CopterHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_CopterHandler@@YAXPAUobject_def@@@Z ; AI_CopterHandler

; 670  : 
; 671  : // set render handler
; 672  : 
; 673  : 	obj->renderhandler = (RENDER_HANDLER)RenderCopter;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderCopter@@YAXPAUobject_def@@@Z ; RenderCopter

; 674  : 
; 675  : // set default model
; 676  : 
; 677  : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_COPTER, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	15					; 0000000fH
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 678  : 
; 679  : // load extra models
; 680  : 
; 681  : 	copter->BladeModel1 = LoadOneLevelModel(LEVEL_MODEL_COPTER_BLADE1, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	16					; 00000010H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [edx], eax

; 682  : 	copter->BladeModel2 = LoadOneLevelModel(LEVEL_MODEL_COPTER_BLADE2, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	17					; 00000011H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [edx+4], eax

; 683  : 
; 684  : // create 3D sfx
; 685  : #ifdef _PC
; 686  : 	obj->Sfx3D = CreateSfx3D(SFX_TOY_COPTER, SFX_MAX_VOL, 22050, TRUE, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	1
	push	22050					; 00005622H
	push	127					; 0000007fH
	push	19					; 00000013H
	call	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ; CreateSfx3D
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+680], eax

; 687  : #endif
; 688  : 
; 689  : // set bounding box for flying around in
; 690  : 
; 691  : 	copter->FlyBox.XMin = obj->body.Centre.Pos.v[X] - (float)flags[0] * 10;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax]
	fmul	DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _obj$[ebp]
	fsubr	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+160]

; 692  : 	copter->FlyBox.XMax = obj->body.Centre.Pos.v[X] + (float)flags[0] * 10;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax]
	fmul	DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+164]

; 693  : 	copter->FlyBox.YMin = obj->body.Centre.Pos.v[Y] - (float)flags[1] * 10 - (float)flags[3] * 50;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _obj$[ebp]
	fsubr	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [edx+12]
	fmul	DWORD PTR __real@42480000
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [eax+168]

; 694  : 	copter->FlyBox.YMax = obj->body.Centre.Pos.v[Y] + (float)flags[1] * 10 - (float)flags[3] * 50;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [edx+12]
	fmul	DWORD PTR __real@42480000
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [eax+172]

; 695  : 	copter->FlyBox.ZMin = obj->body.Centre.Pos.v[Z] - (float)flags[2] * 10;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+8]
	fmul	DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _obj$[ebp]
	fsubr	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+176]

; 696  : 	copter->FlyBox.ZMax = obj->body.Centre.Pos.v[Z] + (float)flags[2] * 10;

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+8]
	fmul	DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _copter$[ebp]
	fstp	DWORD PTR [edx+180]

; 697  : 
; 698  : // set collision handler and type
; 699  : 	obj->CollType = COLL_TYPE_NONE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 0

; 700  : 	obj->collhandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+692], 0

; 701  : 
; 702  : // set motion properties of copter
; 703  : 	copter->State = COPTER_WAIT;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+104], 2

; 704  : 	copter->TurnTime = ZERO;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+156], 0

; 705  : 	copter->Acc = 100;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+212], 1120403456		; 42c80000H

; 706  : 	copter->MaxVel = 300;

	mov	eax, DWORD PTR _copter$[ebp]
	mov	DWORD PTR [eax+208], 1133903872		; 43960000H

; 707  : 
; 708  : 	obj->movehandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+688], 0

; 709  : 
; 710  : // Physical properties
; 711  : 	obj->body.Centre.Mass = ZERO;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax], 0

; 712  : 	obj->body.Centre.InvMass = ZERO;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+4], 0

; 713  : 	SetMat(&obj->body.BodyInertia, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 714  : 	SetMat(&obj->body.BodyInvInertia, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 715  : 
; 716  : 	obj->body.Centre.Hardness = Real(0.5);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+172], 1056964608		; 3f000000H

; 717  : 	obj->body.Centre.Resistance = Real(0.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+176], 0

; 718  : 	obj->body.DefaultAngRes = Real(0.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+368], 0

; 719  : 	obj->body.AngResistance = Real(0.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+376], 0

; 720  : 	obj->body.AngResMod = Real(0.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+372], 0

; 721  : 	obj->body.Centre.Grip = Real(0.01);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+180], 1008981770		; 3c23d70aH

; 722  : 	obj->body.Centre.StaticFriction = Real(1.0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+184], 1065353216		; 3f800000H

; 723  : 	obj->body.Centre.KineticFriction = Real(0.5);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+188], 1056964608		; 3f000000H

; 724  : 
; 725  : // Store initial orientation
; 726  : 	MatToQuat(&obj->body.Centre.WMatrix, &copter->InitialQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z ; MatToQuat
	add	esp, 8

; 727  : 	CopyQuat(&copter->InitialQuat, &copter->CurrentUpQuat);

	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+140], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+144], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+148], edx
	mov	eax, DWORD PTR _copter$[ebp]
	mov	ecx, DWORD PTR _copter$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+152], edx

; 728  : 
; 729  : // Collision skin
; 730  : 	/*SetBodySphere(&obj->body);
; 731  : 	obj->body.CollSkin.AllowWorldColls = FALSE;
; 732  : 	SetBBox(&obj->body.CollSkin.BBox, Real(-150), Real(150), Real(-150), Real(150), Real(-150), Real(150));
; 733  : 	obj->body.CollSkin.Radius = Real(150);*/
; 734  : 
; 735  : // Force field
; 736  : 		obj->Field = AddLocalField(
; 737  : 		obj->ObjID,
; 738  : 		FIELD_PRIORITY_MAX, 
; 739  : 		&obj->body.Centre.Pos,
; 740  : 		&obj->body.Centre.WMatrix,
; 741  : 		&bBox,
; 742  : 		&size,
; 743  : 		&obj->body.Centre.WMatrix.mv[U],
; 744  : 		500,
; 745  : 		ZERO);

	push	0
	push	1140457472				; 43fa0000H
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bBox$[ebp]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	0
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+576]
	push	eax
	call	?AddLocalField@@YAPAUForceFieldStruct@@JJPAUVectorStruct@@PATMatrixUnion@@PAUBBOX@@00MM@Z ; AddLocalField
	add	esp, 36					; 00000024H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+664], eax

; 746  : 
; 747  : // return OK
; 748  : 
; 749  : 	return TRUE;

	mov	eax, 1

; 750  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitCopter@@YAJPAUobject_def@@PAJ@Z ENDP		; InitCopter
_TEXT	ENDS
EXTRN	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z:NEAR ; RotTransVector
EXTRN	?AI_DragonHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_DragonHandler
EXTRN	?RenderDragon@@YAXPAUobject_def@@@Z:NEAR	; RenderDragon
EXTRN	?DragonFireFacingPoly@@3UFACING_POLY@@A:BYTE	; DragonFireFacingPoly
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?SetModelFrames@@YAXPAUMODEL@@PAPADJ@Z:NEAR	; SetModelFrames
EXTRN	?LevelModel@@3PAULEVEL_MODEL@@A:BYTE		; LevelModel
; Function compile flags: /Odt /ZI
;	COMDAT ?InitDragon@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_dragon$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitDragon@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitDragon, COMDAT

; 758  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 759  : 	long i;
; 760  : 	DRAGON_OBJ *dragon = (DRAGON_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _dragon$[ebp], ecx

; 761  : 
; 762  : // set render flags
; 763  : 
; 764  : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 765  : 
; 766  : // set ai handler
; 767  : 
; 768  : 	obj->aihandler = (AI_HANDLER)AI_DragonHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_DragonHandler@@YAXPAUobject_def@@@Z ; AI_DragonHandler

; 769  : 
; 770  : // set render handler
; 771  : 
; 772  : 	obj->renderhandler = (RENDER_HANDLER)RenderDragon;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderDragon@@YAXPAUobject_def@@@Z ; RenderDragon

; 773  : 
; 774  : // load body
; 775  : 
; 776  : 	dragon->BodyModel = LoadOneLevelModel(LEVEL_MODEL_DRAGON1, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	18					; 00000012H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [edx], eax

; 777  : 
; 778  : // load head models
; 779  : 
; 780  : 	dragon->HeadModel = LoadOneLevelModel(LEVEL_MODEL_DRAGON2, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	19					; 00000013H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [edx+4], eax

; 781  : 	if (dragon->HeadModel != -1)

	mov	eax, DWORD PTR _dragon$[ebp]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $L82994

; 782  : 	{
; 783  : 		SetModelFrames(&LevelModel[dragon->HeadModel].Model, DragonMorphFrames, 2);

	push	2
	push	OFFSET FLAT:_DragonMorphFrames
	mov	eax, DWORD PTR _dragon$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	add	ecx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	push	ecx
	call	?SetModelFrames@@YAXPAUMODEL@@PAPADJ@Z	; SetModelFrames
	add	esp, 12					; 0000000cH
$L82994:

; 784  : 	}
; 785  : 
; 786  : // set anim count
; 787  : 
; 788  : 	dragon->Count = 0;

	mov	eax, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [eax+12], 0

; 789  : 
; 790  : // init fire
; 791  : 
; 792  : 	for (i = 0 ; i < DRAGON_FIRE_NUM ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82995
$L82996:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82995:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	SHORT $L82997

; 793  : 	{
; 794  : 		dragon->Fire[i].Time = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 72					; 00000048H
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [ecx+eax+44], 0

; 795  : 	}

	jmp	SHORT $L82996
$L82997:

; 796  : 
; 797  : // set fire gen point, normal
; 798  : 
; 799  : 	RotTransVector(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &DragonFireOffset, &dragon->FireGenPoint);

	mov	eax, DWORD PTR _dragon$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET FLAT:_DragonFireOffset
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 800  : 	RotVector(&obj->body.Centre.WMatrix, &DragonFireDir, &dragon->FireGenDir);

	mov	eax, DWORD PTR _dragon$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET FLAT:_DragonFireDir
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 801  : 
; 802  : // setup fire facing poly
; 803  : 
; 804  : 	DragonFireFacingPoly.U = 64.0f / 256.0f;

	mov	DWORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A+8, 1048576000 ; 3e800000H

; 805  : 	DragonFireFacingPoly.V = 0.0f;

	mov	DWORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A+12, 0

; 806  : 	DragonFireFacingPoly.Usize = 64.0f / 256.0f;

	mov	DWORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A+16, 1048576000 ; 3e800000H

; 807  : 	DragonFireFacingPoly.Vsize = 64.0f / 256.0f;

	mov	DWORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A+20, 1048576000 ; 3e800000H

; 808  : 	DragonFireFacingPoly.Tpage = TPAGE_FX1;

	mov	WORD PTR ?DragonFireFacingPoly@@3UFACING_POLY@@A+24, 27 ; 0000001bH

; 809  : 
; 810  : // set fire gen time stamp
; 811  : 
; 812  : 	dragon->FireGenTime = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, DWORD PTR _dragon$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 813  : 
; 814  : // return OK
; 815  : 
; 816  : 	return TRUE;

	mov	eax, 1

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitDragon@@YAJPAUobject_def@@PAJ@Z ENDP		; InitDragon
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??InitWater@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba ; `InitWater'::`2'::__LINE__Var
PUBLIC	??_C@_0BJ@BCFGIBPO@levels?2toylite?2water?4bmp?$AA@ ; `string'
EXTRN	?AI_WaterHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_WaterHandler
;	COMDAT ?__LINE__Var@?1??InitWater@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT
?__LINE__Var@?1??InitWater@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba DD 0339H ; `InitWater'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BCFGIBPO@levels?2toylite?2water?4bmp?$AA@
CONST	SEGMENT
??_C@_0BJ@BCFGIBPO@levels?2toylite?2water?4bmp?$AA@ DB 'levels\toylite\wa'
	DB	'ter.bmp', 00H				; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitWater@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv236 = -80						; size = 4
_model$ = -12						; size = 4
_water$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitWater@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitWater, COMDAT

; 825  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 826  : 	long i;
; 827  : 	WATER_OBJ *water;
; 828  : 	MODEL *model;
; 829  : 
; 830  : // set render flags
; 831  : 
; 832  : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 833  : 	obj->renderflag.envmap = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 834  : #ifdef _N64
; 835  : 	obj->renderflag.envonly = TRUE;
; 836  : 	obj->renderflag.litsimple = FALSE;
; 837  : 	obj->renderhandler = (RENDER_HANDLER)RenderWater;
; 838  : #endif
; 839  : 
; 840  : // set ai handler
; 841  : 
; 842  : 	obj->aihandler = (AI_HANDLER)AI_WaterHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_WaterHandler@@YAXPAUobject_def@@@Z ; AI_WaterHandler

; 843  : 
; 844  : // load default model
; 845  : 
; 846  : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_WATER, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	20					; 00000014H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 847  : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83006
	xor	eax, eax
	jmp	$L83001
$L83006:

; 848  : 	model = &LevelModel[obj->DefaultModel].Model;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	add	ecx, OFFSET FLAT:?LevelModel@@3PAULEVEL_MODEL@@A+8
	mov	DWORD PTR _model$[ebp], ecx

; 849  : 
; 850  : // alloc ram
; 851  : 
; 852  : #ifdef _PC
; 853  : 	obj->Data = (WATER_OBJ*)malloc(sizeof(WATER_OBJ) + sizeof(WATER_VERTEX) * (model->VertNum - 1));

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitWater@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [ecx+34]
	sub	edx, 1
	imul	edx, 12					; 0000000cH
	add	edx, 20					; 00000014H
	push	edx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+684], eax

; 854  : #endif
; 855  : #ifdef _N64
; 856  : 	obj->Data = (WATER_OBJ*)malloc(sizeof(WATER_OBJ) + sizeof(WATER_VERTEX) * (model->hdr->vtxnum - 1));
; 857  : #endif
; 858  : 	if (!obj->Data) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+684], 0
	jne	SHORT $L83011
	xor	eax, eax
	jmp	$L83001
$L83011:

; 859  : 
; 860  : // load texture
; 861  : 
; 862  : #ifdef _PC
; 863  : 	LoadTextureClever("levels\\toylite\\water.bmp", TPAGE_MISC1, 256, 256, 0, FxTextureSet, TRUE);

	push	1
	mov	eax, DWORD PTR ?FxTextureSet@@3JA	; FxTextureSet
	push	eax
	push	0
	push	256					; 00000100H
	push	256					; 00000100H
	push	30					; 0000001eH
	push	OFFSET FLAT:??_C@_0BJ@BCFGIBPO@levels?2toylite?2water?4bmp?$AA@
	call	?LoadTextureClever@@YA_NPADDJJJJJ@Z	; LoadTextureClever
	add	esp, 28					; 0000001cH

; 864  : #endif
; 865  : 
; 866  : // setup water
; 867  : 
; 868  : 	water = (WATER_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _water$[ebp], ecx

; 869  : 	
; 870  : 	water->Scale = 5;

	mov	eax, DWORD PTR _water$[ebp]
	mov	DWORD PTR [eax+4], 1084227584		; 40a00000H

; 871  : 
; 872  : #ifdef _PC
; 873  : 	water->VertNum = model->VertNum;

	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+34]
	mov	edx, DWORD PTR _water$[ebp]
	mov	DWORD PTR [edx], ecx

; 874  : #endif
; 875  : #ifdef _N64
; 876  : 	water->VertNum = model->hdr->vtxnum;
; 877  : #endif
; 878  : 
; 879  : 	for (i = 0 ; i < water->VertNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83014
$L83015:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L83014:
	mov	eax, DWORD PTR _water$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $L83016

; 880  : 	{
; 881  : #ifdef _PC
; 882  : 		water->Vert[i].Height = model->VertPtr[i].y;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	esi, DWORD PTR _water$[ebp]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+8], edx

; 883  : #endif
; 884  : #ifdef _N64
; 885  : 		water->Vert[i].Height = model->hdr->evtxptr[i].v.ob[1];
; 886  : #endif
; 887  : 		water->Vert[i].Time = 0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _water$[ebp]
	mov	DWORD PTR [ecx+eax+12], 0

; 888  : 		water->Vert[i].TotalTime = frand(2.0f) + 1.0f;

	call	_rand
	mov	DWORD PTR tv236[ebp], eax
	fild	DWORD PTR tv236[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _water$[ebp]
	fstp	DWORD PTR [ecx+eax+16]

; 889  : 	}

	jmp	SHORT $L83015
$L83016:

; 890  : 
; 891  : // force model poly attribs
; 892  : #ifdef _PC
; 893  : 	model->QuadNumTex = 0;

	mov	eax, DWORD PTR _model$[ebp]
	mov	WORD PTR [eax+36], 0

; 894  : 	model->TriNumTex = model->PolyNum;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR _model$[ebp]
	mov	dx, WORD PTR [ecx+32]
	mov	WORD PTR [eax+38], dx

; 895  : 	model->QuadNumRGB = 0;

	mov	eax, DWORD PTR _model$[ebp]
	mov	WORD PTR [eax+40], 0

; 896  : 	model->TriNumRGB = 0;

	mov	eax, DWORD PTR _model$[ebp]
	mov	WORD PTR [eax+42], 0

; 897  : 
; 898  : 	for (i = 0 ; i < model->PolyNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83018
$L83019:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L83018:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+32]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $L83020

; 899  : 	{
; 900  : 		model->PolyPtr[i].Type = POLY_SEMITRANS;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	WORD PTR [eax+edx], 4

; 901  : 		model->PolyPtr[i].Tpage = TPAGE_MISC1;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	WORD PTR [edx+eax+2], 30		; 0000001eH

; 902  : 
; 903  : 		*(long*)&model->PolyRGB[i].rgb[0] = 0xc0808080;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+edx], -1065320320	; c0808080H

; 904  : 		*(long*)&model->PolyRGB[i].rgb[1] = 0xc0808080;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [edx+eax+4], -1065320320	; c0808080H

; 905  : 		*(long*)&model->PolyRGB[i].rgb[2] = 0xc0808080;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [edx+eax+8], -1065320320	; c0808080H

; 906  : 	}

	jmp	SHORT $L83019
$L83020:

; 907  : #endif
; 908  : // return OK
; 909  : 
; 910  : 	return TRUE;

	mov	eax, 1
$L83001:

; 911  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitWater@@YAJPAUobject_def@@PAJ@Z ENDP		; InitWater
_TEXT	ENDS
EXTRN	?InitCar@@YAXPAUCarStruct@@@Z:NEAR		; InitCar
EXTRN	?SetupCar@@YAXPAUPlayerStruct@@H@Z:NEAR		; SetupCar
EXTRN	?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; SetCarPos
EXTRN	?RenderTrolley@@YAXPAUobject_def@@@Z:NEAR	; RenderTrolley
EXTRN	?MOV_MoveCarNew@@YAXPAUobject_def@@@Z:NEAR	; MOV_MoveCarNew
EXTRN	?COL_CarCollHandler@@YAXPAUobject_def@@@Z:NEAR	; COL_CarCollHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?InitTrolley@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitTrolley@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitTrolley, COMDAT

; 921  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 922  : 
; 923  : 	obj->player = (PLAYER *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+684]
	mov	DWORD PTR [eax+588], edx

; 924  : 
; 925  : 	
; 926  : 	obj->player->car.Body = &obj->body;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+900], edx

; 927  : 	obj->player->type = PLAYER_CPU;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+4], 3

; 928  : 	obj->player->ctrltype = CTRL_TYPE_NONE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+16], 0

; 929  : 	obj->player->ownobj = obj;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 930  : 	obj->player->Slot = 0;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx], 0

; 931  : 
; 932  : 	obj->player->conhandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+24], 0

; 933  : 	obj->CollType = COLL_TYPE_CAR;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 2

; 934  : 	obj->movehandler = (MOVE_HANDLER)MOV_MoveCarNew;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+688], OFFSET FLAT:?MOV_MoveCarNew@@YAXPAUobject_def@@@Z ; MOV_MoveCarNew

; 935  : 	obj->collhandler = (COLL_HANDLER)COL_CarCollHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+692], OFFSET FLAT:?COL_CarCollHandler@@YAXPAUobject_def@@@Z ; COL_CarCollHandler

; 936  : 	obj->aihandler = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], 0

; 937  : 
; 938  : 	obj->flag.Draw = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	or	ecx, 1
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+580], ecx

; 939  : 	obj->flag.Move = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	or	ecx, 2
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+580], ecx

; 940  : 	obj->renderhandler = (RENDER_HANDLER)RenderTrolley;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderTrolley@@YAXPAUobject_def@@@Z ; RenderTrolley

; 941  : 	obj->freehandler  = (FREE_HANDLER)FreeTrolley;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+704], OFFSET FLAT:?FreeTrolley@@YAXPAUobject_def@@@Z ; FreeTrolley

; 942  : 	obj->Type = OBJECT_TYPE_TROLLEY;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+568], 7

; 943  : 	obj->Field = NULL;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+664], 0

; 944  : 
; 945  : 	InitCar(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?InitCar@@YAXPAUCarStruct@@@Z		; InitCar
	add	esp, 4

; 946  : 	SetupCar(obj->player, 28);

	push	28					; 0000001cH
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?SetupCar@@YAXPAUPlayerStruct@@H@Z	; SetupCar
	add	esp, 8

; 947  : 	SetCarPos(&obj->player->car, &obj->body.Centre.Pos, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	add	eax, 44					; 0000002cH
	push	eax
	call	?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; SetCarPos
	add	esp, 12					; 0000000cH

; 948  : 
; 949  : 	return TRUE;

	mov	eax, 1

; 950  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitTrolley@@YAJPAUobject_def@@PAJ@Z ENDP		; InitTrolley
_TEXT	ENDS
EXTRN	?FreeCar@@YAXPAUPlayerStruct@@@Z:NEAR		; FreeCar
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeTrolley@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?FreeTrolley@@YAXPAUobject_def@@@Z PROC NEAR		; FreeTrolley, COMDAT

; 953  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 954  : 	FreeCar(obj->player);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?FreeCar@@YAXPAUPlayerStruct@@@Z	; FreeCar
	add	esp, 4

; 955  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeTrolley@@YAXPAUobject_def@@@Z ENDP			; FreeTrolley
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	__real@40800000
EXTRN	?CopyMat@@YAXPATMatrixUnion@@0@Z:NEAR		; CopyMat
EXTRN	?AI_BoatHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_BoatHandler
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitBoat@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv175 = -72						; size = 4
tv172 = -72						; size = 4
tv169 = -72						; size = 4
_boat$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitBoat@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitBoat, COMDAT

; 962  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 963  : 	BOAT_OBJ *boat = (BOAT_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _boat$[ebp], ecx

; 964  : 
; 965  : // set render flags
; 966  : 
; 967  : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 968  : 	obj->EnvRGB = 0x404080;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+652], 4210816		; 00404080H

; 969  : 
; 970  : // set ai handler
; 971  : 
; 972  : 	obj->aihandler = (AI_HANDLER)AI_BoatHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_BoatHandler@@YAXPAUobject_def@@@Z ; AI_BoatHandler

; 973  : 
; 974  : // load default model
; 975  : 
; 976  : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_BOAT1 + flags[0], TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	mov	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 21					; 00000015H
	push	eax
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 977  : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83043
	xor	eax, eax
	jmp	$L83039
$L83043:

; 978  : 
; 979  : // setup boat
; 980  : 
; 981  : 	boat->Height = obj->body.Centre.Pos.v[Y];

	mov	eax, DWORD PTR _boat$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 982  : 
; 983  : 	CopyMat(&obj->body.Centre.WMatrix, &boat->Ori);

	mov	eax, DWORD PTR _boat$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 984  : 
; 985  : 	boat->TimeX = boat->TimeHeight = boat->TimeZ = 0;

	mov	eax, DWORD PTR _boat$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _boat$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _boat$[ebp]
	mov	DWORD PTR [edx+4], 0

; 986  : 
; 987  : 	boat->TotalTimeX = frand(2.0f) + 4.0f;

	call	_rand
	mov	DWORD PTR tv169[ebp], eax
	fild	DWORD PTR tv169[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@40800000
	mov	eax, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [eax+8]

; 988  : 	boat->TotalTimeHeight = frand(1.0f) + 2.0f;

	call	_rand
	mov	DWORD PTR tv172[ebp], eax
	fild	DWORD PTR tv172[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	fadd	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [eax+16]

; 989  : 	boat->TotalTimeZ = frand(2.0f) + 4.0f;

	call	_rand
	mov	DWORD PTR tv175[ebp], eax
	fild	DWORD PTR tv175[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fadd	ST(0), ST(0)
	fadd	DWORD PTR __real@40800000
	mov	eax, DWORD PTR _boat$[ebp]
	fstp	DWORD PTR [eax+24]

; 990  : 	boat->SteamTime = ZERO;

	mov	eax, DWORD PTR _boat$[ebp]
	mov	DWORD PTR [eax+28], 0

; 991  : 
; 992  : // return OK
; 993  : 
; 994  : 	return TRUE;

	mov	eax, 1
$L83039:

; 995  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitBoat@@YAJPAUobject_def@@PAJ@Z ENDP			; InitBoat
_TEXT	ENDS
EXTRN	?AI_RadarHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_RadarHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?InitRadar@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_radar$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitRadar@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitRadar, COMDAT

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1003 : 	RADAR_OBJ *radar = (RADAR_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _radar$[ebp], ecx

; 1004 : 
; 1005 : // set render flags
; 1006 : 
; 1007 : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1008 : 
; 1009 : // set ai handler
; 1010 : 
; 1011 : 	obj->aihandler = (AI_HANDLER)AI_RadarHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_RadarHandler@@YAXPAUobject_def@@@Z ; AI_RadarHandler

; 1012 : 
; 1013 : // load default model
; 1014 : 
; 1015 : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_RADAR, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	24					; 00000018H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 1016 : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83054
	xor	eax, eax
	jmp	$L83050
$L83054:

; 1017 : 
; 1018 : // setup radar
; 1019 : 
; 1020 : 	radar->Time = 0;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	DWORD PTR [eax], 0

; 1021 : 
; 1022 : 	radar->Light1 = AllocLight();

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	ecx, DWORD PTR _radar$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1023 : 	if (radar->Light1)

	mov	eax, DWORD PTR _radar$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$L83055

; 1024 : 	{
; 1025 : 		radar->Light1->x = obj->body.Centre.Pos.v[X];

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx], eax

; 1026 : 		radar->Light1->y = obj->body.Centre.Pos.v[Y];

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+4], eax

; 1027 : 		radar->Light1->z = obj->body.Centre.Pos.v[Z];

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+8], eax

; 1028 : 		radar->Light1->Reach = 2500;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+12], 1159479296		; 451c4000H

; 1029 : 		radar->Light1->Flag = LIGHT_FIXED | LIGHT_MOVING;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+100], 3

; 1030 : 		radar->Light1->Type= LIGHT_SPOTNORMAL;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+101], 3

; 1031 : 		radar->Light1->Cone = 60.0f;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+80], 1114636288		; 42700000H

; 1032 : 		radar->Light1->r = 0;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+88], 0

; 1033 : 		radar->Light1->g = 0;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+92], 0

; 1034 : 		radar->Light1->b = 512;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+96], 512			; 00000200H
$L83055:

; 1035 : 	}
; 1036 : 
; 1037 : 	radar->Light2 = AllocLight();

	call	?AllocLight@@YAPAULIGHT@@XZ		; AllocLight
	mov	ecx, DWORD PTR _radar$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1038 : 	if (radar->Light2)

	mov	eax, DWORD PTR _radar$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	$L83056

; 1039 : 	{
; 1040 : 		radar->Light2->x = obj->body.Centre.Pos.v[X];

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx], eax

; 1041 : 		radar->Light2->y = obj->body.Centre.Pos.v[Y];

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+4], eax

; 1042 : 		radar->Light2->z = obj->body.Centre.Pos.v[Z];

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+8], eax

; 1043 : 		radar->Light2->Reach = 2500;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+12], 1159479296		; 451c4000H

; 1044 : 		radar->Light2->Flag = LIGHT_FIXED | LIGHT_MOVING;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	BYTE PTR [ecx+100], 3

; 1045 : 		radar->Light2->Type= LIGHT_SPOTNORMAL;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	BYTE PTR [ecx+101], 3

; 1046 : 		radar->Light2->Cone = 60.0f;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+80], 1114636288		; 42700000H

; 1047 : 		radar->Light2->r = 512;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+88], 512			; 00000200H

; 1048 : 		radar->Light2->g = 0;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+92], 0

; 1049 : 		radar->Light2->b = 0;

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+96], 0
$L83056:

; 1050 : 	}
; 1051 : 
; 1052 : // return OK
; 1053 : 
; 1054 : 	return TRUE;

	mov	eax, 1
$L83050:

; 1055 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitRadar@@YAJPAUobject_def@@PAJ@Z ENDP		; InitRadar
_TEXT	ENDS
PUBLIC	__real@40a00000
PUBLIC	__real@42b2e410
EXTRN	?AI_SpeedupAIHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_SpeedupAIHandler
EXTRN	?RenderSpeedup@@YAXPAUobject_def@@@Z:NEAR	; RenderSpeedup
EXTRN	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z:NEAR ; AddPointToBBox
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@42b2e410
CONST	SEGMENT
__real@42b2e410 DD 042b2e410r			; 89.4454
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitSpeedup@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_collPoly$ = -24					; size = 4
_speedup$ = -20						; size = 4
_objMat$ = -16						; size = 4
_pos$ = -12						; size = 12
_object$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitSpeedup@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitSpeedup, COMDAT

; 1062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1063 : 	VEC		pos;
; 1064 : 
; 1065 : 	MAT			*objMat = &object->body.Centre.WMatrix;

	mov	eax, DWORD PTR _object$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _objMat$[ebp], eax

; 1066 : 	SPEEDUP_OBJ *speedup = (SPEEDUP_OBJ *)object->Data;

	mov	eax, DWORD PTR _object$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _speedup$[ebp], ecx

; 1067 : 	NEWCOLLPOLY *collPoly = &speedup->CollPoly;

	mov	eax, DWORD PTR _speedup$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _collPoly$[ebp], eax

; 1068 : 
; 1069 : 	// Model and rendering...
; 1070 : 	object->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_SPEEDUP, TRUE, object->renderflag, TPAGE_FX1);

	push	27					; 0000001bH
	mov	eax, DWORD PTR _object$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	23					; 00000017H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _object$[ebp]
	mov	DWORD PTR [edx+656], eax

; 1071 : 	if (object->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _object$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83066
	xor	eax, eax
	jmp	$L83060
$L83066:

; 1072 : 
; 1073 : 	// AI and handlers
; 1074 : 	object->aihandler = (AI_HANDLER)AI_SpeedupAIHandler;

	mov	eax, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_SpeedupAIHandler@@YAXPAUobject_def@@@Z ; AI_SpeedupAIHandler

; 1075 : 	object->renderhandler = (RENDER_HANDLER)RenderSpeedup;

	mov	eax, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderSpeedup@@YAXPAUobject_def@@@Z ; RenderSpeedup

; 1076 : 	object->CollType = COLL_TYPE_NONE;

	mov	eax, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+660], 0

; 1077 : 	//object->body.CollSkin.AllowWorldColls = FALSE;
; 1078 : 	//object->body.CollSkin.AllowObjectColls = FALSE:
; 1079 : 
; 1080 : 	// Other stuff
; 1081 : 	speedup->Width = 5.0f * (REAL)flags[0];

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax]
	fmul	DWORD PTR __real@40a00000
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx]

; 1082 : 	speedup->LoSpeed = MPH2OGU_SPEED * (REAL)flags[1];

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@42b2e410
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1083 : 	speedup->HiSpeed = MPH2OGU_SPEED * (REAL)flags[2];

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+8]
	fmul	DWORD PTR __real@42b2e410
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+12]

; 1084 : 	speedup->Speed = speedup->LoSpeed;

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _speedup$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+16], edx

; 1085 : 	speedup->ChangeTime = (REAL)flags[3];

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [ecx+20]

; 1086 : 	speedup->Time = ZERO;

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1087 : 	speedup->Height = 120.0f;

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	DWORD PTR [eax+4], 1123024896		; 42f00000H

; 1088 : 	SetBBox(&collPoly->BBox, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST);

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax+88], 1232348160		; 49742400H
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax+92], -915135488		; c9742400H
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax+96], 1232348160		; 49742400H
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax+100], -915135488		; c9742400H
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax+104], 1232348160		; 49742400H
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax+108], -915135488		; c9742400H

; 1089 : 
; 1090 : 	// positions of the posts
; 1091 : 	VecPlusScalarVec(&object->body.Centre.Pos, -speedup->Width, &objMat->mv[R], &speedup->PostPos[0]);

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+140]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+144]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+148]

; 1092 : 	VecPlusScalarVec(&object->body.Centre.Pos, speedup->Width, &objMat->mv[R], &speedup->PostPos[1]);

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+152]
	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+156]
	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _speedup$[ebp]
	fstp	DWORD PTR [eax+160]

; 1093 : 
; 1094 : 	// Build the collision poly
; 1095 : 	collPoly->Plane.v[A] = objMat->m[LX];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx

; 1096 : 	collPoly->Plane.v[B] = objMat->m[LY];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx

; 1097 : 	collPoly->Plane.v[C] = objMat->m[LZ];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+16], edx

; 1098 : 	collPoly->Plane.v[D] = -VecDotVec(&objMat->mv[L], &object->body.Centre.Pos);

	mov	eax, DWORD PTR _objMat$[ebp]
	mov	ecx, DWORD PTR _object$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _objMat$[ebp]
	mov	eax, DWORD PTR _object$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR _object$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [eax+20]

; 1099 : 
; 1100 : 	VecPlusScalarVec(&object->body.Centre.Pos, -speedup->Width, &objMat->mv[R], &pos);

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+20]
	fstp	DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+24]
	fstp	DWORD PTR _pos$[ebp+4]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+28]
	fstp	DWORD PTR _pos$[ebp+8]

; 1101 : 	collPoly->EdgePlane[0].v[A] = -objMat->m[RX];

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [ecx+24]

; 1102 : 	collPoly->EdgePlane[0].v[B] = -objMat->m[RY];

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [ecx+28]

; 1103 : 	collPoly->EdgePlane[0].v[C] = -objMat->m[RZ];

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [ecx+32]

; 1104 : 	collPoly->EdgePlane[0].v[D] = VecDotVec(&objMat->mv[R], &pos);

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+4]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [eax+36]

; 1105 : 	AddPointToBBox(&collPoly->BBox, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collPoly$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 1106 : 
; 1107 : 	VecPlusScalarVec(&object->body.Centre.Pos, -speedup->Height, &objMat->mv[U], &pos);

	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+20]
	fstp	DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+24]
	fstp	DWORD PTR _pos$[ebp+4]
	mov	eax, DWORD PTR _speedup$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _objMat$[ebp]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+28]
	fstp	DWORD PTR _pos$[ebp+8]

; 1108 : 	collPoly->EdgePlane[1].v[A] = -objMat->m[UX];

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [ecx+40]

; 1109 : 	collPoly->EdgePlane[1].v[B] = -objMat->m[UY];

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax+16]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [ecx+44]

; 1110 : 	collPoly->EdgePlane[1].v[C] = -objMat->m[UZ];

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax+20]
	fchs
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [ecx+48]

; 1111 : 	collPoly->EdgePlane[1].v[D] = VecDotVec(&objMat->mv[U], &pos);

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+4]
	fmul	DWORD PTR [ecx+16]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+8]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [eax+52]

; 1112 : 	AddPointToBBox(&collPoly->BBox, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collPoly$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 1113 : 
; 1114 : 	VecPlusScalarVec(&object->body.Centre.Pos, speedup->Width, &objMat->mv[R], &pos);

	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+20]
	fstp	DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+24]
	fstp	DWORD PTR _pos$[ebp+4]
	mov	eax, DWORD PTR _speedup$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _object$[ebp]
	fadd	DWORD PTR [edx+28]
	fstp	DWORD PTR _pos$[ebp+8]

; 1115 : 	collPoly->EdgePlane[2].v[A] = objMat->m[RX];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+56], edx

; 1116 : 	collPoly->EdgePlane[2].v[B] = objMat->m[RY];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+60], edx

; 1117 : 	collPoly->EdgePlane[2].v[C] = objMat->m[RZ];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+64], edx

; 1118 : 	collPoly->EdgePlane[2].v[D] = -VecDotVec(&objMat->mv[R], &pos);

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+4]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [eax+68]

; 1119 : 	AddPointToBBox(&collPoly->BBox, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collPoly$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 1120 : 
; 1121 : 	CopyVec(&object->body.Centre.Pos, &pos);

	mov	eax, DWORD PTR _object$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pos$[ebp], ecx
	mov	eax, DWORD PTR _object$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pos$[ebp+4], ecx
	mov	eax, DWORD PTR _object$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _pos$[ebp+8], ecx

; 1122 : 	collPoly->EdgePlane[3].v[A] = objMat->m[UX];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+72], edx

; 1123 : 	collPoly->EdgePlane[3].v[B] = objMat->m[UY];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+76], edx

; 1124 : 	collPoly->EdgePlane[3].v[C] = objMat->m[UZ];

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+80], edx

; 1125 : 	collPoly->EdgePlane[3].v[D] = -VecDotVec(&objMat->mv[U], &pos);

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+4]
	fmul	DWORD PTR [ecx+16]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _pos$[ebp+8]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fstp	DWORD PTR [eax+84]

; 1126 : 	AddPointToBBox(&collPoly->BBox, &pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collPoly$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 1127 : 
; 1128 : 	collPoly->Type = POLY_QUAD;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax], 1

; 1129 : 	collPoly->Material = MATERIAL_DEFAULT;

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1130 : 
; 1131 : 	return TRUE;

	mov	eax, 1
$L83060:

; 1132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSpeedup@@YAJPAUobject_def@@PAJ@Z ENDP		; InitSpeedup
_TEXT	ENDS
EXTRN	?AI_BalloonHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_BalloonHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?InitBalloon@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv94 = -72						; size = 4
_balloon$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitBalloon@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitBalloon, COMDAT

; 1140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1141 : 	BALLOON_OBJ *balloon = (BALLOON_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _balloon$[ebp], ecx

; 1142 : 
; 1143 : // set ai handler
; 1144 : 
; 1145 : 	obj->aihandler = (AI_HANDLER)AI_BalloonHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_BalloonHandler@@YAXPAUobject_def@@@Z ; AI_BalloonHandler

; 1146 : 
; 1147 : // load default model
; 1148 : 
; 1149 : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_BALLOON, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	25					; 00000019H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 1150 : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83082
	xor	eax, eax
	jmp	SHORT $L83078
$L83082:

; 1151 : 
; 1152 : // init balloon
; 1153 : 
; 1154 : 	balloon->Time = frand(1.0f);

	call	_rand
	mov	DWORD PTR tv94[ebp], eax
	fild	DWORD PTR tv94[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _balloon$[ebp]
	fstp	DWORD PTR [eax]

; 1155 : 	balloon->Height = obj->body.Centre.Pos.v[Y];

	mov	eax, DWORD PTR _balloon$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], edx

; 1156 : 
; 1157 : // return OK
; 1158 : 
; 1159 : 	return TRUE;

	mov	eax, 1
$L83078:

; 1160 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitBalloon@@YAJPAUobject_def@@PAJ@Z ENDP		; InitBalloon
_TEXT	ENDS
EXTRN	?AI_HorseRipper@@YAXPAUobject_def@@@Z:NEAR	; AI_HorseRipper
; Function compile flags: /Odt /ZI
;	COMDAT ?InitHorse@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv133 = -72						; size = 4
_horse$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitHorse@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitHorse, COMDAT

; 1167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1168 : 	HORSE_OBJ *horse = (HORSE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _horse$[ebp], ecx

; 1169 : 
; 1170 : // set render flags
; 1171 : 
; 1172 : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1173 : 
; 1174 : // set ai handler
; 1175 : 
; 1176 : 	obj->aihandler = (AI_HANDLER)AI_HorseRipper;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_HorseRipper@@YAXPAUobject_def@@@Z ; AI_HorseRipper

; 1177 : 
; 1178 : // load default model
; 1179 : 
; 1180 : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_HORSE, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	26					; 0000001aH
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 1181 : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83091
	xor	eax, eax
	jmp	SHORT $L83087
$L83091:

; 1182 : 
; 1183 : // init horse
; 1184 : 
; 1185 : 	horse->Time = frand(1.0f);

	call	_rand
	mov	DWORD PTR tv133[ebp], eax
	fild	DWORD PTR tv133[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _horse$[ebp]
	fstp	DWORD PTR [eax+4]

; 1186 : 	horse->Mat = obj->body.Centre.WMatrix;

	mov	esi, DWORD PTR _obj$[ebp]
	add	esi, 100				; 00000064H
	mov	edi, DWORD PTR _horse$[ebp]
	add	edi, 8
	mov	ecx, 9
	rep movsd

; 1187 : 	horse->CreakFlag = 0.5f;

	mov	eax, DWORD PTR _horse$[ebp]
	mov	DWORD PTR [eax], 1056964608		; 3f000000H

; 1188 : 
; 1189 : // return OK
; 1190 : 
; 1191 : 	return TRUE;

	mov	eax, 1
$L83087:

; 1192 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitHorse@@YAJPAUobject_def@@PAJ@Z ENDP		; InitHorse
_TEXT	ENDS
EXTRN	?AI_TrainHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_TrainHandler
EXTRN	?RenderTrain@@YAXPAUobject_def@@@Z:NEAR		; RenderTrain
EXTRN	?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z:NEAR ; TransCollPolys
EXTRN	?MOV_MoveTrain@@YAXPAUobject_def@@@Z:NEAR	; MOV_MoveTrain
; Function compile flags: /Odt /ZI
;	COMDAT ?InitTrain@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_train$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitTrain@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitTrain, COMDAT

; 1199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1200 : 	TRAIN_OBJ *train = (TRAIN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _train$[ebp], ecx

; 1201 : 
; 1202 : // set ai handler
; 1203 : 
; 1204 : 	obj->aihandler = (AI_HANDLER)AI_TrainHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_TrainHandler@@YAXPAUobject_def@@@Z ; AI_TrainHandler

; 1205 : 	obj->movehandler = (MOVE_HANDLER)MOV_MoveTrain;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+688], OFFSET FLAT:?MOV_MoveTrain@@YAXPAUobject_def@@@Z ; MOV_MoveTrain

; 1206 : 
; 1207 : // set render handler
; 1208 : 
; 1209 : 	obj->renderhandler = (RENDER_HANDLER)RenderTrain;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderTrain@@YAXPAUobject_def@@@Z ; RenderTrain

; 1210 : 
; 1211 : // load default model
; 1212 : 
; 1213 : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_TRAIN, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	27					; 0000001bH
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 1214 : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83102
	xor	eax, eax
	jmp	$L83096
$L83102:

; 1215 : 
; 1216 : // load wheels
; 1217 : 
; 1218 : 	train->BackWheel = LoadOneLevelModel(LEVEL_MODEL_TRAIN2, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	28					; 0000001cH
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _train$[ebp]
	mov	DWORD PTR [edx+52], eax

; 1219 : 	train->FrontWheel = LoadOneLevelModel(LEVEL_MODEL_TRAIN3, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	29					; 0000001dH
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _train$[ebp]
	mov	DWORD PTR [edx+48], eax

; 1220 : 
; 1221 : // create sfx
; 1222 : 
; 1223 : 	obj->Sfx3D = CreateSfx3D(SFX_TOY_TRAIN, SFX_MAX_VOL, 22050, TRUE, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	1
	push	22050					; 00005622H
	push	127					; 0000007fH
	push	22					; 00000016H
	call	?CreateSfx3D@@YAPAUSAMPLE_3D@@JJJJPAUVectorStruct@@@Z ; CreateSfx3D
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+680], eax

; 1224 : 
; 1225 : // init train
; 1226 : 
; 1227 : 	train->SteamTime = 0;

	mov	eax, DWORD PTR _train$[ebp]
	mov	DWORD PTR [eax+68], 0

; 1228 : 	train->WhistleFlag = TRUE;

	mov	eax, DWORD PTR _train$[ebp]
	mov	DWORD PTR [eax+56], 1

; 1229 : 
; 1230 : // init physics stuff
; 1231 : 
; 1232 : 	obj->body.Centre.Mass = ZERO;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax], 0

; 1233 : 	obj->body.Centre.InvMass = ZERO;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1234 : 	SetMat(&obj->body.BodyInertia, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 1235 : 	SetMat(&obj->body.BodyInvInertia, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z	; SetMat
	add	esp, 40					; 00000028H

; 1236 : 
; 1237 : 	SetVector(&obj->body.AngVel, 0, 0, 0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+332], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+336], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+340], 0

; 1238 : 	SetVector(&obj->body.Centre.Vel, 0, 0, -200.0f);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+40], -1018691584		; c3480000H

; 1239 : 
; 1240 : 	obj->CollType = COLL_TYPE_BODY;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+660], 1

; 1241 : 	obj->body.CollSkin.CollType = BODY_COLL_POLY;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+472], 2

; 1242 : 	obj->body.CollSkin.AllowWorldColls = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	BYTE PTR [eax+476], 0

; 1243 : 	obj->body.CollSkin.AllowObjColls = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	BYTE PTR [eax+477], 1

; 1244 : 
; 1245 : 	obj->body.CollSkin.NConvex = LevelModel[obj->DefaultModel].CollSkin.NConvex;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ax, WORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+80]
	mov	WORD PTR [edx+392], ax

; 1246 : 	obj->body.CollSkin.NSpheres = LevelModel[obj->DefaultModel].CollSkin.NSpheres;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ax, WORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+96]
	mov	WORD PTR [edx+408], ax

; 1247 : 	obj->body.CollSkin.NCollPolys = LevelModel[obj->DefaultModel].CollSkin.NCollPolys;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ax, WORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+104]
	mov	WORD PTR [edx+416], ax

; 1248 : 	obj->body.CollSkin.Convex = LevelModel[obj->DefaultModel].CollSkin.Convex;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+68]
	mov	DWORD PTR [edx+380], eax

; 1249 : 	obj->body.CollSkin.Sphere = LevelModel[obj->DefaultModel].CollSkin.Sphere;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+84]
	mov	DWORD PTR [edx+396], eax

; 1250 : 	obj->body.CollSkin.CollPoly = LevelModel[obj->DefaultModel].CollSkin.CollPoly;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+100]
	mov	DWORD PTR [edx+412], eax

; 1251 : 	CopyBBox(&LevelModel[obj->DefaultModel].CollSkin.TightBBox, &obj->body.CollSkin.TightBBox);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+108]
	mov	DWORD PTR [edx+420], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+112]
	mov	DWORD PTR [edx+424], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+116]
	mov	DWORD PTR [edx+428], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+120]
	mov	DWORD PTR [edx+432], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+124]
	mov	DWORD PTR [edx+436], eax
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+128]
	mov	DWORD PTR [edx+440], eax

; 1252 : 
; 1253 : 	SetBBox(&obj->body.CollSkin.TightBBox, -2000, 2000, -2000, 2000, -2000, 2000);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+420], -990248960		; c4fa0000H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+424], 1157234688		; 44fa0000H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+428], -990248960		; c4fa0000H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+432], 1157234688		; 44fa0000H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+436], -990248960		; c4fa0000H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+440], 1157234688		; 44fa0000H

; 1254 : 
; 1255 : 	CreateCopyCollSkin(&obj->body.CollSkin);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 380				; 0000017cH
	push	eax
	call	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z ; CreateCopyCollSkin
	add	esp, 4

; 1256 : 	BuildWorldSkin(&obj->body.CollSkin, &obj->body.Centre.Pos, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	call	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
	add	esp, 12					; 0000000cH

; 1257 : 	TransCollPolys(obj->body.CollSkin.CollPoly, obj->body.CollSkin.NCollPolys, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	movsx	edx, WORD PTR [ecx+416]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+412]
	push	ecx
	call	?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z ; TransCollPolys
	add	esp, 12					; 0000000cH

; 1258 : 
; 1259 : // return OK
; 1260 : 
; 1261 : 	return TRUE;

	mov	eax, 1
$L83096:

; 1262 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitTrain@@YAJPAUobject_def@@PAJ@Z ENDP		; InitTrain
_TEXT	ENDS
EXTRN	?AI_StrobeHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_StrobeHandler
EXTRN	?RenderStrobe@@YAXPAUobject_def@@@Z:NEAR	; RenderStrobe
; Function compile flags: /Odt /ZI
;	COMDAT ?InitStrobe@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_strobe$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitStrobe@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitStrobe, COMDAT

; 1269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1270 : 	STROBE_OBJ *strobe = (STROBE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _strobe$[ebp], ecx

; 1271 : 
; 1272 : // set render flags
; 1273 : 
; 1274 : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1275 : 	obj->renderflag.envmap = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1276 : 
; 1277 : // set ai handler
; 1278 : 
; 1279 : 	obj->aihandler = (AI_HANDLER)AI_StrobeHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_StrobeHandler@@YAXPAUobject_def@@@Z ; AI_StrobeHandler

; 1280 : 	obj->renderhandler = (RENDER_HANDLER)RenderStrobe;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderStrobe@@YAXPAUobject_def@@@Z ; RenderStrobe

; 1281 : 
; 1282 : // load default model
; 1283 : 
; 1284 : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_LIGHT1 + flags[0], TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	mov	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 30					; 0000001eH
	push	eax
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 1285 : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83111
	xor	eax, eax
	jmp	$L83106
$L83111:

; 1286 : 
; 1287 : // setup strobe
; 1288 : 
; 1289 : 	strobe->StrobeNum = flags[1];

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1290 : 	strobe->StrobeCount = flags[2];

	mov	eax, DWORD PTR _strobe$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 1291 : 
; 1292 : 	strobe->FadeUp = StrobeTable[flags[0]].FadeUp;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR ?StrobeTable@@3PAUSTROBE_TABLE@@A[ecx]
	mov	DWORD PTR [edx+8], eax

; 1293 : 	strobe->FadeDown = StrobeTable[flags[0]].FadeDown;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR ?StrobeTable@@3PAUSTROBE_TABLE@@A[ecx+4]
	mov	DWORD PTR [edx+12], eax

; 1294 : 
; 1295 : 	strobe->Range = StrobeTable[flags[0]].Range;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _strobe$[ebp]
	mov	eax, DWORD PTR ?StrobeTable@@3PAUSTROBE_TABLE@@A[ecx+8]
	mov	DWORD PTR [edx+28], eax

; 1296 : 
; 1297 : 	strobe->r = StrobeTable[flags[0]].rgb.r;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	movzx	edx, BYTE PTR ?StrobeTable@@3PAUSTROBE_TABLE@@A[ecx+14]
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	DWORD PTR [eax+16], edx

; 1298 : 	strobe->g = StrobeTable[flags[0]].rgb.g;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	movzx	edx, BYTE PTR ?StrobeTable@@3PAUSTROBE_TABLE@@A[ecx+13]
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1299 : 	strobe->b = StrobeTable[flags[0]].rgb.b;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	movzx	edx, BYTE PTR ?StrobeTable@@3PAUSTROBE_TABLE@@A[ecx+12]
	mov	eax, DWORD PTR _strobe$[ebp]
	mov	DWORD PTR [eax+24], edx

; 1300 : 
; 1301 : // setup light pos
; 1302 : 
; 1303 : 	RotTransVector(&obj->body.Centre.WMatrix, &obj->body.Centre.Pos, &StrobeTable[flags[0]].GlowOffset, &strobe->LightPos);

	mov	eax, DWORD PTR _strobe$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 28					; 0000001cH
	add	edx, OFFSET FLAT:?StrobeTable@@3PAUSTROBE_TABLE@@A+16
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1304 : 
; 1305 : // return OK
; 1306 : 
; 1307 : 	return TRUE;

	mov	eax, 1
$L83106:

; 1308 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitStrobe@@YAJPAUobject_def@@PAJ@Z ENDP		; InitStrobe
_TEXT	ENDS
EXTRN	?SparkGenHandler@@YAXPAUobject_def@@@Z:NEAR	; SparkGenHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?InitSparkGen@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv183 = -72						; size = 4
tv178 = -72						; size = 4
tv173 = -72						; size = 4
tv168 = -72						; size = 4
_sparkGen$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitSparkGen@@YAJPAUobject_def@@PAJ@Z PROC NEAR	; InitSparkGen, COMDAT

; 1318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1319 : 	SPARK_GEN *sparkGen = (SPARK_GEN *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _sparkGen$[ebp], ecx

; 1320 : 
; 1321 : 	obj->aihandler = (AI_HANDLER)SparkGenHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?SparkGenHandler@@YAXPAUobject_def@@@Z ; SparkGenHandler

; 1322 : 
; 1323 : 	sparkGen->Type = (enum SparkTypeEnum)flags[0];

	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1324 : 	sparkGen->Parent = NULL;

	mov	eax, DWORD PTR _sparkGen$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1325 : 	VecEqScalarVec(&sparkGen->SparkVel, (REAL)(flags[1] * 10), &obj->body.Centre.WMatrix.mv[L]);

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR tv168[ebp], ecx
	fild	DWORD PTR tv168[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [edx+124]
	mov	eax, DWORD PTR _sparkGen$[ebp]
	fstp	DWORD PTR [eax+20]
	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR tv173[ebp], ecx
	fild	DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [edx+128]
	mov	eax, DWORD PTR _sparkGen$[ebp]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR tv178[ebp], ecx
	fild	DWORD PTR tv178[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [edx+132]
	mov	eax, DWORD PTR _sparkGen$[ebp]
	fstp	DWORD PTR [eax+28]

; 1326 : 	sparkGen->SparkVelVar = REAL(flags[2] * 10);

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR tv183[ebp], ecx
	fild	DWORD PTR tv183[ebp]
	mov	edx, DWORD PTR _sparkGen$[ebp]
	fstp	DWORD PTR [edx+32]

; 1327 : 	sparkGen->MaxTime = Real(5) / Real(flags[3]);

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+12]
	fmul	DWORD PTR __real@3f800000
	fdivr	DWORD PTR __real@40a00000
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	fstp	DWORD PTR [ecx+40]

; 1328 : 	AddPointToBBox(&obj->body.CollSkin.BBox, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 444				; 000001bcH
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 1329 : 	sparkGen->VisiMask = SetObjectVisiMask((BOUNDING_BOX *)&obj->body.CollSkin.BBox);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 444				; 000001bcH
	push	eax
	call	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z ; SetObjectVisiMask
	add	esp, 4
	mov	ecx, DWORD PTR _sparkGen$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], edx

; 1330 : 
; 1331 : 	return TRUE;

	mov	eax, 1

; 1332 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSparkGen@@YAJPAUobject_def@@PAJ@Z ENDP		; InitSparkGen
_TEXT	ENDS
EXTRN	?AI_SpacemanHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_SpacemanHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?InitSpaceman@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_spaceman$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitSpaceman@@YAJPAUobject_def@@PAJ@Z PROC NEAR	; InitSpaceman, COMDAT

; 1339 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1340 : 	SPACEMAN_OBJ *spaceman = (SPACEMAN_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _spaceman$[ebp], ecx

; 1341 : 
; 1342 : // set render flags
; 1343 : 
; 1344 : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1345 : 
; 1346 : // set ai handler
; 1347 : 
; 1348 : 	obj->aihandler = (AI_HANDLER)AI_SpacemanHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_SpacemanHandler@@YAXPAUobject_def@@@Z ; AI_SpacemanHandler

; 1349 : 
; 1350 : // load default model
; 1351 : 
; 1352 : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_SPACEMAN, TRUE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	1
	push	33					; 00000021H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 1353 : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83133
	xor	eax, eax
	jmp	SHORT $L83129
$L83133:

; 1354 : 
; 1355 : // return OK
; 1356 : 
; 1357 : 	return TRUE;

	mov	eax, 1
$L83129:

; 1358 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSpaceman@@YAJPAUobject_def@@PAJ@Z ENDP		; InitSpaceman
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??InitPickup@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba ; `InitPickup'::`2'::__LINE__Var
EXTRN	?AI_PickupHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_PickupHandler
EXTRN	?RenderPickup@@YAXPAUobject_def@@@Z:NEAR	; RenderPickup
;	COMDAT ?__LINE__Var@?1??InitPickup@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT
?__LINE__Var@?1??InitPickup@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba DD 0555H ; `InitPickup'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?InitPickup@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_pickup$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitPickup@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitPickup, COMDAT

; 1365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1366 : 	PICKUP_OBJ *pickup = (PICKUP_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _pickup$[ebp], ecx

; 1367 : 
; 1368 : // set render flags
; 1369 : 
; 1370 : 	obj->renderflag.light = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1371 : 	obj->renderflag.glare = TRUE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1372 : 
; 1373 : // set handlers
; 1374 : 
; 1375 : 	obj->aihandler = (AI_HANDLER)AI_PickupHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_PickupHandler@@YAXPAUobject_def@@@Z ; AI_PickupHandler

; 1376 : 	obj->renderhandler = (RENDER_HANDLER)RenderPickup;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderPickup@@YAXPAUobject_def@@@Z ; RenderPickup

; 1377 : 
; 1378 : // set default model
; 1379 : 
; 1380 : 	obj->DefaultModel = LoadOneLevelModel(LEVEL_MODEL_PICKUP, FALSE, obj->renderflag, 0);

	push	0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	push	0
	push	34					; 00000022H
	call	?LoadOneLevelModel@@YAJJJUrenderflags@@J@Z ; LoadOneLevelModel
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+656], eax

; 1381 : 	if (obj->DefaultModel == -1) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+656], -1
	jne	SHORT $L83142
	xor	eax, eax
	jmp	$L83137
$L83142:

; 1382 : 
; 1383 : // setup pickup
; 1384 : 
; 1385 : 	pickup->Mode = 0;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax], 0

; 1386 : 	pickup->Timer = 1;

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	DWORD PTR [eax+8], 1065353216		; 3f800000H

; 1387 : 
; 1388 : 	CopyVec(&obj->body.Centre.Pos, &pickup->Pos);

	mov	eax, DWORD PTR _pickup$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _pickup$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _pickup$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+20], edx

; 1389 : 
; 1390 : // setup collision info
; 1391 : 
; 1392 : 	SetBodySphere(&obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+472], 1

; 1393 : 	obj->body.CollSkin.Sphere = (SPHERE *)malloc(sizeof(SPHERE));

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitPickup@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
	add	eax, 28					; 0000001cH
	push	eax
	push	16					; 00000010H
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [ecx+396], eax

; 1394 : 	SetVecZero(&obj->body.CollSkin.Sphere[0].Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [ecx+8], 0

; 1395 : 	obj->body.CollSkin.Sphere[0].Radius = LevelModel[obj->DefaultModel].Model.Radius;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+396]
	mov	ecx, DWORD PTR ?LevelModel@@3PAULEVEL_MODEL@@A[ecx+8]
	mov	DWORD PTR [eax+12], ecx

; 1396 : 	obj->body.CollSkin.NSpheres = 1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	WORD PTR [eax+408], 1

; 1397 : 	CreateCopyCollSkin(&obj->body.CollSkin);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 380				; 0000017cH
	push	eax
	call	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z ; CreateCopyCollSkin
	add	esp, 4

; 1398 : 	MakeTightLocalBBox(&obj->body.CollSkin);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 380				; 0000017cH
	push	eax
	call	?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z ; MakeTightLocalBBox
	add	esp, 4

; 1399 : 	BuildWorldSkin(&obj->body.CollSkin, &obj->body.Centre.Pos, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	call	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
	add	esp, 12					; 0000000cH

; 1400 : 
; 1401 : 	SetVector(&obj->body.AngVel, 0, 0, 0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+332], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+336], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+340], 0

; 1402 : 	SetVector(&obj->body.Centre.Vel, 0, 0, 0);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+40], 0

; 1403 : 
; 1404 : // return OK
; 1405 : 
; 1406 : 	return TRUE;

	mov	eax, 1
$L83137:

; 1407 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPickup@@YAJPAUobject_def@@PAJ@Z ENDP		; InitPickup
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?__LINE__Var@?1??InitDissolveModel@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba ; `InitDissolveModel'::`2'::__LINE__Var
PUBLIC	__real@43800000
PUBLIC	__real@4b000000
PUBLIC	__real@42c00000
PUBLIC	__real@43400000
EXTRN	?CopyMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; CopyMatrix
EXTRN	?Identity@@3TMatrixUnion@@A:BYTE		; Identity
EXTRN	?AI_DissolveModelHandler@@YAXPAUobject_def@@@Z:NEAR ; AI_DissolveModelHandler
EXTRN	?RenderDissolveModel@@YAXPAUobject_def@@@Z:NEAR	; RenderDissolveModel
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
;	COMDAT ?__LINE__Var@?1??InitDissolveModel@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
_DATA	SEGMENT
?__LINE__Var@?1??InitDissolveModel@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba DD 0586H ; `InitDissolveModel'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
CONST	ENDS
;	COMDAT __real@42c00000
CONST	SEGMENT
__real@42c00000 DD 042c00000r			; 96
CONST	ENDS
;	COMDAT __real@43400000
CONST	SEGMENT
__real@43400000 DD 043400000r			; 192
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitDissolveModel@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv1870 = -692						; size = 4
tv1867 = -692						; size = 4
tv1864 = -692						; size = 4
tv1861 = -692						; size = 4
tv1858 = -692						; size = 4
tv1855 = -692						; size = 4
tv1244 = -692						; size = 4
__mul$83266 = -624					; size = 4
__mul$83243 = -620					; size = 4
__mul$83207 = -616					; size = 4
__temp$83204 = -612					; size = 4
_centre$ = -608						; size = 12
_uv$ = -596						; size = 32
_cuv$ = -564						; size = 8
_time$ = -556						; size = 4
_uvsource$ = -552					; size = 4
_vert$ = -548						; size = 352
_cvert$ = -196						; size = 88
_mvdest$ = -108						; size = 4
_mvsource$ = -104					; size = 4
_rgb$ = -100						; size = 16
_crgb$ = -84						; size = 4
_mrgbdest$ = -80					; size = 4
_mrgbsource$ = -76					; size = 4
_mpdest$ = -72						; size = 4
_mpsource$ = -68					; size = 4
_particle$ = -64					; size = 4
_dissolve$ = -60					; size = 4
_model$ = -56						; size = 4
_lrgb$ = -52						; size = 16
_ltime$ = -36						; size = 4
_vcount$ = -32						; size = 4
_mem$ = -28						; size = 4
_vertnum$ = -24						; size = 4
_polynum$ = -20						; size = 4
_l$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitDissolveModel@@YAJPAUobject_def@@PAJ@Z PROC NEAR	; InitDissolveModel, COMDAT

; 1414 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 692				; 000002b4H
	push	ebx
	push	esi
	push	edi

; 1415 : 	long i, j, k, l, polynum, vertnum, mem, vcount, ltime, lrgb[4];
; 1416 : 	MODEL *model = (MODEL*)flags[0];

	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _model$[ebp], ecx

; 1417 : 	DISSOLVE_OBJ *dissolve;
; 1418 : 	DISSOLVE_PARTICLE *particle;
; 1419 : 	MODEL_POLY *mpsource, *mpdest;
; 1420 : 	POLY_RGB *mrgbsource, *mrgbdest;
; 1421 : 	MODEL_RGB crgb, rgb[4];
; 1422 : 	MODEL_VERTEX **mvsource, *mvdest, cvert, vert[4];
; 1423 : 	REAL *uvsource, time, cuv[2], uv[8];
; 1424 : 	VEC centre;
; 1425 : 
; 1426 : // get mem needed
; 1427 : 
; 1428 : 	polynum = (model->QuadNumTex + model->QuadNumRGB) * 4 + (model->TriNumTex + model->TriNumRGB) * 3;

	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	mov	edx, DWORD PTR _model$[ebp]
	movsx	eax, WORD PTR [edx+40]
	add	ecx, eax
	mov	edx, DWORD PTR _model$[ebp]
	movsx	eax, WORD PTR [edx+38]
	mov	edx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [edx+42]
	add	eax, edx
	imul	eax, 3
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _polynum$[ebp], eax

; 1429 : 	vertnum = (model->QuadNumTex + model->QuadNumRGB) * 16 + (model->TriNumTex + model->TriNumRGB) * 12;

	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	mov	edx, DWORD PTR _model$[ebp]
	movsx	eax, WORD PTR [edx+40]
	add	ecx, eax
	shl	ecx, 4
	mov	edx, DWORD PTR _model$[ebp]
	movsx	eax, WORD PTR [edx+38]
	mov	edx, DWORD PTR _model$[ebp]
	movsx	edx, WORD PTR [edx+42]
	add	eax, edx
	imul	eax, 12					; 0000000cH
	add	ecx, eax
	mov	DWORD PTR _vertnum$[ebp], ecx

; 1430 : 
; 1431 : 	mem = sizeof(DISSOLVE_OBJ);

	mov	DWORD PTR _mem$[ebp], 68		; 00000044H

; 1432 : 	mem += sizeof(MODEL_POLY) * polynum;

	mov	eax, DWORD PTR _polynum$[ebp]
	imul	eax, 52					; 00000034H
	add	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR _mem$[ebp], eax

; 1433 : 	mem += sizeof(POLY_RGB) * polynum;

	mov	eax, DWORD PTR _polynum$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR _mem$[ebp], eax

; 1434 : 	mem += sizeof(MODEL_VERTEX) * vertnum;

	mov	eax, DWORD PTR _vertnum$[ebp]
	imul	eax, 88					; 00000058H
	add	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR _mem$[ebp], eax

; 1435 : 
; 1436 : 	mem += sizeof(DISSOLVE_PARTICLE) * polynum;

	mov	eax, DWORD PTR _polynum$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR _mem$[ebp], eax

; 1437 : 
; 1438 : 	obj->Data = malloc(mem);

	push	OFFSET FLAT:??_C@_0IN@CLCJMJBN@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??InitDissolveModel@@YAJPAUobject_def@@PAJ@Z@4JA@9d938fba
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+684], eax

; 1439 : 	if (!obj->Data) return FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+684], 0
	jne	SHORT $L83185
	xor	eax, eax
	jmp	$L83149
$L83185:

; 1440 : 	dissolve = (DISSOLVE_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _dissolve$[ebp], ecx

; 1441 : 
; 1442 : // setup copy model
; 1443 : 
; 1444 : 	memcpy(&dissolve->Model, model, sizeof(MODEL));

	push	60					; 0000003cH
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dissolve$[ebp]
	add	ecx, 4
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1445 : 
; 1446 : 	dissolve->Model.PolyNum = (short)polynum;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	cx, WORD PTR _polynum$[ebp]
	mov	WORD PTR [eax+36], cx

; 1447 : 	dissolve->Model.VertNum = (short)vertnum;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	cx, WORD PTR _vertnum$[ebp]
	mov	WORD PTR [eax+38], cx

; 1448 : 
; 1449 : 	dissolve->Model.QuadNumTex = model->QuadNumTex * 4 + model->TriNumTex * 3;

	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	mov	edx, DWORD PTR _model$[ebp]
	movsx	eax, WORD PTR [edx+38]
	imul	eax, 3
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _dissolve$[ebp]
	mov	WORD PTR [edx+40], cx

; 1450 : 	dissolve->Model.QuadNumRGB = model->QuadNumRGB * 4 + model->TriNumRGB * 3;

	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	mov	edx, DWORD PTR _model$[ebp]
	movsx	eax, WORD PTR [edx+42]
	imul	eax, 3
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _dissolve$[ebp]
	mov	WORD PTR [edx+44], cx

; 1451 : 	dissolve->Model.TriNumTex = 0;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	WORD PTR [eax+42], 0

; 1452 : 	dissolve->Model.TriNumRGB = 0;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	WORD PTR [eax+46], 0

; 1453 : 
; 1454 : 	dissolve->Model.PolyPtr = (MODEL_POLY*)(dissolve + 1);

	mov	eax, DWORD PTR _dissolve$[ebp]
	add	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _dissolve$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 1455 : 	dissolve->Model.PolyRGB = (POLY_RGB*)(dissolve->Model.PolyPtr + dissolve->Model.PolyNum);

	mov	eax, DWORD PTR _dissolve$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _dissolve$[ebp]
	add	ecx, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1456 : 	dissolve->Model.VertPtr = (MODEL_VERTEX*)(dissolve->Model.PolyRGB + dissolve->Model.PolyNum);

	mov	eax, DWORD PTR _dissolve$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	shl	ecx, 4
	mov	edx, DWORD PTR _dissolve$[ebp]
	add	ecx, DWORD PTR [edx+48]
	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 1457 : 
; 1458 : // create new polys + verts - quads then tri's
; 1459 : 
; 1460 : 	mpdest = dissolve->Model.PolyPtr;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _mpdest$[ebp], ecx

; 1461 : 	mrgbdest = dissolve->Model.PolyRGB;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _mrgbdest$[ebp], ecx

; 1462 : 	mvdest = dissolve->Model.VertPtr;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1463 : 
; 1464 : 	for (l = 0 ; l < 2 ; l++)

	mov	DWORD PTR _l$[ebp], 0
	jmp	SHORT $L83193
$L83194:
	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax
$L83193:
	cmp	DWORD PTR _l$[ebp], 2
	jge	$L83195

; 1465 : 	{
; 1466 : 		mpsource = model->PolyPtr;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _mpsource$[ebp], ecx

; 1467 : 		mrgbsource = model->PolyRGB;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _mrgbsource$[ebp], ecx

; 1468 : 
; 1469 : 		for (i = 0 ; i < model->PolyNum ; i++, mpsource++, mrgbsource++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83196
$L83197:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mpsource$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _mpsource$[ebp], ecx
	mov	edx, DWORD PTR _mrgbsource$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _mrgbsource$[ebp], edx
$L83196:
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, WORD PTR [eax+32]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$L83198

; 1470 : 		{
; 1471 : 			if ((l + (mpsource->Type & POLY_QUAD)) != 1) continue;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	add	ecx, DWORD PTR _l$[ebp]
	cmp	ecx, 1
	je	SHORT $L83199
	jmp	SHORT $L83197
$L83199:

; 1472 : 
; 1473 : 			vcount = 3 + (mpsource->Type & POLY_QUAD);

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	add	ecx, 3
	mov	DWORD PTR _vcount$[ebp], ecx

; 1474 : 			mvsource = &mpsource->v0;

	mov	eax, DWORD PTR _mpsource$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _mvsource$[ebp], eax

; 1475 : 			uvsource = &mpsource->tu0;

	mov	eax, DWORD PTR _mpsource$[ebp]
	add	eax, 4
	mov	DWORD PTR _uvsource$[ebp], eax

; 1476 : 
; 1477 : // get new points on poly
; 1478 : 
; 1479 : 			ZeroMemory(&cvert, sizeof(cvert));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _cvert$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1480 : 			cuv[0] = cuv[1] = 0.0f;

	mov	DWORD PTR _cuv$[ebp+4], 0
	mov	eax, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR _cuv$[ebp], eax

; 1481 : 			lrgb[0] = lrgb[1] = lrgb[2] = lrgb[3] = 0;

	mov	DWORD PTR _lrgb$[ebp+12], 0
	mov	eax, DWORD PTR _lrgb$[ebp+12]
	mov	DWORD PTR _lrgb$[ebp+8], eax
	mov	ecx, DWORD PTR _lrgb$[ebp+8]
	mov	DWORD PTR _lrgb$[ebp+4], ecx
	mov	edx, DWORD PTR _lrgb$[ebp+4]
	mov	DWORD PTR _lrgb$[ebp], edx

; 1482 : 
; 1483 : 			for (j = 0 ; j < vcount ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L83200
$L83201:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L83200:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _vcount$[ebp]
	jge	$L83202

; 1484 : 			{
; 1485 : 				k = (j + 1) % vcount;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	cdq
	idiv	DWORD PTR _vcount$[ebp]
	mov	DWORD PTR _k$[ebp], edx

; 1486 : 				time = frand(0.5f) + 0.25f;

	call	_rand
	mov	DWORD PTR tv1244[ebp], eax
	fild	DWORD PTR tv1244[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f000000
	fadd	DWORD PTR __real@3e800000
	fstp	DWORD PTR _time$[ebp]

; 1487 : 				FTOL(time * 256.0f, ltime);

	fld	DWORD PTR _time$[ebp]
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$83204[ebp]
	mov	eax, DWORD PTR __temp$83204[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _ltime$[ebp], eax

; 1488 : 
; 1489 : // get edge point
; 1490 : 
; 1491 : 				vert[j].x = mvsource[j]->x + (mvsource[k]->x - mvsource[j]->x) * time;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mvsource$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fmul	DWORD PTR _time$[ebp]
	fadd	DWORD PTR [edx]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+edx]

; 1492 : 				vert[j].y = mvsource[j]->y + (mvsource[k]->y - mvsource[j]->y) * time;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mvsource$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fmul	DWORD PTR _time$[ebp]
	fadd	DWORD PTR [edx+4]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+edx+4]

; 1493 : 				vert[j].z = mvsource[j]->z + (mvsource[k]->z - mvsource[j]->z) * time;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mvsource$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fmul	DWORD PTR _time$[ebp]
	fadd	DWORD PTR [edx+8]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+edx+8]

; 1494 : 
; 1495 : 				vert[j].nx = mvsource[j]->nx + (mvsource[k]->nx - mvsource[j]->nx) * time;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mvsource$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+24]
	fmul	DWORD PTR _time$[ebp]
	fadd	DWORD PTR [edx+24]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+edx+24]

; 1496 : 				vert[j].ny = mvsource[j]->ny + (mvsource[k]->ny - mvsource[j]->ny) * time;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mvsource$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR [ecx+28]
	fmul	DWORD PTR _time$[ebp]
	fadd	DWORD PTR [edx+28]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+edx+28]

; 1497 : 				vert[j].nz = mvsource[j]->nz + (mvsource[k]->nz - mvsource[j]->nz) * time;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mvsource$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	fld	DWORD PTR [eax+32]
	fsub	DWORD PTR [ecx+32]
	fmul	DWORD PTR _time$[ebp]
	fadd	DWORD PTR [edx+32]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+edx+32]

; 1498 : 				NormalizeVector((VEC*)&vert[j].nx);

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	fld	DWORD PTR _vert$[ebp+eax+24]
	fmul	DWORD PTR _vert$[ebp+ecx+24]
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 88					; 00000058H
	fld	DWORD PTR _vert$[ebp+edx+28]
	fmul	DWORD PTR _vert$[ebp+eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 88					; 00000058H
	fld	DWORD PTR _vert$[ebp+ecx+32]
	fmul	DWORD PTR _vert$[ebp+edx+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$83207[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 88					; 00000058H
	fld	DWORD PTR __mul$83207[ebp]
	fmul	DWORD PTR _vert$[ebp+eax+24]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+ecx+24]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 88					; 00000058H
	fld	DWORD PTR __mul$83207[ebp]
	fmul	DWORD PTR _vert$[ebp+eax+28]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+ecx+28]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 88					; 00000058H
	fld	DWORD PTR __mul$83207[ebp]
	fmul	DWORD PTR _vert$[ebp+eax+32]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 88					; 00000058H
	fstp	DWORD PTR _vert$[ebp+ecx+32]

; 1499 : 
; 1500 : 				uv[j * 2] = uvsource[j * 2] + (uvsource[k * 2] - uvsource[j * 2]) * time;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _k$[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 1
	mov	esi, DWORD PTR _uvsource$[ebp]
	mov	edi, DWORD PTR _uvsource$[ebp]
	fld	DWORD PTR [esi+ecx*4]
	fsub	DWORD PTR [edi+edx*4]
	fmul	DWORD PTR _time$[ebp]
	mov	ecx, DWORD PTR _uvsource$[ebp]
	fadd	DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 1
	fstp	DWORD PTR _uv$[ebp+edx*4]

; 1501 : 				uv[j * 2 + 1] = uvsource[j * 2 + 1] + (uvsource[k * 2 + 1] - uvsource[j * 2] + 1) * time;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _k$[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 1
	mov	esi, DWORD PTR _uvsource$[ebp]
	mov	edi, DWORD PTR _uvsource$[ebp]
	fld	DWORD PTR [esi+ecx*4+4]
	fsub	DWORD PTR [edi+edx*4]
	fadd	DWORD PTR __real@3f800000
	fmul	DWORD PTR _time$[ebp]
	mov	ecx, DWORD PTR _uvsource$[ebp]
	fadd	DWORD PTR [ecx+eax*4+4]
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 1
	fstp	DWORD PTR _uv$[ebp+edx*4+4]

; 1502 : 
; 1503 : 				rgb[j].r = mrgbsource->rgb[j].r + (unsigned char)(((mrgbsource->rgb[k].r - mrgbsource->rgb[j].r) * ltime) >> 8);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+2]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	eax, BYTE PTR [ecx+eax*4+2]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mrgbsource$[ebp]
	movzx	ecx, BYTE PTR [esi+ecx*4+2]
	sub	eax, ecx
	imul	eax, DWORD PTR _ltime$[ebp]
	sar	eax, 8
	movzx	eax, al
	add	edx, eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _rgb$[ebp+ecx*4+2], dl

; 1504 : 				rgb[j].g = mrgbsource->rgb[j].g + (unsigned char)(((mrgbsource->rgb[k].g - mrgbsource->rgb[j].g) * ltime) >> 8);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+1]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	eax, BYTE PTR [ecx+eax*4+1]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mrgbsource$[ebp]
	movzx	ecx, BYTE PTR [esi+ecx*4+1]
	sub	eax, ecx
	imul	eax, DWORD PTR _ltime$[ebp]
	sar	eax, 8
	movzx	eax, al
	add	edx, eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _rgb$[ebp+ecx*4+1], dl

; 1505 : 				rgb[j].b = mrgbsource->rgb[j].b + (unsigned char)(((mrgbsource->rgb[k].b - mrgbsource->rgb[j].b) * ltime) >> 8);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	eax, BYTE PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mrgbsource$[ebp]
	movzx	ecx, BYTE PTR [esi+ecx*4]
	sub	eax, ecx
	imul	eax, DWORD PTR _ltime$[ebp]
	sar	eax, 8
	movzx	eax, al
	add	edx, eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _rgb$[ebp+ecx*4], dl

; 1506 : 				rgb[j].a = mrgbsource->rgb[j].a + (unsigned char)(((mrgbsource->rgb[k].b - mrgbsource->rgb[j].b) * ltime) >> 8);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+3]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	eax, BYTE PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _mrgbsource$[ebp]
	movzx	ecx, BYTE PTR [esi+ecx*4]
	sub	eax, ecx
	imul	eax, DWORD PTR _ltime$[ebp]
	sar	eax, 8
	movzx	eax, al
	add	edx, eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _rgb$[ebp+ecx*4+3], dl

; 1507 : 
; 1508 : // add to centre point
; 1509 : 
; 1510 : 				AddVector((VEC*)&cvert.x, (VEC*)&mvsource[j]->x, (VEC*)&cvert.x);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	DWORD PTR _cvert$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR _cvert$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	DWORD PTR _cvert$[ebp+4]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR _cvert$[ebp+4]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	DWORD PTR _cvert$[ebp+8]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR _cvert$[ebp+8]

; 1511 : 				AddVector((VEC*)&cvert.nx, (VEC*)&mvsource[j]->nx, (VEC*)&cvert.nx);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	DWORD PTR _cvert$[ebp+24]
	fadd	DWORD PTR [edx+24]
	fstp	DWORD PTR _cvert$[ebp+24]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	DWORD PTR _cvert$[ebp+28]
	fadd	DWORD PTR [edx+28]
	fstp	DWORD PTR _cvert$[ebp+28]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mvsource$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	DWORD PTR _cvert$[ebp+32]
	fadd	DWORD PTR [edx+32]
	fstp	DWORD PTR _cvert$[ebp+32]

; 1512 : 
; 1513 : 				cuv[0] += uvsource[j * 2];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _uvsource$[ebp]
	fld	DWORD PTR _cuv$[ebp]
	fadd	DWORD PTR [ecx+eax*4]
	fstp	DWORD PTR _cuv$[ebp]

; 1514 : 				cuv[1] += uvsource[j * 2 + 1];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _uvsource$[ebp]
	fld	DWORD PTR _cuv$[ebp+4]
	fadd	DWORD PTR [ecx+eax*4+4]
	fstp	DWORD PTR _cuv$[ebp+4]

; 1515 : 
; 1516 : 				lrgb[0] += mrgbsource->rgb[j].b;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4]
	add	edx, DWORD PTR _lrgb$[ebp]
	mov	DWORD PTR _lrgb$[ebp], edx

; 1517 : 				lrgb[1] += mrgbsource->rgb[j].g;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+1]
	add	edx, DWORD PTR _lrgb$[ebp+4]
	mov	DWORD PTR _lrgb$[ebp+4], edx

; 1518 : 				lrgb[2] += mrgbsource->rgb[j].r;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+2]
	add	edx, DWORD PTR _lrgb$[ebp+8]
	mov	DWORD PTR _lrgb$[ebp+8], edx

; 1519 : 				lrgb[3] += mrgbsource->rgb[j].a;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mrgbsource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*4+3]
	add	edx, DWORD PTR _lrgb$[ebp+12]
	mov	DWORD PTR _lrgb$[ebp+12], edx

; 1520 : 			}

	jmp	$L83201
$L83202:

; 1521 : 
; 1522 : // normalize centre point
; 1523 : 
; 1524 : 			cvert.x /= (float)vcount;

	fild	DWORD PTR _vcount$[ebp]
	fdivr	DWORD PTR _cvert$[ebp]
	fstp	DWORD PTR _cvert$[ebp]

; 1525 : 			cvert.y /= (float)vcount;

	fild	DWORD PTR _vcount$[ebp]
	fdivr	DWORD PTR _cvert$[ebp+4]
	fstp	DWORD PTR _cvert$[ebp+4]

; 1526 : 			cvert.z /= (float)vcount;

	fild	DWORD PTR _vcount$[ebp]
	fdivr	DWORD PTR _cvert$[ebp+8]
	fstp	DWORD PTR _cvert$[ebp+8]

; 1527 : 
; 1528 : 			NormalizeVector((VEC*)&cvert.nx);

	fld	DWORD PTR _cvert$[ebp+24]
	fmul	DWORD PTR _cvert$[ebp+24]
	fld	DWORD PTR _cvert$[ebp+28]
	fmul	DWORD PTR _cvert$[ebp+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _cvert$[ebp+32]
	fmul	DWORD PTR _cvert$[ebp+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$83243[ebp]
	fld	DWORD PTR _cvert$[ebp+24]
	fmul	DWORD PTR __mul$83243[ebp]
	fstp	DWORD PTR _cvert$[ebp+24]
	fld	DWORD PTR _cvert$[ebp+28]
	fmul	DWORD PTR __mul$83243[ebp]
	fstp	DWORD PTR _cvert$[ebp+28]
	fld	DWORD PTR _cvert$[ebp+32]
	fmul	DWORD PTR __mul$83243[ebp]
	fstp	DWORD PTR _cvert$[ebp+32]

; 1529 : 
; 1530 : 			cuv[0] /= (float)vcount;

	fild	DWORD PTR _vcount$[ebp]
	fdivr	DWORD PTR _cuv$[ebp]
	fstp	DWORD PTR _cuv$[ebp]

; 1531 : 			cuv[1] /= (float)vcount;

	fild	DWORD PTR _vcount$[ebp]
	fdivr	DWORD PTR _cuv$[ebp+4]
	fstp	DWORD PTR _cuv$[ebp+4]

; 1532 : 
; 1533 : 			crgb.b = (unsigned char)(lrgb[0] / vcount);

	mov	eax, DWORD PTR _lrgb$[ebp]
	cdq
	idiv	DWORD PTR _vcount$[ebp]
	mov	BYTE PTR _crgb$[ebp], al

; 1534 : 			crgb.g = (unsigned char)(lrgb[1] / vcount);

	mov	eax, DWORD PTR _lrgb$[ebp+4]
	cdq
	idiv	DWORD PTR _vcount$[ebp]
	mov	BYTE PTR _crgb$[ebp+1], al

; 1535 : 			crgb.r = (unsigned char)(lrgb[2] / vcount);

	mov	eax, DWORD PTR _lrgb$[ebp+8]
	cdq
	idiv	DWORD PTR _vcount$[ebp]
	mov	BYTE PTR _crgb$[ebp+2], al

; 1536 : 			crgb.a = (unsigned char)(lrgb[3] / vcount);

	mov	eax, DWORD PTR _lrgb$[ebp+12]
	cdq
	idiv	DWORD PTR _vcount$[ebp]
	mov	BYTE PTR _crgb$[ebp+3], al

; 1537 : 
; 1538 : // build new polys from new points
; 1539 : 
; 1540 : 			if (mpsource->Type & POLY_QUAD)

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	and	ecx, 1
	je	$L83260

; 1541 : 			{
; 1542 : // quad 1
; 1543 : 				mpdest->Type = (mpsource->Type | POLY_DOUBLE | POLY_SEMITRANS) & ~POLY_SEMITRANS_ONE;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	or	ecx, 2
	or	ecx, 4
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _mpdest$[ebp]
	mov	WORD PTR [edx], cx

; 1544 : 				mpdest->Tpage = mpsource->Tpage;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx

; 1545 : 
; 1546 : 				mpdest->tu0 = mpsource->tu0;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1547 : 				mpdest->tv0 = mpsource->tv0;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1548 : 				mpdest->tu1 = uv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1549 : 				mpdest->tv1 = uv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+4]
	mov	DWORD PTR [eax+16], ecx

; 1550 : 				mpdest->tu2 = cuv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1551 : 				mpdest->tv2 = cuv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR [eax+24], ecx

; 1552 : 				mpdest->tu3 = uv[6];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+24]
	mov	DWORD PTR [eax+28], ecx

; 1553 : 				mpdest->tv3 = uv[7];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+28]
	mov	DWORD PTR [eax+32], ecx

; 1554 : 
; 1555 : 				mrgbdest->rgb[0] = mrgbsource->rgb[0];

	mov	eax, DWORD PTR _mrgbsource$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mrgbdest$[ebp]
	mov	DWORD PTR [edx], ecx

; 1556 : 				mrgbdest->rgb[1] = rgb[0];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1557 : 				mrgbdest->rgb[2] = crgb;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _crgb$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1558 : 				mrgbdest->rgb[3] = rgb[3];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+12]
	mov	DWORD PTR [eax+12], ecx

; 1559 : 
; 1560 : 				mpdest->v0 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1561 : 				*mvdest++ = *mpsource->v0;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	esi, DWORD PTR [eax+36]
	mov	ecx, 22					; 00000016H
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _mvdest$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1562 : 				mpdest->v1 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1563 : 				*mvdest++ = vert[0];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1564 : 				mpdest->v2 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1565 : 				*mvdest++ = cvert;

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _cvert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1566 : 				mpdest->v3 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1567 : 				*mvdest++ = vert[3];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+264]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1568 : 
; 1569 : 				mpdest++;

	mov	eax, DWORD PTR _mpdest$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _mpdest$[ebp], eax

; 1570 : 				mrgbdest++;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _mrgbdest$[ebp], eax

; 1571 : // quad 2
; 1572 : 				mpdest->Type = (mpsource->Type | POLY_DOUBLE | POLY_SEMITRANS) & ~POLY_SEMITRANS_ONE;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	or	ecx, 2
	or	ecx, 4
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _mpdest$[ebp]
	mov	WORD PTR [edx], cx

; 1573 : 				mpdest->Tpage = mpsource->Tpage;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx

; 1574 : 
; 1575 : 				mpdest->tu0 = uv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1576 : 				mpdest->tv0 = uv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+4]
	mov	DWORD PTR [eax+8], ecx

; 1577 : 				mpdest->tu1 = mpsource->tu1;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 1578 : 				mpdest->tv1 = mpsource->tv1;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 1579 : 				mpdest->tu2 = uv[2];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+8]
	mov	DWORD PTR [eax+20], ecx

; 1580 : 				mpdest->tv2 = uv[3];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+12]
	mov	DWORD PTR [eax+24], ecx

; 1581 : 				mpdest->tu3 = cuv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1582 : 				mpdest->tv3 = cuv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR [eax+32], ecx

; 1583 : 
; 1584 : 				mrgbdest->rgb[0] = rgb[0];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax], ecx

; 1585 : 				mrgbdest->rgb[1] = mrgbsource->rgb[1];

	mov	eax, DWORD PTR _mrgbsource$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _mrgbdest$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1586 : 				mrgbdest->rgb[2] = rgb[1];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR [eax+8], ecx

; 1587 : 				mrgbdest->rgb[3] = crgb;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _crgb$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1588 : 
; 1589 : 				mpdest->v0 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1590 : 				*mvdest++ = vert[0];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1591 : 				mpdest->v1 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1592 : 				*mvdest++ = *mpsource->v1;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	esi, DWORD PTR [eax+40]
	mov	ecx, 22					; 00000016H
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _mvdest$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1593 : 				mpdest->v2 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1594 : 				*mvdest++ = vert[1];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+88]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1595 : 				mpdest->v3 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1596 : 				*mvdest++ = cvert;

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _cvert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1597 : 
; 1598 : 				mpdest++;

	mov	eax, DWORD PTR _mpdest$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _mpdest$[ebp], eax

; 1599 : 				mrgbdest++;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _mrgbdest$[ebp], eax

; 1600 : // quad 3
; 1601 : 				mpdest->Type = (mpsource->Type | POLY_DOUBLE | POLY_SEMITRANS) & ~POLY_SEMITRANS_ONE;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	or	ecx, 2
	or	ecx, 4
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _mpdest$[ebp]
	mov	WORD PTR [edx], cx

; 1602 : 				mpdest->Tpage = mpsource->Tpage;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx

; 1603 : 
; 1604 : 				mpdest->tu0 = cuv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1605 : 				mpdest->tv0 = cuv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR [eax+8], ecx

; 1606 : 				mpdest->tu1 = uv[2];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+8]
	mov	DWORD PTR [eax+12], ecx

; 1607 : 				mpdest->tv1 = uv[3];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+12]
	mov	DWORD PTR [eax+16], ecx

; 1608 : 				mpdest->tu2 = mpsource->tu2;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 1609 : 				mpdest->tv2 = mpsource->tv2;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 1610 : 				mpdest->tu3 = uv[4];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+16]
	mov	DWORD PTR [eax+28], ecx

; 1611 : 				mpdest->tv3 = uv[5];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+20]
	mov	DWORD PTR [eax+32], ecx

; 1612 : 
; 1613 : 				mrgbdest->rgb[0] = crgb;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _crgb$[ebp]
	mov	DWORD PTR [eax], ecx

; 1614 : 				mrgbdest->rgb[1] = rgb[1];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 1615 : 				mrgbdest->rgb[2] = mrgbsource->rgb[2];

	mov	eax, DWORD PTR _mrgbsource$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _mrgbdest$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1616 : 				mrgbdest->rgb[3] = rgb[2];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR [eax+12], ecx

; 1617 : 
; 1618 : 				mpdest->v0 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1619 : 				*mvdest++ = cvert;

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _cvert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1620 : 				mpdest->v1 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1621 : 				*mvdest++ = vert[1];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+88]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1622 : 				mpdest->v2 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1623 : 				*mvdest++ = *mpsource->v2;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	esi, DWORD PTR [eax+44]
	mov	ecx, 22					; 00000016H
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _mvdest$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1624 : 				mpdest->v3 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1625 : 				*mvdest++ = vert[2];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+176]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1626 : 
; 1627 : 				mpdest++;

	mov	eax, DWORD PTR _mpdest$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _mpdest$[ebp], eax

; 1628 : 				mrgbdest++;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _mrgbdest$[ebp], eax

; 1629 : // quad 4
; 1630 : 				mpdest->Type = (mpsource->Type | POLY_DOUBLE | POLY_SEMITRANS) & ~POLY_SEMITRANS_ONE;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	or	ecx, 2
	or	ecx, 4
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _mpdest$[ebp]
	mov	WORD PTR [edx], cx

; 1631 : 				mpdest->Tpage = mpsource->Tpage;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx

; 1632 : 
; 1633 : 				mpdest->tu0 = uv[6];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+24]
	mov	DWORD PTR [eax+4], ecx

; 1634 : 				mpdest->tv0 = uv[7];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+28]
	mov	DWORD PTR [eax+8], ecx

; 1635 : 				mpdest->tu1 = cuv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1636 : 				mpdest->tv1 = cuv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR [eax+16], ecx

; 1637 : 				mpdest->tu2 = uv[4];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+16]
	mov	DWORD PTR [eax+20], ecx

; 1638 : 				mpdest->tv2 = uv[5];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+20]
	mov	DWORD PTR [eax+24], ecx

; 1639 : 				mpdest->tu3 = mpsource->tu3;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 1640 : 				mpdest->tv3 = mpsource->tv3;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 1641 : 
; 1642 : 				mrgbdest->rgb[0] = rgb[3];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+12]
	mov	DWORD PTR [eax], ecx

; 1643 : 				mrgbdest->rgb[1] = crgb;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _crgb$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1644 : 				mrgbdest->rgb[2] = rgb[2];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 1645 : 				mrgbdest->rgb[3] = mrgbsource->rgb[3];

	mov	eax, DWORD PTR _mrgbsource$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _mrgbdest$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1646 : 
; 1647 : 				mpdest->v0 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1648 : 				*mvdest++ = vert[3];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+264]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1649 : 				mpdest->v1 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1650 : 				*mvdest++ = cvert;

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _cvert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1651 : 				mpdest->v2 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1652 : 				*mvdest++ = vert[2];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+176]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1653 : 				mpdest->v3 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1654 : 				*mvdest++ = *mpsource->v3;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	esi, DWORD PTR [eax+48]
	mov	ecx, 22					; 00000016H
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _mvdest$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1655 : 
; 1656 : 				mpdest++;

	mov	eax, DWORD PTR _mpdest$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _mpdest$[ebp], eax

; 1657 : 				mrgbdest++;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _mrgbdest$[ebp], eax

; 1658 : 			}
; 1659 : 			else

	jmp	$L83261
$L83260:

; 1660 : 			{
; 1661 : // tri 1
; 1662 : 				mpdest->Type = (mpsource->Type | POLY_DOUBLE | POLY_SEMITRANS | POLY_QUAD) & ~POLY_SEMITRANS_ONE;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	or	ecx, 2
	or	ecx, 4
	or	ecx, 1
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _mpdest$[ebp]
	mov	WORD PTR [edx], cx

; 1663 : 				mpdest->Tpage = mpsource->Tpage;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx

; 1664 : 
; 1665 : 				mpdest->tu0 = mpsource->tu0;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1666 : 				mpdest->tv0 = mpsource->tv0;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1667 : 				mpdest->tu1 = uv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1668 : 				mpdest->tv1 = uv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+4]
	mov	DWORD PTR [eax+16], ecx

; 1669 : 				mpdest->tu2 = cuv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1670 : 				mpdest->tv2 = cuv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR [eax+24], ecx

; 1671 : 				mpdest->tu3 = uv[4];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+16]
	mov	DWORD PTR [eax+28], ecx

; 1672 : 				mpdest->tv3 = uv[5];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+20]
	mov	DWORD PTR [eax+32], ecx

; 1673 : 
; 1674 : 				mrgbdest->rgb[0] = mrgbsource->rgb[0];

	mov	eax, DWORD PTR _mrgbsource$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mrgbdest$[ebp]
	mov	DWORD PTR [edx], ecx

; 1675 : 				mrgbdest->rgb[1] = rgb[0];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1676 : 				mrgbdest->rgb[2] = crgb;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _crgb$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1677 : 				mrgbdest->rgb[3] = rgb[2];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR [eax+12], ecx

; 1678 : 
; 1679 : 				mpdest->v0 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1680 : 				*mvdest++ = *mpsource->v0;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	esi, DWORD PTR [eax+36]
	mov	ecx, 22					; 00000016H
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _mvdest$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1681 : 				mpdest->v1 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1682 : 				*mvdest++ = vert[0];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1683 : 				mpdest->v2 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1684 : 				*mvdest++ = cvert;

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _cvert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1685 : 				mpdest->v3 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1686 : 				*mvdest++ = vert[2];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+176]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1687 : 
; 1688 : 				mpdest++;

	mov	eax, DWORD PTR _mpdest$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _mpdest$[ebp], eax

; 1689 : 				mrgbdest++;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _mrgbdest$[ebp], eax

; 1690 : // tri 2
; 1691 : 				mpdest->Type = (mpsource->Type | POLY_DOUBLE | POLY_SEMITRANS | POLY_QUAD) & ~POLY_SEMITRANS_ONE;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	or	ecx, 2
	or	ecx, 4
	or	ecx, 1
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _mpdest$[ebp]
	mov	WORD PTR [edx], cx

; 1692 : 				mpdest->Tpage = mpsource->Tpage;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx

; 1693 : 
; 1694 : 				mpdest->tu0 = uv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1695 : 				mpdest->tv0 = uv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+4]
	mov	DWORD PTR [eax+8], ecx

; 1696 : 				mpdest->tu1 = mpsource->tu1;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 1697 : 				mpdest->tv1 = mpsource->tv1;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 1698 : 				mpdest->tu2 = uv[2];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+8]
	mov	DWORD PTR [eax+20], ecx

; 1699 : 				mpdest->tv2 = uv[3];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+12]
	mov	DWORD PTR [eax+24], ecx

; 1700 : 				mpdest->tu3 = cuv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1701 : 				mpdest->tv3 = cuv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR [eax+32], ecx

; 1702 : 
; 1703 : 				mrgbdest->rgb[0] = rgb[0];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax], ecx

; 1704 : 				mrgbdest->rgb[1] = mrgbsource->rgb[1];

	mov	eax, DWORD PTR _mrgbsource$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _mrgbdest$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1705 : 				mrgbdest->rgb[2] = rgb[1];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR [eax+8], ecx

; 1706 : 				mrgbdest->rgb[3] = crgb;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _crgb$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1707 : 
; 1708 : 				mpdest->v0 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1709 : 				*mvdest++ = vert[0];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1710 : 				mpdest->v1 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1711 : 				*mvdest++ = *mpsource->v1;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	esi, DWORD PTR [eax+40]
	mov	ecx, 22					; 00000016H
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _mvdest$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1712 : 				mpdest->v2 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1713 : 				*mvdest++ = vert[1];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+88]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1714 : 				mpdest->v3 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1715 : 				*mvdest++ = cvert;

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _cvert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1716 : 
; 1717 : 				mpdest++;

	mov	eax, DWORD PTR _mpdest$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _mpdest$[ebp], eax

; 1718 : 				mrgbdest++;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _mrgbdest$[ebp], eax

; 1719 : // tri 3
; 1720 : 				mpdest->Type = (mpsource->Type | POLY_DOUBLE | POLY_SEMITRANS | POLY_QUAD) & ~POLY_SEMITRANS_ONE;

	mov	eax, DWORD PTR _mpsource$[ebp]
	movsx	ecx, WORD PTR [eax]
	or	ecx, 2
	or	ecx, 4
	or	ecx, 1
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _mpdest$[ebp]
	mov	WORD PTR [edx], cx

; 1721 : 				mpdest->Tpage = mpsource->Tpage;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+2], dx

; 1722 : 
; 1723 : 				mpdest->tu0 = cuv[0];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1724 : 				mpdest->tv0 = cuv[1];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _cuv$[ebp+4]
	mov	DWORD PTR [eax+8], ecx

; 1725 : 				mpdest->tu1 = uv[2];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+8]
	mov	DWORD PTR [eax+12], ecx

; 1726 : 				mpdest->tv1 = uv[3];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+12]
	mov	DWORD PTR [eax+16], ecx

; 1727 : 				mpdest->tu2 = mpsource->tu2;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 1728 : 				mpdest->tv2 = mpsource->tv2;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 1729 : 				mpdest->tu3 = uv[4];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+16]
	mov	DWORD PTR [eax+28], ecx

; 1730 : 				mpdest->tv3 = uv[5];

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _uv$[ebp+20]
	mov	DWORD PTR [eax+32], ecx

; 1731 : 
; 1732 : 				mrgbdest->rgb[0] = crgb;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _crgb$[ebp]
	mov	DWORD PTR [eax], ecx

; 1733 : 				mrgbdest->rgb[1] = rgb[1];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 1734 : 				mrgbdest->rgb[2] = mrgbsource->rgb[2];

	mov	eax, DWORD PTR _mrgbsource$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _mrgbdest$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1735 : 				mrgbdest->rgb[3] = rgb[2];

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp+8]
	mov	DWORD PTR [eax+12], ecx

; 1736 : 
; 1737 : 				mpdest->v0 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1738 : 				*mvdest++ = cvert;

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _cvert$[ebp]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1739 : 				mpdest->v1 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1740 : 				*mvdest++ = vert[1];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+88]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1741 : 				mpdest->v2 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1742 : 				*mvdest++ = *mpsource->v2;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	esi, DWORD PTR [eax+44]
	mov	ecx, 22					; 00000016H
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _mvdest$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], ecx

; 1743 : 				mpdest->v3 = mvdest;

	mov	eax, DWORD PTR _mpdest$[ebp]
	mov	ecx, DWORD PTR _mvdest$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1744 : 				*mvdest++ = vert[2];

	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _vert$[ebp+176]
	mov	edi, DWORD PTR _mvdest$[ebp]
	rep movsd
	mov	eax, DWORD PTR _mvdest$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _mvdest$[ebp], eax

; 1745 : 
; 1746 : 				mpdest++;

	mov	eax, DWORD PTR _mpdest$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _mpdest$[ebp], eax

; 1747 : 				mrgbdest++;

	mov	eax, DWORD PTR _mrgbdest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _mrgbdest$[ebp], eax
$L83261:

; 1748 : 			}
; 1749 : 		}

	jmp	$L83197
$L83198:

; 1750 : 	}

	jmp	$L83194
$L83195:

; 1751 : 
; 1752 : // setup particles
; 1753 : 
; 1754 : 	particle = (DISSOLVE_PARTICLE*)(dissolve->Model.VertPtr + vertnum);

	mov	eax, DWORD PTR _vertnum$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _dissolve$[ebp]
	add	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR _particle$[ebp], eax

; 1755 : 	mpsource = dissolve->Model.PolyPtr;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _mpsource$[ebp], ecx

; 1756 : 
; 1757 : 	for (i = 0 ; i < polynum ; i++, particle++, mpsource++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83263
$L83264:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _particle$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _particle$[ebp], ecx
	mov	edx, DWORD PTR _mpsource$[ebp]
	add	edx, 52					; 00000034H
	mov	DWORD PTR _mpsource$[ebp], edx
$L83263:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _polynum$[ebp]
	jge	$L83265

; 1758 : 	{
; 1759 : 		centre.v[X] = (mpsource->v0->x + mpsource->v1->x + mpsource->v2->x + mpsource->v3->x) / 4.0f;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mpsource$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx]
	fdiv	DWORD PTR __real@40800000
	fstp	DWORD PTR _centre$[ebp]

; 1760 : 		centre.v[Y] = (mpsource->v0->y + mpsource->v1->y + mpsource->v2->y + mpsource->v3->y) / 4.0f;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mpsource$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fld	DWORD PTR [ecx+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	fadd	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+4]
	fdiv	DWORD PTR __real@40800000
	fstp	DWORD PTR _centre$[ebp+4]

; 1761 : 		centre.v[Z] = (mpsource->v0->z + mpsource->v1->z + mpsource->v2->z + mpsource->v3->z) / 4.0f;

	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _mpsource$[ebp]
	mov	eax, DWORD PTR [edx+40]
	fld	DWORD PTR [ecx+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _mpsource$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	fadd	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _mpsource$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	fadd	DWORD PTR [ecx+8]
	fdiv	DWORD PTR __real@40800000
	fstp	DWORD PTR _centre$[ebp+8]

; 1762 : 
; 1763 : 		NormalizeVector(&centre);

	fld	DWORD PTR _centre$[ebp]
	fmul	DWORD PTR _centre$[ebp]
	fld	DWORD PTR _centre$[ebp+4]
	fmul	DWORD PTR _centre$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _centre$[ebp+8]
	fmul	DWORD PTR _centre$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$83266[ebp]
	fld	DWORD PTR _centre$[ebp]
	fmul	DWORD PTR __mul$83266[ebp]
	fstp	DWORD PTR _centre$[ebp]
	fld	DWORD PTR _centre$[ebp+4]
	fmul	DWORD PTR __mul$83266[ebp]
	fstp	DWORD PTR _centre$[ebp+4]
	fld	DWORD PTR _centre$[ebp+8]
	fmul	DWORD PTR __mul$83266[ebp]
	fstp	DWORD PTR _centre$[ebp+8]

; 1764 : 
; 1765 : 		particle->Vel.v[X] = centre.v[X] * (frand(96.0f) + 96.0f);

	call	_rand
	mov	DWORD PTR tv1855[ebp], eax
	fild	DWORD PTR tv1855[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42c00000
	fadd	DWORD PTR __real@42c00000
	fmul	DWORD PTR _centre$[ebp]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax]

; 1766 : 		particle->Vel.v[Y] = centre.v[Y] * frand(96.0f) - 192.0f;

	call	_rand
	mov	DWORD PTR tv1858[ebp], eax
	fild	DWORD PTR tv1858[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42c00000
	fmul	DWORD PTR _centre$[ebp+4]
	fsub	DWORD PTR __real@43400000
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+4]

; 1767 : 		particle->Vel.v[Z] = centre.v[Z] * (frand(96.0f) + 96.0f);

	call	_rand
	mov	DWORD PTR tv1861[ebp], eax
	fild	DWORD PTR tv1861[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42c00000
	fadd	DWORD PTR __real@42c00000
	fmul	DWORD PTR _centre$[ebp+8]
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+8]

; 1768 : 
; 1769 : 		particle->Rot.v[X] = frand(1.0f) - 0.5f;

	call	_rand
	mov	DWORD PTR tv1864[ebp], eax
	fild	DWORD PTR tv1864[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	fsub	DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+12]

; 1770 : 		particle->Rot.v[Y] = frand(1.0f) - 0.5f;

	call	_rand
	mov	DWORD PTR tv1867[ebp], eax
	fild	DWORD PTR tv1867[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	fsub	DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+16]

; 1771 : 		particle->Rot.v[Z] = frand(1.0f) - 0.5f;

	call	_rand
	mov	DWORD PTR tv1870[ebp], eax
	fild	DWORD PTR tv1870[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	fsub	DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _particle$[ebp]
	fstp	DWORD PTR [eax+20]

; 1772 : 	}

	jmp	$L83264
$L83265:

; 1773 : 
; 1774 : // setup dissolve
; 1775 : 
; 1776 : 	dissolve->Age = 0.0f;

	mov	eax, DWORD PTR _dissolve$[ebp]
	mov	DWORD PTR [eax], 0

; 1777 : 
; 1778 : 	CopyMatrix(&Identity, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET FLAT:?Identity@@3TMatrixUnion@@A	; Identity
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 1779 : 
; 1780 : // set render flag
; 1781 : 
; 1782 : 	obj->renderflag.envmap = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1783 : 	obj->renderflag.light = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1784 : 	obj->renderflag.reflect = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 1785 : 
; 1786 : // set handlers
; 1787 : 
; 1788 : 	obj->aihandler = (AI_HANDLER)AI_DissolveModelHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_DissolveModelHandler@@YAXPAUobject_def@@@Z ; AI_DissolveModelHandler

; 1789 : 	obj->renderhandler = (RENDER_HANDLER)RenderDissolveModel;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderDissolveModel@@YAXPAUobject_def@@@Z ; RenderDissolveModel

; 1790 : 
; 1791 : // return OK
; 1792 : 
; 1793 : 	return TRUE;

	mov	eax, 1
$L83149:

; 1794 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitDissolveModel@@YAJPAUobject_def@@PAJ@Z ENDP	; InitDissolveModel
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\obj_init.cpp
_TEXT	ENDS
;	COMDAT ?InitFlap@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitFlap@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitFlap, COMDAT

; 1804 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1805 : 
; 1806 : 	return TRUE;

	mov	eax, 1

; 1807 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitFlap@@YAJPAUobject_def@@PAJ@Z ENDP			; InitFlap
_TEXT	ENDS
PUBLIC	??_C@_0CA@PGGGICOM@Laser?5goes?5on?5for?5ever?4?4?4?4?4?4?4?4?4?$AA@ ; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	__real@461c4000
PUBLIC	__real@447a0000
EXTRN	?AI_LaserHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_LaserHandler
EXTRN	__ftol2:NEAR
EXTRN	?RenderLaser@@YAXPAUobject_def@@@Z:NEAR		; RenderLaser
EXTRN	?LineOfSightDist@@YA_NPAUVectorStruct@@0PAMPAPAUPlaneStruct@@@Z:NEAR ; LineOfSightDist
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT ??_C@_0CA@PGGGICOM@Laser?5goes?5on?5for?5ever?4?4?4?4?4?4?4?4?4?$AA@
CONST	SEGMENT
??_C@_0CA@PGGGICOM@Laser?5goes?5on?5for?5ever?4?4?4?4?4?4?4?4?4?$AA@ DB 'L'
	DB	'aser goes on for ever.........', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitLaser@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv440 = -88						; size = 4
tv286 = -88						; size = 4
tv262 = -88						; size = 4
_laser$ = -20						; size = 4
_dest$ = -16						; size = 12
_dist$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitLaser@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitLaser, COMDAT

; 1817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1818 : 	REAL dist;
; 1819 : 	VEC dest;
; 1820 : 	LASER_OBJ *laser = (LASER_OBJ *)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _laser$[ebp], ecx

; 1821 : 
; 1822 : 	obj->aihandler = (AI_HANDLER)AI_LaserHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_LaserHandler@@YAXPAUobject_def@@@Z ; AI_LaserHandler

; 1823 : 	obj->renderhandler = (RENDER_HANDLER)RenderLaser;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderLaser@@YAXPAUobject_def@@@Z ; RenderLaser

; 1824 : 
; 1825 : 	// Find the default destination of the laser beam
; 1826 : 	VecPlusScalarVec(&obj->body.Centre.Pos, 10000, &obj->body.Centre.WMatrix.mv[L], &dest);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@461c4000
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@461c4000
	fmul	DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dest$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR __real@461c4000
	fmul	DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dest$[ebp+8]

; 1827 : 	if (!LineOfSightDist(&obj->body.Centre.Pos, &dest, &dist, NULL)) {

	push	0
	lea	eax, DWORD PTR _dist$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	?LineOfSightDist@@YA_NPAUVectorStruct@@0PAMPAPAUPlaneStruct@@@Z ; LineOfSightDist
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L83290

; 1828 : 		Box("Error", "Laser goes on for ever.........", MB_OK | MB_ICONWARNING);

	push	48					; 00000030H
	push	OFFSET FLAT:??_C@_0CA@PGGGICOM@Laser?5goes?5on?5for?5ever?4?4?4?4?4?4?4?4?4?$AA@
	push	OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH
$L83290:

; 1829 : 	}
; 1830 : 	VecPlusScalarVec(&obj->body.Centre.Pos, 10000 * dist, &obj->body.Centre.WMatrix.mv[L], &laser->Dest);

	fld	DWORD PTR __real@461c4000
	fmul	DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [edx]
	fld	DWORD PTR __real@461c4000
	fmul	DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [edx+4]
	fld	DWORD PTR __real@461c4000
	fmul	DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fmul	DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _obj$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [edx+8]

; 1831 : 	VecMinusVec(&laser->Dest, &obj->body.Centre.Pos, &laser->Delta);

	mov	eax, DWORD PTR _laser$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _laser$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _laser$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [edx+20]

; 1832 : 	SetBBox(&obj->body.CollSkin.BBox, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+444], 1232348160		; 49742400H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+448], -915135488		; c9742400H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+452], 1232348160		; 49742400H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+456], -915135488		; c9742400H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+460], 1232348160		; 49742400H
	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+464], -915135488		; c9742400H

; 1833 : 	AddPointToBBox(&obj->body.CollSkin.BBox, &obj->body.Centre.Pos);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 444				; 000001bcH
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 1834 : 	AddPointToBBox(&obj->body.CollSkin.BBox, &laser->Dest);

	mov	eax, DWORD PTR _laser$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 444				; 000001bcH
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 1835 : 	obj->body.CollSkin.Radius = obj->body.CollSkin.BBox.XMax - obj->body.CollSkin.BBox.XMin;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+448]
	fsub	DWORD PTR [ecx+444]
	mov	edx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [edx+468]

; 1836 : 	obj->body.CollSkin.Radius = Max(obj->body.CollSkin.Radius, obj->body.CollSkin.BBox.YMax - obj->body.CollSkin.BBox.YMin);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+468]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+456]
	fsub	DWORD PTR [edx+452]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83580
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+468]
	mov	DWORD PTR tv262[ebp], ecx
	jmp	SHORT $L83581
$L83580:
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+456]
	fsub	DWORD PTR [eax+452]
	fstp	DWORD PTR tv262[ebp]
$L83581:
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR tv262[ebp]
	mov	DWORD PTR [ecx+468], edx

; 1837 : 	obj->body.CollSkin.Radius = Max(obj->body.CollSkin.Radius, obj->body.CollSkin.BBox.ZMax - obj->body.CollSkin.BBox.ZMin);

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+468]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+464]
	fsub	DWORD PTR [edx+460]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83582
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+468]
	mov	DWORD PTR tv286[ebp], ecx
	jmp	SHORT $L83583
$L83582:
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+464]
	fsub	DWORD PTR [eax+460]
	fstp	DWORD PTR tv286[ebp]
$L83583:
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR tv286[ebp]
	mov	DWORD PTR [ecx+468], edx

; 1838 : 
; 1839 : 	laser->Width = (REAL)flags[0];

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax]
	mov	ecx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [ecx+28]

; 1840 : 	laser->RandWidth = (REAL)flags[1];

	mov	eax, DWORD PTR _flags$[ebp]
	fild	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [ecx+32]

; 1841 : 	laser->Length = VecLen(&laser->Delta);

	mov	eax, DWORD PTR _laser$[ebp]
	mov	ecx, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _laser$[ebp]
	mov	eax, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _laser$[ebp]
	mov	edx, DWORD PTR _laser$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	mov	eax, DWORD PTR _laser$[ebp]
	fstp	DWORD PTR [eax+36]

; 1842 : 	laser->ObjectCollide = (bool)flags[2];

	mov	eax, DWORD PTR _flags$[ebp]
	cmp	DWORD PTR [eax+8], 0
	setne	cl
	mov	edx, DWORD PTR _laser$[ebp]
	mov	BYTE PTR [edx+44], cl

; 1843 : 	laser->Phase = (long)frand(1000);

	call	_rand
	mov	DWORD PTR tv440[ebp], eax
	fild	DWORD PTR tv440[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@447a0000
	call	__ftol2
	mov	ecx, DWORD PTR _laser$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 1844 : 	laser->VisiMask = SetObjectVisiMask((BOUNDING_BOX *)&obj->body.CollSkin.BBox);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 444				; 000001bcH
	push	eax
	call	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z ; SetObjectVisiMask
	add	esp, 4
	mov	ecx, DWORD PTR _laser$[ebp]
	mov	DWORD PTR [ecx+48], eax
	mov	DWORD PTR [ecx+52], edx

; 1845 : 
; 1846 : 	return TRUE;

	mov	eax, 1

; 1847 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitLaser@@YAJPAUobject_def@@PAJ@Z ENDP		; InitLaser
_TEXT	ENDS
PUBLIC	__real@41800000
PUBLIC	__real@42400000
PUBLIC	__real@3f2a7efa
PUBLIC	__real@41000000
PUBLIC	__real@3fe66666
PUBLIC	__real@43000000
PUBLIC	__real@42000000
EXTRN	?AI_SplashHandler@@YAXPAUobject_def@@@Z:NEAR	; AI_SplashHandler
EXTRN	?RenderSplash@@YAXPAUobject_def@@@Z:NEAR	; RenderSplash
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@42400000
CONST	SEGMENT
__real@42400000 DD 042400000r			; 48
CONST	ENDS
;	COMDAT __real@3f2a7efa
CONST	SEGMENT
__real@3f2a7efa DD 03f2a7efar			; 0.666
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@3fe66666
CONST	SEGMENT
__real@3fe66666 DD 03fe66666r			; 1.8
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitSplash@@YAJPAUobject_def@@PAJ@Z
_TEXT	SEGMENT
tv456 = -228						; size = 4
tv494 = -224						; size = 4
tv491 = -224						; size = 4
tv488 = -224						; size = 4
tv485 = -224						; size = 4
tv482 = -224						; size = 4
tv479 = -224						; size = 4
tv476 = -224						; size = 4
tv473 = -224						; size = 4
tv470 = -224						; size = 4
tv467 = -224						; size = 4
tv464 = -224						; size = 4
tv461 = -224						; size = 4
tv451 = -224						; size = 4
tv381 = -224						; size = 4
tv379 = -224						; size = 4
tv372 = -224						; size = 4
tv369 = -224						; size = 4
_vel$ = -156						; size = 12
_v3$ = -144						; size = 12
_v2$ = -132						; size = 12
_v1$ = -120						; size = 12
_v0$ = -108						; size = 12
_mat2$ = -96						; size = 36
_mat$ = -60						; size = 36
_mul$ = -24						; size = 4
_size$ = -20						; size = 4
_rad$ = -16						; size = 4
_i$ = -12						; size = 4
_spoly$ = -8						; size = 4
_splash$ = -4						; size = 4
_obj$ = 8						; size = 4
_flags$ = 12						; size = 4
?InitSplash@@YAJPAUobject_def@@PAJ@Z PROC NEAR		; InitSplash, COMDAT

; 1854 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi

; 1855 : 	SPLASH_OBJ *splash = (SPLASH_OBJ*)obj->Data;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _splash$[ebp], ecx

; 1856 : 	SPLASH_POLY *spoly;
; 1857 : 	long i;
; 1858 : 	REAL rad, size, mul;
; 1859 : 	MAT mat, mat2;
; 1860 : 	VEC v0, v1, v2, v3, vel;
; 1861 : 
; 1862 : // set ai handler
; 1863 : 
; 1864 : 	obj->aihandler = (AI_HANDLER)AI_SplashHandler;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+696], OFFSET FLAT:?AI_SplashHandler@@YAXPAUobject_def@@@Z ; AI_SplashHandler

; 1865 : 	obj->renderhandler = (RENDER_HANDLER)RenderSplash;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+700], OFFSET FLAT:?RenderSplash@@YAXPAUobject_def@@@Z ; RenderSplash

; 1866 : 
; 1867 : // setup splash
; 1868 : 
; 1869 : 	splash->Count = SPLASH_POLY_NUM;

	mov	eax, DWORD PTR _splash$[ebp]
	mov	DWORD PTR [eax], 150			; 00000096H

; 1870 : 
; 1871 : // setup each poly
; 1872 : 
; 1873 : 	spoly = splash->Poly;

	mov	eax, DWORD PTR _splash$[ebp]
	add	eax, 4
	mov	DWORD PTR _spoly$[ebp], eax

; 1874 : 
; 1875 : 	for (i = 0 ; i < SPLASH_POLY_NUM ; i++, spoly++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L83320
$L83321:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _spoly$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _spoly$[ebp], ecx
$L83320:
	cmp	DWORD PTR _i$[ebp], 150			; 00000096H
	jge	$L83322

; 1876 : 	{
; 1877 : 		spoly->Frame = 0.0f;

	mov	eax, DWORD PTR _spoly$[ebp]
	mov	DWORD PTR [eax+96], 0

; 1878 : 		spoly->FrameAdd = (frand(0.5f) + 1.0f) * 16.0f;

	call	_rand
	mov	DWORD PTR tv369[ebp], eax
	fild	DWORD PTR tv369[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f000000
	fadd	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+100]

; 1879 : 
; 1880 : 		RotMatrixY(&mat, frand(1.0f));

	call	_rand
	mov	DWORD PTR tv372[ebp], eax
	fild	DWORD PTR tv372[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?RotMatrixY@@YAXPATMatrixUnion@@M@Z	; RotMatrixY
	add	esp, 8

; 1881 : 		MulMatrix(&obj->body.Centre.WMatrix, &mat, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 1882 : 
; 1883 : 		rad = frand(48.0f);

	call	_rand
	mov	DWORD PTR tv379[ebp], eax
	fild	DWORD PTR tv379[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42400000
	fstp	DWORD PTR _rad$[ebp]

; 1884 : //		size = frand(32.0f) + 8.0f;
; 1885 : 		size = frand(rad * 0.666f) + 8.0f;

	call	_rand
	mov	DWORD PTR tv381[ebp], eax
	fild	DWORD PTR tv381[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fld	DWORD PTR _rad$[ebp]
	fmul	DWORD PTR __real@3f2a7efa
	fmulp	ST(1), ST(0)
	fadd	DWORD PTR __real@41000000
	fstp	DWORD PTR _size$[ebp]

; 1886 : 
; 1887 : 		SetVector(&v0, -size, -size * 4.0f, rad * 1.8f);

	fld	DWORD PTR _size$[ebp]
	fchs
	fstp	DWORD PTR _v0$[ebp]
	fld	DWORD PTR _size$[ebp]
	fchs
	fmul	DWORD PTR __real@40800000
	fstp	DWORD PTR _v0$[ebp+4]
	fld	DWORD PTR _rad$[ebp]
	fmul	DWORD PTR __real@3fe66666
	fstp	DWORD PTR _v0$[ebp+8]

; 1888 : 		SetVector(&v1, size, -size * 4.0f, rad * 1.8f);

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _v1$[ebp], eax
	fld	DWORD PTR _size$[ebp]
	fchs
	fmul	DWORD PTR __real@40800000
	fstp	DWORD PTR _v1$[ebp+4]
	fld	DWORD PTR _rad$[ebp]
	fmul	DWORD PTR __real@3fe66666
	fstp	DWORD PTR _v1$[ebp+8]

; 1889 : 		SetVector(&v2, size, 0.0f, rad);

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _v2$[ebp], eax
	mov	DWORD PTR _v2$[ebp+4], 0
	mov	eax, DWORD PTR _rad$[ebp]
	mov	DWORD PTR _v2$[ebp+8], eax

; 1890 : 		SetVector(&v3, -size, 0.0f, rad);

	fld	DWORD PTR _size$[ebp]
	fchs
	fstp	DWORD PTR _v3$[ebp]
	mov	DWORD PTR _v3$[ebp+4], 0
	mov	eax, DWORD PTR _rad$[ebp]
	mov	DWORD PTR _v3$[ebp+8], eax

; 1891 : 
; 1892 : 		RotTransVector(&mat2, &obj->body.Centre.Pos, &v0, &spoly->Pos[0]);

	mov	eax, DWORD PTR _spoly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v0$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1893 : 		RotTransVector(&mat2, &obj->body.Centre.Pos, &v1, &spoly->Pos[1]);

	mov	eax, DWORD PTR _spoly$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1894 : 		RotTransVector(&mat2, &obj->body.Centre.Pos, &v2, &spoly->Pos[2]);

	mov	eax, DWORD PTR _spoly$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1895 : 		RotTransVector(&mat2, &obj->body.Centre.Pos, &v3, &spoly->Pos[3]);

	mov	eax, DWORD PTR _spoly$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _v3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 1896 : 
; 1897 : 		SubVector(&spoly->Pos[0], &spoly->Pos[3], &vel);

	mov	eax, DWORD PTR _spoly$[ebp]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+36]
	fstp	DWORD PTR _vel$[ebp]
	mov	eax, DWORD PTR _spoly$[ebp]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+40]
	fstp	DWORD PTR _vel$[ebp+4]
	mov	eax, DWORD PTR _spoly$[ebp]
	mov	ecx, DWORD PTR _spoly$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+44]
	fstp	DWORD PTR _vel$[ebp+8]

; 1898 : 		mul = (frand(256.0f) + 128.0f) / Length(&vel);

	call	_rand
	mov	DWORD PTR tv451[ebp], eax
	fild	DWORD PTR tv451[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@43800000
	fadd	DWORD PTR __real@43000000
	fstp	DWORD PTR tv456[ebp]
	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR _vel$[ebp]
	fld	DWORD PTR _vel$[ebp+4]
	fmul	DWORD PTR _vel$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _vel$[ebp+8]
	fmul	DWORD PTR _vel$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR tv456[ebp]
	fstp	DWORD PTR _mul$[ebp]

; 1899 : 		VecMulScalar(&vel, mul);

	fld	DWORD PTR _vel$[ebp]
	fmul	DWORD PTR _mul$[ebp]
	fstp	DWORD PTR _vel$[ebp]
	fld	DWORD PTR _vel$[ebp+4]
	fmul	DWORD PTR _mul$[ebp]
	fstp	DWORD PTR _vel$[ebp+4]
	fld	DWORD PTR _vel$[ebp+8]
	fmul	DWORD PTR _mul$[ebp]
	fstp	DWORD PTR _vel$[ebp+8]

; 1900 : 
; 1901 : 		SetVector(&spoly->Vel[0], vel.v[X] + frand(32.0f) - 16.0f, vel.v[Y] + frand(32.0f) - 16.0f, vel.v[Z] + frand(32.0f) - 16.0f);

	call	_rand
	mov	DWORD PTR tv461[ebp], eax
	fild	DWORD PTR tv461[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+48]
	call	_rand
	mov	DWORD PTR tv464[ebp], eax
	fild	DWORD PTR tv464[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+4]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+52]
	call	_rand
	mov	DWORD PTR tv467[ebp], eax
	fild	DWORD PTR tv467[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+8]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+56]

; 1902 : 		SetVector(&spoly->Vel[1], vel.v[X] + frand(32.0f) - 16.0f, vel.v[Y] + frand(32.0f) - 16.0f, vel.v[Z] + frand(32.0f) - 16.0f);

	call	_rand
	mov	DWORD PTR tv470[ebp], eax
	fild	DWORD PTR tv470[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+60]
	call	_rand
	mov	DWORD PTR tv473[ebp], eax
	fild	DWORD PTR tv473[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+4]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+64]
	call	_rand
	mov	DWORD PTR tv476[ebp], eax
	fild	DWORD PTR tv476[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+8]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+68]

; 1903 : 		SetVector(&spoly->Vel[2], vel.v[X] + frand(32.0f) - 16.0f, vel.v[Y] + frand(32.0f) - 16.0f, vel.v[Z] + frand(32.0f) - 16.0f);

	call	_rand
	mov	DWORD PTR tv479[ebp], eax
	fild	DWORD PTR tv479[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+72]
	call	_rand
	mov	DWORD PTR tv482[ebp], eax
	fild	DWORD PTR tv482[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+4]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+76]
	call	_rand
	mov	DWORD PTR tv485[ebp], eax
	fild	DWORD PTR tv485[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+8]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+80]

; 1904 : 		SetVector(&spoly->Vel[3], vel.v[X] + frand(32.0f) - 16.0f, vel.v[Y] + frand(32.0f) - 16.0f, vel.v[Z] + frand(32.0f) - 16.0f);

	call	_rand
	mov	DWORD PTR tv488[ebp], eax
	fild	DWORD PTR tv488[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+84]
	call	_rand
	mov	DWORD PTR tv491[ebp], eax
	fild	DWORD PTR tv491[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+4]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+88]
	call	_rand
	mov	DWORD PTR tv494[ebp], eax
	fild	DWORD PTR tv494[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@42000000
	fadd	DWORD PTR _vel$[ebp+8]
	fsub	DWORD PTR __real@41800000
	mov	eax, DWORD PTR _spoly$[ebp]
	fstp	DWORD PTR [eax+92]

; 1905 : 	}

	jmp	$L83321
$L83322:

; 1906 : 
; 1907 : // return OK
; 1908 : 
; 1909 : 	return TRUE;

	mov	eax, 1

; 1910 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSplash@@YAJPAUobject_def@@PAJ@Z ENDP		; InitSplash
_TEXT	ENDS
END
