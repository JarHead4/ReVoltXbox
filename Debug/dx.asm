; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\dx.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BJ@ODAMKNKP@Can?8t?5get?5DD?5device?5caps?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KLFHKCPI@Can?8t?5set?5coop?5level?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@BOIMBCBG@DirectX?56?5is?5not?5installed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MDMNHFKP@No?5Zbuffer?5available?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@KEBHFNBB@Can?8t?5set?5display?5mode?5?$CFdx?$CFdx?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MAAKHPMF@Can?8t?5create?5Z?5buffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@CMDHNOP@Can?8t?5create?5draw?5surfaces?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHOIBHJB@Can?8t?5attach?5back?5buffer?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@BEGHCBBH@Can?8t?5create?5primary?5surface?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@GGNLDEBA@Can?8t?5create?5back?5buffer?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@BLIKGNAJ@Can?8t?5create?5clipper?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNPJBKDK@Can?8t?5attach?5Z?5buffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KKAKMMBC@Can?8t?5create?5a?53D?5device?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@BBAJPOFO@Can?8t?5get?5D3D?5device?5caps?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@EIHDCIDC@Can?8t?5create?5a?5viewport?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@IKPFMDJM@Can?8t?5attach?5viewport?5to?53D?5devi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DIBJAHNK@Can?8t?5set?5current?5viewport?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@OACKNBGO@Can?8t?5get?5gamma?5interface?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@CBIJDEPD@Can?8t?5restore?5primary?5display?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MDDLCIE@Can?8t?5restore?5zed?5buffer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FOMFOEKH@Can?8t?5create?5draw?5device?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@MILKILGM@Can?8t?5init?5draw?5device?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@EHJFHMNK@Can?8t?5create?5draw?5device?5?8?$CFs?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@MCKDEALE@Can?8t?5init?5draw?5device?5?8?$CFs?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PAPJPLGD@?$CFdx?$CFdx?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitDD@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitD3D@@YAHKKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetGamma@@YAXJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumZedBufferCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckSurfaces@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlipBuffers@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearBuffers@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFrontBufferRGB@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBackgroundColor@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseDX@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseD3D@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ErrorDX@@YAXJPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupDxState@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDrawDevices@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DisplayModesCallback@@YGJPAU_DDSURFACEDESC2@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?DxState@@3UDX_STATE@@A				; DxState
PUBLIC	?DD@@3PAUIDirectDraw4@@A			; DD
PUBLIC	?FrontBuffer@@3PAUIDirectDrawSurface4@@A	; FrontBuffer
PUBLIC	?BackBuffer@@3PAUIDirectDrawSurface4@@A		; BackBuffer
PUBLIC	?ZedBuffer@@3PAUIDirectDrawSurface4@@A		; ZedBuffer
PUBLIC	?GammaControl@@3PAUIDirectDrawGammaControl@@A	; GammaControl
PUBLIC	?D3D@@3PAUIDirect3D3@@A				; D3D
PUBLIC	?D3Ddevice@@3PAUIDirect3DDevice3@@A		; D3Ddevice
PUBLIC	?D3Dviewport@@3PAUIDirect3DViewport3@@A		; D3Dviewport
PUBLIC	?D3Dcaps@@3U_D3DDeviceDesc@@A			; D3Dcaps
PUBLIC	?ZedBufferFormat@@3U_DDPIXELFORMAT@@A		; ZedBufferFormat
PUBLIC	?ScreenXsize@@3KA				; ScreenXsize
PUBLIC	?ScreenYsize@@3KA				; ScreenYsize
PUBLIC	?ScreenBpp@@3KA					; ScreenBpp
PUBLIC	?ScreenRefresh@@3KA				; ScreenRefresh
PUBLIC	?GammaFlag@@3JA					; GammaFlag
PUBLIC	?NoColorKey@@3JA				; NoColorKey
PUBLIC	?DrawDeviceNum@@3JA				; DrawDeviceNum
PUBLIC	?CurrentDrawDevice@@3JA				; CurrentDrawDevice
PUBLIC	?DisplayModeCount@@3JA				; DisplayModeCount
PUBLIC	?RenderStateChange@@3JA				; RenderStateChange
PUBLIC	?TextureStateChange@@3JA			; TextureStateChange
PUBLIC	?DrawDevices@@3PAUDRAW_DEVICE@@A		; DrawDevices
PUBLIC	?RenderTP@@3FA					; RenderTP
PUBLIC	?RenderTP2@@3FA					; RenderTP2
PUBLIC	?RenderFog@@3FA					; RenderFog
PUBLIC	?RenderAlpha@@3FA				; RenderAlpha
PUBLIC	?RenderAlphaSrc@@3FA				; RenderAlphaSrc
PUBLIC	?RenderAlphaDest@@3FA				; RenderAlphaDest
PUBLIC	?RenderZcmp@@3FA				; RenderZcmp
PUBLIC	?RenderZwrite@@3FA				; RenderZwrite
PUBLIC	?RenderZbuffer@@3FA				; RenderZbuffer
PUBLIC	?DDcaps@@3U_DDCAPS_DX7@@A			; DDcaps
_BSS	SEGMENT
?DxState@@3UDX_STATE@@A DB 040H DUP (?)			; DxState
?DD@@3PAUIDirectDraw4@@A DD 01H DUP (?)			; DD
?FrontBuffer@@3PAUIDirectDrawSurface4@@A DD 01H DUP (?)	; FrontBuffer
?BackBuffer@@3PAUIDirectDrawSurface4@@A DD 01H DUP (?)	; BackBuffer
?ZedBuffer@@3PAUIDirectDrawSurface4@@A DD 01H DUP (?)	; ZedBuffer
?GammaControl@@3PAUIDirectDrawGammaControl@@A DD 01H DUP (?) ; GammaControl
?D3D@@3PAUIDirect3D3@@A DD 01H DUP (?)			; D3D
?D3Ddevice@@3PAUIDirect3DDevice3@@A DD 01H DUP (?)	; D3Ddevice
?D3Dviewport@@3PAUIDirect3DViewport3@@A DD 01H DUP (?)	; D3Dviewport
?D3Dcaps@@3U_D3DDeviceDesc@@A DB 0fcH DUP (?)		; D3Dcaps
?ZedBufferFormat@@3U_DDPIXELFORMAT@@A DB 020H DUP (?)	; ZedBufferFormat
?ScreenXsize@@3KA DD 01H DUP (?)			; ScreenXsize
?ScreenYsize@@3KA DD 01H DUP (?)			; ScreenYsize
?ScreenBpp@@3KA DD 01H DUP (?)				; ScreenBpp
?ScreenRefresh@@3KA DD 01H DUP (?)			; ScreenRefresh
?GammaFlag@@3JA DD 01H DUP (?)				; GammaFlag
?NoColorKey@@3JA DD 01H DUP (?)				; NoColorKey
?DrawDeviceNum@@3JA DD 01H DUP (?)			; DrawDeviceNum
?CurrentDrawDevice@@3JA DD 01H DUP (?)			; CurrentDrawDevice
?DisplayModeCount@@3JA DD 01H DUP (?)			; DisplayModeCount
?RenderStateChange@@3JA DD 01H DUP (?)			; RenderStateChange
?TextureStateChange@@3JA DD 01H DUP (?)			; TextureStateChange
?DrawDevices@@3PAUDRAW_DEVICE@@A DB 01398H DUP (?)	; DrawDevices
?RenderFog@@3FA DW 01H DUP (?)				; RenderFog
	ALIGN	4

?RenderAlpha@@3FA DW 01H DUP (?)			; RenderAlpha
	ALIGN	4

?DDcaps@@3U_DDCAPS_DX7@@A DB 017cH DUP (?)		; DDcaps
_BSS	ENDS
_DATA	SEGMENT
?RenderTP@@3FA DW 0ffffH				; RenderTP
	ORG $+2
?RenderTP2@@3FA DW 0ffffH				; RenderTP2
	ORG $+2
?RenderAlphaSrc@@3FA DW 0ffffH				; RenderAlphaSrc
	ORG $+2
?RenderAlphaDest@@3FA DW 0ffffH				; RenderAlphaDest
	ORG $+2
?RenderZbuffer@@3FA DW 01H				; RenderZbuffer
	ORG $+2
?RenderZwrite@@3FA DW 01H				; RenderZwrite
	ORG $+2
?RenderZcmp@@3FA DW 04H					; RenderZcmp
_DATA	ENDS
PUBLIC	?InitDD@@YAHXZ					; InitDD
PUBLIC	?ReleaseDX@@YAXXZ				; ReleaseDX
PUBLIC	?ErrorDX@@YAXJPAD@Z				; ErrorDX
PUBLIC	?CreateDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z ; CreateDrawDeviceCallback
PUBLIC	??_C@_0BJ@ODAMKNKP@Can?8t?5get?5DD?5device?5caps?$AA@ ; `string'
PUBLIC	??_C@_0BF@KLFHKCPI@Can?8t?5set?5coop?5level?$AA@ ; `string'
PUBLIC	??_C@_0BL@BOIMBCBG@DirectX?56?5is?5not?5installed?$AA@ ; `string'
EXTRN	_DirectDrawEnumerateA@8:NEAR
EXTRN	_memset:NEAR
EXTRN	?RegistrySettings@@3UREGISTRY_SETTINGS@@A:BYTE	; RegistrySettings
EXTRN	_IID_IDirect3D3:BYTE
EXTRN	?FullScreen@@3DA:BYTE				; FullScreen
EXTRN	?hwnd@@3PAUHWND__@@A:DWORD			; hwnd
_BSS	SEGMENT
_TotalScreenMem DD 01H DUP (?)
_TotalTexMem DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BJ@ODAMKNKP@Can?8t?5get?5DD?5device?5caps?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\dx.cpp
CONST	SEGMENT
??_C@_0BJ@ODAMKNKP@Can?8t?5get?5DD?5device?5caps?$AA@ DB 'Can''t get DD d'
	DB	'evice caps', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KLFHKCPI@Can?8t?5set?5coop?5level?$AA@
CONST	SEGMENT
??_C@_0BF@KLFHKCPI@Can?8t?5set?5coop?5level?$AA@ DB 'Can''t set coop leve'
	DB	'l', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BOIMBCBG@DirectX?56?5is?5not?5installed?$AA@
CONST	SEGMENT
??_C@_0BL@BOIMBCBG@DirectX?56?5is?5not?5installed?$AA@ DB 'DirectX 6 is n'
	DB	'ot installed', 00H				; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitDD@@YAHXZ
_TEXT	SEGMENT
_temp$ = -24						; size = 4
_ddscaps2$ = -20					; size = 16
_r$ = -4						; size = 4
?InitDD@@YAHXZ PROC NEAR				; InitDD, COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 58   : 	HRESULT r;
; 59   : 	DDSCAPS2 ddscaps2;
; 60   : 	DWORD temp;
; 61   : 
; 62   : // release
; 63   : 
; 64   : 	ReleaseDX();

	call	?ReleaseDX@@YAXXZ			; ReleaseDX

; 65   : 
; 66   : // create draw device
; 67   : 
; 68   : 	DirectDrawEnumerate(CreateDrawDeviceCallback, NULL);

	push	0
	push	OFFSET FLAT:?CreateDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z ; CreateDrawDeviceCallback
	call	_DirectDrawEnumerateA@8

; 69   : 	CurrentDrawDevice = RegistrySettings.DrawDevice;

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	mov	DWORD PTR ?CurrentDrawDevice@@3JA, eax	; CurrentDrawDevice

; 70   : 
; 71   : // get device caps
; 72   : 
; 73   : 	ZeroMemory(&DDcaps, sizeof(DDcaps));

	push	380					; 0000017cH
	push	0
	push	OFFSET FLAT:?DDcaps@@3U_DDCAPS_DX7@@A	; DDcaps
	call	_memset
	add	esp, 12					; 0000000cH

; 74   : 	DDcaps.dwSize = sizeof(DDcaps);

	mov	DWORD PTR ?DDcaps@@3U_DDCAPS_DX7@@A, 380 ; 0000017cH

; 75   : 
; 76   : 	r = DD->GetCaps(&DDcaps, NULL);

	push	0
	push	OFFSET FLAT:?DDcaps@@3U_DDCAPS_DX7@@A	; DDcaps
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR _r$[ebp], eax

; 77   : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80844

; 78   : 	{
; 79   : 		ErrorDX(r, "Can't get DD device caps");

	push	OFFSET FLAT:??_C@_0BJ@ODAMKNKP@Can?8t?5get?5DD?5device?5caps?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 80   : 		return FALSE;

	xor	eax, eax
	jmp	$L80840
$L80844:

; 81   : 	}
; 82   : 
; 83   : // get total screen / texture mem
; 84   : 
; 85   : 	ddscaps2.dwCaps = DDSCAPS_PRIMARYSURFACE;

	mov	DWORD PTR _ddscaps2$[ebp], 512		; 00000200H

; 86   : 	DD->GetAvailableVidMem(&ddscaps2, &TotalScreenMem, &temp);

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET FLAT:_TotalScreenMem
	lea	ecx, DWORD PTR _ddscaps2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	ecx
	call	DWORD PTR [eax+92]

; 87   : 
; 88   : 	ddscaps2.dwCaps = DDSCAPS_TEXTURE;

	mov	DWORD PTR _ddscaps2$[ebp], 4096		; 00001000H

; 89   : 	DD->GetAvailableVidMem(&ddscaps2, &TotalTexMem, &temp);

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET FLAT:_TotalTexMem
	lea	ecx, DWORD PTR _ddscaps2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	ecx
	call	DWORD PTR [eax+92]

; 90   : 
; 91   : // set exclusive mode
; 92   : 
; 93   : 	if (FullScreen)

	movsx	eax, BYTE PTR ?FullScreen@@3DA		; FullScreen
	test	eax, eax
	je	SHORT $L80846

; 94   : 	{
; 95   : 		r = DD->SetCooperativeLevel(hwnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_ALLOWMODEX | DDSCL_ALLOWREBOOT | DDSCL_FPUSETUP);

	push	2131					; 00000853H
	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+80]
	mov	DWORD PTR _r$[ebp], eax

; 96   : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80847

; 97   : 		{
; 98   : 			ErrorDX(r, "Can't set coop level");

	push	OFFSET FLAT:??_C@_0BF@KLFHKCPI@Can?8t?5set?5coop?5level?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 99   : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L80840
$L80847:

; 100  : 		}
; 101  : 	}
; 102  : 	else

	jmp	SHORT $L80849
$L80846:

; 103  : 	{
; 104  : 		r = DD->SetCooperativeLevel(hwnd, DDSCL_NORMAL | DDSCL_ALLOWREBOOT | DDSCL_FPUSETUP);

	push	2058					; 0000080aH
	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+80]
	mov	DWORD PTR _r$[ebp], eax

; 105  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80849

; 106  : 		{
; 107  : 			ErrorDX(r, "Can't set coop level");

	push	OFFSET FLAT:??_C@_0BF@KLFHKCPI@Can?8t?5set?5coop?5level?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 108  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L80840
$L80849:

; 109  : 		}
; 110  : 	}
; 111  : 
; 112  : // get 3D interface
; 113  : 
; 114  :     r = DD->QueryInterface(IID_IDirect3D3, (void**)&D3D);

	push	OFFSET FLAT:?D3D@@3PAUIDirect3D3@@A	; D3D
	push	OFFSET FLAT:_IID_IDirect3D3
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx]
	mov	DWORD PTR _r$[ebp], eax

; 115  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80852

; 116  : 	{
; 117  : 		ErrorDX(r, "DirectX 6 is not installed");

	push	OFFSET FLAT:??_C@_0BL@BOIMBCBG@DirectX?56?5is?5not?5installed?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 118  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L80840
$L80852:

; 119  : 	}
; 120  : 
; 121  : // return OK
; 122  : 
; 123  : 	return TRUE;

	mov	eax, 1
$L80840:

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitDD@@YAHXZ ENDP					; InitDD
_TEXT	ENDS
PUBLIC	??_C@_0BK@KKAKMMBC@Can?8t?5create?5a?53D?5device?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BK@BBAJPOFO@Can?8t?5get?5D3D?5device?5caps?$AA@ ; `string'
PUBLIC	??_C@_0BI@EIHDCIDC@Can?8t?5create?5a?5viewport?$AA@ ; `string'
PUBLIC	??_C@_0CD@IKPFMDJM@Can?8t?5attach?5viewport?5to?53D?5devi@ ; `string'
PUBLIC	??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@	; `string'
PUBLIC	??_C@_0BL@DIBJAHNK@Can?8t?5set?5current?5viewport?$AA@ ; `string'
PUBLIC	??_C@_0BK@OACKNBGO@Can?8t?5get?5gamma?5interface?$AA@ ; `string'
PUBLIC	?InitD3D@@YAHKKKK@Z				; InitD3D
PUBLIC	?ReleaseD3D@@YAXXZ				; ReleaseD3D
PUBLIC	?SetGamma@@YAXJJ@Z				; SetGamma
PUBLIC	?EnumZedBufferCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z ; EnumZedBufferCallback
PUBLIC	?FlipBuffers@@YAXXZ				; FlipBuffers
PUBLIC	?ClearBuffers@@YAXXZ				; ClearBuffers
PUBLIC	??_C@_0BG@MDMNHFKP@No?5Zbuffer?5available?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CA@KEBHFNBB@Can?8t?5set?5display?5mode?5?$CFdx?$CFdx?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BG@MAAKHPMF@Can?8t?5create?5Z?5buffer?$AA@ ; `string'
PUBLIC	??_C@_0BM@CMDHNOP@Can?8t?5create?5draw?5surfaces?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BK@BHOIBHJB@Can?8t?5attach?5back?5buffer?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BO@BEGHCBBH@Can?8t?5create?5primary?5surface?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BK@GGNLDEBA@Can?8t?5create?5back?5buffer?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BG@BLIKGNAJ@Can?8t?5create?5clipper?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BG@CNPJBKDK@Can?8t?5attach?5Z?5buffer?$AA@ ; `string'
EXTRN	_IID_IDirectDrawGammaControl:BYTE
EXTRN	__fltused:NEAR
EXTRN	?ViewportRect@@3U_D3DRECT@@A:BYTE		; ViewportRect
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	_IID_IDirect3DHALDevice:BYTE
EXTRN	__imp__wsprintfA:NEAR
EXTRN	?NoGamma@@3DA:BYTE				; NoGamma
_BSS	SEGMENT
_BackgroundColor DD 01H DUP (?)
_PolyClear DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BG@MDMNHFKP@No?5Zbuffer?5available?$CB?$AA@
CONST	SEGMENT
??_C@_0BG@MDMNHFKP@No?5Zbuffer?5available?$CB?$AA@ DB 'No Zbuffer availab'
	DB	'le!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KEBHFNBB@Can?8t?5set?5display?5mode?5?$CFdx?$CFdx?$CFd?$AA@
CONST	SEGMENT
??_C@_0CA@KEBHFNBB@Can?8t?5set?5display?5mode?5?$CFdx?$CFdx?$CFd?$AA@ DB 'C'
	DB	'an''t set display mode %dx%dx%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MAAKHPMF@Can?8t?5create?5Z?5buffer?$AA@
CONST	SEGMENT
??_C@_0BG@MAAKHPMF@Can?8t?5create?5Z?5buffer?$AA@ DB 'Can''t create Z buf'
	DB	'fer', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CMDHNOP@Can?8t?5create?5draw?5surfaces?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@CMDHNOP@Can?8t?5create?5draw?5surfaces?$CB?$AA@ DB 'Can''t crea'
	DB	'te draw surfaces!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BHOIBHJB@Can?8t?5attach?5back?5buffer?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@BHOIBHJB@Can?8t?5attach?5back?5buffer?$CB?$AA@ DB 'Can''t attac'
	DB	'h back buffer!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BEGHCBBH@Can?8t?5create?5primary?5surface?$CB?$AA@
CONST	SEGMENT
??_C@_0BO@BEGHCBBH@Can?8t?5create?5primary?5surface?$CB?$AA@ DB 'Can''t c'
	DB	'reate primary surface!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GGNLDEBA@Can?8t?5create?5back?5buffer?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@GGNLDEBA@Can?8t?5create?5back?5buffer?$CB?$AA@ DB 'Can''t creat'
	DB	'e back buffer!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BLIKGNAJ@Can?8t?5create?5clipper?$CB?$AA@
CONST	SEGMENT
??_C@_0BG@BLIKGNAJ@Can?8t?5create?5clipper?$CB?$AA@ DB 'Can''t create cli'
	DB	'pper!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNPJBKDK@Can?8t?5attach?5Z?5buffer?$AA@
CONST	SEGMENT
??_C@_0BG@CNPJBKDK@Can?8t?5attach?5Z?5buffer?$AA@ DB 'Can''t attach Z buf'
	DB	'fer', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KKAKMMBC@Can?8t?5create?5a?53D?5device?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@KKAKMMBC@Can?8t?5create?5a?53D?5device?$CB?$AA@ DB 'Can''t crea'
	DB	'te a 3D device!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BBAJPOFO@Can?8t?5get?5D3D?5device?5caps?$AA@
CONST	SEGMENT
??_C@_0BK@BBAJPOFO@Can?8t?5get?5D3D?5device?5caps?$AA@ DB 'Can''t get D3D'
	DB	' device caps', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EIHDCIDC@Can?8t?5create?5a?5viewport?$AA@
CONST	SEGMENT
??_C@_0BI@EIHDCIDC@Can?8t?5create?5a?5viewport?$AA@ DB 'Can''t create a v'
	DB	'iewport', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IKPFMDJM@Can?8t?5attach?5viewport?5to?53D?5devi@
CONST	SEGMENT
??_C@_0CD@IKPFMDJM@Can?8t?5attach?5viewport?5to?53D?5devi@ DB 'Can''t att'
	DB	'ach viewport to 3D device', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@
CONST	SEGMENT
??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@ DB 'Can''t set viewport', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DIBJAHNK@Can?8t?5set?5current?5viewport?$AA@
CONST	SEGMENT
??_C@_0BL@DIBJAHNK@Can?8t?5set?5current?5viewport?$AA@ DB 'Can''t set cur'
	DB	'rent viewport', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OACKNBGO@Can?8t?5get?5gamma?5interface?$AA@
CONST	SEGMENT
??_C@_0BK@OACKNBGO@Can?8t?5get?5gamma?5interface?$AA@ DB 'Can''t get gamm'
	DB	'a interface', 00H				; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitD3D@@YAHKKKK@Z
_TEXT	SEGMENT
tv571 = -920						; size = 8
tv567 = -920						; size = 8
__f$80921 = -848					; size = 4
_buf$ = -844						; size = 128
_clipper$ = -716					; size = 4
_hel$ = -712						; size = 252
_hal$ = -460						; size = 252
_vd$ = -208						; size = 44
_ddscaps2$ = -164					; size = 16
_ddsd2$ = -148						; size = 124
_r$ = -24						; size = 4
_time2$ = -20						; size = 4
_time1$ = -16						; size = 4
_end$ = -12						; size = 4
_start$ = -8						; size = 4
_i$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_bpp$ = 16						; size = 4
_refresh$ = 20						; size = 4
?InitD3D@@YAHKKKK@Z PROC NEAR				; InitD3D, COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 920				; 00000398H
	push	ebx
	push	esi
	push	edi

; 132  : 	long i, start, end, time1, time2;
; 133  : 	HRESULT r;
; 134  : 	DDSURFACEDESC2 ddsd2;
; 135  : 	DDSCAPS2 ddscaps2;
; 136  : 	D3DVIEWPORT2 vd;
; 137  : 	D3DDEVICEDESC hal, hel;
; 138  : 	IDirectDrawClipper *clipper;
; 139  : 	char buf[128];
; 140  : 
; 141  : // release
; 142  : 
; 143  : 	ReleaseD3D();

	call	?ReleaseD3D@@YAXXZ			; ReleaseD3D

; 144  : 
; 145  : // set screen params
; 146  : 
; 147  : 	ScreenXsize = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR ?ScreenXsize@@3KA, eax	; ScreenXsize

; 148  : 	ScreenYsize = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR ?ScreenYsize@@3KA, eax	; ScreenYsize

; 149  : 	ScreenBpp = bpp;

	mov	eax, DWORD PTR _bpp$[ebp]
	mov	DWORD PTR ?ScreenBpp@@3KA, eax		; ScreenBpp

; 150  : 	ScreenRefresh = refresh;

	mov	eax, DWORD PTR _refresh$[ebp]
	mov	DWORD PTR ?ScreenRefresh@@3KA, eax	; ScreenRefresh

; 151  : 
; 152  : // enumerate z buffer formats
; 153  : 
; 154  : 	ZeroMemory(&ZedBufferFormat, sizeof(ZedBufferFormat));

	push	32					; 00000020H
	push	0
	push	OFFSET FLAT:?ZedBufferFormat@@3U_DDPIXELFORMAT@@A ; ZedBufferFormat
	call	_memset
	add	esp, 12					; 0000000cH

; 155  : 	D3D->EnumZBufferFormats(IID_IDirect3DHALDevice, EnumZedBufferCallback, NULL);

	push	0
	push	OFFSET FLAT:?EnumZedBufferCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z ; EnumZedBufferCallback
	push	OFFSET FLAT:_IID_IDirect3DHALDevice
	mov	eax, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	push	edx
	call	DWORD PTR [ecx+40]

; 156  : 	if (!ZedBufferFormat.dwZBufferBitDepth)

	cmp	DWORD PTR ?ZedBufferFormat@@3U_DDPIXELFORMAT@@A+12, 0
	jne	SHORT $L80873

; 157  : 	{
; 158  : 		Box(NULL, "No Zbuffer available!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0BG@MDMNHFKP@No?5Zbuffer?5available?$CB?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 159  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80873:

; 160  : 	}
; 161  : 
; 162  : // set screen mode
; 163  : 
; 164  : 	if (FullScreen)

	movsx	eax, BYTE PTR ?FullScreen@@3DA		; FullScreen
	test	eax, eax
	je	SHORT $L80875

; 165  : 	{
; 166  : 		r = DD->SetDisplayMode(ScreenXsize, ScreenYsize, ScreenBpp, ScreenRefresh, 0);

	push	0
	mov	eax, DWORD PTR ?ScreenRefresh@@3KA	; ScreenRefresh
	push	eax
	mov	ecx, DWORD PTR ?ScreenBpp@@3KA		; ScreenBpp
	push	ecx
	mov	edx, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	push	edx
	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+84]
	mov	DWORD PTR _r$[ebp], eax

; 167  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80875

; 168  : 		{
; 169  : 			wsprintf(buf, "Can't set display mode %dx%dx%d", ScreenXsize, ScreenYsize, ScreenBpp);

	mov	eax, DWORD PTR ?ScreenBpp@@3KA		; ScreenBpp
	push	eax
	mov	ecx, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	push	ecx
	mov	edx, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	push	edx
	push	OFFSET FLAT:??_C@_0CA@KEBHFNBB@Can?8t?5set?5display?5mode?5?$CFdx?$CFdx?$CFd?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 170  : 			ErrorDX(r, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 171  : 			return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80875:

; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : // create Z buffer first
; 176  : 
; 177  : 	ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 178  : 	ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 179  : 	ddsd2.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_PIXELFORMAT;

	mov	DWORD PTR _ddsd2$[ebp+4], 4103		; 00001007H

; 180  : 	ddsd2.dwWidth = ScreenXsize;

	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 181  : 	ddsd2.dwHeight = ScreenYsize;

	mov	eax, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 182  : 	ddsd2.ddsCaps.dwCaps = DDSCAPS_ZBUFFER | DDSCAPS_VIDEOMEMORY;

	mov	DWORD PTR _ddsd2$[ebp+104], 147456	; 00024000H

; 183  : 	ddsd2.ddsCaps.dwCaps2 = 0;

	mov	DWORD PTR _ddsd2$[ebp+108], 0

; 184  : 	ddsd2.ddpfPixelFormat = ZedBufferFormat;

	mov	ecx, 8
	mov	esi, OFFSET FLAT:?ZedBufferFormat@@3U_DDPIXELFORMAT@@A ; ZedBufferFormat
	lea	edi, DWORD PTR _ddsd2$[ebp+72]
	rep movsd

; 185  : 
; 186  : 	r = DD->CreateSurface(&ddsd2, &ZedBuffer, NULL);

	push	0
	push	OFFSET FLAT:?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 187  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80878

; 188  : 	{
; 189  : 		ErrorDX(r, "Can't create Z buffer");

	push	OFFSET FLAT:??_C@_0BG@MAAKHPMF@Can?8t?5create?5Z?5buffer?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 190  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80878:

; 191  : 	}
; 192  : 
; 193  : // create front buffer with 1 or 2 back buffers
; 194  : 
; 195  : 	if (FullScreen)

	movsx	eax, BYTE PTR ?FullScreen@@3DA		; FullScreen
	test	eax, eax
	je	$L80880

; 196  : 	{
; 197  : 		ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 198  : 		ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 199  : 		ddsd2.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;

	mov	DWORD PTR _ddsd2$[ebp+4], 33		; 00000021H

; 200  : 		ddsd2.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_3DDEVICE | DDSCAPS_VIDEOMEMORY;

	mov	DWORD PTR _ddsd2$[ebp+104], 25112	; 00006218H

; 201  : 		ddsd2.ddsCaps.dwCaps2 = 0;

	mov	DWORD PTR _ddsd2$[ebp+108], 0

; 202  :  
; 203  : 		ddsd2.dwBackBufferCount = 2;

	mov	DWORD PTR _ddsd2$[ebp+20], 2

; 204  : 		r = DD->CreateSurface(&ddsd2, &FrontBuffer, NULL);

	push	0
	push	OFFSET FLAT:?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 205  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80881

; 206  : 		{
; 207  : 			ddsd2.dwBackBufferCount = 1;

	mov	DWORD PTR _ddsd2$[ebp+20], 1

; 208  : 			r = DD->CreateSurface(&ddsd2, &FrontBuffer, NULL);

	push	0
	push	OFFSET FLAT:?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 209  : 			if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80881

; 210  : 			{
; 211  : 				ErrorDX(r, "Can't create draw surfaces!");

	push	OFFSET FLAT:??_C@_0BM@CMDHNOP@Can?8t?5create?5draw?5surfaces?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 212  : 				return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80881:

; 213  : 			}
; 214  : 		}
; 215  : 
; 216  : 		ddscaps2.dwCaps = DDSCAPS_BACKBUFFER;

	mov	DWORD PTR _ddscaps2$[ebp], 4

; 217  : 		r = FrontBuffer->GetAttachedSurface(&ddscaps2, &BackBuffer);

	push	OFFSET FLAT:?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	lea	eax, DWORD PTR _ddscaps2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	eax
	call	DWORD PTR [edx+48]
	mov	DWORD PTR _r$[ebp], eax

; 218  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80884

; 219  : 		{
; 220  : 			ErrorDX(r, "Can't attach back buffer!");

	push	OFFSET FLAT:??_C@_0BK@BHOIBHJB@Can?8t?5attach?5back?5buffer?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 221  : 			return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80884:

; 222  : 		}
; 223  : 	}
; 224  : 	else

	jmp	$L80886
$L80880:

; 225  : 	{
; 226  : 		ZeroMemory(&ddsd2, sizeof(ddsd2));

	push	124					; 0000007cH
	push	0
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 227  : 		ddsd2.dwSize = sizeof(ddsd2);

	mov	DWORD PTR _ddsd2$[ebp], 124		; 0000007cH

; 228  : 		ddsd2.dwFlags = DDSD_CAPS;

	mov	DWORD PTR _ddsd2$[ebp+4], 1

; 229  : 		ddsd2.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_VIDEOMEMORY;

	mov	DWORD PTR _ddsd2$[ebp+104], 16896	; 00004200H

; 230  : 		ddsd2.ddsCaps.dwCaps2 = 0;

	mov	DWORD PTR _ddsd2$[ebp+108], 0

; 231  : 
; 232  : 		r = DD->CreateSurface(&ddsd2, &FrontBuffer, NULL);

	push	0
	push	OFFSET FLAT:?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 233  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80887

; 234  : 		{
; 235  : 			ErrorDX(r, "Can't create primary surface!");

	push	OFFSET FLAT:??_C@_0BO@BEGHCBBH@Can?8t?5create?5primary?5surface?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 236  : 			return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80887:

; 237  : 		}
; 238  : 
; 239  : 		ddsd2.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;

	mov	DWORD PTR _ddsd2$[ebp+4], 7

; 240  : 		ddsd2.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE | DDSCAPS_VIDEOMEMORY;

	mov	DWORD PTR _ddsd2$[ebp+104], 24640	; 00006040H

; 241  : 		ddsd2.dwWidth = ScreenXsize;

	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR _ddsd2$[ebp+12], eax

; 242  : 		ddsd2.dwHeight = ScreenYsize;

	mov	eax, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR _ddsd2$[ebp+8], eax

; 243  : 
; 244  : 		r = DD->CreateSurface(&ddsd2, &BackBuffer, NULL);

	push	0
	push	OFFSET FLAT:?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	lea	eax, DWORD PTR _ddsd2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+24]
	mov	DWORD PTR _r$[ebp], eax

; 245  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80889

; 246  : 		{
; 247  : 			ErrorDX(r, "Can't create back buffer!");

	push	OFFSET FLAT:??_C@_0BK@GGNLDEBA@Can?8t?5create?5back?5buffer?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 248  : 			return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80889:

; 249  : 		}
; 250  : 
; 251  : 		r = DD->CreateClipper(0, &clipper, NULL);

	push	0
	lea	eax, DWORD PTR _clipper$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _r$[ebp], eax

; 252  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80891

; 253  : 		{
; 254  : 			ErrorDX(r, "Can't create clipper!");

	push	OFFSET FLAT:??_C@_0BG@BLIKGNAJ@Can?8t?5create?5clipper?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 255  : 			return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80891:

; 256  : 		}
; 257  : 
; 258  : 		clipper->SetHWnd(0, hwnd);

	mov	eax, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	eax
	push	0
	mov	ecx, DWORD PTR _clipper$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _clipper$[ebp]
	push	eax
	call	DWORD PTR [edx+32]

; 259  : 		FrontBuffer->SetClipper(clipper);

	mov	eax, DWORD PTR _clipper$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	eax
	call	DWORD PTR [edx+112]

; 260  : 		RELEASE(clipper);

	cmp	DWORD PTR _clipper$[ebp], 0
	je	SHORT $L80886
	mov	eax, DWORD PTR _clipper$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _clipper$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR _clipper$[ebp], 0
$L80886:

; 261  : 	}
; 262  : 
; 263  : // attach Z buffer
; 264  : 
; 265  : 	r = BackBuffer->AddAttachedSurface(ZedBuffer);

	mov	eax, DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	push	eax
	mov	ecx, DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	push	eax
	call	DWORD PTR [edx+12]
	mov	DWORD PTR _r$[ebp], eax

; 266  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80894

; 267  : 	{
; 268  : 		ErrorDX(r, "Can't attach Z buffer");

	push	OFFSET FLAT:??_C@_0BG@CNPJBKDK@Can?8t?5attach?5Z?5buffer?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 269  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80894:

; 270  : 	}
; 271  : 
; 272  : // create D3D device
; 273  : 
; 274  : 	r = D3D->CreateDevice(IID_IDirect3DHALDevice, BackBuffer, &D3Ddevice, NULL);

	push	0
	push	OFFSET FLAT:?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	eax, DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	push	eax
	push	OFFSET FLAT:_IID_IDirect3DHALDevice
	mov	ecx, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	push	eax
	call	DWORD PTR [edx+32]
	mov	DWORD PTR _r$[ebp], eax

; 275  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80896

; 276  : 	{
; 277  : 		ErrorDX(r, "Can't create a 3D device!");

	push	OFFSET FLAT:??_C@_0BK@KKAKMMBC@Can?8t?5create?5a?53D?5device?$CB?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 278  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80896:

; 279  : 	}
; 280  : 
; 281  : // get D3D device caps
; 282  : 
; 283  : 	ZeroMemory(&hal, sizeof(hal));

	push	252					; 000000fcH
	push	0
	lea	eax, DWORD PTR _hal$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 284  : 	hal.dwSize = sizeof(hal);

	mov	DWORD PTR _hal$[ebp], 252		; 000000fcH

; 285  : 
; 286  : 	ZeroMemory(&hel, sizeof(hel));

	push	252					; 000000fcH
	push	0
	lea	eax, DWORD PTR _hel$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 287  : 	hel.dwSize = sizeof(hel);

	mov	DWORD PTR _hel$[ebp], 252		; 000000fcH

; 288  : 
; 289  : 	r = D3Ddevice->GetCaps(&hal, &hel);

	lea	eax, DWORD PTR _hel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _hal$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	ecx
	call	DWORD PTR [eax+12]
	mov	DWORD PTR _r$[ebp], eax

; 290  : 
; 291  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80898

; 292  : 	{
; 293  : 		ErrorDX(r, "Can't get D3D device caps");

	push	OFFSET FLAT:??_C@_0BK@BBAJPOFO@Can?8t?5get?5D3D?5device?5caps?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 294  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80898:

; 295  : 	}
; 296  : 
; 297  : 	D3Dcaps = hal;

	mov	ecx, 63					; 0000003fH
	lea	esi, DWORD PTR _hal$[ebp]
	mov	edi, OFFSET FLAT:?D3Dcaps@@3U_D3DDeviceDesc@@A ; D3Dcaps
	rep movsd

; 298  : 
; 299  : // create / setup viewport
; 300  : 
; 301  : 	r = D3D->CreateViewport(&D3Dviewport, NULL);

	push	0
	push	OFFSET FLAT:?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	mov	eax, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	push	edx
	call	DWORD PTR [ecx+24]
	mov	DWORD PTR _r$[ebp], eax

; 302  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80900

; 303  : 	{
; 304  : 		ErrorDX(r, "Can't create a viewport");

	push	OFFSET FLAT:??_C@_0BI@EIHDCIDC@Can?8t?5create?5a?5viewport?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 305  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80900:

; 306  : 	}
; 307  : 
; 308  : 	r = D3Ddevice->AddViewport(D3Dviewport);

	mov	eax, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	push	eax
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+20]
	mov	DWORD PTR _r$[ebp], eax

; 309  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80902

; 310  : 	{
; 311  : 		ErrorDX(r, "Can't attach viewport to 3D device");

	push	OFFSET FLAT:??_C@_0CD@IKPFMDJM@Can?8t?5attach?5viewport?5to?53D?5devi@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 312  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80902:

; 313  : 	}
; 314  : 
; 315  : 	ZeroMemory(&vd, sizeof(vd));

	push	44					; 0000002cH
	push	0
	lea	eax, DWORD PTR _vd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 316  : 	vd.dwSize = sizeof(vd);

	mov	DWORD PTR _vd$[ebp], 44			; 0000002cH

; 317  : 	vd.dwX = 0;

	mov	DWORD PTR _vd$[ebp+4], 0

; 318  : 	vd.dwY = 0;

	mov	DWORD PTR _vd$[ebp+8], 0

; 319  :     vd.dwWidth = ScreenXsize;

	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR _vd$[ebp+12], eax

; 320  :     vd.dwHeight = ScreenYsize;

	mov	eax, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR _vd$[ebp+16], eax

; 321  : 
; 322  :     vd.dvClipX = 0;

	mov	DWORD PTR _vd$[ebp+20], 0

; 323  :     vd.dvClipY = 0;

	mov	DWORD PTR _vd$[ebp+24], 0

; 324  :     vd.dvClipWidth = (float)ScreenXsize;

	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR tv567[ebp], eax
	mov	DWORD PTR tv567[ebp+4], 0
	fild	QWORD PTR tv567[ebp]
	fstp	DWORD PTR _vd$[ebp+28]

; 325  :     vd.dvClipHeight = (float)ScreenYsize;

	mov	eax, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR tv571[ebp], eax
	mov	DWORD PTR tv571[ebp+4], 0
	fild	QWORD PTR tv571[ebp]
	fstp	DWORD PTR _vd$[ebp+32]

; 326  :     vd.dvMinZ = 0;

	mov	DWORD PTR _vd$[ebp+36], 0

; 327  :     vd.dvMaxZ = 1;

	mov	DWORD PTR _vd$[ebp+40], 1065353216	; 3f800000H

; 328  : 
; 329  :     r = D3Dviewport->SetViewport2(&vd);

	lea	eax, DWORD PTR _vd$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	push	eax
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _r$[ebp], eax

; 330  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80906

; 331  : 	{
; 332  : 		ErrorDX(r, "Can't set viewport");

	push	OFFSET FLAT:??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 333  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80906:

; 334  : 	}
; 335  : 
; 336  :     r = D3Ddevice->SetCurrentViewport(D3Dviewport);

	mov	eax, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	push	eax
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+48]
	mov	DWORD PTR _r$[ebp], eax

; 337  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80908

; 338  : 	{
; 339  : 		ErrorDX(r, "Can't set current viewport");

	push	OFFSET FLAT:??_C@_0BL@DIBJAHNK@Can?8t?5set?5current?5viewport?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 340  : 		return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80908:

; 341  : 	}
; 342  : 
; 343  : // get gamma control interface
; 344  : 
; 345  : 	if (NoGamma | !(DDcaps.dwCaps2 & DDCAPS2_PRIMARYGAMMA))

	movsx	eax, BYTE PTR ?NoGamma@@3DA		; NoGamma
	mov	ecx, DWORD PTR ?DDcaps@@3U_DDCAPS_DX7@@A+8
	and	ecx, 131072				; 00020000H
	neg	ecx
	sbb	ecx, ecx
	inc	ecx
	or	eax, ecx
	je	SHORT $L80910

; 346  : 	{
; 347  : 		GammaFlag = GAMMA_UNAVAILABLE;

	mov	DWORD PTR ?GammaFlag@@3JA, 0		; GammaFlag

; 348  : 	}
; 349  : 	else

	jmp	SHORT $L80911
$L80910:

; 350  : 	{
; 351  : 	    r = FrontBuffer->QueryInterface(IID_IDirectDrawGammaControl, (void**)&GammaControl);

	push	OFFSET FLAT:?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	push	OFFSET FLAT:_IID_IDirectDrawGammaControl
	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	edx
	call	DWORD PTR [ecx]
	mov	DWORD PTR _r$[ebp], eax

; 352  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80913

; 353  : 		{
; 354  : 			ErrorDX(r, "Can't get gamma interface");

	push	OFFSET FLAT:??_C@_0BK@OACKNBGO@Can?8t?5get?5gamma?5interface?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 355  : 			return FALSE;

	xor	eax, eax
	jmp	$L80859
$L80913:

; 356  : 		}
; 357  : 
; 358  : //		if (DDcaps.dwCaps2 & DDCAPS2_CANCALIBRATEGAMMA)
; 359  : //			GammaFlag = GAMMA_AUTO;
; 360  : //		else
; 361  : 			GammaFlag = GAMMA_AVAILABLE;

	mov	DWORD PTR ?GammaFlag@@3JA, 1		; GammaFlag

; 362  : 
; 363  : 		SetGamma(RegistrySettings.Brightness, RegistrySettings.Contrast);

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+52
	push	eax
	mov	ecx, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+48
	push	ecx
	call	?SetGamma@@YAXJJ@Z			; SetGamma
	add	esp, 8
$L80911:

; 364  : 	}
; 365  : 
; 366  : // decide screen / zbuffer clear technique
; 367  : 
; 368  : 	BackgroundColor = 0x000000;

	mov	DWORD PTR _BackgroundColor, 0

; 369  : 	ViewportRect.x1 = 0;

	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A, 0

; 370  : 	ViewportRect.y1 = 0;

	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+4, 0

; 371  : 	ViewportRect.x2 = ScreenXsize;

	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+8, eax

; 372  : 	ViewportRect.y2 = ScreenYsize;

	mov	eax, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+12, eax

; 373  : 
; 374  : 	PolyClear = FALSE;

	mov	DWORD PTR _PolyClear, 0

; 375  : 	start = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR _start$[ebp], eax

; 376  : 
; 377  : 	for (i = 0 ; i < 50 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L80915
$L80916:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L80915:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	SHORT $L80917

; 378  : 	{
; 379  : 		FlipBuffers();

	call	?FlipBuffers@@YAXXZ			; FlipBuffers

; 380  : 		ClearBuffers();

	call	?ClearBuffers@@YAXXZ			; ClearBuffers

; 381  : 	}

	jmp	SHORT $L80916
$L80917:

; 382  : 
; 383  : 	end = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR _end$[ebp], eax

; 384  : 	time1 = end - start;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _time1$[ebp], eax

; 385  : 
; 386  : 	PolyClear = TRUE;

	mov	DWORD PTR _PolyClear, 1

; 387  : 	start = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR _start$[ebp], eax

; 388  : 
; 389  : 	for (i = 0 ; i < 50 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L80918
$L80919:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L80918:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	SHORT $L80920

; 390  : 	{
; 391  : 		FlipBuffers();

	call	?FlipBuffers@@YAXXZ			; FlipBuffers

; 392  : 		ClearBuffers();

	call	?ClearBuffers@@YAXXZ			; ClearBuffers

; 393  : 	}

	jmp	SHORT $L80919
$L80920:

; 394  : 
; 395  : 	end = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR _end$[ebp], eax

; 396  : 	time2 = end - start;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _time2$[ebp], eax

; 397  : 
; 398  : 	PolyClear = (time2 < time1);

	mov	eax, DWORD PTR _time2$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _time1$[ebp]
	setl	cl
	mov	DWORD PTR _PolyClear, ecx

; 399  : 
; 400  : // set misc render states
; 401  : 
; 402  : 	CULL_OFF();

	push	1
	push	22					; 00000016H
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 403  : 	SPECULAR_OFF();

	push	0
	push	29					; 0000001dH
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 404  : 	TEXTURE_ADDRESS(D3DTADDRESS_CLAMP);

	push	3
	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	3
	push	12					; 0000000cH
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 405  : 	MIPMAP_LODBIAS(-0.02f);

	mov	DWORD PTR __f$80921[ebp], -1130113270	; bca3d70aH
	mov	eax, DWORD PTR __f$80921[ebp]
	push	eax
	push	19					; 00000013H
	push	0
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	mov	eax, DWORD PTR __f$80921[ebp]
	push	eax
	push	19					; 00000013H
	push	1
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 406  : 
; 407  : // return ok
; 408  : 
; 409  : 	return TRUE;

	mov	eax, 1
$L80859:

; 410  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitD3D@@YAHKKKK@Z ENDP				; InitD3D
_TEXT	ENDS
PUBLIC	__real@43800000
PUBLIC	__real@43000000
PUBLIC	__real@00000000
PUBLIC	__real@477fff00
EXTRN	__ftol2:NEAR
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SetGamma@@YAXJJ@Z
_TEXT	SEGMENT
_ramp$ = -1552						; size = 1536
_n$ = -16						; size = 4
_middle$ = -12						; size = 4
_step$ = -8						; size = 4
_i$ = -4						; size = 4
_brightness$ = 8					; size = 4
_contrast$ = 12						; size = 4
?SetGamma@@YAXJJ@Z PROC NEAR				; SetGamma, COMDAT

; 417  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1616				; 00000650H
	push	ebx
	push	esi
	push	edi

; 418  : 	long i;
; 419  : 	float step, middle, n;
; 420  : 	DDGAMMARAMP ramp;
; 421  : 
; 422  : // skip if no gamma control
; 423  : 
; 424  : 	if (GammaFlag == GAMMA_UNAVAILABLE)

	cmp	DWORD PTR ?GammaFlag@@3JA, 0		; GammaFlag
	jne	SHORT $L80933

; 425  : 		return;

	jmp	$L80927
$L80933:

; 426  : 
; 427  : // set gamma table
; 428  : 
; 429  : 	step = (float)brightness * (float)contrast / 256.0f;

	fild	DWORD PTR _brightness$[ebp]
	fimul	DWORD PTR _contrast$[ebp]
	fdiv	DWORD PTR __real@43800000
	fstp	DWORD PTR _step$[ebp]

; 430  : 	middle = (float)brightness * 128.0f;

	fild	DWORD PTR _brightness$[ebp]
	fmul	DWORD PTR __real@43000000
	fstp	DWORD PTR _middle$[ebp]

; 431  : 
; 432  : 	for (i = 0 ; i < 256 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L80937
$L80938:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L80937:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$L80939

; 433  : 	{
; 434  : 		n = ((float)i - 128.0f) * step + middle;

	fild	DWORD PTR _i$[ebp]
	fsub	DWORD PTR __real@43000000
	fmul	DWORD PTR _step$[ebp]
	fadd	DWORD PTR _middle$[ebp]
	fstp	DWORD PTR _n$[ebp]

; 435  : 
; 436  : 		if (n < 0) n = 0;

	fld	DWORD PTR _n$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L80941
	mov	DWORD PTR _n$[ebp], 0

; 437  : 		else if (n > 65535.0f) n = 65535.0f;

	jmp	SHORT $L80942
$L80941:
	fld	DWORD PTR _n$[ebp]
	fcomp	DWORD PTR __real@477fff00
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L80942
	mov	DWORD PTR _n$[ebp], 1199570688		; 477fff00H
$L80942:

; 438  : 
; 439  : 		ramp.red[i] = (WORD)n;

	fld	DWORD PTR _n$[ebp]
	call	__ftol2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	WORD PTR _ramp$[ebp+ecx*2], ax

; 440  : 		ramp.green[i] = (WORD)n;

	fld	DWORD PTR _n$[ebp]
	call	__ftol2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	WORD PTR _ramp$[ebp+ecx*2+512], ax

; 441  : 		ramp.blue[i] = (WORD)n;

	fld	DWORD PTR _n$[ebp]
	call	__ftol2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	WORD PTR _ramp$[ebp+ecx*2+1024], ax

; 442  : 	}

	jmp	$L80938
$L80939:

; 443  : 
; 444  : 	if (GammaFlag == GAMMA_AUTO)

	cmp	DWORD PTR ?GammaFlag@@3JA, 2		; GammaFlag
	jne	SHORT $L80947

; 445  : 		GammaControl->SetGammaRamp(DDSGR_CALIBRATE, &ramp);

	lea	eax, DWORD PTR _ramp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	push	eax
	call	DWORD PTR [edx+16]

; 446  : 	else

	jmp	SHORT $L80927
$L80947:

; 447  : 		GammaControl->SetGammaRamp(0, &ramp);

	lea	eax, DWORD PTR _ramp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	push	eax
	call	DWORD PTR [edx+16]
$L80927:

; 448  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetGamma@@YAXJJ@Z ENDP					; SetGamma
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?EnumZedBufferCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z
_TEXT	SEGMENT
_ddpf$ = 8						; size = 4
_user$ = 12						; size = 4
?EnumZedBufferCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z PROC NEAR ; EnumZedBufferCallback, COMDAT

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 456  : 
; 457  : // skip if null format
; 458  : 
; 459  : 	if (!ddpf)

	cmp	DWORD PTR _ddpf$[ebp], 0
	jne	SHORT $L80953

; 460  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	SHORT $L80952
$L80953:

; 461  : 
; 462  : // skip if not a zbuffer!
; 463  : 
; 464  : 	if (ddpf->dwFlags != DDPF_ZBUFFER)

	mov	eax, DWORD PTR _ddpf$[ebp]
	cmp	DWORD PTR [eax+4], 1024			; 00000400H
	je	SHORT $L80954

; 465  : 		return DDENUMRET_OK;

	mov	eax, 1
	jmp	SHORT $L80952
$L80954:

; 466  : 
; 467  : // take if we haven't got one
; 468  : 
; 469  : 	if (!ZedBufferFormat.dwZBufferBitDepth)

	cmp	DWORD PTR ?ZedBufferFormat@@3U_DDPIXELFORMAT@@A+12, 0
	jne	SHORT $L80955

; 470  : 	{
; 471  : 		ZedBufferFormat = *ddpf;

	mov	esi, DWORD PTR _ddpf$[ebp]
	mov	ecx, 8
	mov	edi, OFFSET FLAT:?ZedBufferFormat@@3U_DDPIXELFORMAT@@A ; ZedBufferFormat
	rep movsd

; 472  : 		return DDENUMRET_OK;

	mov	eax, 1
	jmp	SHORT $L80952
$L80955:

; 473  : 	}
; 474  : 
; 475  : // take if better than currently got
; 476  : 
; 477  : 	if (ddpf->dwZBufferBitDepth == 16)

	mov	eax, DWORD PTR _ddpf$[ebp]
	cmp	DWORD PTR [eax+12], 16			; 00000010H
	jne	SHORT $L80956

; 478  : 	{
; 479  : 		ZedBufferFormat = *ddpf;

	mov	esi, DWORD PTR _ddpf$[ebp]
	mov	ecx, 8
	mov	edi, OFFSET FLAT:?ZedBufferFormat@@3U_DDPIXELFORMAT@@A ; ZedBufferFormat
	rep movsd

; 480  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	SHORT $L80952
$L80956:

; 481  : 	}
; 482  : 
; 483  : // next please
; 484  : 
; 485  : 	return DDENUMRET_OK;

	mov	eax, 1
$L80952:

; 486  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?EnumZedBufferCallback@@YGJPAU_DDPIXELFORMAT@@PAX@Z ENDP ; EnumZedBufferCallback
_TEXT	ENDS
PUBLIC	??_C@_0BO@CBIJDEPD@Can?8t?5restore?5primary?5display?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MDDLCIE@Can?8t?5restore?5zed?5buffer?$AA@ ; `string'
PUBLIC	?CheckSurfaces@@YAXXZ				; CheckSurfaces
EXTRN	?LoadTexture@@YA_NPADDJJJ@Z:NEAR		; LoadTexture
EXTRN	?LoadMipTexture@@YA_NPADDJJJJ@Z:NEAR		; LoadMipTexture
EXTRN	?FreeOneTexture@@YAXD@Z:NEAR			; FreeOneTexture
EXTRN	?TexInfo@@3PAUTEXINFO@@A:DWORD			; TexInfo
EXTRN	?AppRestore@@3DA:BYTE				; AppRestore
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
;	COMDAT ??_C@_0BO@CBIJDEPD@Can?8t?5restore?5primary?5display?$AA@
CONST	SEGMENT
??_C@_0BO@CBIJDEPD@Can?8t?5restore?5primary?5display?$AA@ DB 'Can''t rest'
	DB	'ore primary display', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MDDLCIE@Can?8t?5restore?5zed?5buffer?$AA@
CONST	SEGMENT
??_C@_0BJ@MDDLCIE@Can?8t?5restore?5zed?5buffer?$AA@ DB 'Can''t restore ze'
	DB	'd buffer', 00H				; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CheckSurfaces@@YAXXZ
_TEXT	SEGMENT
_texinfo$ = -72						; size = 64
_r$ = -8						; size = 4
_i$ = -1						; size = 1
?CheckSurfaces@@YAXXZ PROC NEAR				; CheckSurfaces, COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 494  : 	char i;
; 495  : 	HRESULT r;
; 496  : 	TEXINFO texinfo;
; 497  : 
; 498  : // do we need to?
; 499  : 
; 500  : 	if (!AppRestore)

	movsx	eax, BYTE PTR ?AppRestore@@3DA		; AppRestore
	test	eax, eax
	jne	SHORT $L80963

; 501  : 		return;

	jmp	$L80959
$L80963:

; 502  : 
; 503  : 	AppRestore = FALSE;

	mov	BYTE PTR ?AppRestore@@3DA, 0		; AppRestore

; 504  : 
; 505  : // check FrontBuffer
; 506  : 
; 507  : 	r = FrontBuffer->IsLost();

	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	edx
	call	DWORD PTR [ecx+96]
	mov	DWORD PTR _r$[ebp], eax

; 508  : 	if (r == DDERR_SURFACELOST)

	cmp	DWORD PTR _r$[ebp], -2005532222		; 887601c2H
	jne	SHORT $L80968

; 509  : 	{
; 510  : 		r = FrontBuffer->Restore();

	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	edx
	call	DWORD PTR [ecx+108]
	mov	DWORD PTR _r$[ebp], eax

; 511  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80968

; 512  : 		{
; 513  : 			ErrorDX(r, "Can't restore primary display");

	push	OFFSET FLAT:??_C@_0BO@CBIJDEPD@Can?8t?5restore?5primary?5display?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 514  : 			QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 515  : 			return;

	jmp	$L80959
$L80968:

; 516  : 		}
; 517  : 	}
; 518  : 
; 519  : // check ZedBuffer
; 520  : 
; 521  : 	r = ZedBuffer->IsLost();

	mov	eax, DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	push	edx
	call	DWORD PTR [ecx+96]
	mov	DWORD PTR _r$[ebp], eax

; 522  : 	if (r == DDERR_SURFACELOST)

	cmp	DWORD PTR _r$[ebp], -2005532222		; 887601c2H
	jne	SHORT $L80975

; 523  : 	{
; 524  : 		r = ZedBuffer->Restore();

	mov	eax, DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	push	edx
	call	DWORD PTR [ecx+108]
	mov	DWORD PTR _r$[ebp], eax

; 525  : 		if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L80975

; 526  : 		{
; 527  : 			ErrorDX(r, "Can't restore zed buffer");

	push	OFFSET FLAT:??_C@_0BJ@MDDLCIE@Can?8t?5restore?5zed?5buffer?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 528  : 			QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 529  : 			return;

	jmp	$L80959
$L80975:

; 530  : 		}
; 531  : 	}
; 532  : 
; 533  : // check textures
; 534  : 
; 535  : 	for (i = 0 ; i < TPAGE_NUM ; i++) if (TexInfo[i].Active)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L80978
$L80979:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L80978:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 31					; 0000001fH
	jge	$L80959
	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	cmp	DWORD PTR [ecx+eax], 0
	je	$L80981

; 536  : 	{
; 537  : 		r = TexInfo[i].Surface->IsLost();

	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+56]
	movsx	eax, BYTE PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	eax, DWORD PTR [ecx+eax+56]
	mov	ecx, DWORD PTR [edx]
	push	eax
	call	DWORD PTR [ecx+96]
	mov	DWORD PTR _r$[ebp], eax

; 538  : 		if (r == DDERR_SURFACELOST)

	cmp	DWORD PTR _r$[ebp], -2005532222		; 887601c2H
	jne	SHORT $L80981

; 539  : 		{
; 540  : 			texinfo = TexInfo[i];

	movsx	esi, BYTE PTR _i$[ebp]
	shl	esi, 6
	add	esi, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR _texinfo$[ebp]
	rep movsd

; 541  : 			FreeOneTexture(i);

	mov	al, BYTE PTR _i$[ebp]
	push	eax
	call	?FreeOneTexture@@YAXD@Z			; FreeOneTexture
	add	esp, 4

; 542  : 
; 543  : 			if (!texinfo.MipCount)

	cmp	DWORD PTR _texinfo$[ebp+16], 0
	jne	SHORT $L80987

; 544  : 				LoadTexture(texinfo.File, i, texinfo.Width, texinfo.Height, texinfo.Stage);

	mov	eax, DWORD PTR _texinfo$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _texinfo$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _texinfo$[ebp+4]
	push	edx
	mov	al, BYTE PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _texinfo$[ebp+20]
	push	ecx
	call	?LoadTexture@@YA_NPADDJJJ@Z		; LoadTexture
	add	esp, 20					; 00000014H

; 545  : 			else

	jmp	SHORT $L80981
$L80987:

; 546  : 				LoadMipTexture(texinfo.File, i, texinfo.Width, texinfo.Height, texinfo.Stage, texinfo.MipCount);

	mov	eax, DWORD PTR _texinfo$[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _texinfo$[ebp+12]
	push	ecx
	mov	edx, DWORD PTR _texinfo$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _texinfo$[ebp+4]
	push	eax
	mov	cl, BYTE PTR _i$[ebp]
	push	ecx
	lea	edx, DWORD PTR _texinfo$[ebp+20]
	push	edx
	call	?LoadMipTexture@@YA_NPADDJJJJ@Z		; LoadMipTexture
	add	esp, 24					; 00000018H
$L80981:

; 547  : 		}
; 548  : 	}
; 549  : }

	jmp	$L80979
$L80959:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckSurfaces@@YAXXZ ENDP				; CheckSurfaces
_TEXT	ENDS
EXTRN	__imp__GetWindowRect@8:NEAR
EXTRN	__imp__GetSystemMetrics@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?FlipBuffers@@YAXXZ
_TEXT	SEGMENT
_cy$ = -28						; size = 4
_by$ = -24						; size = 4
_bx$ = -20						; size = 4
_dest$ = -16						; size = 16
?FlipBuffers@@YAXXZ PROC NEAR				; FlipBuffers, COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 557  : 	RECT dest;
; 558  : 	long bx, by, cy;
; 559  : 
; 560  : 	if (FullScreen)

	movsx	eax, BYTE PTR ?FullScreen@@3DA		; FullScreen
	test	eax, eax
	je	SHORT $L80996
$L80998:

; 561  : 	{
; 562  : 		while (FrontBuffer->Flip(NULL, DDFLIP_NOVSYNC) == DDERR_WASSTILLDRAWING);

	push	8
	push	0
	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	edx
	call	DWORD PTR [ecx+44]
	cmp	eax, -2005532132			; 8876021cH
	jne	SHORT $L80999
	jmp	SHORT $L80998
$L80999:

; 563  : 	}
; 564  : 	else

	jmp	SHORT $L80991
$L80996:

; 565  : 	{
; 566  : 		GetWindowRect(hwnd, &dest);

	lea	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?hwnd@@3PAUHWND__@@A	; hwnd
	push	ecx
	call	DWORD PTR __imp__GetWindowRect@8

; 567  : 		bx = GetSystemMetrics(SM_CXSIZEFRAME);

	push	32					; 00000020H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _bx$[ebp], eax

; 568  : 		by = GetSystemMetrics(SM_CYSIZEFRAME);

	push	33					; 00000021H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _by$[ebp], eax

; 569  : 		cy = GetSystemMetrics(SM_CYCAPTION);

	push	4
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _cy$[ebp], eax

; 570  : 
; 571  : 		dest.left += bx;

	mov	eax, DWORD PTR _dest$[ebp]
	add	eax, DWORD PTR _bx$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 572  : 		dest.right -= bx;

	mov	eax, DWORD PTR _dest$[ebp+8]
	sub	eax, DWORD PTR _bx$[ebp]
	mov	DWORD PTR _dest$[ebp+8], eax

; 573  : 		dest.top += cy + by;

	mov	eax, DWORD PTR _cy$[ebp]
	add	eax, DWORD PTR _by$[ebp]
	add	eax, DWORD PTR _dest$[ebp+4]
	mov	DWORD PTR _dest$[ebp+4], eax

; 574  : 		dest.bottom -= by;

	mov	eax, DWORD PTR _dest$[ebp+12]
	sub	eax, DWORD PTR _by$[ebp]
	mov	DWORD PTR _dest$[ebp+12], eax

; 575  : 
; 576  : 		FrontBuffer->Blt(&dest, BackBuffer, NULL, DDBLT_WAIT, NULL);

	push	0
	push	16777216				; 01000000H
	push	0
	mov	eax, DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	push	eax
	lea	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	ecx
	call	DWORD PTR [eax+20]
$L80991:

; 577  : 	}
; 578  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlipBuffers@@YAXXZ ENDP				; FlipBuffers
_TEXT	ENDS
PUBLIC	__real@3f800000
EXTRN	?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A:BYTE		; DrawVertsTEX0
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ClearBuffers@@YAXXZ
_TEXT	SEGMENT
tv240 = -76						; size = 4
_z$ = -8						; size = 4
_zres$ = -4						; size = 4
?ClearBuffers@@YAXXZ PROC NEAR				; ClearBuffers, COMDAT

; 585  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 586  : 	float zres, z;
; 587  : 
; 588  : 	if (!PolyClear)

	cmp	DWORD PTR _PolyClear, 0
	jne	SHORT $L81010

; 589  : 	{
; 590  : 		D3Dviewport->Clear2(1, &ViewportRect, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, BackgroundColor, 1.0f, 0);

	push	0
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _BackgroundColor
	push	eax
	push	3
	push	OFFSET FLAT:?ViewportRect@@3U_D3DRECT@@A ; ViewportRect
	push	1
	mov	ecx, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	push	eax
	call	DWORD PTR [edx+80]

; 591  : 	}
; 592  : 	else

	jmp	$L81007
$L81010:

; 593  : 	{
; 594  : 		zres = (float)(1 << ZedBufferFormat.dwZBufferBitDepth);

	mov	eax, 1
	mov	ecx, DWORD PTR ?ZedBufferFormat@@3U_DDPIXELFORMAT@@A+12
	shl	eax, cl
	mov	DWORD PTR tv240[ebp], eax
	fild	DWORD PTR tv240[ebp]
	fstp	DWORD PTR _zres$[ebp]

; 595  : 		z = (zres - 1.0f) / zres;

	fld	DWORD PTR _zres$[ebp]
	fsub	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _zres$[ebp]
	fstp	DWORD PTR _z$[ebp]

; 596  : 
; 597  : 		DrawVertsTEX0[0].sx = (float)ViewportRect.x1;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A

; 598  : 		DrawVertsTEX0[0].sy = (float)ViewportRect.y1;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+4
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+4

; 599  : 		DrawVertsTEX0[0].sz = z;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+8, eax

; 600  : 		DrawVertsTEX0[0].rhw = 1.0f;

	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+12, 1065353216 ; 3f800000H

; 601  : 		DrawVertsTEX0[0].color = BackgroundColor;

	mov	eax, DWORD PTR _BackgroundColor
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+16, eax

; 602  : 
; 603  : 		DrawVertsTEX0[1].sx = (float)ViewportRect.x2;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+8
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+24

; 604  : 		DrawVertsTEX0[1].sy = (float)ViewportRect.y1;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+4
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+28

; 605  : 		DrawVertsTEX0[1].sz = z;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+32, eax

; 606  : 		DrawVertsTEX0[1].rhw = 1.0f;

	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+36, 1065353216 ; 3f800000H

; 607  : 		DrawVertsTEX0[1].color = BackgroundColor;

	mov	eax, DWORD PTR _BackgroundColor
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+40, eax

; 608  : 
; 609  : 		DrawVertsTEX0[2].sx = (float)ViewportRect.x2;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+8
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+48

; 610  : 		DrawVertsTEX0[2].sy = (float)ViewportRect.y2;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+12
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+52

; 611  : 		DrawVertsTEX0[2].sz = z;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+56, eax

; 612  : 		DrawVertsTEX0[2].rhw = 1.0f;

	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+60, 1065353216 ; 3f800000H

; 613  : 		DrawVertsTEX0[2].color = BackgroundColor;

	mov	eax, DWORD PTR _BackgroundColor
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+64, eax

; 614  : 
; 615  : 		DrawVertsTEX0[3].sx = (float)ViewportRect.x1;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+72

; 616  : 		DrawVertsTEX0[3].sy = (float)ViewportRect.y2;

	fild	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+12
	fstp	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+76

; 617  : 		DrawVertsTEX0[3].sz = z;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+80, eax

; 618  : 		DrawVertsTEX0[3].rhw = 1.0f;

	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+84, 1065353216 ; 3f800000H

; 619  : 		DrawVertsTEX0[3].color = BackgroundColor;

	mov	eax, DWORD PTR _BackgroundColor
	mov	DWORD PTR ?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A+88, eax

; 620  : 
; 621  : 		SET_TPAGE(-1);

	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	je	SHORT $L81021
	mov	WORD PTR ?RenderTP@@3FA, -1		; RenderTP
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	cmp	eax, -1
	jne	SHORT $L81022
	push	0
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
	jmp	SHORT $L81021
$L81022:
	movsx	eax, WORD PTR ?RenderTP@@3FA		; RenderTP
	shl	eax, 6
	mov	ecx, DWORD PTR ?TexInfo@@3PAUTEXINFO@@A	; TexInfo
	mov	edx, DWORD PTR [ecx+eax+52]
	push	edx
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+152]
	mov	eax, DWORD PTR ?TextureStateChange@@3JA	; TextureStateChange
	add	eax, 1
	mov	DWORD PTR ?TextureStateChange@@3JA, eax	; TextureStateChange
$L81021:

; 622  : 
; 623  : 		ZCMP(D3DCMP_ALWAYS);

	movsx	eax, WORD PTR ?RenderZcmp@@3FA		; RenderZcmp
	cmp	eax, 8
	je	SHORT $L81024
	mov	WORD PTR ?RenderZcmp@@3FA, 8		; RenderZcmp
	movsx	eax, WORD PTR ?RenderZcmp@@3FA		; RenderZcmp
	push	eax
	push	23					; 00000017H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81024:

; 624  : 		D3Ddevice->DrawPrimitive(D3DPT_TRIANGLEFAN, FVF_TEX0, DrawVertsTEX0, 4, D3DDP_DONOTUPDATEEXTENTS | D3DDP_DONOTCLIP);

	push	12					; 0000000cH
	push	4
	push	OFFSET FLAT:?DrawVertsTEX0@@3PAUVERTEX_TEX0@@A ; DrawVertsTEX0
	push	196					; 000000c4H
	push	6
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+112]

; 625  : 		ZCMP(D3DCMP_LESSEQUAL);

	movsx	eax, WORD PTR ?RenderZcmp@@3FA		; RenderZcmp
	cmp	eax, 4
	je	SHORT $L81007
	mov	WORD PTR ?RenderZcmp@@3FA, 4		; RenderZcmp
	movsx	eax, WORD PTR ?RenderZcmp@@3FA		; RenderZcmp
	push	eax
	push	23					; 00000017H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81007:

; 626  : 	}
; 627  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearBuffers@@YAXXZ ENDP				; ClearBuffers
_TEXT	ENDS
PUBLIC	?SetFrontBufferRGB@@YAXJ@Z			; SetFrontBufferRGB
; Function compile flags: /Odt /ZI
;	COMDAT ?SetFrontBufferRGB@@YAXJ@Z
_TEXT	SEGMENT
_bltfx$ = -100						; size = 100
_rgb$ = 8						; size = 4
?SetFrontBufferRGB@@YAXJ@Z PROC NEAR			; SetFrontBufferRGB, COMDAT

; 634  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi

; 635  : 	DDBLTFX bltfx;
; 636  : 
; 637  : 	bltfx.dwSize = sizeof(bltfx);

	mov	DWORD PTR _bltfx$[ebp], 100		; 00000064H

; 638  : 	bltfx.dwFillColor = rgb;

	mov	eax, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR _bltfx$[ebp+80], eax

; 639  : 	FrontBuffer->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &bltfx);

	lea	eax, DWORD PTR _bltfx$[ebp]
	push	eax
	push	1024					; 00000400H
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	eax
	call	DWORD PTR [edx+20]

; 640  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetFrontBufferRGB@@YAXJ@Z ENDP				; SetFrontBufferRGB
_TEXT	ENDS
PUBLIC	?SetBackgroundColor@@YAXJ@Z			; SetBackgroundColor
; Function compile flags: /Odt /ZI
;	COMDAT ?SetBackgroundColor@@YAXJ@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
?SetBackgroundColor@@YAXJ@Z PROC NEAR			; SetBackgroundColor, COMDAT

; 647  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 648  : 	BackgroundColor = col;

	mov	eax, DWORD PTR _col$[ebp]
	mov	DWORD PTR _BackgroundColor, eax

; 649  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetBackgroundColor@@YAXJ@Z ENDP			; SetBackgroundColor
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ReleaseDX@@YAXXZ
_TEXT	SEGMENT
?ReleaseDX@@YAXXZ PROC NEAR				; ReleaseDX, COMDAT

; 656  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 657  : 	RELEASE(D3D);

	cmp	DWORD PTR ?D3D@@3PAUIDirect3D3@@A, 0	; D3D
	je	SHORT $L81036
	mov	eax, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3D@@3PAUIDirect3D3@@A	; D3D
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?D3D@@3PAUIDirect3D3@@A, 0	; D3D
$L81036:

; 658  : 	RELEASE(DD);

	cmp	DWORD PTR ?DD@@3PAUIDirectDraw4@@A, 0	; DD
	je	SHORT $L81035
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?DD@@3PAUIDirectDraw4@@A, 0	; DD
$L81035:

; 659  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReleaseDX@@YAXXZ ENDP					; ReleaseDX
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ReleaseD3D@@YAXXZ
_TEXT	SEGMENT
?ReleaseD3D@@YAXXZ PROC NEAR				; ReleaseD3D, COMDAT

; 666  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 667  :     RELEASE(D3Ddevice);

	cmp	DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A, 0 ; D3Ddevice
	je	SHORT $L81041
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A, 0 ; D3Ddevice
$L81041:

; 668  :     RELEASE(GammaControl);

	cmp	DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A, 0 ; GammaControl
	je	SHORT $L81042
	mov	eax, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A, 0 ; GammaControl
$L81042:

; 669  :     RELEASE(D3Dviewport);

	cmp	DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A, 0 ; D3Dviewport
	je	SHORT $L81043
	mov	eax, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A, 0 ; D3Dviewport
$L81043:

; 670  :     RELEASE(GammaControl);

	cmp	DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A, 0 ; GammaControl
	je	SHORT $L81044
	mov	eax, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A ; GammaControl
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?GammaControl@@3PAUIDirectDrawGammaControl@@A, 0 ; GammaControl
$L81044:

; 671  :     RELEASE(ZedBuffer);

	cmp	DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A, 0 ; ZedBuffer
	je	SHORT $L81045
	mov	eax, DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A ; ZedBuffer
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?ZedBuffer@@3PAUIDirectDrawSurface4@@A, 0 ; ZedBuffer
$L81045:

; 672  :     RELEASE(BackBuffer);

	cmp	DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A, 0 ; BackBuffer
	je	SHORT $L81046
	mov	eax, DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A ; BackBuffer
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?BackBuffer@@3PAUIDirectDrawSurface4@@A, 0 ; BackBuffer
$L81046:

; 673  :     RELEASE(FrontBuffer);

	cmp	DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A, 0 ; FrontBuffer
	je	SHORT $L81040
	mov	eax, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A ; FrontBuffer
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?FrontBuffer@@3PAUIDirectDrawSurface4@@A, 0 ; FrontBuffer
$L81040:

; 674  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReleaseD3D@@YAXXZ ENDP					; ReleaseD3D
_TEXT	ENDS
EXTRN	?ErrorListDX@@3PAUERRORDX@@A:BYTE		; ErrorListDX
; Function compile flags: /Odt /ZI
;	COMDAT ?ErrorDX@@YAXJPAD@Z
_TEXT	SEGMENT
_p$ = -4						; size = 4
_r$ = 8							; size = 4
_mess$ = 12						; size = 4
?ErrorDX@@YAXJPAD@Z PROC NEAR				; ErrorDX, COMDAT

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 682  : 	ERRORDX *p = ErrorListDX;

	mov	DWORD PTR _p$[ebp], OFFSET FLAT:?ErrorListDX@@3PAUERRORDX@@A ; ErrorListDX
$L81054:

; 683  : 
; 684  : 	while (p->Result != DD_OK && p->Result != r) p++;

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L81055
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _r$[ebp]
	je	SHORT $L81055
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 8
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $L81054
$L81055:

; 685  : 	Box(p->Error, mess, MB_OK);

	push	0
	mov	eax, DWORD PTR _mess$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 686  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ErrorDX@@YAXJPAD@Z ENDP				; ErrorDX
_TEXT	ENDS
PUBLIC	?SetupDxState@@YAXXZ				; SetupDxState
; Function compile flags: /Odt /ZI
;	COMDAT ?SetupDxState@@YAXXZ
_TEXT	SEGMENT
tv95 = -72						; size = 4
_i$ = -4						; size = 4
?SetupDxState@@YAXXZ PROC NEAR				; SetupDxState, COMDAT

; 693  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 694  : 	long i;
; 695  : 
; 696  : // fill mode
; 697  : 
; 698  : 	DxState.WireframeEnabled = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A, 1

; 699  : 	DxState.Wireframe = D3DFILL_SOLID;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+4, 3

; 700  : 
; 701  : 	WIREFRAME_ON();

	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+4
	push	eax
	push	8
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 702  : 
; 703  : // perspective
; 704  : 
; 705  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_PERSPECTIVE)

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81060
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+132
	and	eax, 1
	je	SHORT $L81060

; 706  : 	{
; 707  : 		DxState.PerspectiveEnabled = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+8, 1

; 708  : 		DxState.Perspective = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+12, 1

; 709  : 	}
; 710  : 	else

	jmp	SHORT $L81061
$L81060:

; 711  : 	{
; 712  : 		DxState.PerspectiveEnabled = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+8, 0

; 713  : 		DxState.Perspective = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+12, 0
$L81061:

; 714  : 	}
; 715  : 
; 716  : 	PERSPECTIVE_ON();

	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+12
	push	eax
	push	4
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 717  : 
; 718  : // texture filtering
; 719  : 
; 720  : 	DxState.TextureFilterFlag = 1;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+16, 1

; 721  : 
; 722  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEAR) DxState.TextureFilterFlag |= 2;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81062
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+136
	and	eax, 2
	je	SHORT $L81062
	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+16
	or	eax, 2
	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+16, eax
$L81062:

; 723  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ANISOTROPY) DxState.TextureFilterFlag |= 4;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81063
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+108
	and	eax, 131072				; 00020000H
	je	SHORT $L81063
	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+16
	or	eax, 4
	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+16, eax
$L81063:

; 724  : 
; 725  : 	for (i = 0 ; i < 3 ; i++) if (DxState.TextureFilterFlag & (1 << i)) DxState.TextureFilter = i;

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81064
$L81065:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81064:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $L81066
	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+16
	je	SHORT $L81067
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+20, eax
$L81067:

; 726  : 
; 727  : 	TEXTUREFILTER_ON();

	jmp	SHORT $L81065
$L81066:
	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+20
	mov	DWORD PTR tv95[ebp], eax
	cmp	DWORD PTR tv95[ebp], 0
	je	SHORT $L81072
	cmp	DWORD PTR tv95[ebp], 1
	je	$L81073
	cmp	DWORD PTR tv95[ebp], 2
	je	$L81074
	jmp	$L81069
$L81072:
	push	1
	push	17					; 00000011H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	1
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	1
	push	17					; 00000011H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	1
	push	16					; 00000010H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	jmp	$L81069
$L81073:
	push	2
	push	17					; 00000011H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	2
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	2
	push	17					; 00000011H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	2
	push	16					; 00000010H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	jmp	$L81069
$L81074:
	push	3
	push	17					; 00000011H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	5
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	3
	push	17					; 00000011H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	push	5
	push	16					; 00000010H
	push	1
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	edx
	call	DWORD PTR [ecx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81069:

; 728  : 
; 729  : // mip map
; 730  : 
; 731  : 	DxState.MipMapFlag = 1;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+24, 1

; 732  : 
; 733  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwTextureFilterCaps & (D3DPTFILTERCAPS_MIPNEAREST | D3DPTFILTERCAPS_MIPLINEAR)) DxState.MipMapFlag |= 2;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81075
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+136
	and	eax, 12					; 0000000cH
	je	SHORT $L81075
	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+24
	or	eax, 2
	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+24, eax
$L81075:

; 734  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwTextureFilterCaps & (D3DPTFILTERCAPS_LINEARMIPNEAREST | D3DPTFILTERCAPS_LINEARMIPLINEAR)) DxState.MipMapFlag |= 4;

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81076
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+136
	and	eax, 48					; 00000030H
	je	SHORT $L81076
	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+24
	or	eax, 4
	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+24, eax
$L81076:

; 735  : 
; 736  : 	for (i = 0 ; i < 3 ; i++) if (DxState.MipMapFlag & (1 << i)) DxState.MipMap = i;

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81077
$L81078:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81077:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $L81079
	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+24
	je	SHORT $L81080
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+28, eax
$L81080:

; 737  : 
; 738  : 	MIPMAP_ON();

	jmp	SHORT $L81078
$L81079:
	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+28
	add	eax, 1
	push	eax
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+28
	add	eax, 1
	push	eax
	push	18					; 00000012H
	push	1
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+160]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 739  : 
; 740  : // fog
; 741  : 
; 742  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwShadeCaps & D3DPSHADECAPS_FOGGOURAUD)

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81081
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+128
	and	eax, 524288				; 00080000H
	je	SHORT $L81081

; 743  : 	{
; 744  : 		DxState.FogEnabled = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+32, 1

; 745  : 		DxState.Fog = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+36, 1

; 746  : 	}
; 747  : 	else

	jmp	SHORT $L81082
$L81081:

; 748  : 	{
; 749  : 		DxState.FogEnabled = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+32, 0

; 750  : 		DxState.Fog = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+36, 0
$L81082:

; 751  : 	}
; 752  : 
; 753  : 	FOG_OFF();

	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	test	eax, eax
	je	SHORT $L81083
	mov	WORD PTR ?RenderFog@@3FA, 0		; RenderFog
	movsx	eax, WORD PTR ?RenderFog@@3FA		; RenderFog
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange
$L81083:

; 754  : 
; 755  : // dither
; 756  : 
; 757  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_DITHER)

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81084
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+108
	and	eax, 1
	je	SHORT $L81084

; 758  : 	{
; 759  : 		DxState.DitherEnabled = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+40, 1

; 760  : 		DxState.Dither = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+44, 1

; 761  : 	}
; 762  : 	else

	jmp	SHORT $L81085
$L81084:

; 763  : 	{
; 764  : 		DxState.DitherEnabled = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+40, 0

; 765  : 		DxState.Dither = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+44, 0
$L81085:

; 766  : 	}
; 767  : 
; 768  : 	DITHER_ON();

	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+44
	push	eax
	push	26					; 0000001aH
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 769  : 
; 770  : // color keying
; 771  : 
; 772  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_TRANSPARENCY && !NoColorKey)

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81086
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+132
	and	eax, 8
	je	SHORT $L81086
	cmp	DWORD PTR ?NoColorKey@@3JA, 0		; NoColorKey
	jne	SHORT $L81086

; 773  : 	{
; 774  : 		DxState.ColorKeyEnabled = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+48, 1

; 775  : 		DxState.ColorKey = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+52, 1

; 776  : 	}
; 777  : 	else

	jmp	SHORT $L81087
$L81086:

; 778  : 	{
; 779  : 		DxState.ColorKeyEnabled = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+48, 0

; 780  : 		DxState.ColorKey = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+52, 0
$L81087:

; 781  : 	}
; 782  : 
; 783  : 	COLORKEY_ON();

	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+52
	push	eax
	push	41					; 00000029H
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 784  : 
; 785  : // anti alias
; 786  : 
; 787  : 	if (D3Dcaps.dwFlags & D3DDD_TRICAPS && D3Dcaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT)

	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+4
	and	eax, 64					; 00000040H
	je	SHORT $L81088
	mov	eax, DWORD PTR ?D3Dcaps@@3U_D3DDeviceDesc@@A+108
	and	eax, 2048				; 00000800H
	je	SHORT $L81088

; 788  : 	{
; 789  : 		DxState.AntiAliasEnabled = TRUE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+56, 1

; 790  : 		DxState.AntiAlias = D3DANTIALIAS_NONE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+60, 0

; 791  : 	}
; 792  : 	else

	jmp	SHORT $L81089
$L81088:

; 793  : 	{
; 794  : 		DxState.AntiAliasEnabled = FALSE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+56, 0

; 795  : 		DxState.AntiAlias = D3DANTIALIAS_NONE;

	mov	DWORD PTR ?DxState@@3UDX_STATE@@A+60, 0
$L81089:

; 796  : 	}
; 797  : 
; 798  : 	ANTIALIAS_ON();

	mov	eax, DWORD PTR ?DxState@@3UDX_STATE@@A+60
	push	eax
	push	2
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+88]
	mov	eax, DWORD PTR ?RenderStateChange@@3JA	; RenderStateChange
	add	eax, 1
	mov	DWORD PTR ?RenderStateChange@@3JA, eax	; RenderStateChange

; 799  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupDxState@@YAXXZ ENDP				; SetupDxState
_TEXT	ENDS
PUBLIC	?GetDrawDevices@@YAXXZ				; GetDrawDevices
PUBLIC	?GetDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z	; GetDrawDeviceCallback
; Function compile flags: /Odt /ZI
;	COMDAT ?GetDrawDevices@@YAXXZ
_TEXT	SEGMENT
?GetDrawDevices@@YAXXZ PROC NEAR			; GetDrawDevices, COMDAT

; 806  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 807  : 
; 808  : // enumerate devices
; 809  : 
; 810  : 	DrawDeviceNum = 0;

	mov	DWORD PTR ?DrawDeviceNum@@3JA, 0	; DrawDeviceNum

; 811  : 	DirectDrawEnumerate(GetDrawDeviceCallback, NULL);

	push	0
	push	OFFSET FLAT:?GetDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z ; GetDrawDeviceCallback
	call	_DirectDrawEnumerateA@8

; 812  : 
; 813  : // set request device to registry setting
; 814  : 
; 815  : 	if (RegistrySettings.DrawDevice >= (DWORD)DrawDeviceNum)

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	cmp	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	jb	SHORT $L81094

; 816  : 		RegistrySettings.DrawDevice = 0;

	mov	DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44, 0
$L81094:

; 817  : 
; 818  : 	DisplayModeCount = DrawDevices[RegistrySettings.DrawDevice].BestDisplayMode;

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+132]
	mov	DWORD PTR ?DisplayModeCount@@3JA, ecx	; DisplayModeCount

; 819  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDrawDevices@@YAXXZ ENDP				; GetDrawDevices
_TEXT	ENDS
PUBLIC	??_C@_0BJ@FOMFOEKH@Can?8t?5create?5draw?5device?$AA@ ; `string'
PUBLIC	??_C@_0BH@MILKILGM@Can?8t?5init?5draw?5device?$AA@ ; `string'
PUBLIC	?DisplayModesCallback@@YGJPAU_DDSURFACEDESC2@@PAX@Z ; DisplayModesCallback
EXTRN	_CLSID_DirectDraw:BYTE
EXTRN	_IID_IDirectDraw4:BYTE
EXTRN	__imp__CoCreateInstance@20:NEAR
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0BJ@FOMFOEKH@Can?8t?5create?5draw?5device?$AA@
CONST	SEGMENT
??_C@_0BJ@FOMFOEKH@Can?8t?5create?5draw?5device?$AA@ DB 'Can''t create dr'
	DB	'aw device', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MILKILGM@Can?8t?5init?5draw?5device?$AA@
CONST	SEGMENT
??_C@_0BH@MILKILGM@Can?8t?5init?5draw?5device?$AA@ DB 'Can''t init draw d'
	DB	'evice', 00H					; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?GetDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_lpGUID$ = 8						; size = 4
_szName$ = 12						; size = 4
_szDevice$ = 16						; size = 4
_lParam$ = 20						; size = 4
?GetDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z PROC NEAR ; GetDrawDeviceCallback, COMDAT

; 826  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 827  : 	HRESULT r;
; 828  : 
; 829  : // stop if reached max
; 830  : 
; 831  : 	if (DrawDeviceNum == MAX_DRAW_DEVICES)

	cmp	DWORD PTR ?DrawDeviceNum@@3JA, 3	; DrawDeviceNum
	jne	SHORT $L81102

; 832  : 	{
; 833  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	$L81100
$L81102:

; 834  : 	}
; 835  : 
; 836  : // create this device
; 837  : 
; 838  : 	r = CoCreateInstance(CLSID_DirectDraw, NULL, CLSCTX_ALL, IID_IDirectDraw4, (void**)&DD);

	push	OFFSET FLAT:?DD@@3PAUIDirectDraw4@@A	; DD
	push	OFFSET FLAT:_IID_IDirectDraw4
	push	7
	push	0
	push	OFFSET FLAT:_CLSID_DirectDraw
	call	DWORD PTR __imp__CoCreateInstance@20
	mov	DWORD PTR _r$[ebp], eax

; 839  : 	if (r != S_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L81105

; 840  : 	{
; 841  : 		Box(NULL, "Can't create draw device", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0BJ@FOMFOEKH@Can?8t?5create?5draw?5device?$AA@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 842  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	$L81100
$L81105:

; 843  : 	}
; 844  : 
; 845  : 	r = DD->Initialize(lpGUID);

	mov	eax, DWORD PTR _lpGUID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+72]
	mov	DWORD PTR _r$[ebp], eax

; 846  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L81107

; 847  : 	{
; 848  : 		ErrorDX(r, "Can't init draw device");

	push	OFFSET FLAT:??_C@_0BH@MILKILGM@Can?8t?5init?5draw?5device?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 849  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	$L81100
$L81107:

; 850  : 	}
; 851  : 
; 852  : // get name
; 853  : 
; 854  : 	memcpy(DrawDevices[DrawDeviceNum].Name, szName, MAX_DRAW_DEVICE_NAME);

	push	128					; 00000080H
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	ecx, 1672				; 00000688H
	add	ecx, OFFSET FLAT:?DrawDevices@@3PAUDRAW_DEVICE@@A ; DrawDevices
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 855  : 
; 856  : // get display modes
; 857  : 
; 858  : 	DrawDevices[DrawDeviceNum].DisplayModeNum = 0;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+128], 0

; 859  : 	DD->EnumDisplayModes(0, NULL, NULL, DisplayModesCallback);

	push	OFFSET FLAT:?DisplayModesCallback@@YGJPAU_DDSURFACEDESC2@@PAX@Z ; DisplayModesCallback
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+32]

; 860  : 
; 861  : // inc count
; 862  : 
; 863  : 	DrawDeviceNum++;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	add	eax, 1
	mov	DWORD PTR ?DrawDeviceNum@@3JA, eax	; DrawDeviceNum

; 864  : 
; 865  : // kill device
; 866  : 
; 867  : 	RELEASE(DD);

	cmp	DWORD PTR ?DD@@3PAUIDirectDraw4@@A, 0	; DD
	je	SHORT $L81109
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	edx
	call	DWORD PTR [ecx+8]
	mov	DWORD PTR ?DD@@3PAUIDirectDraw4@@A, 0	; DD
$L81109:

; 868  : 
; 869  : // next please
; 870  : 
; 871  :     return DDENUMRET_OK;

	mov	eax, 1
$L81100:

; 872  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z ENDP	; GetDrawDeviceCallback
_TEXT	ENDS
PUBLIC	??_C@_0BO@EHJFHMNK@Can?8t?5create?5draw?5device?5?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0BM@MCKDEALE@Can?8t?5init?5draw?5device?5?8?$CFs?8?$AA@ ; `string'
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_0BO@EHJFHMNK@Can?8t?5create?5draw?5device?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BO@EHJFHMNK@Can?8t?5create?5draw?5device?5?8?$CFs?8?$AA@ DB 'Can'''
	DB	't create draw device ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MCKDEALE@Can?8t?5init?5draw?5device?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BM@MCKDEALE@Can?8t?5init?5draw?5device?5?8?$CFs?8?$AA@ DB 'Can''t '
	DB	'init draw device ''%s''', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CreateDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z
_TEXT	SEGMENT
_buf$ = -132						; size = 128
_r$ = -4						; size = 4
_lpGUID$ = 8						; size = 4
_szName$ = 12						; size = 4
_szDevice$ = 16						; size = 4
_lParam$ = 20						; size = 4
?CreateDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z PROC NEAR ; CreateDrawDeviceCallback, COMDAT

; 879  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi

; 880  : 	HRESULT r;
; 881  : 	char buf[128];
; 882  : 
; 883  : // skip if wrong name
; 884  : 
; 885  : 	if (strcmp(szName, DrawDevices[RegistrySettings.DrawDevice].Name))

	mov	eax, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+44
	imul	eax, 1672				; 00000688H
	add	eax, OFFSET FLAT:?DrawDevices@@3PAUDRAW_DEVICE@@A ; DrawDevices
	push	eax
	mov	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L81118

; 886  : 		return DDENUMRET_OK;

	mov	eax, 1
	jmp	$L81115
$L81118:

; 887  : 
; 888  : // create this device
; 889  : 
; 890  : 	r = CoCreateInstance(CLSID_DirectDraw, NULL, CLSCTX_ALL, IID_IDirectDraw4, (void**)&DD);

	push	OFFSET FLAT:?DD@@3PAUIDirectDraw4@@A	; DD
	push	OFFSET FLAT:_IID_IDirectDraw4
	push	7
	push	0
	push	OFFSET FLAT:_CLSID_DirectDraw
	call	DWORD PTR __imp__CoCreateInstance@20
	mov	DWORD PTR _r$[ebp], eax

; 891  : 	if (r != S_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L81121

; 892  : 	{
; 893  : 		wsprintf(buf, "Can't create draw device '%s'", szName);

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BO@EHJFHMNK@Can?8t?5create?5draw?5device?5?8?$CFs?8?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 894  : 		Box(NULL, buf, MB_OK);

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 895  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	SHORT $L81115
$L81121:

; 896  : 	}
; 897  : 
; 898  : 	r = DD->Initialize(lpGUID);

	mov	eax, DWORD PTR _lpGUID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?DD@@3PAUIDirectDraw4@@A	; DD
	push	eax
	call	DWORD PTR [edx+72]
	mov	DWORD PTR _r$[ebp], eax

; 899  : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L81123

; 900  : 	{
; 901  : 		wsprintf(buf, "Can't init draw device '%s'", szName);

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BM@MCKDEALE@Can?8t?5init?5draw?5device?5?8?$CFs?8?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 902  : 		ErrorDX(r, buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 903  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	SHORT $L81115
$L81123:

; 904  : 	}
; 905  : 
; 906  :     return DDENUMRET_CANCEL;

	xor	eax, eax
$L81115:

; 907  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CreateDrawDeviceCallback@@YGHPAU_GUID@@PAD1PAX@Z ENDP	; CreateDrawDeviceCallback
_TEXT	ENDS
PUBLIC	??_C@_08PAPJPLGD@?$CFdx?$CFdx?$CFd?$AA@		; `string'
;	COMDAT ??_C@_08PAPJPLGD@?$CFdx?$CFdx?$CFd?$AA@
CONST	SEGMENT
??_C@_08PAPJPLGD@?$CFdx?$CFdx?$CFd?$AA@ DB '%dx%dx%d', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?DisplayModesCallback@@YGJPAU_DDSURFACEDESC2@@PAX@Z
_TEXT	SEGMENT
_Mode$ = 8						; size = 4
_UserArg$ = 12						; size = 4
?DisplayModesCallback@@YGJPAU_DDSURFACEDESC2@@PAX@Z PROC NEAR ; DisplayModesCallback, COMDAT

; 914  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 915  : 
; 916  : // list full?
; 917  : 
; 918  : 	if (DrawDevices[DrawDeviceNum].DisplayModeNum >= MAX_DISPLAY_MODES)

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	cmp	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+128], 32 ; 00000020H
	jl	SHORT $L81129

; 919  : 		return DDENUMRET_CANCEL;

	xor	eax, eax
	jmp	$L81128
$L81129:

; 920  : 
; 921  : // skip if crap display mode
; 922  : 
; 923  : 	if (!(Mode->ddpfPixelFormat.dwFlags & DDPF_RGB) || Mode->ddpfPixelFormat.dwRGBBitCount < 16)

	mov	eax, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	and	ecx, 64					; 00000040H
	je	SHORT $L81131
	mov	eax, DWORD PTR _Mode$[ebp]
	cmp	DWORD PTR [eax+84], 16			; 00000010H
	jae	SHORT $L81130
$L81131:

; 924  : 		return DDENUMRET_OK;

	mov	eax, 1
	jmp	$L81128
$L81130:

; 925  : 
; 926  : // store mode in current draw device list
; 927  : 
; 928  : 	DrawDevices[DrawDeviceNum].DisplayMode[DrawDevices[DrawDeviceNum].DisplayModeNum].Width = Mode->dwWidth;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	ecx, 1672				; 00000688H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[ecx+128]
	imul	edx, 48					; 00000030H
	mov	ecx, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+edx+136], ecx

; 929  : 	DrawDevices[DrawDeviceNum].DisplayMode[DrawDevices[DrawDeviceNum].DisplayModeNum].Height = Mode->dwHeight;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	ecx, 1672				; 00000688H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[ecx+128]
	imul	edx, 48					; 00000030H
	mov	ecx, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+edx+140], ecx

; 930  : 	DrawDevices[DrawDeviceNum].DisplayMode[DrawDevices[DrawDeviceNum].DisplayModeNum].Bpp = Mode->ddpfPixelFormat.dwRGBBitCount;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	ecx, 1672				; 00000688H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[ecx+128]
	imul	edx, 48					; 00000030H
	mov	ecx, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [ecx+84]
	mov	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+edx+144], ecx

; 931  : 	DrawDevices[DrawDeviceNum].DisplayMode[DrawDevices[DrawDeviceNum].DisplayModeNum].Refresh = Mode->dwRefreshRate;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	ecx, 1672				; 00000688H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[ecx+128]
	imul	edx, 48					; 00000030H
	mov	ecx, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+edx+148], ecx

; 932  : 	wsprintf(DrawDevices[DrawDeviceNum].DisplayMode[DrawDevices[DrawDeviceNum].DisplayModeNum].DisplayText, "%dx%dx%d", (short)Mode->dwWidth, (short)Mode->dwHeight, (short)Mode->ddpfPixelFormat.dwRGBBitCount);

	mov	eax, DWORD PTR _Mode$[ebp]
	movsx	ecx, WORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR _Mode$[ebp]
	movsx	eax, WORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _Mode$[ebp]
	movsx	edx, WORD PTR [ecx+12]
	push	edx
	push	OFFSET FLAT:??_C@_08PAPJPLGD@?$CFdx?$CFdx?$CFd?$AA@
	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	ecx, 1672				; 00000688H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[ecx+128]
	imul	edx, 48					; 00000030H
	lea	eax, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+edx+152]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 933  : 
; 934  : // best display mode?
; 935  : 
; 936  : 	if (Mode->dwWidth <= RegistrySettings.ScreenWidth && Mode->dwHeight <= RegistrySettings.ScreenHeight && Mode->ddpfPixelFormat.dwRGBBitCount <= RegistrySettings.ScreenBpp)

	mov	eax, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+32
	ja	SHORT $L81136
	mov	eax, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+36
	ja	SHORT $L81136
	mov	eax, DWORD PTR _Mode$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR ?RegistrySettings@@3UREGISTRY_SETTINGS@@A+40
	ja	SHORT $L81136

; 937  : 		DrawDevices[DrawDeviceNum].BestDisplayMode = DrawDevices[DrawDeviceNum].DisplayModeNum;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	ecx, 1672				; 00000688H
	mov	edx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+128]
	mov	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[ecx+132], edx
$L81136:

; 938  : 
; 939  : // next please
; 940  : 
; 941  : 	DrawDevices[DrawDeviceNum].DisplayModeNum++;

	mov	eax, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	eax, 1672				; 00000688H
	mov	ecx, DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[eax+128]
	add	ecx, 1
	mov	edx, DWORD PTR ?DrawDeviceNum@@3JA	; DrawDeviceNum
	imul	edx, 1672				; 00000688H
	mov	DWORD PTR ?DrawDevices@@3PAUDRAW_DEVICE@@A[edx+128], ecx

; 942  : 	return DDENUMRET_OK;

	mov	eax, 1
$L81128:

; 943  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DisplayModesCallback@@YGJPAU_DDSURFACEDESC2@@PAX@Z ENDP ; DisplayModesCallback
_TEXT	ENDS
END
