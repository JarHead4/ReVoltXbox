; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\move.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IJ@NFIFEEKO@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MOV_MoveObjects@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MOV_MoveBody@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MOV_MoveCarNew@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MOV_RightCar@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MOV_MoveGhost@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MOV_MoveTrain@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??MOV_RightCar@@YAXPAUobject_def@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??MOV_MoveCarNew@@YAXPAUobject_def@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?MOV_MoveObjects@@YAXXZ				; MOV_MoveObjects
EXTRN	?OBJ_ObjectHead@@3PAUobject_def@@A:DWORD	; OBJ_ObjectHead
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\move.cpp
;	COMDAT ?MOV_MoveObjects@@YAXXZ
_TEXT	SEGMENT
_obj$ = -4						; size = 4
?MOV_MoveObjects@@YAXXZ PROC NEAR			; MOV_MoveObjects, COMDAT

; 55   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 56   : 	OBJECT	*obj;
; 57   : 
; 58   : 	for (obj = OBJ_ObjectHead; obj; obj = obj->next)

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj$[ebp], eax
	jmp	SHORT $L81451
$L81452:
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj$[ebp], ecx
$L81451:
	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $L81449

; 59   : 	{
; 60   : 		if (obj->movehandler && obj->flag.Move)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+688], 0
	je	SHORT $L81454
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $L81454

; 61   : 		{
; 62   : 			obj->movehandler(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	call	DWORD PTR [ecx+688]
	add	esp, 4
$L81454:

; 63   : 		}
; 64   : 		obj->renderflag.visible = FALSE;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [edx+584], ecx

; 65   : 	}	

	jmp	SHORT $L81452
$L81449:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MOV_MoveObjects@@YAXXZ ENDP				; MOV_MoveObjects
_TEXT	ENDS
PUBLIC	?MOV_MoveBody@@YAXPAUobject_def@@@Z		; MOV_MoveBody
EXTRN	__fltused:NEAR
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?UpdateBody@@YAXPAUNewBodyStruct@@M@Z:NEAR	; UpdateBody
; Function compile flags: /Odt /ZI
;	COMDAT ?MOV_MoveBody@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_bodyObj$ = 8						; size = 4
?MOV_MoveBody@@YAXPAUobject_def@@@Z PROC NEAR		; MOV_MoveBody, COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 137  : 	UpdateBody(&bodyObj->body, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _bodyObj$[ebp]
	push	ecx
	call	?UpdateBody@@YAXPAUNewBodyStruct@@M@Z	; UpdateBody
	add	esp, 8

; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MOV_MoveBody@@YAXPAUobject_def@@@Z ENDP		; MOV_MoveBody
_TEXT	ENDS
PUBLIC	?MOV_MoveCarNew@@YAXPAUobject_def@@@Z		; MOV_MoveCarNew
PUBLIC	?__LINE__Var@?1??MOV_MoveCarNew@@YAXPAUobject_def@@@Z@4JA ; `MOV_MoveCarNew'::`2'::__LINE__Var
PUBLIC	??_C@_0IJ@NFIFEEKO@c?3?2documents?5and?5settings?2jarhea@ ; `string'
EXTRN	?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z:NEAR	; UpdateCarAerial2
EXTRN	?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z:NEAR	; UpdateCarWheel
EXTRN	?UpdateRemotePlayer@@YAXPAUPlayerStruct@@@Z:NEAR ; UpdateRemotePlayer
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
EXTRN	?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z:NEAR ; AddPosRadToBBox
;	COMDAT ??_C@_0IJ@NFIFEEKO@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IJ@NFIFEEKO@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\move.'
	DB	'cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??MOV_MoveCarNew@@YAXPAUobject_def@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??MOV_MoveCarNew@@YAXPAUobject_def@@@Z@4JA DD 08dH ; `MOV_MoveCarNew'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?MOV_MoveCarNew@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
tv73 = -77						; size = 1
_car$ = -12						; size = 4
_nPowered$ = -8						; size = 4
_iWheel$ = -4						; size = 4
_carObj$ = 8						; size = 4
?MOV_MoveCarNew@@YAXPAUobject_def@@@Z PROC NEAR		; MOV_MoveCarNew, COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 142  : 	int iWheel, nPowered;
; 143  : 	CAR *car = &carObj->player->car;

	mov	eax, DWORD PTR _carObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], ecx

; 144  : 
; 145  : 	Assert(carObj->Type == OBJECT_TYPE_CAR || carObj->Type == OBJECT_TYPE_TROLLEY);

	mov	eax, DWORD PTR _carObj$[ebp]
	cmp	DWORD PTR [eax+568], -1
	je	SHORT $L81620
	mov	ecx, DWORD PTR _carObj$[ebp]
	cmp	DWORD PTR [ecx+568], 7
	je	SHORT $L81620
	mov	BYTE PTR tv73[ebp], 0
	jmp	SHORT $L81621
$L81620:
	mov	BYTE PTR tv73[ebp], 1
$L81621:
	push	OFFSET FLAT:??_C@_0IJ@NFIFEEKO@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??MOV_MoveCarNew@@YAXPAUobject_def@@@Z@4JA
	add	edx, 4
	push	edx
	mov	al, BYTE PTR tv73[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 146  : 
; 147  : 	// Move the car according to the impulses applied to it
; 148  : 	UpdateBody(car->Body, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	?UpdateBody@@YAXPAUNewBodyStruct@@M@Z	; UpdateBody
	add	esp, 8

; 149  : 	CopyBBox(&car->Body->CollSkin.BBox, &car->BBox);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+444]
	mov	DWORD PTR [edx+3148], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+448]
	mov	DWORD PTR [edx+3152], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+452]
	mov	DWORD PTR [edx+3156], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+456]
	mov	DWORD PTR [edx+3160], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+460]
	mov	DWORD PTR [edx+3164], eax
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [ecx+464]
	mov	DWORD PTR [edx+3168], eax

; 150  : 
; 151  : 	// Move the wheels relative to the car 
; 152  : 	car->Revs = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3504], 0

; 153  : 	nPowered = 0;

	mov	DWORD PTR _nPowered$[ebp], 0

; 154  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L81466
$L81467:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L81466:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L81468

; 155  : 		if (IsWheelPresent(&car->Wheel[iWheel])) {

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 1
	je	SHORT $L81469

; 156  : 			UpdateCarWheel(car, iWheel, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z	; UpdateCarWheel
	add	esp, 12					; 0000000cH

; 157  : 			AddPosRadToBBox(&car->BBox, &car->Wheel[iWheel].CentrePos, car->Wheel[iWheel].Radius);

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1580]
	push	edx
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1744]
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3148				; 00000c4cH
	push	eax
	call	?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z ; AddPosRadToBBox
	add	esp, 12					; 0000000cH
$L81469:

; 158  : 		}
; 159  : 		// Calculate car revs
; 160  : 		if (IsWheelPowered(&car->Wheel[iWheel])) {

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 4
	je	SHORT $L81470

; 161  : 			car->Revs += car->Wheel[iWheel].AngVel;

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+3504]
	fadd	DWORD PTR [edx+eax+1652]
	mov	eax, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [eax+3504]

; 162  : 			nPowered++;

	mov	eax, DWORD PTR _nPowered$[ebp]
	add	eax, 1
	mov	DWORD PTR _nPowered$[ebp], eax
$L81470:

; 163  : 		}
; 164  : 	}

	jmp	$L81467
$L81468:

; 165  : 	if (nPowered > 0) {

	cmp	DWORD PTR _nPowered$[ebp], 0
	jle	SHORT $L81471

; 166  : 		car->Revs /= nPowered;

	fild	DWORD PTR _nPowered$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	fdivr	DWORD PTR [eax+3504]
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+3504]
$L81471:

; 167  : 	}
; 168  : #ifdef _PC
; 169  : 	if (carObj->player->type == PLAYER_REMOTE) {

	mov	eax, DWORD PTR _carObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	cmp	DWORD PTR [ecx+4], 2
	jne	SHORT $L81472

; 170  : 		UpdateRemotePlayer(carObj->player);

	mov	eax, DWORD PTR _carObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	call	?UpdateRemotePlayer@@YAXPAUPlayerStruct@@@Z ; UpdateRemotePlayer
	add	esp, 4
$L81472:

; 171  : 	}
; 172  : #endif
; 173  : 
; 174  : 	// Move the Aerial
; 175  : 	UpdateCarAerial2(car, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z	; UpdateCarAerial2
	add	esp, 8

; 176  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MOV_MoveCarNew@@YAXPAUobject_def@@@Z ENDP		; MOV_MoveCarNew
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?MOV_RightCar@@YAXPAUobject_def@@@Z		; MOV_RightCar
PUBLIC	?__LINE__Var@?1??MOV_RightCar@@YAXPAUobject_def@@@Z@4JA ; `MOV_RightCar'::`2'::__LINE__Var
PUBLIC	__real@42480000
PUBLIC	__real@3727c5ac
PUBLIC	__real@41200000
PUBLIC	__real@40400000
PUBLIC	__real@3f7ff972
EXTRN	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z:NEAR ; MatToQuat
EXTRN	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z:NEAR	; SLerpQuat
EXTRN	?DownVec@@3UVectorStruct@@A:BYTE		; DownVec
EXTRN	?UpVec@@3UVectorStruct@@A:BYTE			; UpVec
;	COMDAT ?__LINE__Var@?1??MOV_RightCar@@YAXPAUobject_def@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??MOV_RightCar@@YAXPAUobject_def@@@Z@4JA DD 0b3H ; `MOV_RightCar'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3f7ff972
CONST	SEGMENT
__real@3f7ff972 DD 03f7ff972r			; 0.9999
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?MOV_RightCar@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_car$ = -60						; size = 4
_mat$ = -56						; size = 36
_dR$ = -20						; size = 12
_lookLen$ = -8						; size = 4
_iWheel$ = -4						; size = 4
_obj$ = 8						; size = 4
?MOV_RightCar@@YAXPAUobject_def@@@Z PROC NEAR		; MOV_RightCar, COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 180  : 	int iWheel;
; 181  : 	REAL lookLen;
; 182  : 	VEC dR;
; 183  : 	MAT	mat;
; 184  : 	CAR *car = &obj->player->car;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], ecx

; 185  : 
; 186  : 	Assert(obj->Type == OBJECT_TYPE_CAR);

	push	OFFSET FLAT:??_C@_0IJ@NFIFEEKO@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??MOV_RightCar@@YAXPAUobject_def@@@Z@4JA
	add	eax, 7
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [ecx+568], -1
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 187  : 
; 188  : 	// Choose an orientation and destination position
; 189  : 	if (!car->Righting) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3814]
	test	ecx, ecx
	jne	$L81482

; 190  : 
; 191  : 		// New position
; 192  : 		VecPlusScalarVec(&car->Body->Centre.Pos, TO_LENGTH(Real(50)), &UpVec, &car->DestPos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR __real@42480000
	fmul	DWORD PTR ?UpVec@@3UVectorStruct@@A
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [edx+3536]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR __real@42480000
	fmul	DWORD PTR ?UpVec@@3UVectorStruct@@A+4
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [edx+3540]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR __real@42480000
	fmul	DWORD PTR ?UpVec@@3UVectorStruct@@A+8
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [edx+3544]

; 193  : 
; 194  : 		// New look direction
; 195  : 		SetVec(&mat.mv[L], car->Body->Centre.WMatrix.m[LX], ZERO, car->Body->Centre.WMatrix.m[LZ]);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR _mat$[ebp+24], edx
	mov	DWORD PTR _mat$[ebp+28], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR _mat$[ebp+32], edx

; 196  : 		lookLen = VecLen(&mat.mv[L]);

	fld	DWORD PTR _mat$[ebp+24]
	fmul	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+28]
	fmul	DWORD PTR _mat$[ebp+28]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat$[ebp+32]
	fmul	DWORD PTR _mat$[ebp+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _lookLen$[ebp]

; 197  : 		if (lookLen > SMALL_REAL) {

	fld	DWORD PTR _lookLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81487

; 198  : 			VecDivScalar(&mat.mv[L], lookLen);

	fld	DWORD PTR _mat$[ebp+24]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+28]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _mat$[ebp+28]
	fld	DWORD PTR _mat$[ebp+32]
	fdiv	DWORD PTR _lookLen$[ebp]
	fstp	DWORD PTR _mat$[ebp+32]

; 199  : 		} else {

	jmp	SHORT $L81488
$L81487:

; 200  : 			SetVec(&mat.mv[L], ONE, ZERO, ZERO);

	mov	DWORD PTR _mat$[ebp+24], 1065353216	; 3f800000H
	mov	DWORD PTR _mat$[ebp+28], 0
	mov	DWORD PTR _mat$[ebp+32], 0
$L81488:

; 201  : 		}
; 202  : 
; 203  : 		// Complete the matrix
; 204  : 		CopyVec(&DownVec, &mat.mv[U]);

	mov	eax, DWORD PTR ?DownVec@@3UVectorStruct@@A
	mov	DWORD PTR _mat$[ebp+12], eax
	mov	eax, DWORD PTR ?DownVec@@3UVectorStruct@@A+4
	mov	DWORD PTR _mat$[ebp+16], eax
	mov	eax, DWORD PTR ?DownVec@@3UVectorStruct@@A+8
	mov	DWORD PTR _mat$[ebp+20], eax

; 205  : 		VecCrossVec(&mat.mv[U], &mat.mv[L], &mat.mv[R]);

	fld	DWORD PTR _mat$[ebp+16]
	fmul	DWORD PTR _mat$[ebp+32]
	fld	DWORD PTR _mat$[ebp+20]
	fmul	DWORD PTR _mat$[ebp+28]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+20]
	fmul	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+12]
	fmul	DWORD PTR _mat$[ebp+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+4]
	fld	DWORD PTR _mat$[ebp+12]
	fmul	DWORD PTR _mat$[ebp+28]
	fld	DWORD PTR _mat$[ebp+16]
	fmul	DWORD PTR _mat$[ebp+24]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+8]

; 206  : 
; 207  : 		// Convert to quaternion
; 208  : 		MatToQuat(&mat, &car->DestQuat);

	mov	eax, DWORD PTR _car$[ebp]
	add	eax, 3548				; 00000ddcH
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z ; MatToQuat
	add	esp, 8

; 209  : 
; 210  : 		// set the self-righting flag
; 211  : 		car->Righting = TRUE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3814], 1
$L81482:

; 212  : 	}
; 213  : 
; 214  : 	// Reset some car status variables
; 215  : 	SetVecZero(&car->Body->Centre.Vel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+32], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+36], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+40], 0

; 216  : 	SetVecZero(&car->Body->Centre.Impulse);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+56], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+60], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+64], 0

; 217  : 	SetVecZero(&car->Body->AngVel);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+332], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+336], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+340], 0

; 218  : 	SetVecZero(&car->Body->AngImpulse);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+356], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+360], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+364], 0

; 219  : 	if (!car->RightingCollide) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3815]
	test	ecx, ecx
	jne	SHORT $L81489

; 220  : 		SetVecZero(&car->Body->Centre.Shift);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+200], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+204], 0
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [ecx+208], 0
$L81489:

; 221  : 	}
; 222  : 
; 223  : 	// Right the car
; 224  : 	VecMinusVec(&car->DestPos, &car->Body->Centre.Pos, &dR);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+3536]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+3540]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+3544]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dR$[ebp+8]

; 225  : #ifndef _PSX
; 226  : 	VecPlusEqScalarVec(&car->Body->Centre.Pos, TimeStep * 10, &dR);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@41200000
	fmul	DWORD PTR _dR$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+20]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@41200000
	fmul	DWORD PTR _dR$[ebp+4]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@41200000
	fmul	DWORD PTR _dR$[ebp+8]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fstp	DWORD PTR [eax+28]

; 227  : 	SLerpQuat(&car->Body->Centre.Quat, &car->DestQuat, TimeStep * 3, &car->Body->Centre.Quat);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 68					; 00000044H
	push	ecx
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@40400000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _car$[ebp]
	add	edx, 3548				; 00000ddcH
	push	edx
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	add	ecx, 68					; 00000044H
	push	ecx
	call	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ; SLerpQuat
	add	esp, 16					; 00000010H

; 228  : #else
; 229  : 	VecPlusEqScalarVec(&car->Body->Centre.Pos, Real(0.12), &dR);
; 230  : 	LerpQuat(&car->Body->Centre.Quat, &car->DestQuat, Real(0.12), &car->Body->Centre.Quat);
; 231  : #endif
; 232  : 	UpdateBody(car->Body, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	?UpdateBody@@YAXPAUNewBodyStruct@@M@Z	; UpdateBody
	add	esp, 8

; 233  : 
; 234  : 	for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L81490
$L81491:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L81490:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	SHORT $L81492

; 235  : 		if (IsWheelPresent(&car->Wheel[iWheel])) {

	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1560]
	and	edx, 1
	je	SHORT $L81493

; 236  : 			UpdateCarWheel(car, iWheel, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _iWheel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?UpdateCarWheel@@YAXPAUCarStruct@@HM@Z	; UpdateCarWheel
	add	esp, 12					; 0000000cH
$L81493:

; 237  : 		}
; 238  : 	}

	jmp	SHORT $L81491
$L81492:

; 239  : 	car->Revs = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3504], 0

; 240  : 
; 241  : 	// Move the Aerial
; 242  : 	UpdateCarAerial2(car, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _car$[ebp]
	push	ecx
	call	?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z	; UpdateCarAerial2
	add	esp, 8

; 243  : 
; 244  : 	// Check to see if the destination has been reached
; 245  : 	if (car->RightingReachDest) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3816]
	test	ecx, ecx
	je	SHORT $L81494

; 246  : 		VecMinusVec(&car->Body->Centre.OldPos, &car->Body->Centre.Pos, &dR);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [eax+20]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+12]
	fsub	DWORD PTR [eax+24]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+16]
	fsub	DWORD PTR [eax+28]
	fstp	DWORD PTR _dR$[ebp+8]

; 247  : 	} else {

	jmp	SHORT $L81495
$L81494:

; 248  : 		SetVecZero(&dR);

	mov	DWORD PTR _dR$[ebp], 0
	mov	DWORD PTR _dR$[ebp+4], 0
	mov	DWORD PTR _dR$[ebp+8], 0
$L81495:

; 249  : 	}
; 250  : 	if ((VecDotVec(&dR, &dR) < SMALL_REAL) &&
; 251  : 		(QuatDotQuat(&car->Body->Centre.Quat, &car->DestQuat) > Real(0.9999)))

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81475
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+68]
	fmul	DWORD PTR [edx+3548]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+72]
	fmul	DWORD PTR [edx+3552]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+76]
	fmul	DWORD PTR [edx+3556]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+80]
	fmul	DWORD PTR [edx+3560]
	faddp	ST(1), ST(0)
	fcomp	DWORD PTR __real@3f7ff972
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81475

; 252  : 	{
; 253  : 		car->Righting = FALSE;

	mov	eax, DWORD PTR _car$[ebp]
	mov	BYTE PTR [eax+3814], 0

; 254  : 		obj->movehandler = (MOVE_HANDLER)MOV_MoveCarNew;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+688], OFFSET FLAT:?MOV_MoveCarNew@@YAXPAUobject_def@@@Z ; MOV_MoveCarNew
$L81475:

; 255  : 	}
; 256  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MOV_RightCar@@YAXPAUobject_def@@@Z ENDP		; MOV_RightCar
_TEXT	ENDS
PUBLIC	?MOV_MoveGhost@@YAXPAUobject_def@@@Z		; MOV_MoveGhost
EXTRN	?InterpGhostData@@YAXPAUCarStruct@@@Z:NEAR	; InterpGhostData
; Function compile flags: /Odt /ZI
;	COMDAT ?MOV_MoveGhost@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_CarObj$ = 8						; size = 4
?MOV_MoveGhost@@YAXPAUobject_def@@@Z PROC NEAR		; MOV_MoveGhost, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 261  : 	// Interpolate the ghost car data
; 262  : 	InterpGhostData(&CarObj->player->car);

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?InterpGhostData@@YAXPAUCarStruct@@@Z	; InterpGhostData
	add	esp, 4

; 263  : 
; 264  : 	// Move the aerial
; 265  : 	UpdateCarAerial2(&CarObj->player->car, TimeStep);

	mov	eax, DWORD PTR ?TimeStep@@3MA
	push	eax
	mov	ecx, DWORD PTR _CarObj$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	add	edx, 44					; 0000002cH
	push	edx
	call	?UpdateCarAerial2@@YAXPAUCarStruct@@M@Z	; UpdateCarAerial2
	add	esp, 8

; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MOV_MoveGhost@@YAXPAUobject_def@@@Z ENDP		; MOV_MoveGhost
_TEXT	ENDS
PUBLIC	?MOV_MoveTrain@@YAXPAUobject_def@@@Z		; MOV_MoveTrain
PUBLIC	__real@43480000
PUBLIC	__real@c633b000
EXTRN	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; BuildWorldSkin
EXTRN	?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z:NEAR ; TransCollPolys
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@c633b000
CONST	SEGMENT
__real@c633b000 DD 0c633b000r			; -11500
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?MOV_MoveTrain@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_vec$ = -12						; size = 12
_obj$ = 8						; size = 4
?MOV_MoveTrain@@YAXPAUobject_def@@@Z PROC NEAR		; MOV_MoveTrain, COMDAT

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 271  : 	VEC vec;
; 272  : 
; 273  : 	// move train
; 274  : 	CopyVec(&obj->body.Centre.Pos, &obj->body.Centre.OldPos);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+16], edx

; 275  : 	obj->body.Centre.Pos.v[Z] -= TimeStep * 200.0f;

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@43480000
	mov	eax, DWORD PTR _obj$[ebp]
	fsubr	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _obj$[ebp]
	fstp	DWORD PTR [ecx+28]

; 276  : 	if (obj->body.Centre.Pos.v[Z] < -11500)

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+28]
	fcomp	DWORD PTR __real@c633b000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81506

; 277  : 		obj->body.Centre.Pos.v[Z] = -400;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+28], -1010302976		; c3c80000H
$L81506:

; 278  : 	VecMinusVec(&obj->body.Centre.Pos, &obj->body.Centre.OldPos, &vec);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR [ecx+16]
	fstp	DWORD PTR _vec$[ebp+8]

; 279  : 	TransCollPolys(obj->body.CollSkin.CollPoly, obj->body.CollSkin.NCollPolys, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	movsx	edx, WORD PTR [ecx+416]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+412]
	push	ecx
	call	?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z ; TransCollPolys
	add	esp, 12					; 0000000cH

; 280  : 
; 281  : 	// update collision skin
; 282  : 	BuildWorldSkin(&obj->body.CollSkin, &obj->body.Centre.Pos, &obj->body.Centre.WMatrix);

	mov	eax, DWORD PTR _obj$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	call	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
	add	esp, 12					; 0000000cH

; 283  : 
; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MOV_MoveTrain@@YAXPAUobject_def@@@Z ENDP		; MOV_MoveTrain
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
END
