; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\timing.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_06NPAAKFED@Player?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DAGGNFD@Car?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NOOJIFMJ@times?4tad?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MEDCMAAH@times?4dat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CCKOKKND@rb?$CL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@EHIEDODD@Failed?5to?5create?5record?5file?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ?UpdateTimeFactor@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CurrentTimer@@YAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRaceTimers@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckForBestLap@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckForBestRace@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTrackTimes@@YAXPAULEVELINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveTrackTimes@@YAXPAULEVELINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?TimerLast@@3KA					; TimerLast
PUBLIC	?TimerDiff@@3KA					; TimerDiff
PUBLIC	?TimerFreq@@3KA					; TimerFreq
PUBLIC	?TotalRaceTime@@3KA				; TotalRaceTime
PUBLIC	?TotalRaceStartTime@@3KA			; TotalRaceStartTime
PUBLIC	?CountdownTime@@3KA				; CountdownTime
PUBLIC	?CountdownEndTime@@3KA				; CountdownEndTime
PUBLIC	?TimeQueue@@3JA					; TimeQueue
PUBLIC	?TimeLoopCount@@3JA				; TimeLoopCount
PUBLIC	?TrackRecords@@3URECORD_ENTRY@@A		; TrackRecords
_BSS	SEGMENT
?TimerLast@@3KA DD 01H DUP (?)				; TimerLast
?TimerDiff@@3KA DD 01H DUP (?)				; TimerDiff
?TimerFreq@@3KA DD 01H DUP (?)				; TimerFreq
?TotalRaceTime@@3KA DD 01H DUP (?)			; TotalRaceTime
?TotalRaceStartTime@@3KA DD 01H DUP (?)			; TotalRaceStartTime
?CountdownTime@@3KA DD 01H DUP (?)			; CountdownTime
?CountdownEndTime@@3KA DD 01H DUP (?)			; CountdownEndTime
?TimeQueue@@3JA DD 01H DUP (?)				; TimeQueue
?TimeLoopCount@@3JA DD 01H DUP (?)			; TimeLoopCount
?TrackRecords@@3URECORD_ENTRY@@A DB 0a78H DUP (?)	; TrackRecords
_BSS	ENDS
PUBLIC	?CurrentTimer@@YAKXZ				; CurrentTimer
PUBLIC	?UpdateTimeFactor@@YAXXZ			; UpdateTimeFactor
PUBLIC	__real@42900000
PUBLIC	__real@41200000
EXTRN	?TimeFactor@@3MA:DWORD				; TimeFactor
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	__fltused:NEAR
;	COMDAT __real@42900000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\timing.cpp
CONST	SEGMENT
__real@42900000 DD 042900000r			; 72
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateTimeFactor@@YAXXZ
_TEXT	SEGMENT
tv134 = -80						; size = 8
tv130 = -72						; size = 8
?UpdateTimeFactor@@YAXXZ PROC NEAR			; UpdateTimeFactor, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 70   : 
; 71   : // set last / current / diff timer
; 72   : 
; 73   : #if RECORD_AVI
; 74   : 	TimerDiff = MS2TIME(1000 / 30);
; 75   : 	//TimerDiff = MS2TIME(1000 / 200);
; 76   : 	TimerLast = TimerCurrent;
; 77   : 	TimerCurrent += TimerDiff;
; 78   : #else
; 79   : 	TimerLast = TimerCurrent;

	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	mov	DWORD PTR ?TimerLast@@3KA, eax		; TimerLast

; 80   : 	TimerCurrent = CurrentTimer();

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR ?TimerCurrent@@3KA, eax	; TimerCurrent

; 81   : 	TimerDiff = TimerCurrent - TimerLast;

	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	sub	eax, DWORD PTR ?TimerLast@@3KA		; TimerLast
	mov	DWORD PTR ?TimerDiff@@3KA, eax		; TimerDiff

; 82   : #endif
; 83   : 
; 84   : // set TimeLoopCount
; 85   : 
; 86   : 	TimeQueue += TimerDiff;

	mov	eax, DWORD PTR ?TimeQueue@@3JA		; TimeQueue
	add	eax, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	DWORD PTR ?TimeQueue@@3JA, eax		; TimeQueue

; 87   : 	TimeLoopCount = TimeQueue / (TimerFreq / 72);

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 72					; 00000048H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimeQueue@@3JA		; TimeQueue
	xor	edx, edx
	div	ecx
	mov	DWORD PTR ?TimeLoopCount@@3JA, eax	; TimeLoopCount

; 88   : 	TimeQueue %= (TimerFreq / 72);

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 72					; 00000048H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimeQueue@@3JA		; TimeQueue
	xor	edx, edx
	div	ecx
	mov	DWORD PTR ?TimeQueue@@3JA, edx		; TimeQueue

; 89   : 	if (TimeLoopCount > 10) TimeLoopCount = 10;

	cmp	DWORD PTR ?TimeLoopCount@@3JA, 10	; TimeLoopCount, 0000000aH
	jle	SHORT $L81554
	mov	DWORD PTR ?TimeLoopCount@@3JA, 10	; TimeLoopCount, 0000000aH
$L81554:

; 90   : 
; 91   : // set TimeFactor
; 92   : 
; 93   : 	TimeFactor = (float)(TimerDiff) / ((float)TimerFreq / 72.0f);

	mov	eax, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR tv130[ebp+4], 0
	fild	QWORD PTR tv130[ebp]
	mov	ecx, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	mov	DWORD PTR tv134[ebp], ecx
	mov	DWORD PTR tv134[ebp+4], 0
	fild	QWORD PTR tv134[ebp]
	fdiv	DWORD PTR __real@42900000
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR ?TimeFactor@@3MA		; TimeFactor

; 94   : 	if (TimeFactor > 10) TimeFactor = 10;

	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fcomp	DWORD PTR __real@41200000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81557
	mov	DWORD PTR ?TimeFactor@@3MA, 1092616192	; 41200000H
$L81557:

; 95   : 
; 96   : // set time step
; 97   : 
; 98   : #if FIXED_TIME_STEP
; 99   : 	//TimeStep = TimeFactor / 72.0f;
; 100  : 	TimeStep = (REAL)1.0f / 100.0f;
; 101  : #else
; 102  : 	TimeStep = TimeFactor / 72.0f;

	fld	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fdiv	DWORD PTR __real@42900000
	fstp	DWORD PTR ?TimeStep@@3MA		; TimeStep

; 103  : #endif
; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTimeFactor@@YAXXZ ENDP				; UpdateTimeFactor
_TEXT	ENDS
EXTRN	__imp__QueryPerformanceCounter@4:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?CurrentTimer@@YAKXZ
_TEXT	SEGMENT
_time$ = -8						; size = 8
?CurrentTimer@@YAKXZ PROC NEAR				; CurrentTimer, COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 115  : 	LARGE_INTEGER time;
; 116  : 	QueryPerformanceCounter(&time);

	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 117  : 	return time.LowPart;

	mov	eax, DWORD PTR _time$[ebp]

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentTimer@@YAKXZ ENDP				; CurrentTimer
_TEXT	ENDS
PUBLIC	?UpdateRaceTimers@@YAXXZ			; UpdateRaceTimers
PUBLIC	?CheckForBestLap@@YAXPAUCarStruct@@@Z		; CheckForBestLap
PUBLIC	?CheckForBestRace@@YAXPAUCarStruct@@@Z		; CheckForBestRace
EXTRN	?Keys@@3PADA:BYTE				; Keys
EXTRN	?LookVec@@3UVectorStruct@@A:BYTE		; LookVec
EXTRN	?InitGhostData@@YAXPAUPlayerStruct@@@Z:NEAR	; InitGhostData
EXTRN	?EndGhostData@@YAXPAUPlayerStruct@@@Z:NEAR	; EndGhostData
EXTRN	?InitBestGhostData@@YAXXZ:NEAR			; InitBestGhostData
EXTRN	?TriggerSplit@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z:NEAR ; TriggerSplit
EXTRN	?GameSettings@@3UGAME_SETTINGS@@A:BYTE		; GameSettings
EXTRN	?PLR_PlayerHead@@3PAUPlayerStruct@@A:DWORD	; PLR_PlayerHead
EXTRN	?PLR_LocalPlayer@@3PAUPlayerStruct@@A:DWORD	; PLR_LocalPlayer
EXTRN	?UpdateCarAiZone@@YADPAUPlayerStruct@@@Z:NEAR	; UpdateCarAiZone
; Function compile flags: /Odt /ZI
;	COMDAT ?UpdateRaceTimers@@YAXXZ
_TEXT	SEGMENT
tv84 = -84						; size = 4
_player$ = -16						; size = 4
_car$ = -12						; size = 4
_countdown$ = -8					; size = 4
_time$ = -4						; size = 4
?UpdateRaceTimers@@YAXXZ PROC NEAR			; UpdateRaceTimers, COMDAT

; 132  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 133  : 	unsigned long time, countdown;
; 134  : 	CAR *car;
; 135  : 	PLAYER *player;
; 136  : 
; 137  : // get current timer
; 138  : 
; 139  : 	time = TimerCurrent;

	mov	eax, DWORD PTR ?TimerCurrent@@3KA	; TimerCurrent
	mov	DWORD PTR _time$[ebp], eax

; 140  : 
; 141  : // counting down?
; 142  : 
; 143  : 	if (CountdownTime)

	cmp	DWORD PTR ?CountdownTime@@3KA, 0	; CountdownTime
	je	SHORT $L81569

; 144  : 	{
; 145  : 		countdown = (CountdownEndTime - time);

	mov	eax, DWORD PTR ?CountdownEndTime@@3KA	; CountdownEndTime
	sub	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR _countdown$[ebp], eax

; 146  : 		CountdownTime = TIME2MS(countdown);

	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR _countdown$[ebp]
	xor	edx, edx
	div	ecx
	mov	DWORD PTR ?CountdownTime@@3KA, eax	; CountdownTime

; 147  : 
; 148  : 		if (countdown & 0x80000000)

	mov	eax, DWORD PTR _countdown$[ebp]
	and	eax, -2147483648			; 80000000H
	je	SHORT $L81570

; 149  : 		{
; 150  : 			TotalRaceStartTime = time + countdown;

	mov	eax, DWORD PTR _time$[ebp]
	add	eax, DWORD PTR _countdown$[ebp]
	mov	DWORD PTR ?TotalRaceStartTime@@3KA, eax	; TotalRaceStartTime

; 151  : 			CountdownTime = 0;

	mov	DWORD PTR ?CountdownTime@@3KA, 0	; CountdownTime

; 152  : 
; 153  : 			for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L81571
$L81572:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L81571:
	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $L81570

; 154  : 			{
; 155  : 				player->car.CurrentLapStartTime = TotalRaceStartTime;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR ?TotalRaceStartTime@@3KA	; TotalRaceStartTime
	mov	DWORD PTR [eax+3544], ecx

; 156  : 			}

	jmp	SHORT $L81572
$L81570:

; 157  : 		}
; 158  : 		return;

	jmp	$L81564
$L81569:

; 159  : 	}
; 160  : 
; 161  : // update race time
; 162  : 
; 163  : #if	RECORD_AVI
; 164  : 	TotalRaceTime += (1000 / 30);
; 165  : #else
; 166  : 	if (GameSettings.Paws) TotalRaceStartTime += TimerDiff;

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+28, 0
	je	SHORT $L81574
	mov	eax, DWORD PTR ?TotalRaceStartTime@@3KA	; TotalRaceStartTime
	add	eax, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	DWORD PTR ?TotalRaceStartTime@@3KA, eax	; TotalRaceStartTime
$L81574:

; 167  : 	TotalRaceTime = TIME2MS(time - TotalRaceStartTime);

	mov	ecx, DWORD PTR _time$[ebp]
	sub	ecx, DWORD PTR ?TotalRaceStartTime@@3KA	; TotalRaceStartTime
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	DWORD PTR ?TotalRaceTime@@3KA, eax	; TotalRaceTime

; 168  : #endif
; 169  : 
; 170  : // loop thru cars
; 171  : 
; 172  : 	for (player = PLR_PlayerHead ; player ; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L81575
$L81576:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L81575:
	cmp	DWORD PTR _player$[ebp], 0
	je	$L81564

; 173  : 	{
; 174  : 		car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 175  : 
; 176  : 		switch (player->type)

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 1
	je	SHORT $L81582
	cmp	DWORD PTR tv84[ebp], 4
	je	$L81590
	jmp	$L81579
$L81582:

; 177  : 		{
; 178  : 
; 179  : // LOCAL PLAYER
; 180  : 
; 181  : 		case PLAYER_LOCAL:
; 182  : 
; 183  : // get lap timer
; 184  : 
; 185  : #if	RECORD_AVI
; 186  : 			car->CurrentLapTime += (1000 / 30);
; 187  : #else
; 188  : 			if (GameSettings.Paws) car->CurrentLapStartTime += TimerDiff;

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+28, 0
	je	SHORT $L81583
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3500]
	add	ecx, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3500], ecx
$L81583:

; 189  : 			car->CurrentLapTime = TIME2MS(time - car->CurrentLapStartTime);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	sub	ecx, DWORD PTR [eax+3500]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3424], eax

; 190  : #endif
; 191  : 
; 192  : // end of lap?
; 193  : 
; 194  : 			if (UpdateCarAiZone(player))

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	?UpdateCarAiZone@@YADPAUPlayerStruct@@@Z ; UpdateCarAiZone
	add	esp, 4
	movsx	ecx, al
	test	ecx, ecx
	je	$L81584

; 195  : 			{
; 196  : 
; 197  : // yep, trigger end split time
; 198  : 
; 199  : 				TriggerSplit(player, 0, -1, &LookVec);

	push	OFFSET FLAT:?LookVec@@3UVectorStruct@@A	; LookVec
	push	-1
	push	0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	?TriggerSplit@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z ; TriggerSplit
	add	esp, 16					; 00000010H

; 200  : 
; 201  : // update lap times
; 202  : 
; 203  : 				car->Laps++;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3420]
	add	ecx, 1
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3420], ecx

; 204  : 				car->NextSplit = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3416], 0

; 205  : 
; 206  : 				car->LastLapTime = car->CurrentLapTime;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3424]
	mov	DWORD PTR [eax+3428], edx

; 207  : 				car->CurrentLapTime = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3424], 0

; 208  : 				car->CurrentLapStartTime = time;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+3500], ecx

; 209  : 
; 210  : // Store times in ghosts data info
; 211  : 			
; 212  : #ifdef _PC
; 213  : 				EndGhostData(PLR_LocalPlayer);

	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	push	eax
	call	?EndGhostData@@YAXPAUPlayerStruct@@@Z	; EndGhostData
	add	esp, 4

; 214  : #endif
; 215  : 
; 216  : // best lap?
; 217  : 
; 218  : 				if (car->LastLapTime < car->BestLapTime)

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [eax+3428]
	cmp	edx, DWORD PTR [ecx+3432]
	jge	SHORT $L81585

; 219  : 					car->BestLapTime = car->LastLapTime;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3428]
	mov	DWORD PTR [eax+3432], edx
$L81585:

; 220  : 
; 221  : 				if (car->AllowedBestTime) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3812]
	test	ecx, ecx
	je	SHORT $L81586

; 222  : 					CheckForBestLap(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?CheckForBestLap@@YAXPAUCarStruct@@@Z	; CheckForBestLap
	add	esp, 4
$L81586:

; 223  : 				}
; 224  : 
; 225  : // reinitalise the ghost car
; 226  : #ifdef _PC
; 227  : 				InitGhostData(PLR_LocalPlayer);

	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	push	eax
	call	?InitGhostData@@YAXPAUPlayerStruct@@@Z	; InitGhostData
	add	esp, 4

; 228  : 				InitBestGhostData();

	call	?InitBestGhostData@@YAXXZ		; InitBestGhostData

; 229  : #endif
; 230  : // best race?
; 231  : 
; 232  : 				if (car->Laps == 5)

	mov	eax, DWORD PTR _car$[ebp]
	cmp	DWORD PTR [eax+3420], 5
	jne	SHORT $L81584

; 233  : 				{
; 234  : 					car->LastRaceTime = TotalRaceTime;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR ?TotalRaceTime@@3KA	; TotalRaceTime
	mov	DWORD PTR [eax+3436], ecx

; 235  : 					TotalRaceTime = 0;

	mov	DWORD PTR ?TotalRaceTime@@3KA, 0	; TotalRaceTime

; 236  : 					TotalRaceStartTime = time;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR ?TotalRaceStartTime@@3KA, eax	; TotalRaceStartTime

; 237  : 
; 238  : 					if (car->LastRaceTime < car->BestRaceTime)

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [eax+3436]
	cmp	edx, DWORD PTR [ecx+3440]
	jge	SHORT $L81588

; 239  : 						car->BestRaceTime = car->LastRaceTime;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3436]
	mov	DWORD PTR [eax+3440], edx
$L81588:

; 240  : 
; 241  : 					if (car->AllowedBestTime) {

	mov	eax, DWORD PTR _car$[ebp]
	movzx	ecx, BYTE PTR [eax+3812]
	test	ecx, ecx
	je	SHORT $L81584

; 242  : 						CheckForBestRace(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?CheckForBestRace@@YAXPAUCarStruct@@@Z	; CheckForBestRace
	add	esp, 4
$L81584:

; 243  : 					}
; 244  : 				}
; 245  : 
; 246  : 			}
; 247  : 
; 248  : 			break;

	jmp	$L81579
$L81590:

; 249  : 
; 250  : // GHOST PLAYER
; 251  : 
; 252  : #ifdef _PC
; 253  : 		case PLAYER_GHOST:
; 254  : 
; 255  : 			if (Keys[DIK_6]) {

	movsx	eax, BYTE PTR ?Keys@@3PADA+7
	test	eax, eax
	je	SHORT $L81591

; 256  : 				if (Keys[DIK_LSHIFT]) {

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	je	SHORT $L81592

; 257  : 					car->CurrentLapStartTime -= TimerDiff;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3500]
	sub	ecx, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3500], ecx

; 258  : 				} else {

	jmp	SHORT $L81591
$L81592:

; 259  : 					car->CurrentLapStartTime += TimerDiff;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3500]
	add	ecx, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3500], ecx
$L81591:

; 260  : 				}
; 261  : 			}
; 262  : 			if (Keys[DIK_7]) {

	movsx	eax, BYTE PTR ?Keys@@3PADA+8
	test	eax, eax
	je	SHORT $L81594

; 263  : 					car->CurrentLapStartTime += TimerDiff * 2;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3500]
	mov	edx, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	lea	eax, DWORD PTR [ecx+edx*2]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [ecx+3500], eax
$L81594:

; 264  : 			}
; 265  : 
; 266  : #if RECORD_AVI
; 267  : 			car->CurrentLapTime += (1000 / 30);
; 268  : #else
; 269  : 			if (GameSettings.Paws) car->CurrentLapStartTime += TimerDiff;

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+28, 0
	je	SHORT $L81595
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+3500]
	add	ecx, DWORD PTR ?TimerDiff@@3KA		; TimerDiff
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3500], ecx
$L81595:

; 270  : 			car->CurrentLapTime = TIME2MS(time - car->CurrentLapStartTime);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	sub	ecx, DWORD PTR [eax+3500]
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	mov	esi, eax
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	edx, DWORD PTR _car$[ebp]
	mov	DWORD PTR [edx+3424], eax
$L81579:

; 271  : #endif
; 272  : 
; 273  : 			break;
; 274  : #endif
; 275  : 
; 276  : // CPU PLAYER
; 277  : 
; 278  : 		case PLAYER_CPU:
; 279  : 			break;
; 280  : 
; 281  : // DEFAULT PLAYER
; 282  : 
; 283  : 		default:
; 284  : 			break;
; 285  : 
; 286  : 		}
; 287  : 	}

	jmp	$L81576
$L81564:

; 288  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateRaceTimers@@YAXXZ ENDP				; UpdateRaceTimers
_TEXT	ENDS
EXTRN	?PlaySfx@@YAXJJJJ@Z:NEAR			; PlaySfx
EXTRN	?SwitchGhostDataStores@@YAXXZ:NEAR		; SwitchGhostDataStores
EXTRN	?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A:DWORD ; GHO_BestGhostInfo
EXTRN	?GHO_GhostExists@@3_NA:BYTE			; GHO_GhostExists
EXTRN	_memcpy:NEAR
EXTRN	?RegistrySettings@@3UREGISTRY_SETTINGS@@A:BYTE	; RegistrySettings
EXTRN	?CarInfo@@3PAUCAR_INFO@@A:DWORD			; CarInfo
_BSS	SEGMENT
_RecordLapFlag DD 0aH DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?CheckForBestLap@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_newGhostCar$ = -1					; size = 1
_car$ = 8						; size = 4
?CheckForBestLap@@YAXPAUCarStruct@@@Z PROC NEAR		; CheckForBestLap, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 296  : 	bool newGhostCar;
; 297  : 	unsigned long i, j;
; 298  : 
; 299  : // new ghost car?
; 300  : #ifdef _PC
; 301  : 	if (car->LastLapTime < GHO_BestGhostInfo->Time[GHOST_LAP_TIME]) {

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR ?GHO_BestGhostInfo@@3PAUGhostInfoStruct@@A ; GHO_BestGhostInfo
	mov	edx, DWORD PTR [eax+3428]
	cmp	edx, DWORD PTR [ecx+108]
	jge	SHORT $L81604

; 302  : 		newGhostCar = TRUE;

	mov	BYTE PTR _newGhostCar$[ebp], 1

; 303  : 	} else {

	jmp	SHORT $L81605
$L81604:

; 304  : 		newGhostCar = FALSE;

	mov	BYTE PTR _newGhostCar$[ebp], 0
$L81605:

; 305  : 	}
; 306  : #endif
; 307  : // loop thru best times
; 308  : 
; 309  : 	for (i = 0 ; i < MAX_RECORD_TIMES ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81606
$L81607:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81606:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jae	$L81608

; 310  : 	{
; 311  : 
; 312  : // check against car last
; 313  : 
; 314  : 		if (car->LastLapTime < TrackRecords.RecordLap[i].Time)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3428]
	cmp	edx, DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+40]
	jge	$L81609

; 315  : 		{
; 316  : 
; 317  : // beat it, copy lower ones down one
; 318  : 
; 319  : #ifdef _PC
; 320  : 			PlaySfx(SFX_RECORD, SFX_MAX_VOL, SFX_CENTRE_PAN, 22050);

	push	22050					; 00005622H
	push	64					; 00000040H
	push	127					; 0000007fH
	push	4
	call	?PlaySfx@@YAXJJJJ@Z			; PlaySfx
	add	esp, 16					; 00000010H

; 321  : #endif
; 322  : 			for (j = MAX_RECORD_TIMES - 1 ; j > i ; j--)

	mov	DWORD PTR _j$[ebp], 9
	jmp	SHORT $L81610
$L81611:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81610:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jbe	SHORT $L81612

; 323  : 			{
; 324  : 				TrackRecords.RecordLap[j] = TrackRecords.RecordLap[j - 1];

	mov	esi, DWORD PTR _j$[ebp]
	sub	esi, 1
	imul	esi, 132				; 00000084H
	add	esi, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+40
	mov	edi, DWORD PTR _j$[ebp]
	imul	edi, 132				; 00000084H
	add	edi, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+40
	mov	ecx, 33					; 00000021H
	rep movsd

; 325  : 				RecordLapFlag[j] = RecordLapFlag[j - 1];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _RecordLapFlag[ecx*4-4]
	mov	DWORD PTR _RecordLapFlag[eax*4], edx

; 326  : 			}

	jmp	SHORT $L81611
$L81612:

; 327  : 
; 328  : // set new record
; 329  : 
; 330  : 			TrackRecords.RecordLap[i].Time = car->LastLapTime;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3428]
	mov	DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+40], edx

; 331  : 			memcpy(TrackRecords.RecordLap[i].Car, CarInfo[car->CarID].Name, CAR_NAMELEN);

	push	64					; 00000040H
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	imul	ecx, 2220				; 000008acH
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	eax, DWORD PTR [edx+ecx+1348]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 132				; 00000084H
	add	ecx, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+108
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 332  : #ifdef _PC
; 333  : 			memcpy(TrackRecords.RecordLap[i].Player, RegistrySettings.PlayerName, MAX_PLAYER_NAME);

	push	64					; 00000040H
	push	OFFSET FLAT:?RegistrySettings@@3UREGISTRY_SETTINGS@@A+60
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	add	eax, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+44
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 334  : #endif
; 335  : 			RecordLapFlag[i] = TRUE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _RecordLapFlag[eax*4], 1

; 336  : 
; 337  : // best time?
; 338  : 
; 339  : 			if (i == 0)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $L81613

; 340  : 			{
; 341  : 				for (j = 0 ; j < MAX_SPLIT_TIMES ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81614
$L81615:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81614:
	cmp	DWORD PTR _j$[ebp], 10			; 0000000aH
	jae	SHORT $L81616

; 342  : 					TrackRecords.SplitTime[j] = car->SplitTime[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+3444]
	mov	DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax*4], ecx
	jmp	SHORT $L81615
$L81616:

; 343  : 
; 344  : 				newGhostCar = TRUE;

	mov	BYTE PTR _newGhostCar$[ebp], 1
$L81613:

; 345  : 			}
; 346  : 
; 347  : 			break;

	jmp	SHORT $L81608
$L81609:

; 348  : 		}
; 349  : 	}

	jmp	$L81607
$L81608:

; 350  : 
; 351  : // store ghost car as best ghost car
; 352  : #ifdef _PC
; 353  : 	if (newGhostCar || !GHO_GhostExists) {

	movzx	eax, BYTE PTR _newGhostCar$[ebp]
	test	eax, eax
	jne	SHORT $L81618
	movzx	eax, BYTE PTR ?GHO_GhostExists@@3_NA	; GHO_GhostExists
	test	eax, eax
	jne	SHORT $L81600
$L81618:

; 354  : 		SwitchGhostDataStores();

	call	?SwitchGhostDataStores@@YAXXZ		; SwitchGhostDataStores
$L81600:

; 355  : 	}
; 356  : #endif
; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckForBestLap@@YAXPAUCarStruct@@@Z ENDP		; CheckForBestLap
_TEXT	ENDS
_BSS	SEGMENT
_RecordRaceFlag DD 0aH DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?CheckForBestRace@@YAXPAUCarStruct@@@Z
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_car$ = 8						; size = 4
?CheckForBestRace@@YAXPAUCarStruct@@@Z PROC NEAR	; CheckForBestRace, COMDAT

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 365  : 	unsigned long i, j;
; 366  : 
; 367  : // loop thru best times
; 368  : 
; 369  : 	for (i = 0 ; i < MAX_RECORD_TIMES ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81624
$L81625:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81624:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jae	$L81621

; 370  : 	{
; 371  : 
; 372  : // check against car last
; 373  : 
; 374  : 		if (car->LastRaceTime < TrackRecords.RecordRace[i].Time)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3436]
	cmp	edx, DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+1360]
	jge	$L81627

; 375  : 		{
; 376  : 
; 377  : // beat it, copy lower ones down one
; 378  : 
; 379  : 			for (j = MAX_RECORD_TIMES - 1 ; j > i ; j--)

	mov	DWORD PTR _j$[ebp], 9
	jmp	SHORT $L81628
$L81629:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81628:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jbe	SHORT $L81630

; 380  : 			{
; 381  : 				TrackRecords.RecordRace[j] = TrackRecords.RecordRace[j - 1];

	mov	esi, DWORD PTR _j$[ebp]
	sub	esi, 1
	imul	esi, 132				; 00000084H
	add	esi, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+1360
	mov	edi, DWORD PTR _j$[ebp]
	imul	edi, 132				; 00000084H
	add	edi, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+1360
	mov	ecx, 33					; 00000021H
	rep movsd

; 382  : 				RecordRaceFlag[j] = RecordRaceFlag[j - 1];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _RecordRaceFlag[ecx*4-4]
	mov	DWORD PTR _RecordRaceFlag[eax*4], edx

; 383  : 			}

	jmp	SHORT $L81629
$L81630:

; 384  : 
; 385  : // set new record
; 386  : 
; 387  : 			TrackRecords.RecordRace[i].Time = car->LastRaceTime;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+3436]
	mov	DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+1360], edx

; 388  : 			memcpy(TrackRecords.RecordRace[i].Car, CarInfo[car->CarID].Name, CAR_NAMELEN);

	push	64					; 00000040H
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	imul	ecx, 2220				; 000008acH
	mov	edx, DWORD PTR ?CarInfo@@3PAUCAR_INFO@@A ; CarInfo
	lea	eax, DWORD PTR [edx+ecx+1348]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 132				; 00000084H
	add	ecx, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+1428
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 389  : #ifdef _PC
; 390  : 			memcpy(TrackRecords.RecordRace[i].Player, RegistrySettings.PlayerName, MAX_PLAYER_NAME);

	push	64					; 00000040H
	push	OFFSET FLAT:?RegistrySettings@@3UREGISTRY_SETTINGS@@A+60
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	add	eax, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+1364
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 391  : #endif
; 392  : 			RecordRaceFlag[i] = TRUE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _RecordRaceFlag[eax*4], 1

; 393  : 
; 394  : 			break;

	jmp	SHORT $L81621
$L81627:

; 395  : 		}
; 396  : 	}

	jmp	$L81625
$L81621:

; 397  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckForBestRace@@YAXPAUCarStruct@@@Z ENDP		; CheckForBestRace
_TEXT	ENDS
PUBLIC	?LoadTrackTimes@@YAXPAULEVELINFO@@@Z		; LoadTrackTimes
PUBLIC	??_C@_06NPAAKFED@Player?$AA@			; `string'
PUBLIC	??_C@_03DAGGNFD@Car?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_09NOOJIFMJ@times?4tad?$AA@		; `string'
PUBLIC	??_C@_09MEDCMAAH@times?4dat?$AA@		; `string'
EXTRN	?GetLevelFilename@@YAPADPADJ@Z:NEAR		; GetLevelFilename
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	__imp__wsprintfA:NEAR
;	COMDAT ??_C@_06NPAAKFED@Player?$AA@
CONST	SEGMENT
??_C@_06NPAAKFED@Player?$AA@ DB 'Player', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAGGNFD@Car?$AA@
CONST	SEGMENT
??_C@_03DAGGNFD@Car?$AA@ DB 'Car', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NOOJIFMJ@times?4tad?$AA@
CONST	SEGMENT
??_C@_09NOOJIFMJ@times?4tad?$AA@ DB 'times.tad', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MEDCMAAH@times?4dat?$AA@
CONST	SEGMENT
??_C@_09MEDCMAAH@times?4dat?$AA@ DB 'times.dat', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadTrackTimes@@YAXPAULEVELINFO@@@Z
_TEXT	SEGMENT
_fp$ = -8						; size = 4
_i$ = -4						; size = 4
_lev$ = 8						; size = 4
?LoadTrackTimes@@YAXPAULEVELINFO@@@Z PROC NEAR		; LoadTrackTimes, COMDAT

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 407  : 	long i;
; 408  : 	FILE *fp;
; 409  : 
; 410  : // set time defaults
; 411  : 
; 412  : 	for (i = 0 ; i < MAX_SPLIT_TIMES ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81636
$L81637:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81636:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jge	SHORT $L81638

; 413  : 	{
; 414  : 		TrackRecords.SplitTime[i] = MAKE_TIME(60, 0, 0);

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax*4], 3600000 ; 0036ee80H

; 415  : 	}

	jmp	SHORT $L81637
$L81638:

; 416  : 
; 417  : 	for (i = 0 ; i < MAX_RECORD_TIMES ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81639
$L81640:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81639:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jge	$L81641

; 418  : 	{
; 419  : 		TrackRecords.RecordLap[i].Time = MAKE_TIME(5, 0, 0);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+40], 300000 ; 000493e0H

; 420  : 		wsprintf(TrackRecords.RecordLap[i].Player, "Player");

	push	OFFSET FLAT:??_C@_06NPAAKFED@Player?$AA@
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	add	eax, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+44
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 421  : 		wsprintf(TrackRecords.RecordLap[i].Car, "Car");

	push	OFFSET FLAT:??_C@_03DAGGNFD@Car?$AA@
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	add	eax, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+108
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 422  : 
; 423  : 		TrackRecords.RecordRace[i].Time = MAKE_TIME(60, 0, 0);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	mov	DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+1360], 3600000 ; 0036ee80H

; 424  : 		wsprintf(TrackRecords.RecordRace[i].Player, "Player");

	push	OFFSET FLAT:??_C@_06NPAAKFED@Player?$AA@
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	add	eax, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+1364
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 425  : 		wsprintf(TrackRecords.RecordRace[i].Car, "Car");

	push	OFFSET FLAT:??_C@_03DAGGNFD@Car?$AA@
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 132				; 00000084H
	add	eax, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+1428
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 426  : 
; 427  : 		RecordLapFlag[i] = FALSE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _RecordLapFlag[eax*4], 0

; 428  : 		RecordRaceFlag[i] = FALSE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _RecordRaceFlag[eax*4], 0

; 429  : 	}

	jmp	$L81640
$L81641:

; 430  : 
; 431  : // read in record file
; 432  : 
; 433  : 	if (GameSettings.Mirrored)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+16, 0
	je	SHORT $L81644

; 434  : 		fp = fopen(GetLevelFilename(RECORDS_FILENAME_MIRRORED, FILENAME_GAME_SETTINGS), "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09NOOJIFMJ@times?4tad?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 435  : 	else

	jmp	SHORT $L81647
$L81644:

; 436  : 		fp = fopen(GetLevelFilename(RECORDS_FILENAME, FILENAME_GAME_SETTINGS), "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09MEDCMAAH@times?4dat?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
$L81647:

; 437  : 	if (!fp) return;

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81649
	jmp	SHORT $L81633
$L81649:

; 438  : 
; 439  : 	fread(&TrackRecords, sizeof(TrackRecords), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2680					; 00000a78H
	push	OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A
	call	_fread
	add	esp, 16					; 00000010H

; 440  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L81633:

; 441  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadTrackTimes@@YAXPAULEVELINFO@@@Z ENDP		; LoadTrackTimes
_TEXT	ENDS
PUBLIC	?SaveTrackTimes@@YAXPAULEVELINFO@@@Z		; SaveTrackTimes
PUBLIC	??_C@_03CCKOKKND@rb?$CL?$AA@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0BN@EHIEDODD@Failed?5to?5create?5record?5file?$AA@ ; `string'
EXTRN	?LevelInf@@3PAULEVELINFO@@A:DWORD		; LevelInf
EXTRN	_fseek:NEAR
EXTRN	_fwrite:NEAR
EXTRN	?LoadGhostData@@YA_NPAULEVELINFO@@@Z:NEAR	; LoadGhostData
EXTRN	?SaveGhostData@@YA_NPAULEVELINFO@@@Z:NEAR	; SaveGhostData
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
;	COMDAT ??_C@_03CCKOKKND@rb?$CL?$AA@
CONST	SEGMENT
??_C@_03CCKOKKND@rb?$CL?$AA@ DB 'rb+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EHIEDODD@Failed?5to?5create?5record?5file?$AA@
CONST	SEGMENT
??_C@_0BN@EHIEDODD@Failed?5to?5create?5record?5file?$AA@ DB 'Failed to cr'
	DB	'eate record file', 00H			; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SaveTrackTimes@@YAXPAULEVELINFO@@@Z
_TEXT	SEGMENT
_record$ = -2832					; size = 2680
_buf$ = -152						; size = 128
_fp$ = -24						; size = 4
_updateGhost$ = -20					; size = 4
_update$ = -16						; size = 4
_l$ = -12						; size = 4
_k$ = -8						; size = 4
_j$ = -4						; size = 4
_lev$ = 8						; size = 4
?SaveTrackTimes@@YAXPAULEVELINFO@@@Z PROC NEAR		; SaveTrackTimes, COMDAT

; 448  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2896				; 00000b50H
	push	ebx
	push	esi
	push	edi

; 449  : 	long j, k, l, update, updateGhost;
; 450  : 	FILE *fp;
; 451  : 	char buf[128];
; 452  : 	RECORD_ENTRY record;
; 453  : 
; 454  : // open records file
; 455  : 
; 456  : 	if (GameSettings.Mirrored)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+16, 0
	je	SHORT $L81661

; 457  : 		fp = fopen(GetLevelFilename(RECORDS_FILENAME_MIRRORED, FILENAME_GAME_SETTINGS), "rb+");

	push	OFFSET FLAT:??_C@_03CCKOKKND@rb?$CL?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09NOOJIFMJ@times?4tad?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 458  : 	else

	jmp	SHORT $L81663
$L81661:

; 459  : 		fp = fopen(GetLevelFilename(RECORDS_FILENAME, FILENAME_GAME_SETTINGS), "rb+");

	push	OFFSET FLAT:??_C@_03CCKOKKND@rb?$CL?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09MEDCMAAH@times?4dat?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
$L81663:

; 460  : 
; 461  : // if none, create new
; 462  : 
; 463  : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	$L81664

; 464  : 	{
; 465  : 		if (GameSettings.Mirrored)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+16, 0
	je	SHORT $L81665

; 466  : 			fp = fopen(GetLevelFilename(RECORDS_FILENAME_MIRRORED, FILENAME_GAME_SETTINGS), "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09NOOJIFMJ@times?4tad?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 467  : 		else

	jmp	SHORT $L81667
$L81665:

; 468  : 			fp = fopen(GetLevelFilename(RECORDS_FILENAME, FILENAME_GAME_SETTINGS), "wb");

	push	OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
	push	2
	push	OFFSET FLAT:??_C@_09MEDCMAAH@times?4dat?$AA@
	call	?GetLevelFilename@@YAPADPADJ@Z		; GetLevelFilename
	add	esp, 8
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
$L81667:

; 469  : 
; 470  : 
; 471  : 		if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81668

; 472  : 		{
; 473  : 			Box(buf, "Failed to create record file", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0BN@EHIEDODD@Failed?5to?5create?5record?5file?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 474  : 			return;

	jmp	$L81652
$L81668:

; 475  : 		}
; 476  : 
; 477  : 		fwrite(&TrackRecords, sizeof(TrackRecords), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2680					; 00000a78H
	push	OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A ; TrackRecords
	call	_fwrite
	add	esp, 16					; 00000010H

; 478  : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 479  : 		SaveGhostData(lev);

	mov	eax, DWORD PTR _lev$[ebp]
	push	eax
	call	?SaveGhostData@@YA_NPAULEVELINFO@@@Z	; SaveGhostData
	add	esp, 4

; 480  : 		return;

	jmp	$L81652
$L81664:

; 481  : 	}
; 482  : 
; 483  : // else munge times with file
; 484  : 
; 485  : 	updateGhost = FALSE;

	mov	DWORD PTR _updateGhost$[ebp], 0

; 486  : 	update = FALSE;

	mov	DWORD PTR _update$[ebp], 0

; 487  : 	fread(&record, sizeof(record), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2680					; 00000a78H
	lea	ecx, DWORD PTR _record$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 488  : 
; 489  : // check lap times
; 490  : 
; 491  : 	for (j = 0 ; j < MAX_RECORD_TIMES ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81670
$L81671:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81670:
	cmp	DWORD PTR _j$[ebp], 10			; 0000000aH
	jge	$L81672

; 492  : 	{
; 493  : 		if (RecordLapFlag[j])

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _RecordLapFlag[eax*4], 0
	je	$L81673

; 494  : 		{
; 495  : 			RecordLapFlag[j] = FALSE;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _RecordLapFlag[eax*4], 0

; 496  : 
; 497  : 			for (k = 0 ; k < MAX_RECORD_TIMES ; k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L81674
$L81675:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L81674:
	cmp	DWORD PTR _k$[ebp], 10			; 0000000aH
	jge	$L81673

; 498  : 			{
; 499  : 				if (TrackRecords.RecordLap[j].Time < record.RecordLap[k].Time)

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _k$[ebp]
	imul	ecx, 132				; 00000084H
	mov	edx, DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+40]
	cmp	edx, DWORD PTR _record$[ebp+ecx+40]
	jge	$L81677

; 500  : 				{
; 501  : 					for (l = MAX_RECORD_TIMES - 1 ; l > k ; l--) record.RecordLap[l] = record.RecordLap[l - 1];

	mov	DWORD PTR _l$[ebp], 9
	jmp	SHORT $L81678
$L81679:
	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 1
	mov	DWORD PTR _l$[ebp], eax
$L81678:
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jle	SHORT $L81680
	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 1
	imul	eax, 132				; 00000084H
	lea	esi, DWORD PTR _record$[ebp+eax+40]
	mov	ecx, DWORD PTR _l$[ebp]
	imul	ecx, 132				; 00000084H
	lea	edi, DWORD PTR _record$[ebp+ecx+40]
	mov	ecx, 33					; 00000021H
	rep movsd
	jmp	SHORT $L81679
$L81680:

; 502  : 					record.RecordLap[k] = TrackRecords.RecordLap[j];

	mov	esi, DWORD PTR _j$[ebp]
	imul	esi, 132				; 00000084H
	add	esi, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+40
	mov	eax, DWORD PTR _k$[ebp]
	imul	eax, 132				; 00000084H
	lea	edi, DWORD PTR _record$[ebp+eax+40]
	mov	ecx, 33					; 00000021H
	rep movsd

; 503  : 					update = TRUE;

	mov	DWORD PTR _update$[ebp], 1

; 504  : 
; 505  : // best time?
; 506  : 
; 507  : 					if (k == 0)

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $L81681

; 508  : 					{
; 509  : 						for (l = 0 ; l < MAX_SPLIT_TIMES ; l++)

	mov	DWORD PTR _l$[ebp], 0
	jmp	SHORT $L81682
$L81683:
	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax
$L81682:
	cmp	DWORD PTR _l$[ebp], 10			; 0000000aH
	jge	SHORT $L81684

; 510  : 							record.SplitTime[l] = TrackRecords.SplitTime[l];

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[ecx*4]
	mov	DWORD PTR _record$[ebp+eax*4], edx
	jmp	SHORT $L81683
$L81684:

; 511  : 
; 512  : 						updateGhost = TRUE;

	mov	DWORD PTR _updateGhost$[ebp], 1
$L81681:

; 513  : 					}
; 514  : 					break;

	jmp	SHORT $L81673
$L81677:

; 515  : 				}
; 516  : 			}

	jmp	$L81675
$L81673:

; 517  : 		}
; 518  : 	}

	jmp	$L81671
$L81672:

; 519  : 
; 520  : // check race times
; 521  : 
; 522  : 	for (j = 0 ; j < MAX_RECORD_TIMES ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81685
$L81686:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81685:
	cmp	DWORD PTR _j$[ebp], 10			; 0000000aH
	jge	$L81687

; 523  : 	{
; 524  : 		if (RecordRaceFlag[j])

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _RecordRaceFlag[eax*4], 0
	je	$L81688

; 525  : 		{
; 526  : 			RecordRaceFlag[j] = FALSE;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _RecordRaceFlag[eax*4], 0

; 527  : 
; 528  : 			for (k = 0 ; k < MAX_RECORD_TIMES ; k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L81689
$L81690:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L81689:
	cmp	DWORD PTR _k$[ebp], 10			; 0000000aH
	jge	$L81688

; 529  : 			{
; 530  : 				if (TrackRecords.RecordRace[j].Time < record.RecordRace[k].Time)

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 132				; 00000084H
	mov	ecx, DWORD PTR _k$[ebp]
	imul	ecx, 132				; 00000084H
	mov	edx, DWORD PTR ?TrackRecords@@3URECORD_ENTRY@@A[eax+1360]
	cmp	edx, DWORD PTR _record$[ebp+ecx+1360]
	jge	SHORT $L81692

; 531  : 				{
; 532  : 					for (l = MAX_RECORD_TIMES - 1 ; l > k ; l--) record.RecordRace[l] = record.RecordRace[l - 1];

	mov	DWORD PTR _l$[ebp], 9
	jmp	SHORT $L81693
$L81694:
	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 1
	mov	DWORD PTR _l$[ebp], eax
$L81693:
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jle	SHORT $L81695
	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 1
	imul	eax, 132				; 00000084H
	lea	esi, DWORD PTR _record$[ebp+eax+1360]
	mov	ecx, DWORD PTR _l$[ebp]
	imul	ecx, 132				; 00000084H
	lea	edi, DWORD PTR _record$[ebp+ecx+1360]
	mov	ecx, 33					; 00000021H
	rep movsd
	jmp	SHORT $L81694
$L81695:

; 533  : 					record.RecordRace[k] = TrackRecords.RecordRace[j];

	mov	esi, DWORD PTR _j$[ebp]
	imul	esi, 132				; 00000084H
	add	esi, OFFSET FLAT:?TrackRecords@@3URECORD_ENTRY@@A+1360
	mov	eax, DWORD PTR _k$[ebp]
	imul	eax, 132				; 00000084H
	lea	edi, DWORD PTR _record$[ebp+eax+1360]
	mov	ecx, 33					; 00000021H
	rep movsd

; 534  : 					update = TRUE;

	mov	DWORD PTR _update$[ebp], 1

; 535  : 					break;

	jmp	SHORT $L81688
$L81692:

; 536  : 				}
; 537  : 			}

	jmp	$L81690
$L81688:

; 538  : 		}
; 539  : 	}

	jmp	$L81686
$L81687:

; 540  : 
; 541  : // update record?
; 542  : 
; 543  : 	if (update)

	cmp	DWORD PTR _update$[ebp], 0
	je	SHORT $L81696

; 544  : 	{
; 545  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 546  : 		fwrite(&record, sizeof(record), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2680					; 00000a78H
	lea	ecx, DWORD PTR _record$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
$L81696:

; 547  : 	}
; 548  : 
; 549  : // close file
; 550  : 
; 551  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 552  : 
; 553  : // update the ghost if required
; 554  : 
; 555  : 	if (updateGhost) 

	cmp	DWORD PTR _updateGhost$[ebp], 0
	je	SHORT $L81697

; 556  : 	{
; 557  : 		SaveGhostData(&LevelInf[GameSettings.Level]);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	call	?SaveGhostData@@YA_NPAULEVELINFO@@@Z	; SaveGhostData
	add	esp, 4

; 558  : 	} else {

	jmp	SHORT $L81652
$L81697:

; 559  : 		LoadGhostData(&LevelInf[GameSettings.Level]);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	call	?LoadGhostData@@YA_NPAULEVELINFO@@@Z	; LoadGhostData
	add	esp, 4
$L81652:

; 560  : 	}
; 561  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SaveTrackTimes@@YAXPAULEVELINFO@@@Z ENDP		; SaveTrackTimes
_TEXT	ENDS
CRT$XCU	SEGMENT
_$S2	DD	FLAT:_$E1
; Function compile flags: /Odt /ZI
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 35   : unsigned long TimerCurrent = CurrentTimer();

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	DWORD PTR ?TimerCurrent@@3KA, eax	; TimerCurrent
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	?TimerCurrent@@3KA				; TimerCurrent
_BSS	SEGMENT
?TimerCurrent@@3KA DD 01H DUP (?)			; TimerCurrent
_BSS	ENDS
END
