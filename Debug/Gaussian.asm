; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Gaussian.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IN@MMFCLFLP@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exp@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearBigMat@@YAXPAUBIGMAT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearBigVec@@YAXPAUBIGVEC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyBigMat@@YAXPAUBIGMAT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyBigVec@@YAXPAUBIGVEC@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BigVecDotVec@@YAMPAUBIGVEC@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TestSolver@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TestConjGrad@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckSolution@@YA_NPAUBIGMAT@@PAUBIGVEC@@11M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??BigVecDotVec@@YAMPAUBIGVEC@@0@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?r@@3UBIGVEC@@A					; r
PUBLIC	?p@@3UBIGVEC@@A					; p
PUBLIC	?t@@3UBIGVEC@@A					; t
_BSS	SEGMENT
?r@@3UBIGVEC@@A DB 084H DUP (?)				; r
?p@@3UBIGVEC@@A DB 084H DUP (?)				; p
?t@@3UBIGVEC@@A DB 084H DUP (?)				; t
_BSS	ENDS
PUBLIC	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
PUBLIC	__real@00000000
PUBLIC	__real@bf800000
EXTRN	__fltused:NEAR
;	COMDAT __real@00000000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\gaussian.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z
_TEXT	SEGMENT
tv392 = -108						; size = 4
tv252 = -108						; size = 4
tv233 = -108						; size = 4
tv208 = -108						; size = 4
tv189 = -108						; size = 4
tv167 = -108						; size = 4
tv148 = -108						; size = 4
tv135 = -108						; size = 4
tv87 = -108						; size = 4
_tReal$ = -40						; size = 4
_maxRes$ = -36						; size = 4
_maxCoef$ = -32						; size = 4
_maxCol$ = -28						; size = 4
_maxRow$ = -24						; size = 4
_tInt$ = -20						; size = 4
_nSolvable$ = -16					; size = 4
_kk$ = -12						; size = 4
_jj$ = -8						; size = 4
_ii$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_resTol$ = 16						; size = 4
_coefTol$ = 20						; size = 4
_origRow$ = 24						; size = 4
_origCol$ = 28						; size = 4
_z$ = 32						; size = 4
_x$ = 36						; size = 4
?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z PROC NEAR ; SolveLinearEquations, COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 52   : 	int		ii, jj, kk;
; 53   : 	int		nSolvable, tInt;
; 54   : 	int		maxRow, maxCol;
; 55   : 	REAL	maxCoef, maxRes;
; 56   : 	REAL	tReal;
; 57   : 	
; 58   : 	
; 59   : 	// Make sure there is something to solve
; 60   : 	if (NRows(a) == 0) return 0;

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+4096], 0
	jne	SHORT $L76378
	xor	eax, eax
	jmp	$L76367
$L76378:

; 61   : 
; 62   : 	// Initialise row and column permutation vectors
; 63   : 	for (ii = 0; ii < NRows(a); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76379
$L76380:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76379:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76381

; 64   : 		origRow[ii] = origCol[ii] = ii;

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _origCol$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _origRow$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 65   : 	}

	jmp	SHORT $L76380
$L76381:

; 66   : 
; 67   : 	// Main elimination loop 
; 68   : 	// (on exit, kk is the number of solvable equations)
; 69   : 	for (kk = 0; kk < NRows(a); kk++) {

	mov	DWORD PTR _kk$[ebp], 0
	jmp	SHORT $L76382
$L76383:
	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _kk$[ebp], eax
$L76382:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	$L76384

; 70   : 
; 71   : 		// Find the equation with the largest residual
; 72   : 		maxRow = kk;

	mov	eax, DWORD PTR _kk$[ebp]
	mov	DWORD PTR _maxRow$[ebp], eax

; 73   : 		maxRes = abs(b->v[maxRow]);

	mov	eax, DWORD PTR _maxRow$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76755
	mov	edx, DWORD PTR _maxRow$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR tv87[ebp]
	jmp	SHORT $L76756
$L76755:
	mov	ecx, DWORD PTR _maxRow$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fchs
	fstp	DWORD PTR tv87[ebp]
$L76756:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR _maxRes$[ebp], eax

; 74   : 		for (ii = kk + 1; ii < NRows(a); ii++) {

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $L76385
$L76386:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76385:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	$L76387

; 75   : 			if (abs(b->v[ii]) > maxRes) {

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76757
	mov	edx, DWORD PTR _ii$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR tv135[ebp]
	jmp	SHORT $L76758
$L76757:
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fchs
	fstp	DWORD PTR tv135[ebp]
$L76758:
	fld	DWORD PTR tv135[ebp]
	fcomp	DWORD PTR _maxRes$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76388

; 76   : 				maxRes = abs(b->v[ii]);

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76759
	mov	edx, DWORD PTR _ii$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR tv148[ebp]
	jmp	SHORT $L76760
$L76759:
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fchs
	fstp	DWORD PTR tv148[ebp]
$L76760:
	mov	eax, DWORD PTR tv148[ebp]
	mov	DWORD PTR _maxRes$[ebp], eax

; 77   : 				maxRow = ii;

	mov	eax, DWORD PTR _ii$[ebp]
	mov	DWORD PTR _maxRow$[ebp], eax
$L76388:

; 78   : 			}
; 79   : 		}

	jmp	$L76386
$L76387:

; 80   : 
; 81   : 		// If the largest resudual is less than tolerance, start back substitution
; 82   : 		// since all further variables must be zero or undetermined
; 83   : 		if (maxRes < resTol) {

	fld	DWORD PTR _maxRes$[ebp]
	fcomp	DWORD PTR _resTol$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76389

; 84   : 			break;

	jmp	$L76384
$L76389:

; 85   : 		}
; 86   : 
; 87   : 		// Determine the pivot column
; 88   : 		maxCol = kk;

	mov	eax, DWORD PTR _kk$[ebp]
	mov	DWORD PTR _maxCol$[ebp], eax

; 89   : 		maxCoef = abs(a->m[maxRow][maxCol]);

	mov	eax, DWORD PTR _maxRow$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _maxCol$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76761
	mov	edx, DWORD PTR _maxRow$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _maxCol$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv167[ebp]
	jmp	SHORT $L76762
$L76761:
	mov	ecx, DWORD PTR _maxRow$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _maxCol$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv167[ebp]
$L76762:
	mov	eax, DWORD PTR tv167[ebp]
	mov	DWORD PTR _maxCoef$[ebp], eax

; 90   : 		for (ii = kk + 1; ii < NRows(a); ii++) {

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $L76390
$L76391:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76390:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	$L76392

; 91   : 			if (abs(a->m[maxRow][ii]) > maxCoef) {

	mov	eax, DWORD PTR _maxRow$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76763
	mov	edx, DWORD PTR _maxRow$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _ii$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv189[ebp]
	jmp	SHORT $L76764
$L76763:
	mov	ecx, DWORD PTR _maxRow$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv189[ebp]
$L76764:
	fld	DWORD PTR tv189[ebp]
	fcomp	DWORD PTR _maxCoef$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76393

; 92   : 				maxCoef = abs(a->m[maxRow][ii]);

	mov	eax, DWORD PTR _maxRow$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76765
	mov	edx, DWORD PTR _maxRow$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _ii$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv208[ebp]
	jmp	SHORT $L76766
$L76765:
	mov	ecx, DWORD PTR _maxRow$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv208[ebp]
$L76766:
	mov	eax, DWORD PTR tv208[ebp]
	mov	DWORD PTR _maxCoef$[ebp], eax

; 93   : 				maxCol = ii;

	mov	eax, DWORD PTR _ii$[ebp]
	mov	DWORD PTR _maxCol$[ebp], eax
$L76393:

; 94   : 			}
; 95   : 		}

	jmp	$L76391
$L76392:

; 96   : 
; 97   : 		// If pivot less than tolerance, perform full pivot on
; 98   : 		// lower square of matrix and determine a new pivot
; 99   : 		if (maxCoef < coefTol) {

	fld	DWORD PTR _maxCoef$[ebp]
	fcomp	DWORD PTR _coefTol$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	$L76394

; 100  : 			maxCoef = ZERO;

	mov	DWORD PTR _maxCoef$[ebp], 0

; 101  : 			for (ii = kk; ii < NRows(a); ii++) {

	mov	eax, DWORD PTR _kk$[ebp]
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $L76395
$L76396:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76395:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	$L76397

; 102  : 				for (jj = kk; jj < NRows(a); jj++) {

	mov	eax, DWORD PTR _kk$[ebp]
	mov	DWORD PTR _jj$[ebp], eax
	jmp	SHORT $L76398
$L76399:
	mov	eax, DWORD PTR _jj$[ebp]
	add	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
$L76398:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	$L76400

; 103  : 					if (abs(a->m[ii][jj]) > maxCoef) {

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76767
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv233[ebp]
	jmp	SHORT $L76768
$L76767:
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv233[ebp]
$L76768:
	fld	DWORD PTR tv233[ebp]
	fcomp	DWORD PTR _maxCoef$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76401

; 104  : 						maxCoef = abs(a->m[ii][jj]);

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76769
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [edx+eax*4]
	fstp	DWORD PTR tv252[ebp]
	jmp	SHORT $L76770
$L76769:
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv252[ebp]
$L76770:
	mov	eax, DWORD PTR tv252[ebp]
	mov	DWORD PTR _maxCoef$[ebp], eax

; 105  : 						maxRow = ii;

	mov	eax, DWORD PTR _ii$[ebp]
	mov	DWORD PTR _maxRow$[ebp], eax

; 106  : 						maxCol = jj;

	mov	eax, DWORD PTR _jj$[ebp]
	mov	DWORD PTR _maxCol$[ebp], eax
$L76401:

; 107  : 					}
; 108  : 				}

	jmp	$L76399
$L76400:

; 109  : 			}

	jmp	$L76396
$L76397:

; 110  : 
; 111  : 			// If pivot still below tolerance, start back substitution
; 112  : 			if (maxCoef < coefTol) {

	fld	DWORD PTR _maxCoef$[ebp]
	fcomp	DWORD PTR _coefTol$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76394

; 113  : 				break;

	jmp	$L76384
$L76394:

; 114  : 			}
; 115  : 		}
; 116  : 
; 117  : 		// If pivot row is not the kth row, perform permutations to make it so
; 118  : 		// and record the change 
; 119  : 		if (maxRow != kk) {

	mov	eax, DWORD PTR _maxRow$[ebp]
	cmp	eax, DWORD PTR _kk$[ebp]
	je	$L76403

; 120  : 			for (jj = 0; jj < NRows(a); jj++) {

	mov	DWORD PTR _jj$[ebp], 0
	jmp	SHORT $L76404
$L76405:
	mov	eax, DWORD PTR _jj$[ebp]
	add	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
$L76404:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76406

; 121  : 				tReal = a->m[kk][jj];

	mov	eax, DWORD PTR _kk$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _tReal$[ebp], edx

; 122  : 				a->m[kk][jj] = a->m[maxRow][jj];

	mov	eax, DWORD PTR _maxRow$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	esi, DWORD PTR _jj$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 123  : 				a->m[maxRow][jj] = tReal;

	mov	eax, DWORD PTR _maxRow$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 124  : 			}

	jmp	SHORT $L76405
$L76406:

; 125  : 			tReal = b->v[kk];

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tReal$[ebp], edx

; 126  : 			b->v[kk] = b->v[maxRow];

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _maxRow$[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 127  : 			b->v[maxRow] = tReal;

	mov	eax, DWORD PTR _maxRow$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 128  : 			tInt = origRow[kk];

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _origRow$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tInt$[ebp], edx

; 129  : 			origRow[kk] = origRow[maxRow];

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _origRow$[ebp]
	mov	edx, DWORD PTR _maxRow$[ebp]
	mov	esi, DWORD PTR _origRow$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 130  : 			origRow[maxRow] = tInt;

	mov	eax, DWORD PTR _maxRow$[ebp]
	mov	ecx, DWORD PTR _origRow$[ebp]
	mov	edx, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$L76403:

; 131  : 		}
; 132  : 
; 133  : 		// If pivot column is not kth column, perform permutations to make it so
; 134  : 		// and record the change
; 135  : 		if (maxCol != kk) {

	mov	eax, DWORD PTR _maxCol$[ebp]
	cmp	eax, DWORD PTR _kk$[ebp]
	je	$L76407

; 136  : 			for (jj = 0; jj < NRows(a); jj++) {

	mov	DWORD PTR _jj$[ebp], 0
	jmp	SHORT $L76408
$L76409:
	mov	eax, DWORD PTR _jj$[ebp]
	add	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
$L76408:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76410

; 137  : 				tReal = a->m[jj][kk];

	mov	eax, DWORD PTR _jj$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _tReal$[ebp], edx

; 138  : 				a->m[jj][kk] = a->m[jj][maxCol];

	mov	eax, DWORD PTR _jj$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _kk$[ebp]
	mov	esi, DWORD PTR _maxCol$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 139  : 				a->m[jj][maxCol] = tReal;

	mov	eax, DWORD PTR _jj$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _maxCol$[ebp]
	mov	edx, DWORD PTR _tReal$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 140  : 			}

	jmp	SHORT $L76409
$L76410:

; 141  : 			tInt = origCol[kk];

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _origCol$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tInt$[ebp], edx

; 142  : 			origCol[kk] = origCol[maxCol];

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _origCol$[ebp]
	mov	edx, DWORD PTR _maxCol$[ebp]
	mov	esi, DWORD PTR _origCol$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 143  : 			origCol[maxCol] = tInt;

	mov	eax, DWORD PTR _maxCol$[ebp]
	mov	ecx, DWORD PTR _origCol$[ebp]
	mov	edx, DWORD PTR _tInt$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$L76407:

; 144  : 		}
; 145  : 
; 146  : 		// Do the elimination for this step
; 147  : 		tReal = - ONE / a->m[kk][kk];

	mov	eax, DWORD PTR _kk$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
	fld	DWORD PTR __real@bf800000
	fdiv	DWORD PTR [eax+ecx*4]
	fstp	DWORD PTR _tReal$[ebp]

; 148  : 		//tReal = - a->m[kk][kk];
; 149  : 		for (ii = kk + 1; ii < NRows(a); ii++) {

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $L76411
$L76412:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76411:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76413

; 150  : 			a->m[ii][kk] *= tReal;

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
	fld	DWORD PTR _tReal$[ebp]
	fmul	DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _kk$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 151  : 		}

	jmp	SHORT $L76412
$L76413:

; 152  : 		// a matrix
; 153  : 		for (jj = kk + 1; jj < NRows(a); jj++) {

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
	jmp	SHORT $L76414
$L76415:
	mov	eax, DWORD PTR _jj$[ebp]
	add	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
$L76414:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76416

; 154  : 			tReal = a->m[kk][jj];

	mov	eax, DWORD PTR _kk$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _tReal$[ebp], edx

; 155  : 			for (ii = kk + 1; ii < NRows(a); ii++) {

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $L76417
$L76418:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76417:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76419

; 156  : 				a->m[ii][jj] += tReal * a->m[ii][kk];

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _kk$[ebp]
	fld	DWORD PTR _tReal$[ebp]
	fmul	DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _jj$[ebp]
	fadd	DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _jj$[ebp]
	fstp	DWORD PTR [edx+eax*4]

; 157  : 			}

	jmp	SHORT $L76418
$L76419:

; 158  : 		}

	jmp	SHORT $L76415
$L76416:

; 159  : 		// b vector
; 160  : 		tReal = b->v[kk];

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tReal$[ebp], edx

; 161  : 		for (ii = kk + 1; ii < NRows(a); ii++) {

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $L76420
$L76421:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76420:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76422

; 162  : 			b->v[ii] += tReal * a->m[ii][kk];

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
	fld	DWORD PTR _tReal$[ebp]
	fmul	DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fadd	DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 163  : 		}

	jmp	SHORT $L76421
$L76422:

; 164  : 		/*tReal = ONE / a->m[kk][kk];
; 165  : 		for (jj = kk + 1; jj < NRows(a); jj++) {
; 166  : 			b->v[jj] -= b->v[kk] * a->m[jj][kk] * tReal; // / a->m[kk][kk];
; 167  : 			for (ii = NRows(a) - 1; ii >= kk; ii--) {
; 168  : 				a->m[jj][ii] -= a->m[kk][ii] * a->m[jj][kk] * tReal; // / a->m[kk][kk];
; 169  : 			}
; 170  : 		}*/
; 171  : 
; 172  : 
; 173  : 
; 174  : 	}

	jmp	$L76383
$L76384:

; 175  : 
; 176  : 	// kk is the number of solvable, non-trivial equations 
; 177  : 	// (unless last b element is less than tolerance)
; 178  : 	if (abs(b->v[kk - 1]) < resTol) {

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+eax*4-4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76771
	mov	edx, DWORD PTR _kk$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+edx*4-4]
	fstp	DWORD PTR tv392[ebp]
	jmp	SHORT $L76772
$L76771:
	mov	ecx, DWORD PTR _kk$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+ecx*4-4]
	fchs
	fstp	DWORD PTR tv392[ebp]
$L76772:
	fld	DWORD PTR tv392[ebp]
	fcomp	DWORD PTR _resTol$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76423

; 179  : 		nSolvable = kk -1;

	mov	eax, DWORD PTR _kk$[ebp]
	sub	eax, 1
	mov	DWORD PTR _nSolvable$[ebp], eax

; 180  : 	} else {

	jmp	SHORT $L76424
$L76423:

; 181  : 		nSolvable = kk;

	mov	eax, DWORD PTR _kk$[ebp]
	mov	DWORD PTR _nSolvable$[ebp], eax
$L76424:

; 182  : 	}
; 183  : 
; 184  : 	// Make sure there are some solvable and non-trivial equations
; 185  : 	if (nSolvable <= 0) {

	cmp	DWORD PTR _nSolvable$[ebp], 0
	jg	SHORT $L76425

; 186  : 		return 0;

	xor	eax, eax
	jmp	$L76367
$L76425:

; 187  : 	}
; 188  : 
; 189  : 	// Perform back-substitution to solve the solvable equations
; 190  : 	if (nSolvable > 1) {

	cmp	DWORD PTR _nSolvable$[ebp], 1
	jle	$L76426

; 191  : 		for (jj = nSolvable - 1; jj > 0; jj--) {

	mov	eax, DWORD PTR _nSolvable$[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
	jmp	SHORT $L76427
$L76428:
	mov	eax, DWORD PTR _jj$[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
$L76427:
	cmp	DWORD PTR _jj$[ebp], 0
	jle	SHORT $L76426

; 192  : 			z->v[jj] = b->v[jj] / a->m[jj][jj];

	mov	eax, DWORD PTR _jj$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fdiv	DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _jj$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	fstp	DWORD PTR [ecx+eax*4]

; 193  : 			tReal = - z->v[jj];

	mov	eax, DWORD PTR _jj$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fchs
	fstp	DWORD PTR _tReal$[ebp]

; 194  : 			for (ii = 0; ii < jj; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76430
$L76431:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76430:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _jj$[ebp]
	jge	SHORT $L76432

; 195  : 				b->v[ii] += tReal * a->m[ii][jj];

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	fld	DWORD PTR _tReal$[ebp]
	fmul	DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fadd	DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 196  : 			}

	jmp	SHORT $L76431
$L76432:

; 197  : 		}

	jmp	SHORT $L76428
$L76426:

; 198  : 	}
; 199  : 	z->v[0] = b->v[0] / a->m[0][0];

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR [ecx]
	mov	edx, DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx]

; 200  : 
; 201  : 	// Zero the unused variables
; 202  : 	for (ii = nSolvable; ii < NRows(a); ii++) {

	mov	eax, DWORD PTR _nSolvable$[ebp]
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $L76433
$L76434:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76433:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76435

; 203  : 		z->v[ii] = ZERO;

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 204  : 	}

	jmp	SHORT $L76434
$L76435:

; 205  : 
; 206  : 	// Reorder variables to correspond the the input order
; 207  : 	for (ii = 0; ii < NRows(a); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76436
$L76437:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76436:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76438

; 208  : 		x->v[origCol[ii]] = z->v[ii];

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _origCol$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 209  : 	}

	jmp	SHORT $L76437
$L76438:

; 210  : 
; 211  : 	return nSolvable;

	mov	eax, DWORD PTR _nSolvable$[ebp]
$L76367:

; 212  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ENDP ; SolveLinearEquations
_TEXT	ENDS
PUBLIC	?ClearBigMat@@YAXPAUBIGMAT@@@Z			; ClearBigMat
; Function compile flags: /Odt /ZI
;	COMDAT ?ClearBigMat@@YAXPAUBIGMAT@@@Z
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
?ClearBigMat@@YAXPAUBIGMAT@@@Z PROC NEAR		; ClearBigMat, COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 225  : 	int i,j;
; 226  : 
; 227  : 	for (i = 0; i < NRows(a); i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76444
$L76445:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76444:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76441

; 228  : 		for (j = 0; j < NCols(a); j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L76447
$L76448:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L76447:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4100]
	jge	SHORT $L76449

; 229  : 			a->m[i][j] = ZERO;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 230  : 		}

	jmp	SHORT $L76448
$L76449:

; 231  : 	}

	jmp	SHORT $L76445
$L76441:

; 232  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearBigMat@@YAXPAUBIGMAT@@@Z ENDP			; ClearBigMat
_TEXT	ENDS
PUBLIC	?ClearBigVec@@YAXPAUBIGVEC@@@Z			; ClearBigVec
; Function compile flags: /Odt /ZI
;	COMDAT ?ClearBigVec@@YAXPAUBIGVEC@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_b$ = 8							; size = 4
?ClearBigVec@@YAXPAUBIGVEC@@@Z PROC NEAR		; ClearBigVec, COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 236  : 	int i;
; 237  : 
; 238  : 	for (i = 0; i < NSize(b); i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76454
$L76455:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76454:
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+128]
	jge	SHORT $L76452

; 239  : 		b->v[i] = ZERO;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 240  : 	}

	jmp	SHORT $L76455
$L76452:

; 241  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearBigVec@@YAXPAUBIGVEC@@@Z ENDP			; ClearBigVec
_TEXT	ENDS
PUBLIC	?CopyBigMat@@YAXPAUBIGMAT@@0@Z			; CopyBigMat
; Function compile flags: /Odt /ZI
;	COMDAT ?CopyBigMat@@YAXPAUBIGMAT@@0@Z
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?CopyBigMat@@YAXPAUBIGMAT@@0@Z PROC NEAR		; CopyBigMat, COMDAT

; 244  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 245  : 	int i, j;
; 246  : 
; 247  : 	SetBigMatSize((dest), NRows(src), NCols(src));

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4096]
	mov	DWORD PTR [eax+4096], edx
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4100]
	mov	DWORD PTR [eax+4100], edx

; 248  : 	for (i = 0; i < NRows(src); i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76463
$L76464:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76463:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76460

; 249  : 		for (j = 0; j < NCols(src); j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L76466
$L76467:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L76466:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4100]
	jge	SHORT $L76468

; 250  : 			(dest)->m[i][j] = (src)->m[i][j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 251  : 		}

	jmp	SHORT $L76467
$L76468:

; 252  : 	}

	jmp	SHORT $L76464
$L76460:

; 253  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyBigMat@@YAXPAUBIGMAT@@0@Z ENDP			; CopyBigMat
_TEXT	ENDS
PUBLIC	?CopyBigVec@@YAXPAUBIGVEC@@0@Z			; CopyBigVec
; Function compile flags: /Odt /ZI
;	COMDAT ?CopyBigVec@@YAXPAUBIGVEC@@0@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?CopyBigVec@@YAXPAUBIGVEC@@0@Z PROC NEAR		; CopyBigVec, COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 257  : 	int i;
; 258  : 
; 259  : 	SetBigVecSize((dest), NSize(src));

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx

; 260  : 	for (i = 0; i < NSize(src); i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76474
$L76475:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76474:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+128]
	jge	SHORT $L76472

; 261  : 		(dest)->v[i] = (src)->v[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 262  : 	}

	jmp	SHORT $L76475
$L76472:

; 263  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyBigVec@@YAXPAUBIGVEC@@0@Z ENDP			; CopyBigVec
_TEXT	ENDS
PUBLIC	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z	; BigMatMulVec
; Function compile flags: /Odt /ZI
;	COMDAT ?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z
_TEXT	SEGMENT
_jj$ = -8						; size = 4
_ii$ = -4						; size = 4
_matLeft$ = 8						; size = 4
_vecRight$ = 12						; size = 4
_vecOut$ = 16						; size = 4
?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z PROC NEAR	; BigMatMulVec, COMDAT

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 267  : 	int ii, jj;
; 268  : 
; 269  : 	if (NCols(matLeft) != NSize(vecRight)) return;

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _vecRight$[ebp]
	mov	edx, DWORD PTR [eax+4100]
	cmp	edx, DWORD PTR [ecx+128]
	je	SHORT $L76484
	jmp	SHORT $L76481
$L76484:

; 270  : 
; 271  : 	for (ii = 0; ii < NRows(matLeft); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76485
$L76486:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76485:
	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76481

; 272  : 		vecOut->v[ii] = ZERO;

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _vecOut$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 273  : 		for (jj = 0; jj < NCols(matLeft); jj++) {

	mov	DWORD PTR _jj$[ebp], 0
	jmp	SHORT $L76488
$L76489:
	mov	eax, DWORD PTR _jj$[ebp]
	add	eax, 1
	mov	DWORD PTR _jj$[ebp], eax
$L76488:
	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	cmp	ecx, DWORD PTR [eax+4100]
	jge	SHORT $L76490

; 274  : 			vecOut->v[ii] += MulScalar(matLeft->m[ii][jj], vecRight->v[jj]);

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _jj$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	eax, DWORD PTR _vecRight$[ebp]
	fmul	DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR _vecOut$[ebp]
	fadd	DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _vecOut$[ebp]
	fstp	DWORD PTR [ecx+eax*4]

; 275  : 		}

	jmp	SHORT $L76489
$L76490:

; 276  : 	}

	jmp	SHORT $L76486
$L76481:

; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ENDP	; BigMatMulVec
_TEXT	ENDS
PUBLIC	?BigVecDotVec@@YAMPAUBIGVEC@@0@Z		; BigVecDotVec
PUBLIC	?__LINE__Var@?1??BigVecDotVec@@YAMPAUBIGVEC@@0@Z@4JA ; `BigVecDotVec'::`2'::__LINE__Var
PUBLIC	??_C@_0IN@MMFCLFLP@c?3?2documents?5and?5settings?2jarhea@ ; `string'
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
;	COMDAT ??_C@_0IN@MMFCLFLP@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IN@MMFCLFLP@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\gauss'
	DB	'ian.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??BigVecDotVec@@YAMPAUBIGVEC@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??BigVecDotVec@@YAMPAUBIGVEC@@0@Z@4JA DD 0118H ; `BigVecDotVec'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?BigVecDotVec@@YAMPAUBIGVEC@@0@Z
_TEXT	SEGMENT
_dot$ = -8						; size = 4
_ii$ = -4						; size = 4
_vLeft$ = 8						; size = 4
_vRight$ = 12						; size = 4
?BigVecDotVec@@YAMPAUBIGVEC@@0@Z PROC NEAR		; BigVecDotVec, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 281  : 	int ii;
; 282  : 	REAL dot;
; 283  : 
; 284  : 	Assert(NSize(vLeft) == NSize(vRight));

	push	OFFSET FLAT:??_C@_0IN@MMFCLFLP@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??BigVecDotVec@@YAMPAUBIGVEC@@0@Z@4JA
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _vLeft$[ebp]
	mov	edx, DWORD PTR _vRight$[ebp]
	mov	eax, DWORD PTR [ecx+128]
	cmp	eax, DWORD PTR [edx+128]
	sete	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 285  : 
; 286  : 	dot = ZERO;

	mov	DWORD PTR _dot$[ebp], 0

; 287  : 	for (ii = 0; ii < NSize(vLeft); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76499
$L76500:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76499:
	mov	eax, DWORD PTR _vLeft$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+128]
	jge	SHORT $L76501

; 288  : 		dot += MulScalar(vLeft->v[ii], vRight->v[ii]);

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _vLeft$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	eax, DWORD PTR _vRight$[ebp]
	fmul	DWORD PTR [eax+edx*4]
	fadd	DWORD PTR _dot$[ebp]
	fstp	DWORD PTR _dot$[ebp]

; 289  : 	}

	jmp	SHORT $L76500
$L76501:

; 290  : 
; 291  : 	return dot;

	fld	DWORD PTR _dot$[ebp]

; 292  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BigVecDotVec@@YAMPAUBIGVEC@@0@Z ENDP			; BigVecDotVec
_TEXT	ENDS
PUBLIC	?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z	; BigVecPlusScalarVec
PUBLIC	?__LINE__Var@?1??BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z@4JA ; `BigVecPlusScalarVec'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z@4JA DD 0127H ; `BigVecPlusScalarVec'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z
_TEXT	SEGMENT
_ii$ = -4						; size = 4
_vLeft$ = 8						; size = 4
_s$ = 12						; size = 4
_vRight$ = 16						; size = 4
_vOut$ = 20						; size = 4
?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z PROC NEAR	; BigVecPlusScalarVec, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 296  : 	int ii;
; 297  : 
; 298  : 	Assert(NSize(vLeft) == NSize(vRight));

	push	OFFSET FLAT:??_C@_0IN@MMFCLFLP@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z@4JA
	add	eax, 3
	push	eax
	mov	ecx, DWORD PTR _vLeft$[ebp]
	mov	edx, DWORD PTR _vRight$[ebp]
	mov	eax, DWORD PTR [ecx+128]
	cmp	eax, DWORD PTR [edx+128]
	sete	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 299  : 
; 300  : 	for (ii = 0; ii < NSize(vLeft); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76510
$L76511:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76510:
	mov	eax, DWORD PTR _vLeft$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+128]
	jge	SHORT $L76507

; 301  : 		vOut->v[ii] = vLeft->v[ii] + MulScalar(s, vRight->v[ii]);

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _vRight$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	eax, DWORD PTR _vLeft$[ebp]
	fadd	DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 302  : 	}

	jmp	SHORT $L76511
$L76507:

; 303  : 
; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z ENDP		; BigVecPlusScalarVec
_TEXT	ENDS
PUBLIC	?exp@@YAMM@Z					; exp
PUBLIC	?pow@@YAMMH@Z					; pow
PUBLIC	?TestSolver@@YAXXZ				; TestSolver
PUBLIC	__real@3e800000
PUBLIC	__real@41000000
PUBLIC	__real@3f800000
_BSS	SEGMENT
_Coef	DB	01008H DUP (?)
_OrigCoef DB	01008H DUP (?)
_Res	DB	084H DUP (?)
_NewRes	DB	084H DUP (?)
_OrigRes DB	084H DUP (?)
_Soln	DB	084H DUP (?)
_Work	DB	084H DUP (?)
_OrigRow DD	020H DUP (?)
_OrigCol DD	020H DUP (?)
_BSS	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?TestSolver@@YAXXZ
_TEXT	SEGMENT
tv351 = -80						; size = 4
tv342 = -80						; size = 4
tv309 = -80						; size = 4
_xx$ = -12						; size = 4
_kk$ = -8						; size = 4
_ii$ = -4						; size = 4
?TestSolver@@YAXXZ PROC NEAR				; TestSolver, COMDAT

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 324  : 	int		ii, kk;
; 325  : 	REAL	xx;
; 326  : 
; 327  : 	/////////////////////////////////////////////////////////////////////
; 328  : 	// Test 1: Simple solution
; 329  : 	//
; 330  : 	SetBigMatSize(&Coef, 4, 4);

	mov	DWORD PTR _Coef+4096, 4
	mov	DWORD PTR _Coef+4100, 4

; 331  : 	SetBigVecSize(&Res, 4);

	mov	DWORD PTR _Res+128, 4

; 332  : 
; 333  : 	Coef.m[0][0] = 1.0f;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 334  : 	Coef.m[0][1] = 0.0f;

	mov	DWORD PTR _Coef+4, 0

; 335  : 	Coef.m[0][2] = 1.0f;

	mov	DWORD PTR _Coef+8, 1065353216		; 3f800000H

; 336  : 	Coef.m[0][3] = 0.0f;

	mov	DWORD PTR _Coef+12, 0

; 337  : 
; 338  : 	Coef.m[1][0] = 1.0f;

	mov	DWORD PTR _Coef+128, 1065353216		; 3f800000H

; 339  : 	Coef.m[1][1] = 0.0f;

	mov	DWORD PTR _Coef+132, 0

; 340  : 	Coef.m[1][2] = 1.0f;

	mov	DWORD PTR _Coef+136, 1065353216		; 3f800000H

; 341  : 	Coef.m[1][3] = 0.0f;

	mov	DWORD PTR _Coef+140, 0

; 342  : 
; 343  : 	Coef.m[2][0] = 0.0f;

	mov	DWORD PTR _Coef+256, 0

; 344  : 	Coef.m[2][1] = 1.0f;

	mov	DWORD PTR _Coef+260, 1065353216		; 3f800000H

; 345  : 	Coef.m[2][2] = 0.0f;

	mov	DWORD PTR _Coef+264, 0

; 346  : 	Coef.m[2][3] = 1.0f;

	mov	DWORD PTR _Coef+268, 1065353216		; 3f800000H

; 347  : 
; 348  : 	Coef.m[3][0] = 0.0f;

	mov	DWORD PTR _Coef+384, 0

; 349  : 	Coef.m[3][1] = 1.0f;

	mov	DWORD PTR _Coef+388, 1065353216		; 3f800000H

; 350  : 	Coef.m[3][2] = 1.0f;

	mov	DWORD PTR _Coef+392, 1065353216		; 3f800000H

; 351  : 	Coef.m[3][3] = 1.0f;

	mov	DWORD PTR _Coef+396, 1065353216		; 3f800000H

; 352  : 
; 353  : 	Res.v[0] = 2.0f;

	mov	DWORD PTR _Res, 1073741824		; 40000000H

; 354  : 	Res.v[1] = 2.0f;

	mov	DWORD PTR _Res+4, 1073741824		; 40000000H

; 355  : 	Res.v[2] = 2.0f;

	mov	DWORD PTR _Res+8, 1073741824		; 40000000H

; 356  : 	Res.v[3] = 2.0f;

	mov	DWORD PTR _Res+12, 1073741824		; 40000000H

; 357  : 
; 358  : 	SolveLinearEquations(&Coef, &Res, 0.0001f, 0.01f, OrigRow, OrigCol, &Work, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	1008981770				; 3c23d70aH
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 359  : 
; 360  : 
; 361  : 	/////////////////////////////////////////////////////////////////////
; 362  : 	// Test 2:
; 363  : 	//
; 364  : 	SetBigMatSize(&Coef, 2, 2);

	mov	DWORD PTR _Coef+4096, 2
	mov	DWORD PTR _Coef+4100, 2

; 365  : 	SetBigVecSize(&Res, 2);

	mov	DWORD PTR _Res+128, 2

; 366  : 
; 367  : 	Coef.m[0][0] = 1.0f;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 368  : 	Coef.m[0][1] = 0.0f;

	mov	DWORD PTR _Coef+4, 0

; 369  : 	Coef.m[1][0] = 1.01f;

	mov	DWORD PTR _Coef+128, 1065437102		; 3f8147aeH

; 370  : 	Coef.m[1][1] = 0.0f;

	mov	DWORD PTR _Coef+132, 0

; 371  : 
; 372  : 	Res.v[0] = 2.0f;

	mov	DWORD PTR _Res, 1073741824		; 40000000H

; 373  : 	Res.v[1] = 1.0f;

	mov	DWORD PTR _Res+4, 1065353216		; 3f800000H

; 374  : 
; 375  : 	SolveLinearEquations(&Coef, &Res, 0.0001f, 0.01f, OrigRow, OrigCol, &Work, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	1008981770				; 3c23d70aH
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 376  : 
; 377  : 
; 378  : 	/////////////////////////////////////////////////////////////////////
; 379  : 	// Test 3:
; 380  : 	//
; 381  : 	SetBigMatSize(&Coef, 5, 5);

	mov	DWORD PTR _Coef+4096, 5
	mov	DWORD PTR _Coef+4100, 5

; 382  : 	SetBigVecSize(&Res, 5);

	mov	DWORD PTR _Res+128, 5

; 383  : 	SetBigVecSize(&Soln, 5);

	mov	DWORD PTR _Soln+128, 5

; 384  : 	for (ii = 0; ii < NRows(&Coef); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76527
$L76528:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76527:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	SHORT $L76529

; 385  : 		xx = (ii + 1) * Real(0.25);

	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR tv309[ebp], eax
	fild	DWORD PTR tv309[ebp]
	fmul	DWORD PTR __real@3e800000
	fstp	DWORD PTR _xx$[ebp]

; 386  : 		for (kk = 0; kk < NRows(&Coef); kk++) {

	mov	DWORD PTR _kk$[ebp], 0
	jmp	SHORT $L76531
$L76532:
	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _kk$[ebp], eax
$L76531:
	mov	eax, DWORD PTR _kk$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	SHORT $L76533

; 387  : 			Coef.m[ii][kk] = (REAL)pow(xx, kk + 1);

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _kk$[ebp]
	fstp	DWORD PTR _Coef[edx+eax*4]

; 388  : 		}

	jmp	SHORT $L76532
$L76533:

; 389  : 		Res.v[ii] = xx * (REAL)exp(-xx);

	fld	DWORD PTR _xx$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fmul	DWORD PTR _xx$[ebp]
	mov	eax, DWORD PTR _ii$[ebp]
	fstp	DWORD PTR _Res[eax*4]

; 390  : 	}

	jmp	$L76528
$L76529:

; 391  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 392  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 393  : 	SolveLinearEquations(&Coef, &Res, 0.0f, 0.0001f, OrigRow, OrigCol, &Work, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	0
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 394  : 
; 395  : 	BigMatMulVec(&OrigCoef, &Soln, &NewRes);

	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_OrigCoef
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 396  : 
; 397  : 	/////////////////////////////////////////////////////////////////////
; 398  : 	// Test 4: 
; 399  : 	//
; 400  : 	SetBigMatSize(&Coef, 9, 9);

	mov	DWORD PTR _Coef+4096, 9
	mov	DWORD PTR _Coef+4100, 9

; 401  : 	SetBigVecSize(&Res, 9);

	mov	DWORD PTR _Res+128, 9

; 402  : 	SetBigVecSize(&Soln, 9);

	mov	DWORD PTR _Soln+128, 9

; 403  : 	ClearBigMat(&Coef);

	push	OFFSET FLAT:_Coef
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 404  : 	ClearBigVec(&Res);

	push	OFFSET FLAT:_Res
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 405  : 
; 406  : 	for (ii = 0; ii < NRows(&Coef); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76536
$L76537:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76536:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	$L76538

; 407  : 		xx = ii / Real(8.0);

	fild	DWORD PTR _ii$[ebp]
	fdiv	DWORD PTR __real@41000000
	fstp	DWORD PTR _xx$[ebp]

; 408  : 		Coef.m[ii][0] = ONE;

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	mov	DWORD PTR _Coef[eax], 1065353216	; 3f800000H

; 409  : 		Coef.m[ii][1] = xx;

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _xx$[ebp]
	mov	DWORD PTR _Coef[eax+4], ecx

; 410  : 		Coef.m[ii][2] = xx - ONE;

	fld	DWORD PTR _xx$[ebp]
	fsub	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	fstp	DWORD PTR _Coef[eax+8]

; 411  : 		Coef.m[ii][3] = (REAL)pow(xx, 2);

	push	2
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+12]

; 412  : 		Coef.m[ii][4] = (REAL)pow(xx, 2) - xx;

	push	2
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsub	DWORD PTR _xx$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+16]

; 413  : 		Coef.m[ii][5] = (REAL)pow(xx, 3);

	push	3
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+20]

; 414  : 		Coef.m[ii][6] = (REAL)pow(xx, 3) - (REAL)pow(xx, 2);

	push	3
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	fstp	DWORD PTR tv342[ebp]
	add	esp, 8
	push	2
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsubr	DWORD PTR tv342[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	fstp	DWORD PTR _Coef[edx+24]

; 415  : 		Coef.m[ii][7] = (REAL)pow(xx, 4);

	push	4
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+28]

; 416  : 		Coef.m[ii][8] = (REAL)pow(xx, 4) - (REAL)pow(xx, 3);

	push	4
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	fstp	DWORD PTR tv351[ebp]
	add	esp, 8
	push	3
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsubr	DWORD PTR tv351[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	fstp	DWORD PTR _Coef[edx+32]

; 417  : 		Res.v[ii] = (REAL)exp(xx);

	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	mov	ecx, DWORD PTR _ii$[ebp]
	fstp	DWORD PTR _Res[ecx*4]

; 418  : 	}

	jmp	$L76537
$L76538:

; 419  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 420  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 421  : 	SolveLinearEquations(&Coef, &Res, 0.0f, 0.0001f, OrigRow, OrigCol, &Work, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	0
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 422  : 
; 423  : 	BigMatMulVec(&OrigCoef, &Soln, &NewRes);

	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_OrigCoef
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 424  : 
; 425  : 	/////////////////////////////////////////////////////////////////////
; 426  : 	// Test 5: 
; 427  : 	//
; 428  : 	SetBigMatSize(&Coef, 2, 2);

	mov	DWORD PTR _Coef+4096, 2
	mov	DWORD PTR _Coef+4100, 2

; 429  : 	SetBigVecSize(&Res, 2);

	mov	DWORD PTR _Res+128, 2

; 430  : 	SetBigVecSize(&Soln, 2);

	mov	DWORD PTR _Soln+128, 2

; 431  : 	ClearBigMat(&Coef);

	push	OFFSET FLAT:_Coef
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 432  : 	ClearBigVec(&Res);

	push	OFFSET FLAT:_Res
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 433  : 
; 434  : 	Coef.m[0][0] = ONE;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 435  : 	Coef.m[0][1] = ZERO;

	mov	DWORD PTR _Coef+4, 0

; 436  : 	Coef.m[1][0] = ZERO;

	mov	DWORD PTR _Coef+128, 0

; 437  : 	Coef.m[1][1] = 0.00001f;

	mov	DWORD PTR _Coef+132, 925353388		; 3727c5acH

; 438  : 	Res.v[0] = ONE;

	mov	DWORD PTR _Res, 1065353216		; 3f800000H

; 439  : 	Res.v[1] = 1.00001f;

	mov	DWORD PTR _Res+4, 1065353300		; 3f800054H

; 440  : 
; 441  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 442  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 443  : 	SolveLinearEquations(&Coef, &Res, 0.0f, 0.0001f, OrigRow, OrigCol, &Work, &Soln);

	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_Work
	push	OFFSET FLAT:_OrigCol
	push	OFFSET FLAT:_OrigRow
	push	953267991				; 38d1b717H
	push	0
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H

; 444  : 
; 445  : 	BigMatMulVec(&OrigCoef, &Soln, &NewRes);

	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_OrigCoef
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 446  : 
; 447  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TestSolver@@YAXXZ ENDP					; TestSolver
_TEXT	ENDS
PUBLIC	_expf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?exp@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?exp@@YAMM@Z PROC NEAR					; exp, COMDAT

; 553  :         {return (expf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_expf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?exp@@YAMM@Z ENDP					; exp
_TEXT	ENDS
EXTRN	_exp:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _expf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_expf	PROC NEAR					; COMDAT

; 448  :         {return ((float)exp((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_exp
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_expf	ENDP
_TEXT	ENDS
PUBLIC	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z	; ConjGrad
PUBLIC	?TestConjGrad@@YAXXZ				; TestConjGrad
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\gaussian.cpp
;	COMDAT ?TestConjGrad@@YAXXZ
_TEXT	SEGMENT
tv404 = -88						; size = 4
tv395 = -88						; size = 4
tv360 = -88						; size = 4
_xx$ = -20						; size = 4
_res$ = -16						; size = 4
_nIts$ = -12						; size = 4
_kk$ = -8						; size = 4
_ii$ = -4						; size = 4
?TestConjGrad@@YAXXZ PROC NEAR				; TestConjGrad, COMDAT

; 451  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 452  : 	int		ii, kk, nIts;
; 453  : 	REAL	res;
; 454  : 	float	xx;
; 455  : 
; 456  : 	/////////////////////////////////////////////////////////////////////
; 457  : 	// Test 1: Simple solution
; 458  : 	//
; 459  : 	SetBigMatSize(&Coef, 4, 4);

	mov	DWORD PTR _Coef+4096, 4
	mov	DWORD PTR _Coef+4100, 4

; 460  : 	SetBigVecSize(&Res, 4);

	mov	DWORD PTR _Res+128, 4

; 461  : 	SetBigVecSize(&Soln, 4);

	mov	DWORD PTR _Soln+128, 4

; 462  : 
; 463  : 	Coef.m[0][0] = ONE;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 464  : 	Coef.m[0][1] = ZERO;

	mov	DWORD PTR _Coef+4, 0

; 465  : 	Coef.m[0][2] = ZERO;

	mov	DWORD PTR _Coef+8, 0

; 466  : 	Coef.m[0][3] = ZERO;

	mov	DWORD PTR _Coef+12, 0

; 467  : 
; 468  : 	Coef.m[1][0] = ZERO;

	mov	DWORD PTR _Coef+128, 0

; 469  : 	Coef.m[1][1] = ONE;

	mov	DWORD PTR _Coef+132, 1065353216		; 3f800000H

; 470  : 	Coef.m[1][2] = ZERO;

	mov	DWORD PTR _Coef+136, 0

; 471  : 	Coef.m[1][3] = ZERO;

	mov	DWORD PTR _Coef+140, 0

; 472  : 
; 473  : 	Coef.m[2][0] = ZERO;

	mov	DWORD PTR _Coef+256, 0

; 474  : 	Coef.m[2][1] = ZERO;

	mov	DWORD PTR _Coef+260, 0

; 475  : 	Coef.m[2][2] = ZERO;

	mov	DWORD PTR _Coef+264, 0

; 476  : 	Coef.m[2][3] = ONE;

	mov	DWORD PTR _Coef+268, 1065353216		; 3f800000H

; 477  : 
; 478  : 	Coef.m[3][0] = ZERO;

	mov	DWORD PTR _Coef+384, 0

; 479  : 	Coef.m[3][1] = ZERO;

	mov	DWORD PTR _Coef+388, 0

; 480  : 	Coef.m[3][2] = ONE;

	mov	DWORD PTR _Coef+392, 1065353216		; 3f800000H

; 481  : 	Coef.m[3][3] = ZERO;

	mov	DWORD PTR _Coef+396, 0

; 482  : 
; 483  : 	Res.v[0] = Real(1.0);

	mov	DWORD PTR _Res, 1065353216		; 3f800000H

; 484  : 	Res.v[1] = Real(5.0);

	mov	DWORD PTR _Res+4, 1084227584		; 40a00000H

; 485  : 	Res.v[2] = Real(1.0);

	mov	DWORD PTR _Res+8, 1065353216		; 3f800000H

; 486  : 	Res.v[3] = Real(2.0);

	mov	DWORD PTR _Res+12, 1073741824		; 40000000H

; 487  : 
; 488  : 	ConjGrad(&Coef, &Res, Real(0.0001), 10, &Soln, &res, &nIts);

	lea	eax, DWORD PTR _nIts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$[ebp]
	push	ecx
	push	OFFSET FLAT:_Soln
	push	10					; 0000000aH
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ; ConjGrad
	add	esp, 28					; 0000001cH

; 489  : 
; 490  : #ifdef _PSX
; 491  : 	printf("Solution:\n%d %d %d %d\n", Soln.v[0], Soln.v[1], Soln.v[2], Soln.v[3]);
; 492  : 	printf("Res: %d  Its: %d\n", res, nIts);
; 493  : #endif
; 494  : 
; 495  : 	/////////////////////////////////////////////////////////////////////
; 496  : 	// Test 2:
; 497  : 	//
; 498  : 	SetBigMatSize(&Coef, 2, 2);

	mov	DWORD PTR _Coef+4096, 2
	mov	DWORD PTR _Coef+4100, 2

; 499  : 	SetBigVecSize(&Res, 2);

	mov	DWORD PTR _Res+128, 2

; 500  : 
; 501  : 	Coef.m[0][0] = ONE;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 502  : 	Coef.m[0][1] = ZERO;

	mov	DWORD PTR _Coef+4, 0

; 503  : 	Coef.m[1][0] = ONE;

	mov	DWORD PTR _Coef+128, 1065353216		; 3f800000H

; 504  : 	Coef.m[1][1] = ZERO;

	mov	DWORD PTR _Coef+132, 0

; 505  : 
; 506  : 	Res.v[0] = Real(2.0f);

	mov	DWORD PTR _Res, 1073741824		; 40000000H

; 507  : 	Res.v[1] = Real(1.0f);

	mov	DWORD PTR _Res+4, 1065353216		; 3f800000H

; 508  : 
; 509  : 	ConjGrad(&Coef, &Res, Real(0.0001), 10, &Soln, &res, &nIts);

	lea	eax, DWORD PTR _nIts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$[ebp]
	push	ecx
	push	OFFSET FLAT:_Soln
	push	10					; 0000000aH
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ; ConjGrad
	add	esp, 28					; 0000001cH

; 510  : 
; 511  : #ifdef _PSX
; 512  : 	printf("Solution:\n%d %d\n", Soln.v[0], Soln.v[1]);
; 513  : 	printf("Res: %d  Its: %d\n", res, nIts);
; 514  : #endif
; 515  : 
; 516  : 
; 517  : 	/////////////////////////////////////////////////////////////////////
; 518  : 	// Test 3:
; 519  : 	//
; 520  : 	SetBigMatSize(&Coef, 5, 5);

	mov	DWORD PTR _Coef+4096, 5
	mov	DWORD PTR _Coef+4100, 5

; 521  : 	SetBigVecSize(&Res, 5);

	mov	DWORD PTR _Res+128, 5

; 522  : 	SetBigVecSize(&Soln, 5);

	mov	DWORD PTR _Soln+128, 5

; 523  : 	for (ii = 0; ii < NRows(&Coef); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76564
$L76565:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76564:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	$L76566

; 524  : 		xx = (ii + 1) * 0.25f;

	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR tv360[ebp], eax
	fild	DWORD PTR tv360[ebp]
	fmul	DWORD PTR __real@3e800000
	fstp	DWORD PTR _xx$[ebp]

; 525  : 		for (kk = 0; kk < NRows(&Coef); kk++) {

	mov	DWORD PTR _kk$[ebp], 0
	jmp	SHORT $L76567
$L76568:
	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	mov	DWORD PTR _kk$[ebp], eax
$L76567:
	mov	eax, DWORD PTR _kk$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	SHORT $L76569

; 526  : 			Coef.m[ii][kk] = (REAL)pow(xx, kk + 1);

	mov	eax, DWORD PTR _kk$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _kk$[ebp]
	fstp	DWORD PTR _Coef[edx+eax*4]

; 527  : 		}

	jmp	SHORT $L76568
$L76569:

; 528  : 		xx = xx  * (float)exp(-xx);

	fld	DWORD PTR _xx$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fmul	DWORD PTR _xx$[ebp]
	fstp	DWORD PTR _xx$[ebp]

; 529  : 		Res.v[ii] = Real(xx);

	fld	DWORD PTR __real@3f800000
	fmul	DWORD PTR _xx$[ebp]
	mov	eax, DWORD PTR _ii$[ebp]
	fstp	DWORD PTR _Res[eax*4]

; 530  : 	}

	jmp	$L76565
$L76566:

; 531  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 532  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 533  : 	ConjGrad(&Coef, &Res, Real(0.0001), 10, &Soln, &res, &nIts);

	lea	eax, DWORD PTR _nIts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$[ebp]
	push	ecx
	push	OFFSET FLAT:_Soln
	push	10					; 0000000aH
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ; ConjGrad
	add	esp, 28					; 0000001cH

; 534  : 
; 535  : #ifdef _PSX
; 536  : 	printf("Solution:\n%d %d %d %d %d\n", Soln.v[0], Soln.v[1], Soln.v[2], Soln.v[3], Soln.v[4]);
; 537  : 	printf("Res: %d  Its: %d\n", res, nIts);
; 538  : #endif
; 539  : 
; 540  : 
; 541  : 	BigMatMulVec(&OrigCoef, &Soln, &NewRes);

	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_OrigCoef
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 542  : 
; 543  : 	/////////////////////////////////////////////////////////////////////
; 544  : 	// Test 4: 
; 545  : 	//
; 546  : 	SetBigMatSize(&Coef, 9, 9);

	mov	DWORD PTR _Coef+4096, 9
	mov	DWORD PTR _Coef+4100, 9

; 547  : 	SetBigVecSize(&Res, 9);

	mov	DWORD PTR _Res+128, 9

; 548  : 	SetBigVecSize(&Soln, 9);

	mov	DWORD PTR _Soln+128, 9

; 549  : 	ClearBigMat(&Coef);

	push	OFFSET FLAT:_Coef
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 550  : 	ClearBigVec(&Res);

	push	OFFSET FLAT:_Res
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 551  : 
; 552  : 	for (ii = 0; ii < NRows(&Coef); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76574
$L76575:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76574:
	mov	eax, DWORD PTR _ii$[ebp]
	cmp	eax, DWORD PTR _Coef+4096
	jge	$L76576

; 553  : 		xx = ii / 8.0f;

	fild	DWORD PTR _ii$[ebp]
	fdiv	DWORD PTR __real@41000000
	fstp	DWORD PTR _xx$[ebp]

; 554  : 		Coef.m[ii][0] = ONE;

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	mov	DWORD PTR _Coef[eax], 1065353216	; 3f800000H

; 555  : 		Coef.m[ii][1] = Real(xx);

	fld	DWORD PTR __real@3f800000
	fmul	DWORD PTR _xx$[ebp]
	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	fstp	DWORD PTR _Coef[eax+4]

; 556  : 		Coef.m[ii][2] = Real(xx - 1.0f);

	fld	DWORD PTR _xx$[ebp]
	fsub	DWORD PTR __real@3f800000
	fmul	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 7
	fstp	DWORD PTR _Coef[eax+8]

; 557  : 		Coef.m[ii][3] = Real(pow(xx, 2));

	push	2
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fmul	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+12]

; 558  : 		Coef.m[ii][4] = Real(pow(xx, 2) - xx);

	push	2
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsub	DWORD PTR _xx$[ebp]
	fmul	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+16]

; 559  : 		Coef.m[ii][5] = Real(pow(xx, 3));

	push	3
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fmul	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+20]

; 560  : 		Coef.m[ii][6] = Real(pow(xx, 3) - pow(xx, 2));

	push	3
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	fstp	DWORD PTR tv395[ebp]
	add	esp, 8
	push	2
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsubr	DWORD PTR tv395[ebp]
	fmul	DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	fstp	DWORD PTR _Coef[edx+24]

; 561  : 		Coef.m[ii][7] = Real(pow(xx, 4));

	push	4
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fmul	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 7
	fstp	DWORD PTR _Coef[ecx+28]

; 562  : 		Coef.m[ii][8] = Real(pow(xx, 4) - pow(xx, 3));

	push	4
	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?pow@@YAMMH@Z				; pow
	fstp	DWORD PTR tv404[ebp]
	add	esp, 8
	push	3
	mov	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fsubr	DWORD PTR tv404[ebp]
	fmul	DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _ii$[ebp]
	shl	edx, 7
	fstp	DWORD PTR _Coef[edx+32]

; 563  : 		Res.v[ii] = Real(exp(xx));

	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fmul	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _ii$[ebp]
	fstp	DWORD PTR _Res[ecx*4]

; 564  : 	}

	jmp	$L76575
$L76576:

; 565  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 566  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 567  : 	ConjGrad(&Coef, &Res, Real(0.0001), 100, &Soln, &res, &nIts);

	lea	eax, DWORD PTR _nIts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$[ebp]
	push	ecx
	push	OFFSET FLAT:_Soln
	push	100					; 00000064H
	push	953267991				; 38d1b717H
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ; ConjGrad
	add	esp, 28					; 0000001cH

; 568  : 
; 569  : #ifdef _PSX
; 570  : 	printf("Solution:\n%d %d %d %d\n%d %d %d %d\n", Soln.v[0], Soln.v[1], Soln.v[2], Soln.v[3], Soln.v[4], Soln.v[5], Soln.v[6], Soln.v[7]);
; 571  : 	printf("Res: %d  Its: %d\n", res, nIts);
; 572  : #endif
; 573  : 
; 574  : 
; 575  : 	BigMatMulVec(&OrigCoef, &Soln, &NewRes);

	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_OrigCoef
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 576  : 
; 577  : 	/////////////////////////////////////////////////////////////////////
; 578  : 	// Test 5: 
; 579  : 	//
; 580  : 	SetBigMatSize(&Coef, 2, 2);

	mov	DWORD PTR _Coef+4096, 2
	mov	DWORD PTR _Coef+4100, 2

; 581  : 	SetBigVecSize(&Res, 2);

	mov	DWORD PTR _Res+128, 2

; 582  : 	SetBigVecSize(&Soln, 2);

	mov	DWORD PTR _Soln+128, 2

; 583  : 	ClearBigMat(&Coef);

	push	OFFSET FLAT:_Coef
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 584  : 	ClearBigVec(&Res);

	push	OFFSET FLAT:_Res
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 585  : 
; 586  : 	Coef.m[0][0] = ONE;

	mov	DWORD PTR _Coef, 1065353216		; 3f800000H

; 587  : 	Coef.m[0][1] = ZERO;

	mov	DWORD PTR _Coef+4, 0

; 588  : 	Coef.m[1][0] = ONE;

	mov	DWORD PTR _Coef+128, 1065353216		; 3f800000H

; 589  : 	Coef.m[1][1] = Real(0.001);

	mov	DWORD PTR _Coef+132, 981668463		; 3a83126fH

; 590  : 	Res.v[0] = ONE;

	mov	DWORD PTR _Res, 1065353216		; 3f800000H

; 591  : 	Res.v[1] = Real(1.001);

	mov	DWORD PTR _Res+4, 1065361605		; 3f8020c5H

; 592  : 
; 593  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 594  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 595  : 	ConjGrad(&Coef, &Res, Real(0.001), 10, &Soln, &res, &nIts);

	lea	eax, DWORD PTR _nIts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$[ebp]
	push	ecx
	push	OFFSET FLAT:_Soln
	push	10					; 0000000aH
	push	981668463				; 3a83126fH
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ; ConjGrad
	add	esp, 28					; 0000001cH

; 596  : 
; 597  : #ifdef _PSX
; 598  : 	printf("Solution:\n%d %d\n", Soln.v[0], Soln.v[1]);
; 599  : 	printf("Res: %d  Its: %d\n", res, nIts);
; 600  : #endif
; 601  : 
; 602  : 	BigMatMulVec(&OrigCoef, &Soln, &NewRes);

	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_OrigCoef
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 603  : 
; 604  : 	/////////////////////////////////////////////////////////////////////
; 605  : 	// Test 6: 
; 606  : 	//
; 607  : 	SetBigMatSize(&Coef, 1, 1);

	mov	DWORD PTR _Coef+4096, 1
	mov	DWORD PTR _Coef+4100, 1

; 608  : 	SetBigVecSize(&Res, 1);

	mov	DWORD PTR _Res+128, 1

; 609  : 	SetBigVecSize(&Soln, 1);

	mov	DWORD PTR _Soln+128, 1

; 610  : 	ClearBigMat(&Coef);

	push	OFFSET FLAT:_Coef
	call	?ClearBigMat@@YAXPAUBIGMAT@@@Z		; ClearBigMat
	add	esp, 4

; 611  : 	ClearBigVec(&Res);

	push	OFFSET FLAT:_Res
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 612  : 
; 613  : 	Coef.m[0][0] = Real(0.908250);

	mov	DWORD PTR _Coef, 1063813906		; 3f688312H

; 614  : 	Res.v[0] = Real(0.002644);

	mov	DWORD PTR _Res, 992823030		; 3b2d46f6H

; 615  : 
; 616  : 	CopyBigMat(&Coef, &OrigCoef);

	push	OFFSET FLAT:_OrigCoef
	push	OFFSET FLAT:_Coef
	call	?CopyBigMat@@YAXPAUBIGMAT@@0@Z		; CopyBigMat
	add	esp, 8

; 617  : 	CopyBigVec(&Res, &OrigRes);

	push	OFFSET FLAT:_OrigRes
	push	OFFSET FLAT:_Res
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 618  : 	ConjGrad(&Coef, &Res, Real(0.001), 10, &Soln, &res, &nIts);

	lea	eax, DWORD PTR _nIts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$[ebp]
	push	ecx
	push	OFFSET FLAT:_Soln
	push	10					; 0000000aH
	push	981668463				; 3a83126fH
	push	OFFSET FLAT:_Res
	push	OFFSET FLAT:_Coef
	call	?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ; ConjGrad
	add	esp, 28					; 0000001cH

; 619  : 
; 620  : #ifdef _PSX
; 621  : 	printf("Solution:\n%d %d\n", Soln.v[0], Soln.v[1]);
; 622  : 	printf("Res: %d  Its: %d\n", res, nIts);
; 623  : #endif
; 624  : 
; 625  : 	BigMatMulVec(&OrigCoef, &Soln, &NewRes);

	push	OFFSET FLAT:_NewRes
	push	OFFSET FLAT:_Soln
	push	OFFSET FLAT:_OrigCoef
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 626  : 
; 627  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TestConjGrad@@YAXXZ ENDP				; TestConjGrad
_TEXT	ENDS
PUBLIC	??$_Pow_int@M@@YAMMH@Z				; _Pow_int<float>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?pow@@YAMMH@Z PROC NEAR					; pow, COMDAT

; 573  :         {return (_Pow_int(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __Y$[ebp]
	push	eax
	mov	ecx, DWORD PTR __X$[ebp]
	push	ecx
	call	??$_Pow_int@M@@YAMMH@Z			; _Pow_int<float>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pow@@YAMMH@Z ENDP					; pow
_TEXT	ENDS
PUBLIC	?CheckSolution@@YA_NPAUBIGMAT@@PAUBIGVEC@@11M@Z	; CheckSolution
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\gaussian.cpp
;	COMDAT ?CheckSolution@@YA_NPAUBIGMAT@@PAUBIGVEC@@11M@Z
_TEXT	SEGMENT
tv78 = -84						; size = 4
_solnOkay$ = -13					; size = 1
_diffSq$ = -12						; size = 4
_diff$ = -8						; size = 4
_ii$ = -4						; size = 4
_origCoef$ = 8						; size = 4
_origRes$ = 12						; size = 4
_soln$ = 16						; size = 4
_newRes$ = 20						; size = 4
_error$ = 24						; size = 4
?CheckSolution@@YA_NPAUBIGMAT@@PAUBIGVEC@@11M@Z PROC NEAR ; CheckSolution, COMDAT

; 631  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 632  : 	int ii;
; 633  : 	REAL diff, diffSq;
; 634  : 	bool solnOkay = TRUE;

	mov	BYTE PTR _solnOkay$[ebp], 1

; 635  : 
; 636  : 	//Calculate new residual from the supplied solution
; 637  : 	BigMatMulVec(origCoef, soln, newRes);

	mov	eax, DWORD PTR _newRes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _soln$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origCoef$[ebp]
	push	edx
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 638  : 
; 639  : 	for (ii = 0; ii < NRows(origCoef); ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L76604
$L76605:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L76604:
	mov	eax, DWORD PTR _origCoef$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	cmp	ecx, DWORD PTR [eax+4096]
	jge	SHORT $L76606

; 640  : 		diff = newRes->v[ii] - origRes->v[ii];

	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _newRes$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _origRes$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fsub	DWORD PTR [esi+edx*4]
	fstp	DWORD PTR _diff$[ebp]

; 641  : 		diffSq = diff * diff;

	fld	DWORD PTR _diff$[ebp]
	fmul	DWORD PTR _diff$[ebp]
	fstp	DWORD PTR _diffSq$[ebp]

; 642  : 		if (abs(diff) > error) {

	fld	DWORD PTR _diff$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76810
	mov	eax, DWORD PTR _diff$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $L76811
$L76810:
	fld	DWORD PTR _diff$[ebp]
	fchs
	fstp	DWORD PTR tv78[ebp]
$L76811:
	fld	DWORD PTR tv78[ebp]
	fcomp	DWORD PTR _error$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76607

; 643  : 			solnOkay = FALSE;

	mov	BYTE PTR _solnOkay$[ebp], 0
$L76607:

; 644  : 		}
; 645  : 	}

	jmp	SHORT $L76605
$L76606:

; 646  : 
; 647  : 	return solnOkay;

	mov	al, BYTE PTR _solnOkay$[ebp]

; 648  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckSolution@@YA_NPAUBIGMAT@@PAUBIGVEC@@11M@Z ENDP	; CheckSolution
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	__real@3727c5ac
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?__LINE__Var@?1??ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z@4JA ; `ConjGrad'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z@4JA DD 0296H ; `ConjGrad'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z
_TEXT	SEGMENT
tv138 = -96						; size = 4
tv69 = -90						; size = 1
_terminate$ = -25					; size = 1
_pDott$ = -24						; size = 4
_rNorm$ = -20						; size = 4
_rSqOld$ = -16						; size = 4
_rSq$ = -12						; size = 4
_beta$ = -8						; size = 4
_alpha$ = -4						; size = 4
_A$ = 8							; size = 4
_b$ = 12						; size = 4
_tol$ = 16						; size = 4
_maxIts$ = 20						; size = 4
_x$ = 24						; size = 4
_res$ = 28						; size = 4
_nIts$ = 32						; size = 4
?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z PROC NEAR ; ConjGrad, COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 663  : 	REAL alpha, beta;
; 664  : 	REAL rSq, rSqOld, rNorm, pDott;
; 665  : 	bool terminate = FALSE;;

	mov	BYTE PTR _terminate$[ebp], 0

; 666  : 
; 667  : 	Assert((tol > ZERO) && (maxIts > 0));

	fld	DWORD PTR _tol$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76814
	cmp	DWORD PTR _maxIts$[ebp], 0
	jle	SHORT $L76814
	mov	BYTE PTR tv69[ebp], 1
	jmp	SHORT $L76815
$L76814:
	mov	BYTE PTR tv69[ebp], 0
$L76815:
	push	OFFSET FLAT:??_C@_0IN@MMFCLFLP@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z@4JA
	add	eax, 5
	push	eax
	mov	cl, BYTE PTR tv69[ebp]
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 668  : 
; 669  : 	// Initialise
; 670  : 	SetBigVecSize(&r, NSize(b));

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR ?r@@3UBIGVEC@@A+128, ecx

; 671  : 	SetBigVecSize(&t, NSize(b));

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR ?t@@3UBIGVEC@@A+128, ecx

; 672  : 	SetBigVecSize(x, NSize(b));

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx

; 673  : 	ClearBigVec(x);

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	?ClearBigVec@@YAXPAUBIGVEC@@@Z		; ClearBigVec
	add	esp, 4

; 674  : 	CopyBigVec(b, &p);

	push	OFFSET FLAT:?p@@3UBIGVEC@@A		; p
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 675  : 	CopyBigVec(b, &r);

	push	OFFSET FLAT:?r@@3UBIGVEC@@A		; r
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?CopyBigVec@@YAXPAUBIGVEC@@0@Z		; CopyBigVec
	add	esp, 8

; 676  : 	beta = ZERO;

	mov	DWORD PTR _beta$[ebp], 0

; 677  : 	rSq = ZERO;

	mov	DWORD PTR _rSq$[ebp], 0

; 678  : 	rNorm = MulScalar( Real(2), tol );

	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _tol$[ebp]
	fstp	DWORD PTR _rNorm$[ebp]

; 679  : 
; 680  : 	// Minimise - loop while not too many iterations and outside residual tolerance
; 681  : 	*nIts = 0;

	mov	eax, DWORD PTR _nIts$[ebp]
	mov	DWORD PTR [eax], 0
$L76629:

; 682  : 
; 683  : 	do {
; 684  : 
; 685  : 		rSqOld = rSq;

	mov	eax, DWORD PTR _rSq$[ebp]
	mov	DWORD PTR _rSqOld$[ebp], eax

; 686  : 		rSq = BigVecDotVec(&r, &r);

	push	OFFSET FLAT:?r@@3UBIGVEC@@A		; r
	push	OFFSET FLAT:?r@@3UBIGVEC@@A		; r
	call	?BigVecDotVec@@YAMPAUBIGVEC@@0@Z	; BigVecDotVec
	add	esp, 8
	fstp	DWORD PTR _rSq$[ebp]

; 687  : 
; 688  : #ifdef _PSX
; 689  : 		rNorm = SquareRoot1616(rSq);
; 690  : #else
; 691  : 		rNorm = (REAL)sqrt(rSq);

	mov	eax, DWORD PTR _rSq$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _rNorm$[ebp]

; 692  : #endif
; 693  : 
; 694  : 		if ((*nIts < maxIts) && ((*res = rNorm - tol) > ZERO)) {

	mov	eax, DWORD PTR _nIts$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _maxIts$[ebp]
	jge	$L76633
	fld	DWORD PTR _rNorm$[ebp]
	fsub	DWORD PTR _tol$[ebp]
	mov	eax, DWORD PTR _res$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _res$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L76633

; 695  : 
; 696  : 			if (*nIts > 0) {

	mov	eax, DWORD PTR _nIts$[ebp]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $L76634

; 697  : 				/*if (rSqOld > SMALL_REAL) {
; 698  : 					beta = DivScalar( rSq, rSqOld);
; 699  : 					BigVecPlusScalarVec(&r, beta, &p, &p);
; 700  : 				} else {
; 701  : 					CopyBigVec(&r, &p);
; 702  : 					terminate = TRUE;
; 703  : 				}*/
; 704  : 				beta = DivScalar( rSq, rSqOld);

	fld	DWORD PTR _rSq$[ebp]
	fdiv	DWORD PTR _rSqOld$[ebp]
	fstp	DWORD PTR _beta$[ebp]

; 705  : 				BigVecPlusScalarVec(&r, beta, &p, &p);

	push	OFFSET FLAT:?p@@3UBIGVEC@@A		; p
	push	OFFSET FLAT:?p@@3UBIGVEC@@A		; p
	mov	eax, DWORD PTR _beta$[ebp]
	push	eax
	push	OFFSET FLAT:?r@@3UBIGVEC@@A		; r
	call	?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z ; BigVecPlusScalarVec
	add	esp, 16					; 00000010H
$L76634:

; 706  : 			}
; 707  : 
; 708  : 			BigMatMulVec(A, &p, &t);

	push	OFFSET FLAT:?t@@3UBIGVEC@@A		; t
	push	OFFSET FLAT:?p@@3UBIGVEC@@A		; p
	mov	eax, DWORD PTR _A$[ebp]
	push	eax
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 709  : 
; 710  : 			pDott = BigVecDotVec(&p, &t);

	push	OFFSET FLAT:?t@@3UBIGVEC@@A		; t
	push	OFFSET FLAT:?p@@3UBIGVEC@@A		; p
	call	?BigVecDotVec@@YAMPAUBIGVEC@@0@Z	; BigVecDotVec
	add	esp, 8
	fstp	DWORD PTR _pDott$[ebp]

; 711  : 			if (abs(pDott) > SMALL_REAL) {

	fld	DWORD PTR _pDott$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76816
	mov	eax, DWORD PTR _pDott$[ebp]
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $L76817
$L76816:
	fld	DWORD PTR _pDott$[ebp]
	fchs
	fstp	DWORD PTR tv138[ebp]
$L76817:
	fld	DWORD PTR tv138[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76635

; 712  : 				alpha = DivScalar( rSq, pDott);

	fld	DWORD PTR _rSq$[ebp]
	fdiv	DWORD PTR _pDott$[ebp]
	fstp	DWORD PTR _alpha$[ebp]

; 713  : 				BigVecPlusScalarVec(x, alpha, &p, x);

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET FLAT:?p@@3UBIGVEC@@A		; p
	mov	ecx, DWORD PTR _alpha$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z ; BigVecPlusScalarVec
	add	esp, 16					; 00000010H

; 714  : 
; 715  : 				BigMatMulVec(A, &p, &t);

	push	OFFSET FLAT:?t@@3UBIGVEC@@A		; t
	push	OFFSET FLAT:?p@@3UBIGVEC@@A		; p
	mov	eax, DWORD PTR _A$[ebp]
	push	eax
	call	?BigMatMulVec@@YAXPAUBIGMAT@@PAUBIGVEC@@1@Z ; BigMatMulVec
	add	esp, 12					; 0000000cH

; 716  : 				BigVecPlusScalarVec(&r, -alpha, &t, &r);

	push	OFFSET FLAT:?r@@3UBIGVEC@@A		; r
	push	OFFSET FLAT:?t@@3UBIGVEC@@A		; t
	fld	DWORD PTR _alpha$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	push	OFFSET FLAT:?r@@3UBIGVEC@@A		; r
	call	?BigVecPlusScalarVec@@YAXPAUBIGVEC@@M00@Z ; BigVecPlusScalarVec
	add	esp, 16					; 00000010H

; 717  : 				(*nIts)++;

	mov	eax, DWORD PTR _nIts$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _nIts$[ebp]
	mov	DWORD PTR [edx], ecx

; 718  : 			} else {

	jmp	SHORT $L76636
$L76635:

; 719  : 				terminate = TRUE;

	mov	BYTE PTR _terminate$[ebp], 1
$L76636:

; 720  : 			}
; 721  : 		} else {

	jmp	SHORT $L76630
$L76633:

; 722  : 			terminate = TRUE;

	mov	BYTE PTR _terminate$[ebp], 1
$L76630:

; 723  : 		}
; 724  : 
; 725  : 	} while(!terminate);

	movzx	eax, BYTE PTR _terminate$[ebp]
	test	eax, eax
	je	$L76629

; 726  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConjGrad@@YAXPAUBIGMAT@@PAUBIGVEC@@MH1PAMPAH@Z ENDP	; ConjGrad
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT
tv74 = -76						; size = 4
__Z$76662 = -8						; size = 4
__N$ = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
??$_Pow_int@M@@YAMMH@Z PROC NEAR			; _Pow_int<float>, COMDAT

; 517  :         {unsigned int _N;

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 518  :         if (_Y >= 0)

	cmp	DWORD PTR __Y$[ebp], 0
	jl	SHORT $L76660

; 519  :                 _N = _Y;

	mov	eax, DWORD PTR __Y$[ebp]
	mov	DWORD PTR __N$[ebp], eax

; 520  :         else

	jmp	SHORT $L76661
$L76660:

; 521  :                 _N = -_Y;

	mov	eax, DWORD PTR __Y$[ebp]
	neg	eax
	mov	DWORD PTR __N$[ebp], eax
$L76661:

; 522  :         for (_Ty _Z = _Ty(1); ; _X *= _X)

	mov	DWORD PTR __Z$76662[ebp], 1065353216	; 3f800000H
	jmp	SHORT $L76663
$L76664:
	fld	DWORD PTR __X$[ebp]
	fmul	DWORD PTR __X$[ebp]
	fstp	DWORD PTR __X$[ebp]
$L76663:

; 523  :                 {if ((_N & 1) != 0)

	mov	eax, DWORD PTR __N$[ebp]
	and	eax, 1
	je	SHORT $L76666

; 524  :                         _Z *= _X;

	fld	DWORD PTR __Z$76662[ebp]
	fmul	DWORD PTR __X$[ebp]
	fstp	DWORD PTR __Z$76662[ebp]
$L76666:

; 525  :                 if ((_N >>= 1) == 0)

	mov	eax, DWORD PTR __N$[ebp]
	shr	eax, 1
	mov	DWORD PTR __N$[ebp], eax
	cmp	DWORD PTR __N$[ebp], 0
	jne	SHORT $L76667

; 526  :                         return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

	cmp	DWORD PTR __Y$[ebp], 0
	jge	SHORT $L76828
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR __Z$76662[ebp]
	fstp	DWORD PTR tv74[ebp]
	jmp	SHORT $L76829
$L76828:
	mov	eax, DWORD PTR __Z$76662[ebp]
	mov	DWORD PTR tv74[ebp], eax
$L76829:
	fld	DWORD PTR tv74[ebp]
	jmp	SHORT $L76658
$L76667:
	jmp	SHORT $L76664
$L76658:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pow_int@M@@YAMMH@Z ENDP				; _Pow_int<float>
_TEXT	ENDS
END
