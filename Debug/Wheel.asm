; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Wheel.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSkid@@YAPAUSKIDMARK@@PAUSKIDMARK_START@@0J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSkidEnd@@YAXPAUSKIDMARK@@PAUSKIDMARK_START@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FadeSkidMarks@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearSkids@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupWheel@@YAXPAUWHEEL@@PAUWHEEL_INFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupSuspension@@YAXPAUSPRING@@PAUSPRING_INFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpringDampedForce@@YAMPAUSPRING@@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?WHL_NSkids@@3HA				; WHL_NSkids
PUBLIC	?WHL_SkidHead@@3HA				; WHL_SkidHead
PUBLIC	?WHL_SkidMark@@3PAUSKIDMARK@@A			; WHL_SkidMark
_BSS	SEGMENT
?WHL_NSkids@@3HA DD 01H DUP (?)				; WHL_NSkids
?WHL_SkidHead@@3HA DD 01H DUP (?)			; WHL_SkidHead
?WHL_SkidMark@@3PAUSKIDMARK@@A DB 011940H DUP (?)	; WHL_SkidMark
_BSS	ENDS
PUBLIC	?AddSkid@@YAPAUSKIDMARK@@PAUSKIDMARK_START@@0J@Z ; AddSkid
PUBLIC	?FadeSkidMarks@@YAXXZ				; FadeSkidMarks
EXTRN	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z:NEAR ; SetObjectVisiMask
EXTRN	__fltused:NEAR
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\wheel.cpp
;	COMDAT ?AddSkid@@YAPAUSKIDMARK@@PAUSKIDMARK_START@@0J@Z
_TEXT	SEGMENT
_box$ = -40						; size = 24
_skid$ = -16						; size = 4
_right$ = -12						; size = 12
_skidStart$ = 8						; size = 4
_skidEnd$ = 12						; size = 4
_rgb$ = 16						; size = 4
?AddSkid@@YAPAUSKIDMARK@@PAUSKIDMARK_START@@0J@Z PROC NEAR ; AddSkid, COMDAT

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 32   : 	VEC			right;
; 33   : 	SKIDMARK		*skid;
; 34   : 	BOUNDING_BOX	box;
; 35   : 
; 36   : 	skid = &WHL_SkidMark[WHL_SkidHead++];

	mov	eax, DWORD PTR ?WHL_SkidHead@@3HA	; WHL_SkidHead
	imul	eax, 72					; 00000048H
	add	eax, OFFSET FLAT:?WHL_SkidMark@@3PAUSKIDMARK@@A ; WHL_SkidMark
	mov	DWORD PTR _skid$[ebp], eax
	mov	ecx, DWORD PTR ?WHL_SkidHead@@3HA	; WHL_SkidHead
	add	ecx, 1
	mov	DWORD PTR ?WHL_SkidHead@@3HA, ecx	; WHL_SkidHead

; 37   : 	Wrap(WHL_SkidHead, 0, SKID_MAX_SKIDS);

	jns	SHORT $L80350
	mov	eax, DWORD PTR ?WHL_SkidHead@@3HA	; WHL_SkidHead
	add	eax, 1000				; 000003e8H
	mov	DWORD PTR ?WHL_SkidHead@@3HA, eax	; WHL_SkidHead
$L80350:
	cmp	DWORD PTR ?WHL_SkidHead@@3HA, 1000	; WHL_SkidHead, 000003e8H
	jl	SHORT $L80351
	mov	eax, DWORD PTR ?WHL_SkidHead@@3HA	; WHL_SkidHead
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR ?WHL_SkidHead@@3HA, eax	; WHL_SkidHead
$L80351:

; 38   : 	WHL_NSkids++;

	mov	eax, DWORD PTR ?WHL_NSkids@@3HA		; WHL_NSkids
	add	eax, 1
	mov	DWORD PTR ?WHL_NSkids@@3HA, eax		; WHL_NSkids

; 39   : 	Limit(WHL_NSkids, 0, SKID_MAX_SKIDS);

	jns	SHORT $L80352
	mov	DWORD PTR ?WHL_NSkids@@3HA, 0		; WHL_NSkids
$L80352:
	cmp	DWORD PTR ?WHL_NSkids@@3HA, 1000	; WHL_NSkids, 000003e8H
	jle	SHORT $L80353
	mov	DWORD PTR ?WHL_NSkids@@3HA, 1000	; WHL_NSkids, 000003e8H
$L80353:

; 40   : 
; 41   : 	// Calculate the position of the four corners
; 42   : 	VecCrossVec(&skidStart->Dir, &skidStart->Normal, &right);

	mov	eax, DWORD PTR _skidStart$[ebp]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _skidStart$[ebp]
	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+36]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _skidStart$[ebp]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _skidStart$[ebp]
	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+40]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp+4]
	mov	eax, DWORD PTR _skidStart$[ebp]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _skidStart$[ebp]
	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [eax+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp+8]

; 43   : 	VecPlusScalarVec(&skidStart->Pos, skidStart->Width, &right, &skid->Corner[0]);

	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp+4]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp+8]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+8]

; 44   : 	VecPlusScalarVec(&skidStart->Pos, -skidStart->Width, &right, &skid->Corner[1]);

	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp+4]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _skidStart$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp+8]
	mov	ecx, DWORD PTR _skidStart$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+20]

; 45   : 
; 46   : 	VecCrossVec(&skidEnd->Dir, &skidEnd->Normal, &right);

	mov	eax, DWORD PTR _skidEnd$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _skidEnd$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+36]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _skidEnd$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+40]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp+4]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _skidEnd$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [eax+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp+8]

; 47   : 	VecPlusScalarVec(&skidEnd->Pos, -skidEnd->Width, &right, &skid->Corner[2]);

	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp+4]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp+8]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+32]

; 48   : 	VecPlusScalarVec(&skidEnd->Pos, skidEnd->Width, &right, &skid->Corner[3]);

	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp+4]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp+8]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+44]

; 49   : 
; 50   : 	// Set colour
; 51   : #ifdef _PC
; 52   : 	skid->RGB = rgb;

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 53   : #endif
; 54   : #ifdef _N64
; 55   : 	skid->RGB = (rgb << 8) | (rgb & 0xFF);
; 56   : #endif
; 57   : 
; 58   : 	// set visibox mask
; 59   : 	box.Xmin = box.Xmax = skidStart->Pos.v[X];

	mov	eax, DWORD PTR _skidStart$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _box$[ebp+4], ecx
	mov	edx, DWORD PTR _box$[ebp+4]
	mov	DWORD PTR _box$[ebp], edx

; 60   : 	box.Ymin = box.Ymax = skidStart->Pos.v[Y];

	mov	eax, DWORD PTR _skidStart$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _box$[ebp+12], ecx
	mov	edx, DWORD PTR _box$[ebp+12]
	mov	DWORD PTR _box$[ebp+8], edx

; 61   : 	box.Zmin = box.Zmax = skidStart->Pos.v[Z];

	mov	eax, DWORD PTR _skidStart$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _box$[ebp+20], ecx
	mov	edx, DWORD PTR _box$[ebp+20]
	mov	DWORD PTR _box$[ebp+16], edx

; 62   : 
; 63   : #ifndef _PSX
; 64   : 	skid->VisiMask = SetObjectVisiMask(&box);

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	call	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z ; SetObjectVisiMask
	add	esp, 4
	mov	ecx, DWORD PTR _skid$[ebp]
	mov	DWORD PTR [ecx+64], eax
	mov	DWORD PTR [ecx+68], edx

; 65   : 
; 66   : 	// Fade the old SkidMarks
; 67   : 	FadeSkidMarks();

	call	?FadeSkidMarks@@YAXXZ			; FadeSkidMarks

; 68   : #endif
; 69   : 
; 70   : 	return skid;

	mov	eax, DWORD PTR _skid$[ebp]

; 71   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddSkid@@YAPAUSKIDMARK@@PAUSKIDMARK_START@@0J@Z ENDP	; AddSkid
_TEXT	ENDS
PUBLIC	?MoveSkidEnd@@YAXPAUSKIDMARK@@PAUSKIDMARK_START@@@Z ; MoveSkidEnd
PUBLIC	__real@40000000
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?MoveSkidEnd@@YAXPAUSKIDMARK@@PAUSKIDMARK_START@@@Z
_TEXT	SEGMENT
_right$ = -12						; size = 12
_skid$ = 8						; size = 4
_skidEnd$ = 12						; size = 4
?MoveSkidEnd@@YAXPAUSKIDMARK@@PAUSKIDMARK_START@@@Z PROC NEAR ; MoveSkidEnd, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 82   : 	VEC right;
; 83   : 
; 84   : 	VecCrossVec(&skidEnd->Dir, &skidEnd->Normal, &right);

	mov	eax, DWORD PTR _skidEnd$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _skidEnd$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+36]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _skidEnd$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+40]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp+4]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _skidEnd$[ebp]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [eax+32]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _right$[ebp+8]

; 85   : 	VecPlusScalarVec(&skidEnd->Pos, -skidEnd->Width, &right, &skid->Corner[2]);

	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp+4]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	fmul	DWORD PTR _right$[ebp+8]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+32]

; 86   : 	VecPlusScalarVec(&skidEnd->Pos, skidEnd->Width, &right, &skid->Corner[3]);

	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+36]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp+4]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+40]
	mov	eax, DWORD PTR _skidEnd$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR _right$[ebp+8]
	mov	ecx, DWORD PTR _skidEnd$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+44]

; 87   : 
; 88   : 	skid->Centre.v[X] = (skid->Corner[0].v[X] + skid->Corner[2].v[X]) / 2;

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR _skid$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx+24]
	fdiv	DWORD PTR __real@40000000
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+48]

; 89   : 	skid->Centre.v[Y] = (skid->Corner[0].v[Y] + skid->Corner[2].v[Y]) / 2;

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR _skid$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+28]
	fdiv	DWORD PTR __real@40000000
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+52]

; 90   : 	skid->Centre.v[Z] = (skid->Corner[0].v[Z] + skid->Corner[2].v[Z]) / 2;

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR _skid$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+32]
	fdiv	DWORD PTR __real@40000000
	mov	edx, DWORD PTR _skid$[ebp]
	fstp	DWORD PTR [edx+56]

; 91   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveSkidEnd@@YAXPAUSKIDMARK@@PAUSKIDMARK_START@@@Z ENDP ; MoveSkidEnd
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?FadeSkidMarks@@YAXXZ
_TEXT	SEGMENT
_skid$ = -20						; size = 4
_b$ = -15						; size = 1
_g$ = -14						; size = 1
_r$ = -13						; size = 1
_nFade$ = -12						; size = 4
_currentSkid$ = -8					; size = 4
_iSkid$ = -4						; size = 4
?FadeSkidMarks@@YAXXZ PROC NEAR				; FadeSkidMarks, COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 103  : 	int iSkid, currentSkid;
; 104  : 	int nFade;
; 105  : 	unsigned char r, g, b;
; 106  : 	SKIDMARK *skid;
; 107  : 
; 108  : 	if (WHL_NSkids < SKID_FADE_START) return;

	cmp	DWORD PTR ?WHL_NSkids@@3HA, 900		; WHL_NSkids, 00000384H
	jge	SHORT $L80368
	jmp	$L80360
$L80368:

; 109  : 
; 110  : 	nFade = WHL_NSkids - SKID_FADE_START;

	mov	eax, DWORD PTR ?WHL_NSkids@@3HA		; WHL_NSkids
	sub	eax, 900				; 00000384H
	mov	DWORD PTR _nFade$[ebp], eax

; 111  : 
; 112  : 	currentSkid = WHL_SkidHead - WHL_NSkids + 1;

	mov	eax, DWORD PTR ?WHL_SkidHead@@3HA	; WHL_SkidHead
	sub	eax, DWORD PTR ?WHL_NSkids@@3HA		; WHL_NSkids
	add	eax, 1
	mov	DWORD PTR _currentSkid$[ebp], eax

; 113  : 	for (iSkid = 0; iSkid < nFade; iSkid++)

	mov	DWORD PTR _iSkid$[ebp], 0
	jmp	SHORT $L80369
$L80370:
	mov	eax, DWORD PTR _iSkid$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkid$[ebp], eax
$L80369:
	mov	eax, DWORD PTR _iSkid$[ebp]
	cmp	eax, DWORD PTR _nFade$[ebp]
	jge	$L80360

; 114  : 	{
; 115  : 		Wrap(currentSkid, 0, SKID_MAX_SKIDS);

	cmp	DWORD PTR _currentSkid$[ebp], 0
	jge	SHORT $L80372
	mov	eax, DWORD PTR _currentSkid$[ebp]
	add	eax, 1000				; 000003e8H
	mov	DWORD PTR _currentSkid$[ebp], eax
$L80372:
	cmp	DWORD PTR _currentSkid$[ebp], 1000	; 000003e8H
	jl	SHORT $L80373
	mov	eax, DWORD PTR _currentSkid$[ebp]
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR _currentSkid$[ebp], eax
$L80373:

; 116  : 		skid = &WHL_SkidMark[currentSkid++];

	mov	eax, DWORD PTR _currentSkid$[ebp]
	imul	eax, 72					; 00000048H
	add	eax, OFFSET FLAT:?WHL_SkidMark@@3PAUSKIDMARK@@A ; WHL_SkidMark
	mov	DWORD PTR _skid$[ebp], eax
	mov	ecx, DWORD PTR _currentSkid$[ebp]
	add	ecx, 1
	mov	DWORD PTR _currentSkid$[ebp], ecx

; 117  : 
; 118  : 		// Calculate new RGB
; 119  : #ifdef _PC
; 120  : 		r = (unsigned char)((skid->RGB & RGB_RED_MASK) >> 16);

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 16711680				; 00ff0000H
	sar	ecx, 16					; 00000010H
	mov	BYTE PTR _r$[ebp], cl

; 121  : 		g = (unsigned char)((skid->RGB & RGB_GREEN_MASK) >> 8);

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	mov	BYTE PTR _g$[ebp], cl

; 122  : 		b = (unsigned char)(skid->RGB & RGB_BLUE_MASK);

	mov	eax, DWORD PTR _skid$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _b$[ebp], cl

; 123  : 
; 124  : 		if (r > SKID_FADE_FACTOR) {

	movzx	eax, BYTE PTR _r$[ebp]
	cmp	eax, 2
	jle	SHORT $L80377

; 125  : 			r -= SKID_FADE_FACTOR;

	movzx	eax, BYTE PTR _r$[ebp]
	sub	eax, 2
	mov	BYTE PTR _r$[ebp], al

; 126  : 		} else {

	jmp	SHORT $L80378
$L80377:

; 127  : 			r = 0;

	mov	BYTE PTR _r$[ebp], 0
$L80378:

; 128  : 		}
; 129  : 		if (g > SKID_FADE_FACTOR) {

	movzx	eax, BYTE PTR _g$[ebp]
	cmp	eax, 2
	jle	SHORT $L80379

; 130  : 			g -= SKID_FADE_FACTOR;

	movzx	eax, BYTE PTR _g$[ebp]
	sub	eax, 2
	mov	BYTE PTR _g$[ebp], al

; 131  : 		} else {

	jmp	SHORT $L80380
$L80379:

; 132  : 			g = 0;

	mov	BYTE PTR _g$[ebp], 0
$L80380:

; 133  : 		}
; 134  : 		if (b > SKID_FADE_FACTOR) {

	movzx	eax, BYTE PTR _b$[ebp]
	cmp	eax, 2
	jle	SHORT $L80381

; 135  : 			b -= SKID_FADE_FACTOR;

	movzx	eax, BYTE PTR _b$[ebp]
	sub	eax, 2
	mov	BYTE PTR _b$[ebp], al

; 136  : 		} else {

	jmp	SHORT $L80382
$L80381:

; 137  : 			b = 0;

	mov	BYTE PTR _b$[ebp], 0
$L80382:

; 138  : 		}
; 139  : 
; 140  : 		skid->RGB = (r << 16) | (g << 8) | (b);

	movzx	eax, BYTE PTR _r$[ebp]
	shl	eax, 16					; 00000010H
	movzx	ecx, BYTE PTR _g$[ebp]
	shl	ecx, 8
	or	eax, ecx
	movzx	edx, BYTE PTR _b$[ebp]
	or	eax, edx
	mov	ecx, DWORD PTR _skid$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 141  : #endif
; 142  : #ifdef _N64
; 143  : 		r = skid->RGB & 0xFF;
; 144  : 		if (r > SKID_FADE_FACTOR) {
; 145  : 			r -= SKID_FADE_FACTOR;
; 146  : 		} else {
; 147  : 			r = 0;
; 148  : 		}
; 149  : 		skid->RGB = (skid->RGB & 0xFFFFFF00) | (unsigned char)r;
; 150  : #endif
; 151  : 	}

	jmp	$L80370
$L80360:

; 152  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FadeSkidMarks@@YAXXZ ENDP				; FadeSkidMarks
_TEXT	ENDS
PUBLIC	?ClearSkids@@YAXXZ				; ClearSkids
; Function compile flags: /Odt /ZI
;	COMDAT ?ClearSkids@@YAXXZ
_TEXT	SEGMENT
?ClearSkids@@YAXXZ PROC NEAR				; ClearSkids, COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 165  : 	WHL_NSkids = 0;

	mov	DWORD PTR ?WHL_NSkids@@3HA, 0		; WHL_NSkids

; 166  : 	WHL_SkidHead = 0;

	mov	DWORD PTR ?WHL_SkidHead@@3HA, 0		; WHL_SkidHead

; 167  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearSkids@@YAXXZ ENDP					; ClearSkids
_TEXT	ENDS
PUBLIC	?SetupWheel@@YAXPAUWHEEL@@PAUWHEEL_INFO@@@Z	; SetupWheel
PUBLIC	__real@3f800000
PUBLIC	__real@466a6000
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@466a6000
CONST	SEGMENT
__real@466a6000 DD 0466a6000r			; 15000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SetupWheel@@YAXPAUWHEEL@@PAUWHEEL_INFO@@@Z
_TEXT	SEGMENT
_wheel$ = 8						; size = 4
_wheelInfo$ = 12					; size = 4
?SetupWheel@@YAXPAUWHEEL@@PAUWHEEL_INFO@@@Z PROC NEAR	; SetupWheel, COMDAT

; 176  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 177  : 	// Status
; 178  : 	wheel->Status = 0;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax], 0

; 179  : 	if (wheelInfo->IsPresent) {

	mov	eax, DWORD PTR _wheelInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+72]
	test	ecx, ecx
	je	SHORT $L80389

; 180  : 		SetWheelPresent(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx
$L80389:

; 181  : 	}
; 182  : 	if (wheelInfo->IsTurnable) {

	mov	eax, DWORD PTR _wheelInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+73]
	test	ecx, ecx
	je	SHORT $L80390

; 183  : 		SetWheelTurnable(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx
$L80390:

; 184  : 	}
; 185  : 	if (wheelInfo->IsPowered) {

	mov	eax, DWORD PTR _wheelInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+74]
	test	ecx, ecx
	je	SHORT $L80391

; 186  : 		SetWheelPowered(wheel);

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 4
	mov	edx, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [edx], ecx
$L80391:

; 187  : 	}
; 188  : 
; 189  : 	// Mass
; 190  : 	wheel->Mass = wheelInfo->Mass;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+4], edx

; 191  : 	wheel->InvMass = DivScalar(ONE, wheelInfo->Mass);

	mov	eax, DWORD PTR _wheelInfo$[ebp]
	fld	DWORD PTR [eax+32]
	fdivr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+8]

; 192  : 
; 193  : 	// Radius
; 194  : 	wheel->Radius = wheelInfo->Radius;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+20], edx

; 195  : 
; 196  : 	// Inertia
; 197  : 	wheel->Inertia = MulScalar(wheelInfo->Mass, MulScalar(wheelInfo->Radius, wheelInfo->Radius)) / 2;

	mov	eax, DWORD PTR _wheelInfo$[ebp]
	fld	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	fld	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _wheelInfo$[ebp]
	fmul	DWORD PTR [edx+28]
	fmulp	ST(1), ST(0)
	fdiv	DWORD PTR __real@40000000
	mov	eax, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [eax+12]

; 198  : 	wheel->InvInertia = DivScalar(ONE, wheel->Inertia);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+12]
	fdivr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+16]

; 199  : 	
; 200  : 	// Gravity
; 201  : 	wheel->Gravity = wheelInfo->Gravity;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+24], edx

; 202  : 
; 203  : 	// Friction
; 204  : 	wheel->Grip = wheelInfo->Grip;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+28], edx

; 205  : 	wheel->StaticFriction = wheelInfo->StaticFriction;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+32], edx

; 206  : 	wheel->KineticFriction = wheelInfo->KineticFriction;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+36], edx

; 207  : 	wheel->AxleFriction = wheelInfo->AxleFriction;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+48], edx

; 208  : 
; 209  : 	// Steering ratio
; 210  : 	wheel->SteerRatio = wheelInfo->SteerRatio;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+40], edx

; 211  : 
; 212  : 	// Engine Ratio
; 213  : #ifndef _PSX
; 214  : 	wheel->EngineRatio = wheelInfo->EngineRatio;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+44], edx

; 215  : #else
; 216  : 	wheel->EngineRatio = DivScalar(wheelInfo->EngineRatio, wheel->Radius);
; 217  : #endif
; 218  : 
; 219  : 
; 220  : 	// Bounding box
; 221  : 	SetBBox(&wheel->BBox, 
; 222  : 		-wheelInfo->Radius, wheelInfo->Radius, 
; 223  : 		-wheelInfo->Radius, wheelInfo->Radius, 
; 224  : 		-wheelInfo->Radius, wheelInfo->Radius);

	mov	eax, DWORD PTR _wheelInfo$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _wheelInfo$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR _wheelInfo$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+72], edx

; 225  : 	wheel->BBRadius = wheelInfo->Radius;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+76], edx

; 226  : 
; 227  : 	// Max displacement
; 228  : 	wheel->MaxPos = wheelInfo->MaxPos;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+112], edx

; 229  : 
; 230  : 	// Skid Width
; 231  : 	wheel->SkidWidth = wheelInfo->SkidWidth;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	ecx, DWORD PTR _wheelInfo$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+352], edx

; 232  : 
; 233  : 	// Oil time
; 234  : 	wheel->OilTime = OILY_WHEEL_TIME;

	mov	eax, DWORD PTR _wheel$[ebp]
	mov	DWORD PTR [eax+356], 1075838976		; 40200000H

; 235  : 
; 236  : 	// Spinning impulse
; 237  : 	wheel->SpinAngImp = MulScalar(MulScalar(wheel->Mass, TO_ACC(Real(15000))), wheel->Radius);

	mov	eax, DWORD PTR _wheel$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@466a6000
	mov	ecx, DWORD PTR _wheel$[ebp]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _wheel$[ebp]
	fstp	DWORD PTR [edx+120]

; 238  : 
; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupWheel@@YAXPAUWHEEL@@PAUWHEEL_INFO@@@Z ENDP	; SetupWheel
_TEXT	ENDS
PUBLIC	?SetupSuspension@@YAXPAUSPRING@@PAUSPRING_INFO@@@Z ; SetupSuspension
; Function compile flags: /Odt /ZI
;	COMDAT ?SetupSuspension@@YAXPAUSPRING@@PAUSPRING_INFO@@@Z
_TEXT	SEGMENT
_spring$ = 8						; size = 4
_info$ = 12						; size = 4
?SetupSuspension@@YAXPAUSPRING@@PAUSPRING_INFO@@@Z PROC NEAR ; SetupSuspension, COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 250  : 	spring->Stiffness = info->Stiffness;

	mov	eax, DWORD PTR _spring$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx

; 251  : 	spring->Damping = info->Damping;

	mov	eax, DWORD PTR _spring$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+4], edx

; 252  : 	spring->Restitution = info->Restitution;

	mov	eax, DWORD PTR _spring$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+8], edx

; 253  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupSuspension@@YAXPAUSPRING@@PAUSPRING_INFO@@@Z ENDP	; SetupSuspension
_TEXT	ENDS
PUBLIC	?SpringDampedForce@@YAMPAUSPRING@@MM@Z		; SpringDampedForce
PUBLIC	__real@00000000
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SpringDampedForce@@YAMPAUSPRING@@MM@Z
_TEXT	SEGMENT
tv78 = -84						; size = 4
tv79 = -80						; size = 4
tv74 = -76						; size = 4
tv75 = -72						; size = 4
_force$ = -4						; size = 4
_spring$ = 8						; size = 4
_extension$ = 12					; size = 4
_velocity$ = 16						; size = 4
?SpringDampedForce@@YAMPAUSPRING@@MM@Z PROC NEAR	; SpringDampedForce, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 265  : 	REAL force;
; 266  : 
; 267  : 	force = - MulScalar(spring->Stiffness, extension) - MulScalar(spring->Damping, velocity);

	mov	eax, DWORD PTR _spring$[ebp]
	fld	DWORD PTR _extension$[ebp]
	fmul	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _spring$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _velocity$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _force$[ebp]

; 268  : 
; 269  : 	if (Sign(force) == Sign(extension)) {

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _force$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L80531
	mov	DWORD PTR tv75[ebp], 0
	jmp	SHORT $L80532
$L80531:
	fld	DWORD PTR _force$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L80529
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $L80530
$L80529:
	mov	DWORD PTR tv74[ebp], 1
$L80530:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], eax
$L80532:
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _extension$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L80535
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $L80536
$L80535:
	fld	DWORD PTR _extension$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L80533
	mov	DWORD PTR tv78[ebp], -1
	jmp	SHORT $L80534
$L80533:
	mov	DWORD PTR tv78[ebp], 1
$L80534:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
$L80536:
	mov	edx, DWORD PTR tv75[ebp]
	cmp	edx, DWORD PTR tv79[ebp]
	jne	SHORT $L80404

; 270  : 		force = ZERO;

	mov	DWORD PTR _force$[ebp], 0
$L80404:

; 271  : 	}
; 272  : 
; 273  : 	return force;

	fld	DWORD PTR _force$[ebp]

; 274  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpringDampedForce@@YAMPAUSPRING@@MM@Z ENDP		; SpringDampedForce
_TEXT	ENDS
END
