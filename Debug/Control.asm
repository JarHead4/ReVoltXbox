; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Control.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CON_DoPlayerControl@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CON_LocalCarControl@@YAXPAUCtrlStruct@@PAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_Pickup2WeaponTable DD 012H
	DD	013H
	DD	013H
	DD	014H
	DD	015H
	DD	016H
	DD	018H
	DD	019H
	DD	01bH
_DATA	ENDS
PUBLIC	__real@00000000
PUBLIC	?CON_DoPlayerControl@@YAXXZ			; CON_DoPlayerControl
EXTRN	__fltused:NEAR
EXTRN	?CountdownTime@@3KA:DWORD			; CountdownTime
EXTRN	?PLR_PlayerHead@@3PAUPlayerStruct@@A:DWORD	; PLR_PlayerHead
EXTRN	?GameSettings@@3UGAME_SETTINGS@@A:BYTE		; GameSettings
;	COMDAT __real@00000000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\control.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CON_DoPlayerControl@@YAXXZ
_TEXT	SEGMENT
_lastdigital$ = -8					; size = 2
_player$ = -4						; size = 4
?CON_DoPlayerControl@@YAXXZ PROC NEAR			; CON_DoPlayerControl, COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 61   : 	PLAYER	*player;
; 62   : 	unsigned short lastdigital;
; 63   : 
; 64   : // loop thru players
; 65   : 
; 66   : 	for (player = PLR_PlayerHead; player; player = player->next)

	mov	eax, DWORD PTR ?PLR_PlayerHead@@3PAUPlayerStruct@@A ; PLR_PlayerHead
	mov	DWORD PTR _player$[ebp], eax
	jmp	SHORT $L81870
$L81871:
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _player$[ebp], ecx
$L81870:
	cmp	DWORD PTR _player$[ebp], 0
	je	$L81867

; 67   : 	{
; 68   : 
; 69   : // save last digital
; 70   : 
; 71   : 		lastdigital = player->controls.digital;

	mov	eax, DWORD PTR _player$[ebp]
	mov	cx, WORD PTR [eax+30]
	mov	WORD PTR _lastdigital$[ebp], cx

; 72   : 
; 73   : // no control?
; 74   : 
; 75   : #ifdef _PC
; 76   : 		if (CountdownTime || GameSettings.Paws)

	cmp	DWORD PTR ?CountdownTime@@3KA, 0	; CountdownTime
	jne	SHORT $L81874
	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+28, 0
	je	SHORT $L81873
$L81874:

; 77   : 		{
; 78   : 			player->controls.dx = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	BYTE PTR [eax+28], 0

; 79   : 			player->controls.dy = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	BYTE PTR [eax+29], 0

; 80   : 			player->controls.digital = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	WORD PTR [eax+30], 0

; 81   : 			player->controls.idigital = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	WORD PTR [eax+32], 0

; 82   : 			continue;

	jmp	SHORT $L81871
$L81873:

; 83   : 		}
; 84   : #endif
; 85   : 
; 86   : // zero inputs if local player
; 87   : 
; 88   : 		if (player->type == PLAYER_LOCAL)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $L81875

; 89   : 		{
; 90   : 			player->controls.dx = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	BYTE PTR [eax+28], 0

; 91   : 			player->controls.dy = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	BYTE PTR [eax+29], 0

; 92   : 			player->controls.digital = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	WORD PTR [eax+30], 0
$L81875:

; 93   : 		}
; 94   : 
; 95   : // get inputs
; 96   : 
; 97   : 		if (player->ctrlhandler)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $L81876

; 98   : 		{
; 99   : 			player->ctrlhandler(&player->controls);

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	call	DWORD PTR [ecx+20]
	add	esp, 4

; 100  : 			player->controls.idigital = (player->controls.digital ^ lastdigital) & player->controls.digital;

	mov	eax, DWORD PTR _player$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	movzx	edx, WORD PTR _lastdigital$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _player$[ebp]
	movzx	edx, WORD PTR [eax+30]
	and	ecx, edx
	mov	eax, DWORD PTR _player$[ebp]
	mov	WORD PTR [eax+32], cx
$L81876:

; 101  : 		}
; 102  : 
; 103  : // lost power?
; 104  : 
; 105  : 		if (player->car.PowerTimer)

	mov	eax, DWORD PTR _player$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [eax+3556]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L81877

; 106  : 		{
; 107  : 			player->controls.dy = 0;

	mov	eax, DWORD PTR _player$[ebp]
	mov	BYTE PTR [eax+29], 0
$L81877:

; 108  : 		}
; 109  : 
; 110  : // act on inputs
; 111  : 
; 112  : 		if (player->conhandler)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L81878

; 113  : 		{
; 114  : 			player->conhandler(&player->controls, player->ownobj);

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	call	DWORD PTR [eax+24]
	add	esp, 8
$L81878:

; 115  : 		}
; 116  : 	}

	jmp	$L81871
$L81867:

; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CON_DoPlayerControl@@YAXXZ ENDP			; CON_DoPlayerControl
_TEXT	ENDS
PUBLIC	__real@3c010204
PUBLIC	__real@3f800000
PUBLIC	?CON_LocalCarControl@@YAXPAUCtrlStruct@@PAUobject_def@@@Z ; CON_LocalCarControl
EXTRN	?LevelInf@@3PAULEVELINFO@@A:DWORD		; LevelInf
EXTRN	?CurrentTimer@@YAKXZ:NEAR			; CurrentTimer
EXTRN	?LoadTrackTimes@@YAXPAULEVELINFO@@@Z:NEAR	; LoadTrackTimes
EXTRN	?SaveTrackTimes@@YAXPAULEVELINFO@@@Z:NEAR	; SaveTrackTimes
EXTRN	?TimerFreq@@3KA:DWORD				; TimerFreq
EXTRN	?CAM_MainCamera@@3PAUCameraStruct@@A:DWORD	; CAM_MainCamera
EXTRN	?MOV_MoveCarNew@@YAXPAUobject_def@@@Z:NEAR	; MOV_MoveCarNew
EXTRN	?MOV_RightCar@@YAXPAUobject_def@@@Z:NEAR	; MOV_RightCar
EXTRN	?AiStartNode@@3JA:DWORD				; AiStartNode
EXTRN	?Keys@@3PADA:BYTE				; Keys
EXTRN	?Everything@@3DA:BYTE				; Everything
EXTRN	?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z:NEAR ; CreateObject
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	?AiZoneNumID@@3JA:DWORD				; AiZoneNumID
EXTRN	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; GetCarGrid
EXTRN	?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z:NEAR ; SetCarPos
EXTRN	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z:NEAR ; RotTransVector
;	COMDAT __real@3c010204
CONST	SEGMENT
__real@3c010204 DD 03c010204r			; 0.00787402
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CON_LocalCarControl@@YAXPAUCtrlStruct@@PAUobject_def@@@Z
_TEXT	SEGMENT
tv86 = -156						; size = 4
tv87 = -152						; size = 4
tv78 = -148						; size = 4
tv492 = -144						; size = 4
tv418 = -144						; size = 4
tv79 = -144						; size = 4
_flag$ = -76						; size = 4
_mat$ = -72						; size = 36
_vec2$ = -36						; size = 12
_vec$ = -24						; size = 12
_step$ = -12						; size = 4
_dest$ = -8						; size = 4
_car$ = -4						; size = 4
_Control$ = 8						; size = 4
_CarObj$ = 12						; size = 4
?CON_LocalCarControl@@YAXPAUCtrlStruct@@PAUobject_def@@@Z PROC NEAR ; CON_LocalCarControl, COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi

; 123  : 	CAR		*car;
; 124  : 	REAL	dest, step;
; 125  : 	VEC		vec, vec2;
; 126  : 	MAT		mat;
; 127  : 	long	flag;
; 128  : 
; 129  : 	car = &CarObj->player->car;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], ecx

; 130  : 	if (car == NULL)

	jne	SHORT $L81890

; 131  : 	{
; 132  : 		return;					// Specified object is not a car

	jmp	$L81882
$L81890:

; 133  : 	}	
; 134  : 
; 135  : 	// Set the angle of the wheels and engine voltage from
; 136  : 	// the position of the controls 
; 137  : 
; 138  : 	// Set the angle of the steering wheel
; 139  : 	dest = ((ONE / CTRL_RANGE_MAX) * (REAL)(Control->dx));

	mov	eax, DWORD PTR _Control$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv418[ebp], ecx
	fild	DWORD PTR tv418[ebp]
	fmul	DWORD PTR __real@3c010204
	fstp	DWORD PTR _dest$[ebp]

; 140  : #ifndef _PSX
; 141  : 	step = MulScalar(car->SteerRate, TimeStep);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+828]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _step$[ebp]

; 142  : #else
; 143  : 	step = MulScalar(car->SteerRate, TimeStep) << 1;
; 144  : #endif
; 145  : 	if ((dest == ZERO) || (Sign(dest) != Sign(car->SteerAngle))) {

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _dest$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$L81893
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _dest$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82027
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $L82028
$L82027:
	fld	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82025
	mov	DWORD PTR tv78[ebp], -1
	jmp	SHORT $L82026
$L82025:
	mov	DWORD PTR tv78[ebp], 1
$L82026:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], eax
$L82028:
	mov	ecx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [ecx+824]
	fld	DWORD PTR __real@00000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82031
	mov	DWORD PTR tv87[ebp], 0
	jmp	SHORT $L82032
$L82031:
	mov	edx, DWORD PTR _car$[ebp]
	fld	DWORD PTR [edx+824]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82029
	mov	DWORD PTR tv86[ebp], -1
	jmp	SHORT $L82030
$L82029:
	mov	DWORD PTR tv86[ebp], 1
$L82030:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], eax
$L82032:
	mov	ecx, DWORD PTR tv79[ebp]
	cmp	ecx, DWORD PTR tv87[ebp]
	je	SHORT $L81892
$L81893:

; 146  : 		step *= 2;

	fld	DWORD PTR _step$[ebp]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _step$[ebp]

; 147  : 	}
; 148  : #ifndef _PSX
; 149  : 	else {

	jmp	SHORT $L81894
$L81892:

; 150  : 		step *= ONE - (car->SteerModifier * VecDotVec(&car->Body->Centre.Vel, &car->Body->Centre.WMatrix.mv[L]) / car->TopSpeed);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	fld	DWORD PTR [edx+36]
	fmul	DWORD PTR [ecx+128]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [edx+132]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _car$[ebp]
	fmul	DWORD PTR [eax+832]
	mov	ecx, DWORD PTR _car$[ebp]
	fdiv	DWORD PTR [ecx+844]
	fsubr	DWORD PTR __real@3f800000
	fmul	DWORD PTR _step$[ebp]
	fstp	DWORD PTR _step$[ebp]
$L81894:

; 151  : 	}
; 152  : #endif
; 153  : 	if (dest > car->SteerAngle) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR [eax+824]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81895

; 154  : 		if (dest - car->SteerAngle < step) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _dest$[ebp]
	fsub	DWORD PTR [eax+824]
	fcomp	DWORD PTR _step$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81896

; 155  : 			car->SteerAngle = dest;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+824], ecx

; 156  : 		} else {

	jmp	SHORT $L81895
$L81896:

; 157  : 			car->SteerAngle += step;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _step$[ebp]
	fadd	DWORD PTR [eax+824]
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+824]
$L81895:

; 158  : 		}
; 159  : 	}
; 160  : 	if (dest < car->SteerAngle) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR [eax+824]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81898

; 161  : 		if (car->SteerAngle - dest < step) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+824]
	fsub	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR _step$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81899

; 162  : 			car->SteerAngle = dest;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+824], ecx

; 163  : 		} else {

	jmp	SHORT $L81898
$L81899:

; 164  : 			car->SteerAngle -= step;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+824]
	fsub	DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+824]
$L81898:

; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 
; 169  : 	// Set voltage across the motor
; 170  : 	dest = -((ONE / CTRL_RANGE_MAX) * (REAL)(Control->dy));

	mov	eax, DWORD PTR _Control$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	mov	DWORD PTR tv492[ebp], ecx
	fild	DWORD PTR tv492[ebp]
	fmul	DWORD PTR __real@3c010204
	fchs
	fstp	DWORD PTR _dest$[ebp]

; 171  : 	step = MulScalar(car->EngineRate, TimeStep);

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+840]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fstp	DWORD PTR _step$[ebp]

; 172  : 	if ((dest < ZERO && car->EngineVolt > ZERO) || (dest > ZERO && car->EngineVolt < ZERO)) {

	fld	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81904
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81903
$L81904:
	fld	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81902
	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81902
$L81903:

; 173  : 		car->EngineVolt = ZERO;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+836], 0
$L81902:

; 174  : 	}
; 175  : 	if (dest > car->EngineVolt) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR [eax+836]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81905

; 176  : 		if (dest - car->EngineVolt < step) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _dest$[ebp]
	fsub	DWORD PTR [eax+836]
	fcomp	DWORD PTR _step$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81906

; 177  : 			car->EngineVolt = dest;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+836], ecx

; 178  : 		} else {

	jmp	SHORT $L81905
$L81906:

; 179  : 			car->EngineVolt += step;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _step$[ebp]
	fadd	DWORD PTR [eax+836]
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+836]
$L81905:

; 180  : 		}
; 181  : 	}
; 182  : 	if (dest < car->EngineVolt) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR [eax+836]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81908

; 183  : 		if (car->EngineVolt - dest < step) {

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	fsub	DWORD PTR _dest$[ebp]
	fcomp	DWORD PTR _step$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81909

; 184  : 			car->EngineVolt = dest;

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+836], ecx

; 185  : 		} else {

	jmp	SHORT $L81908
$L81909:

; 186  : 			car->EngineVolt -= step;

	mov	eax, DWORD PTR _car$[ebp]
	fld	DWORD PTR [eax+836]
	fsub	DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _car$[ebp]
	fstp	DWORD PTR [ecx+836]
$L81908:

; 187  : 		}
; 188  : 	}
; 189  : 
; 190  : 	// Reset car?
; 191  : 	if (Control->idigital & CTRL_RESET)

	mov	eax, DWORD PTR _Control$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	and	ecx, 32					; 00000020H
	je	$L81911

; 192  : 	{
; 193  : #ifdef _PC
; 194  : 		if ((Keys[DIK_LSHIFT] || Keys[DIK_RSHIFT]) && Everything) {

	movsx	eax, BYTE PTR ?Keys@@3PADA+42
	test	eax, eax
	jne	SHORT $L81913
	movsx	eax, BYTE PTR ?Keys@@3PADA+54
	test	eax, eax
	je	$L81912
$L81913:
	movsx	eax, BYTE PTR ?Everything@@3DA		; Everything
	test	eax, eax
	je	$L81912

; 195  : 			SetVector(&vec2, 0, 0, 256);

	mov	DWORD PTR _vec2$[ebp], 0
	mov	DWORD PTR _vec2$[ebp+4], 0
	mov	DWORD PTR _vec2$[ebp+8], 1132462080	; 43800000H

; 196  : 			RotTransVector(&CAM_MainCamera->WMatrix, &CAM_MainCamera->WPos, &vec2, &vec);

	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	add	eax, 16					; 00000010H
	push	eax
	call	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
	add	esp, 16					; 00000010H

; 197  : 
; 198  : 			CopyVec(&CAM_MainCamera->WMatrix.mv[R], &mat.mv[R]);

	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _mat$[ebp], ecx
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _mat$[ebp+4], ecx
	mov	eax, DWORD PTR ?CAM_MainCamera@@3PAUCameraStruct@@A ; CAM_MainCamera
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _mat$[ebp+8], ecx

; 199  : 			SetVector(&mat.mv[U], 0, 1, 0);

	mov	DWORD PTR _mat$[ebp+12], 0
	mov	DWORD PTR _mat$[ebp+16], 1065353216	; 3f800000H
	mov	DWORD PTR _mat$[ebp+20], 0

; 200  : 			CrossProduct(&mat.mv[R], &mat.mv[U], &mat.mv[L]);

	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+20]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+12]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+20]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+28]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+16]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+32]

; 201  : 			SetCarPos(car, &vec, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; SetCarPos
	add	esp, 12					; 0000000cH
$L81912:

; 202  : 		}
; 203  : #endif		
; 204  : 		CarObj->player->car.RightingCollide = TRUE;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	BYTE PTR [ecx+3859], 1

; 205  : 		CarObj->player->car.RightingReachDest = FALSE;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	BYTE PTR [ecx+3860], 0

; 206  : 		CarObj->movehandler = (MOVE_HANDLER)MOV_RightCar;	

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	DWORD PTR [eax+688], OFFSET FLAT:?MOV_RightCar@@YAXPAUobject_def@@@Z ; MOV_RightCar
$L81911:

; 207  : 	}
; 208  : 
; 209  : 	// Restart car?
; 210  : #ifndef _PSX
; 211  : 	if (CarObj->player->controls.idigital & CTRL_RESTART && !CountdownTime)

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	movzx	edx, WORD PTR [ecx+32]
	and	edx, 32768				; 00008000H
	je	$L81915
	cmp	DWORD PTR ?CountdownTime@@3KA, 0	; CountdownTime
	jne	$L81915

; 212  : 	{
; 213  : 		GetCarGrid(0, &vec, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	push	0
	call	?GetCarGrid@@YAXJPAUVectorStruct@@PATMatrixUnion@@@Z ; GetCarGrid
	add	esp, 12					; 0000000cH

; 214  : 		SetCarPos(car, &vec, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _car$[ebp]
	push	edx
	call	?SetCarPos@@YAXPAUCarStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; SetCarPos
	add	esp, 12					; 0000000cH

; 215  : 
; 216  : 		car->Laps = -1;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3420], -1

; 217  : 		CarObj->player->CarAI.ZoneID = AiZoneNumID - 1;

	mov	eax, DWORD PTR ?AiZoneNumID@@3JA	; AiZoneNumID
	sub	eax, 1
	mov	ecx, DWORD PTR _CarObj$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	mov	DWORD PTR [edx+10120], eax

; 218  : 
; 219  : 		CarObj->player->CarAI.FinishDistNode = AiStartNode;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR ?AiStartNode@@3JA	; AiStartNode
	mov	DWORD PTR [ecx+10196], edx

; 220  : 		CarObj->player->CarAI.FinishDist = 0.0f;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+10200], 0

; 221  : 		CarObj->player->CarAI.FinishDistPanel = 0.0f;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+10204], 0

; 222  : 
; 223  : 		CarObj->movehandler = (MOVE_HANDLER)MOV_MoveCarNew;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	DWORD PTR [eax+688], OFFSET FLAT:?MOV_MoveCarNew@@YAXPAUobject_def@@@Z ; MOV_MoveCarNew

; 224  : 
; 225  : #ifdef _PC																	// !MT! TEMP OUT of N64 version
; 226  : 		CarObj->player->car.CurrentLapStartTime = CurrentTimer() - MS2TIME(MAKE_TIME(10, 0, 0));

	call	?CurrentTimer@@YAKXZ			; CurrentTimer
	mov	ecx, eax
	mov	eax, DWORD PTR ?TimerFreq@@3KA		; TimerFreq
	xor	edx, edx
	mov	esi, 1000				; 000003e8H
	div	esi
	imul	eax, 600000				; 000927c0H
	sub	ecx, eax
	mov	edx, DWORD PTR _CarObj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	DWORD PTR [eax+3544], ecx

; 227  : 
; 228  : 		SaveTrackTimes(&LevelInf[GameSettings.Level]);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	call	?SaveTrackTimes@@YAXPAULEVELINFO@@@Z	; SaveTrackTimes
	add	esp, 4

; 229  : 		LoadTrackTimes(&LevelInf[GameSettings.Level]);

	mov	eax, DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+4
	imul	eax, 232				; 000000e8H
	add	eax, DWORD PTR ?LevelInf@@3PAULEVELINFO@@A ; LevelInf
	push	eax
	call	?LoadTrackTimes@@YAXPAULEVELINFO@@@Z	; LoadTrackTimes
	add	esp, 4
$L81915:

; 230  : #endif
; 231  : 	}
; 232  : #else 
; 233  : 	if (CarObj->player->controls.idigital & CTRL_RESTART)
; 234  : 	{
; 235  : 		GetCarGrid(0, &vec, &mat);
; 236  : 		SetCarPos(car, &vec, &Identity);
; 237  : 
; 238  : 		CarObj->movehandler = (MOVE_HANDLER)MOV_MoveCarNew;
; 239  : 	}
; 240  : #endif
; 241  : 
; 242  : #ifdef _PC
; 243  : 	// release weapon?
; 244  : 	if (Control->idigital & CTRL_FIRE && CarObj->player->PickupNum)

	mov	eax, DWORD PTR _Control$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	and	ecx, 16					; 00000010H
	je	$L81882
	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	cmp	DWORD PTR [ecx+10232], 0
	je	$L81882

; 245  : 	{
; 246  : 		flag = (long)CarObj->player;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR _flag$[ebp], ecx

; 247  :  		CreateObject(&CarObj->player->car.Body->Centre.Pos, &CarObj->player->car.Body->Centre.WMatrix, Pickup2WeaponTable[CarObj->player->PickupType], &flag);

	lea	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CarObj$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10228]
	mov	ecx, DWORD PTR _Pickup2WeaponTable[eax*4]
	push	ecx
	mov	edx, DWORD PTR _CarObj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	ecx, DWORD PTR [eax+900]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _CarObj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	ecx, DWORD PTR [eax+900]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?CreateObject@@YAPAUobject_def@@PAUVectorStruct@@PATMatrixUnion@@JPAJ@Z ; CreateObject
	add	esp, 16					; 00000010H

; 248  : 
; 249  : 		if (--CarObj->player->PickupNum == 0) {

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR [ecx+10232]
	sub	edx, 1
	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+10232], edx
	mov	edx, DWORD PTR _CarObj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	cmp	DWORD PTR [eax+10232], 0
	jne	SHORT $L81882

; 250  : 			CarObj->player->PickupType = PICKUP_NONE;

	mov	eax, DWORD PTR _CarObj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+10228], -1
$L81882:

; 251  : 		}
; 252  : 
; 253  : 	}
; 254  : #endif
; 255  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CON_LocalCarControl@@YAXPAUCtrlStruct@@PAUobject_def@@@Z ENDP ; CON_LocalCarControl
_TEXT	ENDS
END
