; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\camera.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCamera@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitCamPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraFreedom@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraEdit@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraForwardLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraRearLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraRelativePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraAwayLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraNewFollowPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraFollowPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraRotatePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraWorldColls@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraDynamicNodePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraStartEndNodes@@YA_NPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraFreedomPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraMouseLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraEditPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraNullLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCameraView@@YAXPATMatrixUnion@@PAUVectorStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetViewport@@YAXMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCamera@@YAPAUCameraStruct@@MMMMJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveCamera@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitCameras@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetProjMatrix@@YAXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadCameraNodes@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TriggerCamera@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcCamZoom@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CameraNearestNodePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcCameraCollPoly@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??LoadCameraNodes@@YAJPAU_iobuf@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?CameraCount@@3DA				; CameraCount
PUBLIC	?CameraHomeHeight@@3MA				; CameraHomeHeight
PUBLIC	?ViewMatrixScaled@@3TMatrixUnion@@A		; ViewMatrixScaled
PUBLIC	?ViewMatrix@@3TMatrixUnion@@A			; ViewMatrix
PUBLIC	?ViewCameraMatrix@@3TMatrixUnion@@A		; ViewCameraMatrix
PUBLIC	?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A	; ViewMatrixScaledMirrorY
PUBLIC	?ViewTransScaled@@3UVectorStruct@@A		; ViewTransScaled
PUBLIC	?ViewTrans@@3UVectorStruct@@A			; ViewTrans
PUBLIC	?ViewCameraPos@@3UVectorStruct@@A		; ViewCameraPos
PUBLIC	?MouseXpos@@3MA					; MouseXpos
PUBLIC	?MouseYpos@@3MA					; MouseYpos
PUBLIC	?MouseXrel@@3MA					; MouseXrel
PUBLIC	?MouseYrel@@3MA					; MouseYrel
PUBLIC	?CameraEditXrel@@3MA				; CameraEditXrel
PUBLIC	?CameraEditYrel@@3MA				; CameraEditYrel
PUBLIC	?CameraEditZrel@@3MA				; CameraEditZrel
PUBLIC	?MouseLeft@@3DA					; MouseLeft
PUBLIC	?MouseRight@@3DA				; MouseRight
PUBLIC	?MouseLastLeft@@3DA				; MouseLastLeft
PUBLIC	?MouseLastRight@@3DA				; MouseLastRight
PUBLIC	?CameraPlaneLeft@@3UPlaneStruct@@A		; CameraPlaneLeft
PUBLIC	?CameraPlaneRight@@3UPlaneStruct@@A		; CameraPlaneRight
PUBLIC	?CameraPlaneTop@@3UPlaneStruct@@A		; CameraPlaneTop
PUBLIC	?CameraPlaneBottom@@3UPlaneStruct@@A		; CameraPlaneBottom
PUBLIC	?Camera@@3PAUCameraStruct@@A			; Camera
PUBLIC	?CAM_MainCamera@@3PAUCameraStruct@@A		; CAM_MainCamera
PUBLIC	?CAM_CameraNode@@3PAUCamNodeStruct@@A		; CAM_CameraNode
PUBLIC	?CAM_NCameraNodes@@3JA				; CAM_NCameraNodes
PUBLIC	?ViewportRect@@3U_D3DRECT@@A			; ViewportRect
PUBLIC	?CAM_StartNode@@3PAUCamNodeStruct@@A		; CAM_StartNode
PUBLIC	?CAM_EndNode@@3PAUCamNodeStruct@@A		; CAM_EndNode
PUBLIC	?CAM_NodeCamPos@@3UVectorStruct@@A		; CAM_NodeCamPos
PUBLIC	?CAM_NodeCamOldPos@@3UVectorStruct@@A		; CAM_NodeCamOldPos
PUBLIC	?CAM_NodeCamDir@@3UVectorStruct@@A		; CAM_NodeCamDir
PUBLIC	?CAM_NodeCamPoleLen@@3MA			; CAM_NodeCamPoleLen
PUBLIC	?CAM_NodeCamDoColls@@3_NA			; CAM_NodeCamDoColls
PUBLIC	?CAM_LineOfSight@@3_NA				; CAM_LineOfSight
_BSS	SEGMENT
?CameraCount@@3DA DB 01H DUP (?)			; CameraCount
	ALIGN	4

?CameraHomeHeight@@3MA DD 01H DUP (?)			; CameraHomeHeight
?ViewMatrixScaled@@3TMatrixUnion@@A DB 024H DUP (?)	; ViewMatrixScaled
?ViewMatrix@@3TMatrixUnion@@A DB 024H DUP (?)		; ViewMatrix
?ViewCameraMatrix@@3TMatrixUnion@@A DB 024H DUP (?)	; ViewCameraMatrix
?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A DB 024H DUP (?) ; ViewMatrixScaledMirrorY
?ViewTransScaled@@3UVectorStruct@@A DB 0cH DUP (?)	; ViewTransScaled
?ViewTrans@@3UVectorStruct@@A DB 0cH DUP (?)		; ViewTrans
?ViewCameraPos@@3UVectorStruct@@A DB 0cH DUP (?)	; ViewCameraPos
?MouseXrel@@3MA DD 01H DUP (?)				; MouseXrel
?MouseYrel@@3MA DD 01H DUP (?)				; MouseYrel
?CameraEditXrel@@3MA DD 01H DUP (?)			; CameraEditXrel
?CameraEditYrel@@3MA DD 01H DUP (?)			; CameraEditYrel
?CameraEditZrel@@3MA DD 01H DUP (?)			; CameraEditZrel
?MouseLeft@@3DA DB 01H DUP (?)				; MouseLeft
	ALIGN	4

?MouseRight@@3DA DB 01H DUP (?)				; MouseRight
	ALIGN	4

?MouseLastLeft@@3DA DB 01H DUP (?)			; MouseLastLeft
	ALIGN	4

?MouseLastRight@@3DA DB 01H DUP (?)			; MouseLastRight
	ALIGN	4

?CameraPlaneLeft@@3UPlaneStruct@@A DB 010H DUP (?)	; CameraPlaneLeft
?CameraPlaneRight@@3UPlaneStruct@@A DB 010H DUP (?)	; CameraPlaneRight
?CameraPlaneTop@@3UPlaneStruct@@A DB 010H DUP (?)	; CameraPlaneTop
?CameraPlaneBottom@@3UPlaneStruct@@A DB 010H DUP (?)	; CameraPlaneBottom
?Camera@@3PAUCameraStruct@@A DB 0ae0H DUP (?)		; Camera
?CAM_MainCamera@@3PAUCameraStruct@@A DD 01H DUP (?)	; CAM_MainCamera
?CAM_CameraNode@@3PAUCamNodeStruct@@A DB 0a000H DUP (?)	; CAM_CameraNode
?CAM_NCameraNodes@@3JA DD 01H DUP (?)			; CAM_NCameraNodes
?ViewportRect@@3U_D3DRECT@@A DB 010H DUP (?)		; ViewportRect
?CAM_StartNode@@3PAUCamNodeStruct@@A DD 01H DUP (?)	; CAM_StartNode
?CAM_EndNode@@3PAUCamNodeStruct@@A DD 01H DUP (?)	; CAM_EndNode
?CAM_NodeCamPos@@3UVectorStruct@@A DB 0cH DUP (?)	; CAM_NodeCamPos
?CAM_NodeCamOldPos@@3UVectorStruct@@A DB 0cH DUP (?)	; CAM_NodeCamOldPos
?CAM_NodeCamPoleLen@@3MA DD 01H DUP (?)			; CAM_NodeCamPoleLen
_BSS	ENDS
_DATA	SEGMENT
?MouseXpos@@3MA DD 043a00000r			; 320	; MouseXpos
?MouseYpos@@3MA DD 043700000r			; 240	; MouseYpos
?CAM_NodeCamDir@@3UVectorStruct@@A DD 03f800000r ; 1	; CAM_NodeCamDir
	DD	000000000r			; 0
	DD	000000000r			; 0
?CAM_NodeCamDoColls@@3_NA DB 01H			; CAM_NodeCamDoColls
?CAM_LineOfSight@@3_NA DB 01H				; CAM_LineOfSight
	ORG $+2
_OuterRadius DD	042f00000r			; 120
_InnerRadius DD	042820000r			; 65
_CamFollowData DB 01H
	ORG $+3
	DD	000000000r			; 0
	DD	0c3160000r			; -150
	DD	0c3e60000r			; -460
	DD	000000000r			; 0
	DD	0c3480000r			; -200
	DD	000000000r			; 0
	DB	00H
	ORG $+3
	DD	000000000r			; 0
	DD	0c28c0000r			; -70
	DD	0c3520000r			; -210
	DD	000000000r			; 0
	DD	0c3480000r			; -200
	DD	000000000r			; 0
	DB	00H
	ORG $+3
	DD	0c3520000r			; -210
	DD	0c2be0000r			; -95
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DB	00H
	ORG $+3
	DD	043520000r			; 210
	DD	0c2be0000r			; -95
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DB	00H
	ORG $+3
	DD	000000000r			; 0
	DD	0c2b40000r			; -90
	DD	043520000r			; 210
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DB	00H
	ORG $+3
	DD	000000000r			; 0
	DD	0c2f00000r			; -120
	DD	0c38c0000r			; -280
	DD	000000000r			; 0
	DD	0c3160000r			; -150
	DD	000000000r			; 0
_CamAttachedData DD 000000000r			; 0
	DD	0c2300000r			; -44
	DD	000000000r			; 0
	DB	01H
	ORG $+3
	DD	042700000r			; 60
	DD	0c2200000r			; -40
	DD	0c33e0000r			; -190
	DB	01H
	ORG $+3
	DD	0c2700000r			; -60
	DD	0c2200000r			; -40
	DD	0c33e0000r			; -190
	DB	01H
	ORG $+3
	DD	000000000r			; 0
	DD	0c2300000r			; -44
	DD	000000000r			; 0
	DB	00H
	ORG $+3
_DATA	ENDS
PUBLIC	?UpdateCamera@@YAXPAUCameraStruct@@@Z		; UpdateCamera
PUBLIC	__real@00000000
PUBLIC	?CalcCamZoom@@YAXPAUCameraStruct@@@Z		; CalcCamZoom
PUBLIC	?CalcCameraCollPoly@@YAXPAUCameraStruct@@@Z	; CalcCameraCollPoly
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
EXTRN	__fltused:NEAR
EXTRN	?Keys@@3PADA:BYTE				; Keys
EXTRN	?LastKeys@@3PADA:BYTE				; LastKeys
;	COMDAT __real@00000000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\camera.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?UpdateCamera@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
?UpdateCamera@@YAXPAUCameraStruct@@@Z PROC NEAR		; UpdateCamera, COMDAT

; 172  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi

; 173  : 	REAL flag, dist;
; 174  : 	VEC out;
; 175  : 	MAT mat, mat2, mat3;
; 176  : #ifdef _N64
; 177  : 	long	JoyX, JoyY;
; 178  : 	BUTTONS	Buttons;
; 179  : 	
; 180  : 	// Read in controls direct from controller 2
; 181  : 	CRD_GetNewButtons(1, &Buttons);
; 182  : 	CRD_GetJoyXY(1, &JoyX, &JoyY);
; 183  : #endif
; 184  : 
; 185  : 	// Set Zoom Mod on/off
; 186  : #ifdef _PC
; 187  : 	if (Keys[DIK_TAB] && !LastKeys[DIK_TAB]) {

	movsx	eax, BYTE PTR ?Keys@@3PADA+15
	test	eax, eax
	je	SHORT $L81619
	movsx	eax, BYTE PTR ?LastKeys@@3PADA+15
	test	eax, eax
	jne	SHORT $L81619

; 188  : #endif
; 189  : #ifdef _N64
; 190  : 	if (Buttons & BUT_R) {
; 191  : #endif
; 192  : 		camera->Zoom = !camera->Zoom;

	mov	eax, DWORD PTR _camera$[ebp]
	movzx	ecx, BYTE PTR [eax+181]
	neg	ecx
	sbb	ecx, ecx
	inc	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [edx+181], cl

; 193  : 		camera->ZoomMod = LENS_DIST_MOD;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+176], 1048576000		; 3e800000H

; 194  : 		camera->Lens = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+168], 0
$L81619:

; 195  : 	}
; 196  : 
; 197  : 	// Move the camera offset if required
; 198  : /*	if (camera->Type == CAM_FOLLOW)
; 199  : 	{
; 200  : 		if (CAMERA_UP && Everything) camera->LookOffset.v[Y] -= 100 * TimeStep;
; 201  : 		if (CAMERA_DOWN && Everything) camera->LookOffset.v[Y] += 100 * TimeStep;
; 202  : 
; 203  : 		if (!GameSettings.Paws)
; 204  : 		{
; 205  : 			flag = 0;
; 206  : #ifdef _PC
; 207  : 			if ((CAMERA_FORWARDS || Mouse.rgbButtons[0]) && Everything) flag = 5 * TimeFactor;
; 208  : 			if ((CAMERA_BACKWARDS || Mouse.rgbButtons[1]) && Everything) flag = -5 * TimeFactor;
; 209  : #endif
; 210  : #ifdef _N64
; 211  : 			if (CAMERA_FORWARDS && Everything) flag = 5 * TimeFactor;
; 212  : 			if (CAMERA_BACKWARDS && Everything) flag = -5 * TimeFactor;
; 213  : #endif
; 214  : 			if (flag)
; 215  : 			{
; 216  : 				dist = Length(&camera->PosOffset);
; 217  : 				if (dist < 64 && flag > 0) flag = 0;
; 218  : 				dist /= dist + flag;
; 219  : 				camera->PosOffset.v[X] *= dist;
; 220  : 				camera->PosOffset.v[Y] *= dist;
; 221  : 				camera->PosOffset.v[Z] *= dist;
; 222  : 			}
; 223  : 
; 224  : 			dist = Length(&camera->PosOffset);
; 225  : 			SetVector(&out, 0, 0, 0);
; 226  : 			BuildLookMatrixForward(&out, &camera->PosOffset, &mat);
; 227  : #ifdef _PC
; 228  : 			RotMatrixZYX(&mat2, (REAL)Mouse.lY / 4096, -(REAL)Mouse.lX / 4096, 0);
; 229  : #endif
; 230  : #ifdef _N64
; 231  : 			RotMatrixZYX(&mat2, (REAL)JoyY / 4096, -(REAL)JoyX / 4096, 0);
; 232  : #endif
; 233  : 			MulMatrix(&mat, &mat2, &mat3);
; 234  : 			camera->PosOffset.v[0] = mat3.m[LX] * dist;
; 235  : 			camera->PosOffset.v[1] = mat3.m[LY] * dist;
; 236  : 			camera->PosOffset.v[2] = mat3.m[LZ] * dist;
; 237  : 		}
; 238  : 	}
; 239  : 
; 240  : 	if (camera->Type == CAM_ATTACHED) {
; 241  : 		if (CAMERA_UP) camera->PosOffset.v[Y] -= 100 * TimeStep;
; 242  : 		if (CAMERA_DOWN) camera->PosOffset.v[Y] += 100 * TimeStep;
; 243  : 		if (CAMERA_LEFT) camera->PosOffset.v[X] -= 100 * TimeStep;
; 244  : 		if (CAMERA_RIGHT) camera->PosOffset.v[X] += 100 * TimeStep;
; 245  : 		if (CAMERA_FORWARDS) camera->PosOffset.v[Z] -= 100 * TimeStep;
; 246  : 		if (CAMERA_BACKWARDS) camera->PosOffset.v[Z] += 100 * TimeStep;
; 247  : 	}
; 248  : */
; 249  : 	camera->Timer += TimeStep;

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+184]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+184]

; 250  : 
; 251  : 	// Calculate camera's world position
; 252  : 	if (camera->CalcCamPos != NULL) {

	mov	eax, DWORD PTR _camera$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L81620

; 253  : 		camera->CalcCamPos(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	call	DWORD PTR [ecx+8]
	add	esp, 4
$L81620:

; 254  : 	}
; 255  : 	// Update the Lens modifier if necessary
; 256  : 	if (camera->Zoom && (camera->Object != NULL)) {

	mov	eax, DWORD PTR _camera$[ebp]
	movzx	ecx, BYTE PTR [eax+181]
	test	ecx, ecx
	je	SHORT $L81621
	mov	eax, DWORD PTR _camera$[ebp]
	cmp	DWORD PTR [eax+164], 0
	je	SHORT $L81621

; 257  : 		CalcCamZoom(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?CalcCamZoom@@YAXPAUCameraStruct@@@Z	; CalcCamZoom
	add	esp, 4
$L81621:

; 258  : 	}
; 259  : 	// Calculate camera matrix
; 260  : 	if (camera->CalcCamLook != NULL) {

	mov	eax, DWORD PTR _camera$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L81622

; 261  : 		camera->CalcCamLook(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	call	DWORD PTR [ecx+12]
	add	esp, 4
$L81622:

; 262  : 	}
; 263  : 
; 264  : 	// Create the collision polygon for the view glass
; 265  : 	CalcCameraCollPoly(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?CalcCameraCollPoly@@YAXPAUCameraStruct@@@Z ; CalcCameraCollPoly
	add	esp, 4

; 266  : 
; 267  : 	// Decrease shake?
; 268  : 	if (camera->Shake)

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [eax+188]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L81612

; 269  : 	{
; 270  : 		camera->Shake -= TimeStep;

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+188]
	fsub	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+188]

; 271  : 		if (camera->Shake < 0.0f)

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+188]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81612

; 272  : 			camera->Shake = 0.0f;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+188], 0
$L81612:

; 273  : 	}
; 274  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCamera@@YAXPAUCameraStruct@@@Z ENDP		; UpdateCamera
_TEXT	ENDS
PUBLIC	?InitCamPos@@YAXPAUCameraStruct@@@Z		; InitCamPos
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	__real@3f800000
PUBLIC	?CameraAwayLook@@YAXPAUCameraStruct@@@Z		; CameraAwayLook
EXTRN	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z:NEAR ; RotVector
EXTRN	?CopyMat@@YAXPATMatrixUnion@@0@Z:NEAR		; CopyMat
EXTRN	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z:NEAR ; VecMulMat
EXTRN	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z:NEAR ; MatToQuat
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InitCamPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
tv284 = -108						; size = 4
tv73 = -108						; size = 4
__mul$81635 = -40					; size = 4
_mat$ = -36						; size = 36
_camera$ = 8						; size = 4
?InitCamPos@@YAXPAUCameraStruct@@@Z PROC NEAR		; InitCamPos, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 285  : 	MAT mat;
; 286  : 
; 287  : 	// Set default stuf, same for all camera types
; 288  : 	SetVecZero(&camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+96], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+100], 0

; 289  : 
; 290  : 	switch (camera->Type) {

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $L81633
	cmp	DWORD PTR tv73[ebp], 1
	je	$L81637
	cmp	DWORD PTR tv73[ebp], 2
	je	$L81638
	jmp	$L81627
$L81633:

; 291  : 		// Follow Camera
; 292  : 	case CAM_FOLLOW:
; 293  : 		// get desired camera world matrix
; 294  : 		mat.m[RX] = camera->Object->body.Centre.WMatrix.m[LZ];

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR _mat$[ebp], edx

; 295  : 		mat.m[RY] = ZERO;

	mov	DWORD PTR _mat$[ebp+4], 0

; 296  : 		mat.m[RZ] = -camera->Object->body.Centre.WMatrix.m[LX];

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR [ecx+124]
	fchs
	fstp	DWORD PTR _mat$[ebp+8]

; 297  : 
; 298  : 		if (!mat.m[RX] && !mat.m[RZ])

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _mat$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81634
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _mat$[ebp+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81634

; 299  : 			mat.m[RX] = ONE;

	mov	DWORD PTR _mat$[ebp], 1065353216	; 3f800000H
$L81634:

; 300  : 
; 301  : 		NormalizeVector(&mat.mv[R]);

	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81635[ebp]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR __mul$81635[ebp]
	fstp	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR __mul$81635[ebp]
	fstp	DWORD PTR _mat$[ebp+4]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR __mul$81635[ebp]
	fstp	DWORD PTR _mat$[ebp+8]

; 302  : 
; 303  : 		mat.m[UX] = ZERO;

	mov	DWORD PTR _mat$[ebp+12], 0

; 304  : 		mat.m[UY] = ONE;

	mov	DWORD PTR _mat$[ebp+16], 1065353216	; 3f800000H

; 305  : 		mat.m[UZ] = ZERO;

	mov	DWORD PTR _mat$[ebp+20], 0

; 306  : 
; 307  : 		CrossProduct(&mat.mv[R], &mat.mv[U], &mat.mv[L]);

	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+20]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+12]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+20]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+28]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+16]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+32]

; 308  : 
; 309  : 		// get desired offset vector
; 310  : 		RotVector(&mat, &camera->PosOffset, &camera->WorldPosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 311  : 		VecPlusVec(&camera->WorldPosOffset, &camera->Object->body.Centre.Pos, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+128]
	fadd	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+68]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+132]
	fadd	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+72]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+136]
	fadd	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+76]

; 312  : 		CopyVec(&camera->WPos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+88], edx

; 313  : 
; 314  : 
; 315  : 		CameraAwayLook(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?CameraAwayLook@@YAXPAUCameraStruct@@@Z	; CameraAwayLook
	add	esp, 4

; 316  : 		break;

	jmp	$L81627
$L81637:

; 317  : 
; 318  : 	case CAM_ATTACHED:
; 319  : 		VecMulMat(&camera->PosOffset, &camera->Object->body.Centre.WMatrix, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 320  : 		VecPlusEqVec(&camera->WPos, &camera->Object->body.Centre.Pos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+68]
	fadd	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+68]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+72]
	fadd	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+72]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+76]
	fadd	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+76]

; 321  : 		MatToQuat(&camera->Object->body.Centre.WMatrix, &camera->Quat);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	add	edx, 100				; 00000064H
	push	edx
	call	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z ; MatToQuat
	add	esp, 8

; 322  : 		CopyMat(&camera->Object->body.Centre.WMatrix, &camera->WMatrix);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	add	edx, 100				; 00000064H
	push	edx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 323  : 		break;

	jmp	SHORT $L81627
$L81638:

; 324  : 
; 325  : 	case CAM_RAIL:
; 326  : 		switch (camera->SubType) {

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv284[ebp], ecx
$L81627:

; 327  : 		case CAM_RAIL_DYNAMIC_MONO:
; 328  : 			break;
; 329  : 		case CAM_RAIL_STATIC_NEAREST:
; 330  : 			break;
; 331  : 		default:
; 332  : 			break;
; 333  : 		}
; 334  : 
; 335  : 	default:
; 336  : 		break;
; 337  : 
; 338  : 	}
; 339  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitCamPos@@YAXPAUCameraStruct@@@Z ENDP		; InitCamPos
_TEXT	ENDS
PUBLIC	?SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ; SetCameraNewFollow
PUBLIC	?CameraNewFollowPos@@YAXPAUCameraStruct@@@Z	; CameraNewFollowPos
PUBLIC	?__LINE__Var@?1??SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA ; `SetCameraNewFollow'::`2'::__LINE__Var
PUBLIC	??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@ ; `string'
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
;	COMDAT ??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\camer'
	DB	'a.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA DD 015dH ; `SetCameraNewFollow'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
_object$ = 12						; size = 4
_followType$ = 16					; size = 4
?SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z PROC NEAR ; SetCameraNewFollow, COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 350  : 	Assert(followType < CAM_FOLLOW_NTYPES);

	push	OFFSET FLAT:??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
	add	eax, 1
	push	eax
	cmp	DWORD PTR _followType$[ebp], 6
	setl	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 351  : 
; 352  : 	camera->Type = CAM_NEWFOLLOW;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax], 4

; 353  : 	camera->SubType = followType;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _followType$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 354  : 	camera->CalcCamPos = CameraNewFollowPos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraNewFollowPos@@YAXPAUCameraStruct@@@Z ; CameraNewFollowPos

; 355  : 	camera->CalcCamLook = CameraAwayLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraAwayLook@@YAXPAUCameraStruct@@@Z ; CameraAwayLook

; 356  : 	camera->Object = object;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+164], ecx

; 357  : 	camera->Collide = CamFollowData[followType].Collide;

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	dl, BYTE PTR _CamFollowData[eax]
	mov	BYTE PTR [ecx+180], dl

; 358  : 	camera->Zoom = FALSE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+181], 0

; 359  : 	camera->ZoomMod = LENS_DIST_MOD;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+176], 1048576000		; 3e800000H

; 360  : 	camera->Lens = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+168], 0

; 361  : 	camera->Timer = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+184], 0

; 362  : 
; 363  : 	CopyVec(&CamFollowData[followType].PosOffset, &camera->DestOffset);

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+4]
	mov	DWORD PTR [ecx+104], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+8]
	mov	DWORD PTR [ecx+108], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+12]
	mov	DWORD PTR [ecx+112], edx

; 364  : 	CopyVec(&CamFollowData[followType].LookOffset, &camera->LookOffset);

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+16]
	mov	DWORD PTR [ecx+140], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+20]
	mov	DWORD PTR [ecx+144], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+24]
	mov	DWORD PTR [ecx+148], edx

; 365  : 	CopyVec(&CamFollowData[followType].LookOffset, &camera->OldLookOffset);

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+16]
	mov	DWORD PTR [ecx+152], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+20]
	mov	DWORD PTR [ecx+156], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+24]
	mov	DWORD PTR [ecx+160], edx

; 366  : 	InitCamPos(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?InitCamPos@@YAXPAUCameraStruct@@@Z	; InitCamPos
	add	esp, 4

; 367  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCameraNewFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ENDP ; SetCameraNewFollow
_TEXT	ENDS
PUBLIC	?SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ; SetCameraFollow
PUBLIC	?CameraFollowPos@@YAXPAUCameraStruct@@@Z	; CameraFollowPos
PUBLIC	?CameraRotatePos@@YAXPAUCameraStruct@@@Z	; CameraRotatePos
PUBLIC	?__LINE__Var@?1??SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA ; `SetCameraFollow'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA DD 0172H ; `SetCameraFollow'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
_object$ = 12						; size = 4
_followType$ = 16					; size = 4
?SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z PROC NEAR ; SetCameraFollow, COMDAT

; 370  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 371  : 	Assert(followType < CAM_FOLLOW_NTYPES);

	push	OFFSET FLAT:??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
	add	eax, 1
	push	eax
	cmp	DWORD PTR _followType$[ebp], 6
	setl	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 372  : 
; 373  : 	camera->Type = CAM_FOLLOW;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax], 0

; 374  : 	camera->SubType = followType;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _followType$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 375  : 	if (followType != CAM_FOLLOW_ROTATE) {

	cmp	DWORD PTR _followType$[ebp], 5
	je	SHORT $L81660

; 376  : 		camera->CalcCamPos = CameraFollowPos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraFollowPos@@YAXPAUCameraStruct@@@Z ; CameraFollowPos

; 377  : 	} else {

	jmp	SHORT $L81661
$L81660:

; 378  : 		camera->CalcCamPos = CameraRotatePos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraRotatePos@@YAXPAUCameraStruct@@@Z ; CameraRotatePos
$L81661:

; 379  : 	}
; 380  : 	camera->CalcCamLook = CameraAwayLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraAwayLook@@YAXPAUCameraStruct@@@Z ; CameraAwayLook

; 381  : 	camera->Object = object;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+164], ecx

; 382  : 	camera->Collide = CamFollowData[followType].Collide;

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	dl, BYTE PTR _CamFollowData[eax]
	mov	BYTE PTR [ecx+180], dl

; 383  : 	camera->Zoom = FALSE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+181], 0

; 384  : 	camera->ZoomMod = LENS_DIST_MOD;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+176], 1048576000		; 3e800000H

; 385  : 	camera->Lens = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+168], 0

; 386  : 	camera->Timer = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+184], 0

; 387  : 
; 388  : 	CopyVec(&CamFollowData[followType].PosOffset, &camera->DestOffset);

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+4]
	mov	DWORD PTR [ecx+104], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+8]
	mov	DWORD PTR [ecx+108], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+12]
	mov	DWORD PTR [ecx+112], edx

; 389  : 	CopyVec(&CamFollowData[followType].LookOffset, &camera->LookOffset);

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+16]
	mov	DWORD PTR [ecx+140], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+20]
	mov	DWORD PTR [ecx+144], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+24]
	mov	DWORD PTR [ecx+148], edx

; 390  : 	CopyVec(&CamFollowData[followType].LookOffset, &camera->OldLookOffset);

	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+16]
	mov	DWORD PTR [ecx+152], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+20]
	mov	DWORD PTR [ecx+156], edx
	mov	eax, DWORD PTR _followType$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamFollowData[eax+24]
	mov	DWORD PTR [ecx+160], edx

; 391  : 	InitCamPos(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?InitCamPos@@YAXPAUCameraStruct@@@Z	; InitCamPos
	add	esp, 4

; 392  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCameraFollow@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ENDP ; SetCameraFollow
_TEXT	ENDS
PUBLIC	?SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ; SetCameraAttached
PUBLIC	?CameraForwardLook@@YAXPAUCameraStruct@@@Z	; CameraForwardLook
PUBLIC	?CameraRearLook@@YAXPAUCameraStruct@@@Z		; CameraRearLook
PUBLIC	?CameraRelativePos@@YAXPAUCameraStruct@@@Z	; CameraRelativePos
PUBLIC	?__LINE__Var@?1??SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA ; `SetCameraAttached'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA DD 018bH ; `SetCameraAttached'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
_object$ = 12						; size = 4
_attachedType$ = 16					; size = 4
?SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z PROC NEAR ; SetCameraAttached, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 396  : 	Assert(attachedType < CAM_ATTACHED_NTYPES);

	push	OFFSET FLAT:??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
	add	eax, 1
	push	eax
	cmp	DWORD PTR _attachedType$[ebp], 4
	setl	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 397  : 
; 398  : 	camera->Type = CAM_ATTACHED;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax], 1

; 399  : 	camera->SubType = attachedType;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _attachedType$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 400  : 	camera->CalcCamPos = CameraRelativePos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraRelativePos@@YAXPAUCameraStruct@@@Z ; CameraRelativePos

; 401  : 	if (CamAttachedData[attachedType].Forward) {

	mov	eax, DWORD PTR _attachedType$[ebp]
	shl	eax, 4
	movzx	ecx, BYTE PTR _CamAttachedData[eax+12]
	test	ecx, ecx
	je	SHORT $L81668

; 402  : 		camera->CalcCamLook = CameraForwardLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraForwardLook@@YAXPAUCameraStruct@@@Z ; CameraForwardLook

; 403  : 	} else {

	jmp	SHORT $L81669
$L81668:

; 404  : 		camera->CalcCamLook = CameraRearLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraRearLook@@YAXPAUCameraStruct@@@Z ; CameraRearLook
$L81669:

; 405  : 	}
; 406  : 	camera->Object = object;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+164], ecx

; 407  : 	camera->Collide = FALSE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+180], 0

; 408  : 	camera->Zoom = FALSE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+181], 0

; 409  : 	camera->ZoomMod = LENS_DIST_MOD;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+176], 1048576000		; 3e800000H

; 410  : 	camera->Lens = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+168], 0

; 411  : 	camera->Timer = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+184], 0

; 412  : 
; 413  : 	CopyVec(&CamAttachedData[attachedType].PosOffset, &camera->DestOffset);

	mov	eax, DWORD PTR _attachedType$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamAttachedData[eax]
	mov	DWORD PTR [ecx+104], edx
	mov	eax, DWORD PTR _attachedType$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamAttachedData[eax+4]
	mov	DWORD PTR [ecx+108], edx
	mov	eax, DWORD PTR _attachedType$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamAttachedData[eax+8]
	mov	DWORD PTR [ecx+112], edx

; 414  : 	CopyVec(&CamAttachedData[attachedType].PosOffset, &camera->WorldPosOffset);

	mov	eax, DWORD PTR _attachedType$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamAttachedData[eax]
	mov	DWORD PTR [ecx+128], edx
	mov	eax, DWORD PTR _attachedType$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamAttachedData[eax+4]
	mov	DWORD PTR [ecx+132], edx
	mov	eax, DWORD PTR _attachedType$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _CamAttachedData[eax+8]
	mov	DWORD PTR [ecx+136], edx

; 415  : 	InitCamPos(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?InitCamPos@@YAXPAUCameraStruct@@@Z	; InitCamPos
	add	esp, 4

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCameraAttached@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ENDP ; SetCameraAttached
_TEXT	ENDS
PUBLIC	?SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ; SetCameraRail
PUBLIC	?CameraNearestNodePos@@YAXPAUCameraStruct@@@Z	; CameraNearestNodePos
PUBLIC	?CameraDynamicNodePos@@YAXPAUCameraStruct@@@Z	; CameraDynamicNodePos
PUBLIC	?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z ; NearestNode
PUBLIC	?__LINE__Var@?1??SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA ; `SetCameraRail'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA DD 01a3H ; `SetCameraRail'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT
tv80 = -72						; size = 4
_node$ = -4						; size = 4
_camera$ = 8						; size = 4
_object$ = 12						; size = 4
_type$ = 16						; size = 4
?SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z PROC NEAR ; SetCameraRail, COMDAT

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 420  : 	CAMNODE *node;
; 421  : 
; 422  : 	Assert(type < CAM_RAIL_NTYPES);

	push	OFFSET FLAT:??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z@4JA
	add	eax, 3
	push	eax
	cmp	DWORD PTR _type$[ebp], 2
	setl	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 423  : 
; 424  : 	camera->Type = CAM_RAIL;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax], 2

; 425  : 	camera->SubType = type;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 426  : 	camera->CalcCamLook = CameraAwayLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraAwayLook@@YAXPAUCameraStruct@@@Z ; CameraAwayLook

; 427  : 	camera->Object = object;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+164], ecx

; 428  : 	camera->Collide = TRUE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+180], 1

; 429  : 	camera->Timer = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+184], 0

; 430  : 
; 431  : 	// Find the nearest camera node and set sub-type according to the node type
; 432  : 	node = NearestNode(-1, &object->body.Centre.Pos);

	mov	eax, DWORD PTR _object$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	-1
	call	?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z ; NearestNode
	add	esp, 8
	mov	DWORD PTR _node$[ebp], eax

; 433  : 	if (node == NULL) return;

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $L81677
	jmp	SHORT $L81674
$L81677:

; 434  : 
; 435  : 	// Set sub-type specific stuff
; 436  : 	switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv80[ebp], eax
	cmp	DWORD PTR tv80[ebp], 0
	je	SHORT $L81682
	cmp	DWORD PTR tv80[ebp], 1
	je	SHORT $L81683
	jmp	SHORT $L81674
$L81682:

; 437  : 	case CAM_RAIL_DYNAMIC_MONO:
; 438  : 		camera->Zoom = TRUE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+181], 1

; 439  : 		camera->ZoomMod = LENS_DIST_MOD;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+176], 1048576000		; 3e800000H

; 440  : 		camera->CalcCamPos = CameraDynamicNodePos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraDynamicNodePos@@YAXPAUCameraStruct@@@Z ; CameraDynamicNodePos

; 441  : 		break;

	jmp	SHORT $L81674
$L81683:

; 442  : 	case CAM_RAIL_STATIC_NEAREST:
; 443  : 		camera->CalcCamPos = CameraNearestNodePos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraNearestNodePos@@YAXPAUCameraStruct@@@Z ; CameraNearestNodePos

; 444  : 		camera->Zoom = TRUE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+181], 1

; 445  : 		camera->ZoomMod = LENS_DIST_MOD;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+176], 1048576000		; 3e800000H
$L81674:

; 446  : 		break;
; 447  : 	default:
; 448  : 		break;
; 449  : 	}
; 450  : 
; 451  : 	//InitCamPos(camera);
; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCameraRail@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ENDP ; SetCameraRail
_TEXT	ENDS
PUBLIC	?SetCameraFreedom@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ; SetCameraFreedom
PUBLIC	?CameraMouseLook@@YAXPAUCameraStruct@@@Z	; CameraMouseLook
PUBLIC	?CameraFreedomPos@@YAXPAUCameraStruct@@@Z	; CameraFreedomPos
; Function compile flags: /Odt /ZI
;	COMDAT ?SetCameraFreedom@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
_object$ = 12						; size = 4
_unUsed$ = 16						; size = 4
?SetCameraFreedom@@YAXPAUCameraStruct@@PAUobject_def@@J@Z PROC NEAR ; SetCameraFreedom, COMDAT

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 456  : 	camera->Type = CAM_FREEDOM;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax], 3

; 457  : 	camera->SubType = 0;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+4], 0

; 458  : 	camera->CalcCamPos = CameraFreedomPos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraFreedomPos@@YAXPAUCameraStruct@@@Z ; CameraFreedomPos

; 459  : 	if (object == NULL) {

	cmp	DWORD PTR _object$[ebp], 0
	jne	SHORT $L81690

; 460  : 		camera->CalcCamLook = CameraMouseLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraMouseLook@@YAXPAUCameraStruct@@@Z ; CameraMouseLook

; 461  : 		camera->Object = NULL;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+164], 0

; 462  : 	} else {

	jmp	SHORT $L81691
$L81690:

; 463  : 		camera->CalcCamLook = CameraAwayLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraAwayLook@@YAXPAUCameraStruct@@@Z ; CameraAwayLook

; 464  : 		camera->Object = object;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _object$[ebp]
	mov	DWORD PTR [eax+164], ecx

; 465  : 		SetVecZero(&camera->LookOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+140], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+144], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+148], 0

; 466  : 		SetVecZero(&camera->OldLookOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+152], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+156], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+160], 0
$L81691:

; 467  : 	}
; 468  : 	camera->Collide = FALSE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+180], 0

; 469  : 	camera->Zoom = TRUE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	BYTE PTR [eax+181], 1

; 470  : 	camera->Timer = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+184], 0

; 471  : 
; 472  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCameraFreedom@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ENDP ; SetCameraFreedom
_TEXT	ENDS
PUBLIC	?SetCameraEdit@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ; SetCameraEdit
PUBLIC	?CameraNullLook@@YAXPAUCameraStruct@@@Z		; CameraNullLook
PUBLIC	?CameraEditPos@@YAXPAUCameraStruct@@@Z		; CameraEditPos
; Function compile flags: /Odt /ZI
;	COMDAT ?SetCameraEdit@@YAXPAUCameraStruct@@PAUobject_def@@J@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
_object$ = 12						; size = 4
_unUsed$ = 16						; size = 4
?SetCameraEdit@@YAXPAUCameraStruct@@PAUobject_def@@J@Z PROC NEAR ; SetCameraEdit, COMDAT

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 477  : 	camera->Type = CAM_EDIT;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax], 5

; 478  : 	camera->SubType = 0;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+4], 0

; 479  : 	camera->CalcCamPos = CameraEditPos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+8], OFFSET FLAT:?CameraEditPos@@YAXPAUCameraStruct@@@Z ; CameraEditPos

; 480  : 	camera->CalcCamLook = CameraNullLook;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+12], OFFSET FLAT:?CameraNullLook@@YAXPAUCameraStruct@@@Z ; CameraNullLook

; 481  : 	camera->Object = NULL;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+164], 0

; 482  : 	camera->Timer = ZERO;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+184], 0

; 483  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCameraEdit@@YAXPAUCameraStruct@@PAUobject_def@@J@Z ENDP ; SetCameraEdit
_TEXT	ENDS
PUBLIC	__real@41200000
PUBLIC	__real@3727c5ac
EXTRN	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z:NEAR ; QuatToMat
EXTRN	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z:NEAR	; SLerpQuat
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraForwardLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_qLen$81701 = -20					; size = 4
_quat$ = -16						; size = 16
_camera$ = 8						; size = 4
?CameraForwardLook@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraForwardLook, COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 494  : 	QUATERNION quat;
; 495  : 
; 496  : 	SLerpQuat(&camera->Quat, &camera->Object->body.Centre.Quat, TimeStep * 10, &quat);

	lea	eax, DWORD PTR _quat$[ebp]
	push	eax
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@41200000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	call	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ; SLerpQuat
	add	esp, 16					; 00000010H

; 497  : 	NormalizeQuat(&quat);

	fld	DWORD PTR _quat$[ebp]
	fmul	DWORD PTR _quat$[ebp]
	fld	DWORD PTR _quat$[ebp+4]
	fmul	DWORD PTR _quat$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _quat$[ebp+8]
	fmul	DWORD PTR _quat$[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _quat$[ebp+12]
	fmul	DWORD PTR _quat$[ebp+12]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$81701[ebp]
	fld	DWORD PTR _qLen$81701[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81703
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$81701[ebp]
	fstp	DWORD PTR _qLen$81701[ebp]
	fld	DWORD PTR _quat$[ebp]
	fmul	DWORD PTR _qLen$81701[ebp]
	fstp	DWORD PTR _quat$[ebp]
	fld	DWORD PTR _quat$[ebp+4]
	fmul	DWORD PTR _qLen$81701[ebp]
	fstp	DWORD PTR _quat$[ebp+4]
	fld	DWORD PTR _quat$[ebp+8]
	fmul	DWORD PTR _qLen$81701[ebp]
	fstp	DWORD PTR _quat$[ebp+8]
	fld	DWORD PTR _quat$[ebp+12]
	fmul	DWORD PTR _qLen$81701[ebp]
	fstp	DWORD PTR _quat$[ebp+12]
$L81703:

; 498  : 
; 499  : 	CopyQuat(&quat, &camera->Quat);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp+4]
	mov	DWORD PTR [eax+56], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp+8]
	mov	DWORD PTR [eax+60], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp+12]
	mov	DWORD PTR [eax+64], ecx

; 500  : 	QuatToMat(&quat, &camera->WMatrix);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _quat$[ebp]
	push	ecx
	call	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z ; QuatToMat
	add	esp, 8

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraForwardLook@@YAXPAUCameraStruct@@@Z ENDP		; CameraForwardLook
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?CameraRearLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_qLen$81708 = -20					; size = 4
_quat$ = -16						; size = 16
_camera$ = 8						; size = 4
?CameraRearLook@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraRearLook, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 505  : 	QUATERNION quat;
; 506  : 
; 507  : 	SLerpQuat(&camera->Quat, &camera->Object->body.Centre.Quat, TimeStep * 10, &quat);

	lea	eax, DWORD PTR _quat$[ebp]
	push	eax
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@41200000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	call	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ; SLerpQuat
	add	esp, 16					; 00000010H

; 508  : 	NormalizeQuat(&quat);

	fld	DWORD PTR _quat$[ebp]
	fmul	DWORD PTR _quat$[ebp]
	fld	DWORD PTR _quat$[ebp+4]
	fmul	DWORD PTR _quat$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _quat$[ebp+8]
	fmul	DWORD PTR _quat$[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _quat$[ebp+12]
	fmul	DWORD PTR _quat$[ebp+12]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _qLen$81708[ebp]
	fld	DWORD PTR _qLen$81708[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81710
	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _qLen$81708[ebp]
	fstp	DWORD PTR _qLen$81708[ebp]
	fld	DWORD PTR _quat$[ebp]
	fmul	DWORD PTR _qLen$81708[ebp]
	fstp	DWORD PTR _quat$[ebp]
	fld	DWORD PTR _quat$[ebp+4]
	fmul	DWORD PTR _qLen$81708[ebp]
	fstp	DWORD PTR _quat$[ebp+4]
	fld	DWORD PTR _quat$[ebp+8]
	fmul	DWORD PTR _qLen$81708[ebp]
	fstp	DWORD PTR _quat$[ebp+8]
	fld	DWORD PTR _quat$[ebp+12]
	fmul	DWORD PTR _qLen$81708[ebp]
	fstp	DWORD PTR _quat$[ebp+12]
$L81710:

; 509  : 
; 510  : 	CopyQuat(&quat, &camera->Quat);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp+4]
	mov	DWORD PTR [eax+56], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp+8]
	mov	DWORD PTR [eax+60], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp+12]
	mov	DWORD PTR [eax+64], ecx

; 511  : 	QuatToMat(&quat, &camera->WMatrix);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _quat$[ebp]
	push	ecx
	call	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z ; QuatToMat
	add	esp, 8

; 512  : 	NegateVec(&camera->WMatrix.mv[L]);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+40]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+44]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+48]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+48]

; 513  : 	NegateVec(&camera->WMatrix.mv[R]);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+16]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+20]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+24]

; 514  : 
; 515  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraRearLook@@YAXPAUCameraStruct@@@Z ENDP		; CameraRearLook
_TEXT	ENDS
PUBLIC	__real@3e000000
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraRelativePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_xyWorld$ = -36						; size = 12
_xyOff$ = -24						; size = 12
_dR$ = -12						; size = 12
_camera$ = 8						; size = 4
?CameraRelativePos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraRelativePos, COMDAT

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 527  : 	VEC dR;
; 528  : 	VEC xyOff;
; 529  : 	VEC xyWorld;
; 530  : 
; 531  : 	CopyVec(&camera->WPos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+88], edx

; 532  : 
; 533  : 	VecMinusVec(&camera->DestOffset, &camera->PosOffset, &dR);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+104]
	fsub	DWORD PTR [ecx+116]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+108]
	fsub	DWORD PTR [ecx+120]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+112]
	fsub	DWORD PTR [ecx+124]
	fstp	DWORD PTR _dR$[ebp+8]

; 534  : 	VecPlusEqScalarVec(&camera->PosOffset, ONE / 8, &dR);

	fld	DWORD PTR __real@3e000000
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+116]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+116]
	fld	DWORD PTR __real@3e000000
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+120]
	fld	DWORD PTR __real@3e000000
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+124]

; 535  : 
; 536  : 	SetVec(&xyOff, camera->PosOffset.v[X], ZERO, camera->PosOffset.v[Z]);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR _xyOff$[ebp], ecx
	mov	DWORD PTR _xyOff$[ebp+4], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _xyOff$[ebp+8], ecx

; 537  : 	VecMulMat(&xyOff, &camera->Object->body.Centre.WMatrix, &xyWorld);

	lea	eax, DWORD PTR _xyWorld$[ebp]
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	add	edx, 100				; 00000064H
	push	edx
	lea	eax, DWORD PTR _xyOff$[ebp]
	push	eax
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 538  : 	xyWorld.v[Y] = camera->PosOffset.v[Y];

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _xyWorld$[ebp+4], ecx

; 539  : 	VecPlusVec(&xyWorld, &camera->Object->body.Centre.Pos, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _xyWorld$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+68]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _xyWorld$[ebp+4]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+72]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _xyWorld$[ebp+8]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+76]

; 540  : 
; 541  : 	if (TimeStep > SMALL_REAL) {

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81717

; 542  : 		VecMinusVec(&camera->WPos, &camera->OldWPos, &camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+100]

; 543  : 		VecDivScalar(&camera->Vel, TimeStep);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+92]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+96]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+100]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+100]

; 544  : 	} else {

	jmp	SHORT $L81713
$L81717:

; 545  : 		SetVecZero(&camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+96], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+100], 0
$L81713:

; 546  : 	}
; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraRelativePos@@YAXPAUCameraStruct@@@Z ENDP		; CameraRelativePos
_TEXT	ENDS
PUBLIC	__real@42480000
PUBLIC	__real@447a0000
EXTRN	?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z:NEAR ; BuildLookMatrixForward
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraAwayLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_dR$ = -40						; size = 12
_lookOff$ = -28						; size = 12
_lookPos$ = -16						; size = 12
_dRLen$ = -4						; size = 4
_camera$ = 8						; size = 4
?CameraAwayLook@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraAwayLook, COMDAT

; 557  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 558  : 	REAL dRLen;
; 559  : 	VEC lookPos, lookOff, dR;
; 560  : 
; 561  : 	VecMinusVec(&camera->Object->body.Centre.Pos, &camera->WPos, &dR);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR [edx+68]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR [edx+72]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR [edx+76]
	fstp	DWORD PTR _dR$[ebp+8]

; 562  : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 563  : 
; 564  : 	if (dRLen < 50) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@42480000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81727

; 565  : 		CopyMat(&camera->Object->body.Centre.WMatrix, &camera->WMatrix);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	add	edx, 100				; 00000064H
	push	edx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 566  : 		return;

	jmp	$L81721
$L81727:

; 567  : 	}
; 568  : 
; 569  : 	if (dRLen < 1000) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@447a0000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81728

; 570  : 		VecEqScalarVec(&lookOff, dRLen / 1000, &camera->LookOffset);

	fld	DWORD PTR _dRLen$[ebp]
	fdiv	DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _camera$[ebp]
	fmul	DWORD PTR [eax+140]
	fstp	DWORD PTR _lookOff$[ebp]
	fld	DWORD PTR _dRLen$[ebp]
	fdiv	DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _camera$[ebp]
	fmul	DWORD PTR [eax+144]
	fstp	DWORD PTR _lookOff$[ebp+4]
	fld	DWORD PTR _dRLen$[ebp]
	fdiv	DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _camera$[ebp]
	fmul	DWORD PTR [eax+148]
	fstp	DWORD PTR _lookOff$[ebp+8]

; 571  : 	} else {

	jmp	SHORT $L81729
$L81728:

; 572  : 		CopyVec(&camera->LookOffset, &lookOff);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _lookOff$[ebp], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _lookOff$[ebp+4], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR _lookOff$[ebp+8], ecx
$L81729:

; 573  : 	}
; 574  : 
; 575  : 
; 576  : 	// Make camera look at car
; 577  : 	VecPlusVec(&camera->Object->body.Centre.Pos, &lookOff, &lookPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _lookOff$[ebp]
	fadd	DWORD PTR [ecx+20]
	fstp	DWORD PTR _lookPos$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _lookOff$[ebp+4]
	fadd	DWORD PTR [ecx+24]
	fstp	DWORD PTR _lookPos$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _lookOff$[ebp+8]
	fadd	DWORD PTR [ecx+28]
	fstp	DWORD PTR _lookPos$[ebp+8]

; 578  : 	BuildLookMatrixForward(&camera->WPos, &lookPos, &camera->WMatrix);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _lookPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	call	?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ; BuildLookMatrixForward
	add	esp, 12					; 0000000cH
$L81721:

; 579  : 
; 580  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraAwayLook@@YAXPAUCameraStruct@@@Z ENDP		; CameraAwayLook
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	__real@40400000
PUBLIC	?CameraWorldColls@@YAXPAUCameraStruct@@@Z	; CameraWorldColls
EXTRN	?QuatRotVec@@YAXPAUQuaternionStruct@@PAUVectorStruct@@1@Z:NEAR ; QuatRotVec
;	COMDAT __real@40400000
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\camera.cpp
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraNewFollowPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_objQuat$ = -28						; size = 4
_objMat$ = -24						; size = 4
_objPos$ = -20						; size = 4
_q$ = -16						; size = 16
_camera$ = 8						; size = 4
?CameraNewFollowPos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraNewFollowPos, COMDAT

; 590  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 591  : 	QUATERNION q;
; 592  : 	VEC		*objPos;
; 593  : 	MAT		*objMat;
; 594  : 	QUATERNION *objQuat;
; 595  : 
; 596  : 	objQuat = &camera->Object->body.Centre.Quat;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 68					; 00000044H
	mov	DWORD PTR _objQuat$[ebp], ecx

; 597  : 	objMat = &camera->Object->body.Centre.WMatrix;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _objMat$[ebp], ecx

; 598  : 	objPos = &camera->Object->body.Centre.Pos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _objPos$[ebp], ecx

; 599  : 
; 600  : 	CopyVec(&camera->WPos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+88], edx

; 601  : 
; 602  : 	// Calculate position of camera mount point
; 603  : 	SLerpQuat(&camera->Quat, objQuat, TimeStep * 3, &q);

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR __real@40400000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _objQuat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	call	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ; SLerpQuat
	add	esp, 16					; 00000010H

; 604  : 	CopyQuat(&q, &camera->Quat);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _q$[ebp+4]
	mov	DWORD PTR [eax+56], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _q$[ebp+8]
	mov	DWORD PTR [eax+60], ecx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _q$[ebp+12]
	mov	DWORD PTR [eax+64], ecx

; 605  : 	QuatRotVec(&camera->Quat, &camera->PosOffset, &camera->WorldPosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	call	?QuatRotVec@@YAXPAUQuaternionStruct@@PAUVectorStruct@@1@Z ; QuatRotVec
	add	esp, 12					; 0000000cH

; 606  : 
; 607  : 	VecPlusVec(&camera->WorldPosOffset, objPos, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+128]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+68]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+132]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+72]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+136]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+76]

; 608  : 
; 609  : 	CameraWorldColls(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?CameraWorldColls@@YAXPAUCameraStruct@@@Z ; CameraWorldColls
	add	esp, 4

; 610  : 
; 611  : 	VecMinusVec(&camera->WPos, objPos, &camera->WorldPosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+128]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+132]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+136]

; 612  : 	CopyVec(&camera->CollPos, &camera->OldCollPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR [eax+316], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	mov	DWORD PTR [eax+320], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	mov	DWORD PTR [eax+324], edx

; 613  : 
; 614  : 	if (TimeStep > SMALL_REAL) {

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81737

; 615  : 		VecMinusVec(&camera->WPos, &camera->OldWPos, &camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+100]

; 616  : 		VecDivScalar(&camera->Vel, TimeStep);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+92]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+96]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+100]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+100]

; 617  : 	} else {

	jmp	SHORT $L81732
$L81737:

; 618  : 		SetVecZero(&camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+96], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+100], 0
$L81732:

; 619  : 	}
; 620  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraNewFollowPos@@YAXPAUCameraStruct@@@Z ENDP	; CameraNewFollowPos
_TEXT	ENDS
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraFollowPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
tv374 = -152						; size = 4
tv367 = -152						; size = 4
tv360 = -152						; size = 4
__mul$81758 = -84					; size = 4
__mul$81750 = -80					; size = 4
_homeLen$ = -76						; size = 4
_poleLen$ = -72						; size = 4
_objMat$ = -68						; size = 4
_mat$ = -64						; size = 36
_objPos$ = -28						; size = 4
_delta$ = -24						; size = 12
_newPole$ = -12						; size = 12
_camera$ = 8						; size = 4
?CameraFollowPos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraFollowPos, COMDAT

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi

; 624  : 	VEC		newPole, delta, *objPos;
; 625  : 	MAT		mat, *objMat;
; 626  : 	REAL	poleLen, homeLen;
; 627  : 
; 628  : 	objMat = &camera->Object->body.Centre.WMatrix;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _objMat$[ebp], ecx

; 629  : 	objPos = &camera->Object->body.Centre.Pos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _objPos$[ebp], ecx

; 630  : 
; 631  : 	CopyVec(&camera->WPos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+88], edx

; 632  : 
; 633  : 	// get desired camera world matrix
; 634  : 	mat.m[RX] = objMat->m[LZ];

	mov	eax, DWORD PTR _objMat$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _mat$[ebp], ecx

; 635  : 	mat.m[RY] = ZERO;

	mov	DWORD PTR _mat$[ebp+4], 0

; 636  : 	mat.m[RZ] = -objMat->m[LX];

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	fstp	DWORD PTR _mat$[ebp+8]

; 637  : 
; 638  : 	if (!mat.m[RX] && !mat.m[RZ])

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _mat$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81749
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _mat$[ebp+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81749

; 639  : 		mat.m[RX] = ONE;

	mov	DWORD PTR _mat$[ebp], 1065353216	; 3f800000H
$L81749:

; 640  : 
; 641  : 	NormalizeVector(&mat.mv[R]);

	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81750[ebp]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR __mul$81750[ebp]
	fstp	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR __mul$81750[ebp]
	fstp	DWORD PTR _mat$[ebp+4]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR __mul$81750[ebp]
	fstp	DWORD PTR _mat$[ebp+8]

; 642  : 
; 643  : 	mat.m[UX] = ZERO;

	mov	DWORD PTR _mat$[ebp+12], 0

; 644  : 	mat.m[UY] = ONE;

	mov	DWORD PTR _mat$[ebp+16], 1065353216	; 3f800000H

; 645  : 	mat.m[UZ] = ZERO;

	mov	DWORD PTR _mat$[ebp+20], 0

; 646  : 
; 647  : 	CrossProduct(&mat.mv[R], &mat.mv[U], &mat.mv[L]);

	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+20]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+12]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+20]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+28]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+16]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+32]

; 648  : 
; 649  : 	// get desired offset vector
; 650  : 	VecMinusVec(&camera->DestOffset, &camera->PosOffset, &newPole);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+104]
	fsub	DWORD PTR [ecx+116]
	fstp	DWORD PTR _newPole$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+108]
	fsub	DWORD PTR [ecx+120]
	fstp	DWORD PTR _newPole$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+112]
	fsub	DWORD PTR [ecx+124]
	fstp	DWORD PTR _newPole$[ebp+8]

; 651  : 	VecPlusEqScalarVec(&camera->PosOffset, ONE / 8, &newPole);

	fld	DWORD PTR __real@3e000000
	fmul	DWORD PTR _newPole$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+116]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+116]
	fld	DWORD PTR __real@3e000000
	fmul	DWORD PTR _newPole$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+120]
	fld	DWORD PTR __real@3e000000
	fmul	DWORD PTR _newPole$[ebp+8]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+124]

; 652  : 
; 653  : 	RotVector(&mat, &camera->PosOffset, &newPole);

	lea	eax, DWORD PTR _newPole$[ebp]
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 654  : 	homeLen = Length(&camera->PosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+116]
	fmul	DWORD PTR [ecx+116]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+120]
	fmul	DWORD PTR [eax+120]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+124]
	fmul	DWORD PTR [edx+124]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _homeLen$[ebp]

; 655  : 	if (homeLen > SMALL_REAL) {

	fld	DWORD PTR _homeLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81753

; 656  : 		VecDivScalar(&newPole, homeLen);

	fld	DWORD PTR _newPole$[ebp]
	fdiv	DWORD PTR _homeLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fdiv	DWORD PTR _homeLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR _newPole$[ebp+8]
	fdiv	DWORD PTR _homeLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+8]
$L81753:

; 657  : 	}
; 658  : 
; 659  : 	// Get length and direction of last offset
; 660  : 	poleLen = VecLen(&camera->WorldPosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+128]
	fmul	DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+132]
	fmul	DWORD PTR [eax+132]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+136]
	fmul	DWORD PTR [edx+136]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _poleLen$[ebp]

; 661  : 	if (poleLen > SMALL_REAL) {

	fld	DWORD PTR _poleLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81755

; 662  : 		VecDivScalar(&camera->WorldPosOffset, poleLen);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+128]
	fdiv	DWORD PTR _poleLen$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+128]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+132]
	fdiv	DWORD PTR _poleLen$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+132]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+136]
	fdiv	DWORD PTR _poleLen$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+136]
$L81755:

; 663  : 	}
; 664  :  
; 665  : 	// rotate offset towards desired offset
; 666  : 	SubVector(&newPole, &camera->WorldPosOffset, &delta);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _newPole$[ebp]
	fsub	DWORD PTR [eax+128]
	fstp	DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fsub	DWORD PTR [eax+132]
	fstp	DWORD PTR _delta$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _newPole$[ebp+8]
	fsub	DWORD PTR [eax+136]
	fstp	DWORD PTR _delta$[ebp+8]

; 667  : 	VecPlusScalarVec(&camera->WorldPosOffset, TimeStep / 0.25f, &delta, &newPole);

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e800000
	fmul	DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+128]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e800000
	fmul	DWORD PTR _delta$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+132]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e800000
	fmul	DWORD PTR _delta$[ebp+8]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+136]
	fstp	DWORD PTR _newPole$[ebp+8]

; 668  : 	if ((abs(newPole.v[X]) > SMALL_REAL) || (abs(newPole.v[Y]) > SMALL_REAL) || (abs(newPole.v[Z]) > SMALL_REAL)) {

	fld	DWORD PTR _newPole$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82255
	mov	eax, DWORD PTR _newPole$[ebp]
	mov	DWORD PTR tv360[ebp], eax
	jmp	SHORT $L82256
$L82255:
	fld	DWORD PTR _newPole$[ebp]
	fchs
	fstp	DWORD PTR tv360[ebp]
$L82256:
	fld	DWORD PTR tv360[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81757
	fld	DWORD PTR _newPole$[ebp+4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82257
	mov	eax, DWORD PTR _newPole$[ebp+4]
	mov	DWORD PTR tv367[ebp], eax
	jmp	SHORT $L82258
$L82257:
	fld	DWORD PTR _newPole$[ebp+4]
	fchs
	fstp	DWORD PTR tv367[ebp]
$L82258:
	fld	DWORD PTR tv367[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81757
	fld	DWORD PTR _newPole$[ebp+8]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82259
	mov	eax, DWORD PTR _newPole$[ebp+8]
	mov	DWORD PTR tv374[ebp], eax
	jmp	SHORT $L82260
$L82259:
	fld	DWORD PTR _newPole$[ebp+8]
	fchs
	fstp	DWORD PTR tv374[ebp]
$L82260:
	fld	DWORD PTR tv374[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81756
$L81757:

; 669  : 		NormalizeVec(&newPole);

	fld	DWORD PTR _newPole$[ebp]
	fmul	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fmul	DWORD PTR _newPole$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _newPole$[ebp+8]
	fmul	DWORD PTR _newPole$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81758[ebp]
	fld	DWORD PTR _newPole$[ebp]
	fmul	DWORD PTR __mul$81758[ebp]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fmul	DWORD PTR __mul$81758[ebp]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR _newPole$[ebp+8]
	fmul	DWORD PTR __mul$81758[ebp]
	fstp	DWORD PTR _newPole$[ebp+8]
$L81756:

; 670  : 	}
; 671  : 
; 672  : 	// Calculate new offset length
; 673  : 	poleLen = poleLen + (homeLen - poleLen) * TimeStep / 0.30f;

	fld	DWORD PTR _homeLen$[ebp]
	fsub	DWORD PTR _poleLen$[ebp]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e99999a
	fadd	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _poleLen$[ebp]

; 674  : 
; 675  : 	// Set the new offset
; 676  : 	VecMulScalar(&newPole, poleLen);

	fld	DWORD PTR _newPole$[ebp]
	fmul	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fmul	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR _newPole$[ebp+8]
	fmul	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+8]

; 677  : 
; 678  : 	// Modify desired postion according to camera collision
; 679  : 	VecPlusVec(objPos, &newPole, &camera->WPos);

	mov	eax, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR _newPole$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR _newPole$[ebp+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+76]

; 680  : 	CameraWorldColls(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?CameraWorldColls@@YAXPAUCameraStruct@@@Z ; CameraWorldColls
	add	esp, 4

; 681  : 
; 682  : 
; 683  : 	// copy new to last
; 684  : 	VecMinusVec(&camera->WPos, objPos, &camera->WorldPosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+128]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+132]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+136]

; 685  : 	CopyVec(&camera->CollPos, &camera->OldCollPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR [eax+316], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	mov	DWORD PTR [eax+320], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	mov	DWORD PTR [eax+324], edx

; 686  : 
; 687  : 	if (TimeStep > SMALL_REAL) {

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81760

; 688  : 		VecMinusVec(&camera->WPos, &camera->OldWPos, &camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+100]

; 689  : 		VecDivScalar(&camera->Vel, TimeStep);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+92]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+96]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+100]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+100]

; 690  : 	} else {

	jmp	SHORT $L81741
$L81760:

; 691  : 		SetVecZero(&camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+96], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+100], 0
$L81741:

; 692  : 	}
; 693  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraFollowPos@@YAXPAUCameraStruct@@@Z ENDP		; CameraFollowPos
_TEXT	ENDS
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	__real@40490fdb
PUBLIC	__real@40a00000
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraRotatePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
__mul$81782 = -96					; size = 4
__mul$81778 = -92					; size = 4
_cosTheta$ = -88					; size = 4
_sinTheta$ = -84					; size = 4
_theta$ = -80						; size = 4
_homeLen$ = -76						; size = 4
_poleLen$ = -72						; size = 4
_objMat$ = -68						; size = 4
_mat$ = -64						; size = 36
_objPos$ = -28						; size = 4
_delta$ = -24						; size = 12
_newPole$ = -12						; size = 12
_camera$ = 8						; size = 4
?CameraRotatePos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraRotatePos, COMDAT

; 696  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi

; 697  : 	VEC		newPole, delta, *objPos;
; 698  : 	MAT		mat, *objMat;
; 699  : 	REAL	poleLen, homeLen, theta, sinTheta, cosTheta;
; 700  : 
; 701  : 	objMat = &camera->Object->body.Centre.WMatrix;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _objMat$[ebp], ecx

; 702  : 	objPos = &camera->Object->body.Centre.Pos;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _objPos$[ebp], ecx

; 703  : 
; 704  : 	CopyVec(&camera->WPos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+88], edx

; 705  : 
; 706  : 	// get rotation angle of camera for current frame
; 707  : 	theta = camera->Timer * 2 * PI / 5.0f;

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+184]
	fadd	ST(0), ST(0)
	fmul	DWORD PTR __real@40490fdb
	fdiv	DWORD PTR __real@40a00000
	fstp	DWORD PTR _theta$[ebp]

; 708  : 	sinTheta = (REAL)sin(theta);

	mov	eax, DWORD PTR _theta$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinTheta$[ebp]

; 709  : 	cosTheta = (REAL)cos(theta);

	mov	eax, DWORD PTR _theta$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosTheta$[ebp]

; 710  : 
; 711  : 	// get desired camera world matrix
; 712  : 	mat.m[RX] = objMat->m[LZ] * cosTheta + objMat->m[LX] * sinTheta;

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _cosTheta$[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _sinTheta$[ebp]
	fmul	DWORD PTR [ecx+24]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp]

; 713  : 	mat.m[RY] = ZERO;

	mov	DWORD PTR _mat$[ebp+4], 0

; 714  : 	mat.m[RZ] = -objMat->m[LX] * cosTheta + objMat->m[LZ] * sinTheta;

	mov	eax, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	fmul	DWORD PTR _cosTheta$[ebp]
	mov	ecx, DWORD PTR _objMat$[ebp]
	fld	DWORD PTR _sinTheta$[ebp]
	fmul	DWORD PTR [ecx+32]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+8]

; 715  : 
; 716  : 	if (!mat.m[RX] && !mat.m[RZ])

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _mat$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81777
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _mat$[ebp+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81777

; 717  : 		mat.m[RX] = ONE;

	mov	DWORD PTR _mat$[ebp], 1065353216	; 3f800000H
$L81777:

; 718  : 
; 719  : 	NormalizeVector(&mat.mv[R]);

	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81778[ebp]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR __mul$81778[ebp]
	fstp	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR __mul$81778[ebp]
	fstp	DWORD PTR _mat$[ebp+4]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR __mul$81778[ebp]
	fstp	DWORD PTR _mat$[ebp+8]

; 720  : 
; 721  : 	mat.m[UX] = ZERO;

	mov	DWORD PTR _mat$[ebp+12], 0

; 722  : 	mat.m[UY] = ONE;

	mov	DWORD PTR _mat$[ebp+16], 1065353216	; 3f800000H

; 723  : 	mat.m[UZ] = ZERO;

	mov	DWORD PTR _mat$[ebp+20], 0

; 724  : 
; 725  : 	CrossProduct(&mat.mv[R], &mat.mv[U], &mat.mv[L]);

	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+20]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+16]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+24]
	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR _mat$[ebp+12]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+20]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+28]
	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR _mat$[ebp+16]
	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR _mat$[ebp+12]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _mat$[ebp+32]

; 726  : 
; 727  : 	// get desired offset vector
; 728  : 	RotVector(&mat, &camera->PosOffset, &newPole);

	lea	eax, DWORD PTR _newPole$[ebp]
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 729  : 	homeLen = Length(&camera->PosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+116]
	fmul	DWORD PTR [ecx+116]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+120]
	fmul	DWORD PTR [eax+120]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+124]
	fmul	DWORD PTR [edx+124]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _homeLen$[ebp]

; 730  : 	VecDivScalar(&newPole, homeLen);

	fld	DWORD PTR _newPole$[ebp]
	fdiv	DWORD PTR _homeLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fdiv	DWORD PTR _homeLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR _newPole$[ebp+8]
	fdiv	DWORD PTR _homeLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+8]

; 731  : 
; 732  : 	// Get length and direction of last offset
; 733  : 	poleLen = VecLen(&camera->WorldPosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+128]
	fmul	DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+132]
	fmul	DWORD PTR [eax+132]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+136]
	fmul	DWORD PTR [edx+136]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _poleLen$[ebp]

; 734  : 	VecDivScalar(&camera->WorldPosOffset, poleLen);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+128]
	fdiv	DWORD PTR _poleLen$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+128]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+132]
	fdiv	DWORD PTR _poleLen$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+132]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+136]
	fdiv	DWORD PTR _poleLen$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+136]

; 735  : 
; 736  : 	// rotate offset towards desired offset
; 737  : 	SubVector(&newPole, &camera->WorldPosOffset, &delta);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _newPole$[ebp]
	fsub	DWORD PTR [eax+128]
	fstp	DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fsub	DWORD PTR [eax+132]
	fstp	DWORD PTR _delta$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _newPole$[ebp+8]
	fsub	DWORD PTR [eax+136]
	fstp	DWORD PTR _delta$[ebp+8]

; 738  : 	VecPlusScalarVec(&camera->WorldPosOffset, TimeStep / 0.25f, &delta, &newPole);

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e800000
	fmul	DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+128]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e800000
	fmul	DWORD PTR _delta$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+132]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e800000
	fmul	DWORD PTR _delta$[ebp+8]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+136]
	fstp	DWORD PTR _newPole$[ebp+8]

; 739  : 	NormalizeVec(&newPole);

	fld	DWORD PTR _newPole$[ebp]
	fmul	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fmul	DWORD PTR _newPole$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _newPole$[ebp+8]
	fmul	DWORD PTR _newPole$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81782[ebp]
	fld	DWORD PTR _newPole$[ebp]
	fmul	DWORD PTR __mul$81782[ebp]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fmul	DWORD PTR __mul$81782[ebp]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR _newPole$[ebp+8]
	fmul	DWORD PTR __mul$81782[ebp]
	fstp	DWORD PTR _newPole$[ebp+8]

; 740  : 
; 741  : 	// Calculate new offset length
; 742  : 	poleLen = poleLen + (homeLen - poleLen) * TimeStep / 0.30f;

	fld	DWORD PTR _homeLen$[ebp]
	fsub	DWORD PTR _poleLen$[ebp]
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fdiv	DWORD PTR __real@3e99999a
	fadd	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _poleLen$[ebp]

; 743  : 
; 744  : 	// Set the new offset
; 745  : 	VecMulScalar(&newPole, poleLen);

	fld	DWORD PTR _newPole$[ebp]
	fmul	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fmul	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+4]
	fld	DWORD PTR _newPole$[ebp+8]
	fmul	DWORD PTR _poleLen$[ebp]
	fstp	DWORD PTR _newPole$[ebp+8]

; 746  : 
; 747  : 	// Modify desired postion according to camera collision
; 748  : 	VecPlusVec(objPos, &newPole, &camera->WPos);

	mov	eax, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR _newPole$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR _newPole$[ebp+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR _newPole$[ebp+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+76]

; 749  : 	CameraWorldColls(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?CameraWorldColls@@YAXPAUCameraStruct@@@Z ; CameraWorldColls
	add	esp, 4

; 750  : 
; 751  : 	// copy new to last
; 752  : 	VecMinusVec(&camera->WPos, objPos, &camera->WorldPosOffset);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+128]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+132]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _objPos$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+136]

; 753  : 	CopyVec(&camera->CollPos, &camera->OldCollPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR [eax+316], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	mov	DWORD PTR [eax+320], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	mov	DWORD PTR [eax+324], edx

; 754  : 
; 755  : 	if (TimeStep > SMALL_REAL) {

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81784

; 756  : 		VecMinusVec(&camera->WPos, &camera->OldWPos, &camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+100]

; 757  : 		VecDivScalar(&camera->Vel, TimeStep);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+92]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+96]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+100]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+100]

; 758  : 	} else {

	jmp	SHORT $L81764
$L81784:

; 759  : 		SetVecZero(&camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+96], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+100], 0
$L81764:

; 760  : 	}
; 761  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraRotatePos@@YAXPAUCameraStruct@@@Z ENDP		; CameraRotatePos
_TEXT	ENDS
PUBLIC	_cosf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC NEAR					; cos, COMDAT

; 549  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_cosf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
EXTRN	_cos:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _cosf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_cosf	PROC NEAR					; COMDAT

; 444  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cos
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
PUBLIC	_sinf
; Function compile flags: /Odt /ZI
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC NEAR					; sin, COMDAT

; 575  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sinf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
EXTRN	_sin:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sinf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sinf	PROC NEAR					; COMDAT

; 466  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
EXTRN	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z:NEAR ; PosToCollGrid
EXTRN	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z:NEAR ; SphereCollPoly
EXTRN	?ModifyShift@@YAXPAUVectorStruct@@M0@Z:NEAR	; ModifyShift
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\camera.cpp
;	COMDAT ?CameraWorldColls@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_poly$ = -92						; size = 4
_collGrid$ = -88					; size = 4
_collPlane$ = -84					; size = 16
_objCamVec$ = -68					; size = 12
_worldPos$ = -56					; size = 12
_relPos$ = -44						; size = 12
_shift$ = -32						; size = 12
_newObjCamDist$ = -20					; size = 4
_objCamDist$ = -16					; size = 4
_time$ = -12						; size = 4
_depth$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_camera$ = 8						; size = 4
?CameraWorldColls@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraWorldColls, COMDAT

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi

; 771  : 	//bool		los;
; 772  : 	//REAL		shiftDotFace;
; 773  : 	int			iPoly;
; 774  : 	REAL		depth, time, objCamDist, newObjCamDist;
; 775  : 	VEC			shift, relPos, worldPos, objCamVec;
; 776  : 	PLANE		collPlane;
; 777  : 	COLLGRID	*collGrid;
; 778  : 	NEWCOLLPOLY	*poly;
; 779  : 
; 780  : 	// Make sure this camera can collide
; 781  : 	if (!camera->Collide) return;

	mov	eax, DWORD PTR _camera$[ebp]
	movzx	ecx, BYTE PTR [eax+180]
	test	ecx, ecx
	jne	SHORT $L81801
	jmp	$L81788
$L81801:

; 782  : 
; 783  : 	// Initialisation
; 784  : 	SetVecZero(&shift);

	mov	DWORD PTR _shift$[ebp], 0
	mov	DWORD PTR _shift$[ebp+4], 0
	mov	DWORD PTR _shift$[ebp+8], 0

; 785  : 
; 786  : 	// Calculate object-camera relative unit vector and their separation
; 787  : 	VecMinusVec(&camera->Object->body.Centre.Pos, &camera->WPos, &objCamVec);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR [edx+68]
	fstp	DWORD PTR _objCamVec$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR [edx+72]
	fstp	DWORD PTR _objCamVec$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR [edx+76]
	fstp	DWORD PTR _objCamVec$[ebp+8]

; 788  : 	objCamDist = VecLen(&objCamVec);

	fld	DWORD PTR _objCamVec$[ebp]
	fmul	DWORD PTR _objCamVec$[ebp]
	fld	DWORD PTR _objCamVec$[ebp+4]
	fmul	DWORD PTR _objCamVec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _objCamVec$[ebp+8]
	fmul	DWORD PTR _objCamVec$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _objCamDist$[ebp]

; 789  : 	if (objCamDist > SMALL_REAL) {

	fld	DWORD PTR _objCamDist$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81803

; 790  : 		VecDivScalar(&objCamVec, objCamDist);

	fld	DWORD PTR _objCamVec$[ebp]
	fdiv	DWORD PTR _objCamDist$[ebp]
	fstp	DWORD PTR _objCamVec$[ebp]
	fld	DWORD PTR _objCamVec$[ebp+4]
	fdiv	DWORD PTR _objCamDist$[ebp]
	fstp	DWORD PTR _objCamVec$[ebp+4]
	fld	DWORD PTR _objCamVec$[ebp+8]
	fdiv	DWORD PTR _objCamDist$[ebp]
	fstp	DWORD PTR _objCamVec$[ebp+8]

; 791  : 	} else {

	jmp	SHORT $L81804
$L81803:

; 792  : 		SetVecZero(&objCamVec);

	mov	DWORD PTR _objCamVec$[ebp], 0
	mov	DWORD PTR _objCamVec$[ebp+4], 0
	mov	DWORD PTR _objCamVec$[ebp+8], 0
$L81804:

; 793  : 	}
; 794  : 
; 795  : 	// Calculate the point to check for collisions
; 796  : 	VecPlusScalarVec(&camera->WPos, RenderSettings.NearClip, &objCamVec, &camera->CollPos);

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fmul	DWORD PTR _objCamVec$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+304]
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fmul	DWORD PTR _objCamVec$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+308]
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fmul	DWORD PTR _objCamVec$[ebp+8]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+312]

; 797  : 
; 798  : 	// Calculate the grid location of the camera
; 799  : 	collGrid = PosToCollGrid(&camera->CollPos);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	call	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ; PosToCollGrid
	add	esp, 4
	mov	DWORD PTR _collGrid$[ebp], eax

; 800  : 	if (collGrid == NULL) return;

	cmp	DWORD PTR _collGrid$[ebp], 0
	jne	SHORT $L81805
	jmp	$L81788
$L81805:

; 801  : 
; 802  : 	// Check that the camera hasn't passed through any polys
; 803  : #ifdef _PC
; 804  : 	for (iPoly = 0; iPoly < collGrid->NWorldPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L81806
$L81807:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L81806:
	mov	eax, DWORD PTR _collGrid$[ebp]
	mov	ecx, DWORD PTR _iPoly$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L81808

; 805  : #endif
; 806  : #ifdef _N64
; 807  : 	for (iPoly = 0; iPoly < collGrid->NCollPolys; iPoly++) {			// !MT! This was a bug?
; 808  : #endif
; 809  : 		poly = collGrid->CollPolyPtr[iPoly];

	mov	eax, DWORD PTR _collGrid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iPoly$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _poly$[ebp], eax

; 810  : 
; 811  : 		if (PolyObjectOnly(poly)) continue;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4
	je	SHORT $L81809
	jmp	SHORT $L81807
$L81809:

; 812  : 		if (SphereCollPoly(&camera->OldCollPos, &camera->CollPos, InnerRadius, poly, &collPlane,  &relPos, &worldPos, &depth, &time)) {

	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	lea	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _worldPos$[ebp]
	push	edx
	lea	eax, DWORD PTR _relPos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _collPlane$[ebp]
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	push	edx
	mov	eax, DWORD PTR _InnerRadius
	push	eax
	mov	ecx, DWORD PTR _camera$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	add	edx, 316				; 0000013cH
	push	edx
	call	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z ; SphereCollPoly
	add	esp, 36					; 00000024H
	movzx	eax, al
	test	eax, eax
	je	SHORT $L81810

; 813  : 
; 814  : 			ModifyShift(&shift, -depth, PlaneNormal(&collPlane));

	lea	eax, DWORD PTR _collPlane$[ebp]
	push	eax
	fld	DWORD PTR _depth$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _shift$[ebp]
	push	ecx
	call	?ModifyShift@@YAXPAUVectorStruct@@M0@Z	; ModifyShift
	add	esp, 12					; 0000000cH
$L81810:

; 815  : 
; 816  : 		}
; 817  : 	}

	jmp	$L81807
$L81808:

; 818  : 
; 819  : 	// Shift camera out of collision
; 820  : 	VecPlusEqVec(&camera->CollPos, &shift);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _shift$[ebp]
	fadd	DWORD PTR [eax+304]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+304]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _shift$[ebp+4]
	fadd	DWORD PTR [eax+308]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+308]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _shift$[ebp+8]
	fadd	DWORD PTR [eax+312]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+312]

; 821  : 
; 822  : 	// Calculate new pole length
; 823  : 	VecMinusVec(&camera->Object->body.Centre.Pos, &camera->CollPos, &objCamVec);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+20]
	fsub	DWORD PTR [edx+304]
	fstp	DWORD PTR _objCamVec$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+24]
	fsub	DWORD PTR [edx+308]
	fstp	DWORD PTR _objCamVec$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+28]
	fsub	DWORD PTR [edx+312]
	fstp	DWORD PTR _objCamVec$[ebp+8]

; 824  : 	newObjCamDist = VecLen(&objCamVec);

	fld	DWORD PTR _objCamVec$[ebp]
	fmul	DWORD PTR _objCamVec$[ebp]
	fld	DWORD PTR _objCamVec$[ebp+4]
	fmul	DWORD PTR _objCamVec$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _objCamVec$[ebp+8]
	fmul	DWORD PTR _objCamVec$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _newObjCamDist$[ebp]

; 825  : 	if (newObjCamDist > SMALL_REAL) {

	fld	DWORD PTR _newObjCamDist$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L81813

; 826  : 		VecDivScalar(&objCamVec, newObjCamDist);

	fld	DWORD PTR _objCamVec$[ebp]
	fdiv	DWORD PTR _newObjCamDist$[ebp]
	fstp	DWORD PTR _objCamVec$[ebp]
	fld	DWORD PTR _objCamVec$[ebp+4]
	fdiv	DWORD PTR _newObjCamDist$[ebp]
	fstp	DWORD PTR _objCamVec$[ebp+4]
	fld	DWORD PTR _objCamVec$[ebp+8]
	fdiv	DWORD PTR _newObjCamDist$[ebp]
	fstp	DWORD PTR _objCamVec$[ebp+8]

; 827  : 		if (newObjCamDist > objCamDist - RenderSettings.NearClip) {

	fld	DWORD PTR _objCamDist$[ebp]
	fsub	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fcomp	DWORD PTR _newObjCamDist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81813

; 828  : 			VecPlusScalarVec(&camera->Object->body.Centre.Pos, -objCamDist + RenderSettings.NearClip, &objCamVec, &camera->CollPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _objCamDist$[ebp]
	fchs
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fmul	DWORD PTR _objCamVec$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+304]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _objCamDist$[ebp]
	fchs
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fmul	DWORD PTR _objCamVec$[ebp+4]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+308]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _objCamDist$[ebp]
	fchs
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fmul	DWORD PTR _objCamVec$[ebp+8]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+312]
$L81813:

; 829  : 		}
; 830  : 	}
; 831  : 
; 832  : 	// Get new camera position
; 833  : 	VecPlusScalarVec(&camera->CollPos, - RenderSettings.NearClip, &objCamVec, &camera->WPos);

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fchs
	fmul	DWORD PTR _objCamVec$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+304]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+68]
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fchs
	fmul	DWORD PTR _objCamVec$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+308]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+72]
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fchs
	fmul	DWORD PTR _objCamVec$[ebp+8]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+312]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+76]
$L81788:

; 834  : 
; 835  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraWorldColls@@YAXPAUCameraStruct@@@Z ENDP		; CameraWorldColls
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?CameraDynamicNodePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_node2$81825 = -40					; size = 4
_node1$81824 = -36					; size = 4
_dR2$ = -32						; size = 12
_dR$ = -20						; size = 12
_velDot$ = -8						; size = 4
_dRLen$ = -4						; size = 4
_camera$ = 8						; size = 4
?CameraDynamicNodePos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraDynamicNodePos, COMDAT

; 916  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 917  : 	REAL dRLen, velDot;
; 918  : 	VEC dR, dR2;
; 919  : 
; 920  : 	// Make sure there is a valid dynamic node nearby
; 921  : 	if (camera->Object->player->ValidRailCamNode == -1) {

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	cmp	DWORD PTR [edx+10312], -1
	jne	SHORT $L81822

; 922  : 		CameraNearestNodePos(camera);

	mov	eax, DWORD PTR _camera$[ebp]
	push	eax
	call	?CameraNearestNodePos@@YAXPAUCameraStruct@@@Z ; CameraNearestNodePos
	add	esp, 4

; 923  : 		return;

	jmp	$L81817
$L81822:

; 924  : 	}
; 925  : 
; 926  : 	// See if we have just switched to dynamic camera mode
; 927  : 	if (camera->Object->player->ValidRailCamNode != camera->Object->player->LastValidRailCamNode) {

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [ecx+588]
	mov	ecx, DWORD PTR [edx+10312]
	cmp	ecx, DWORD PTR [eax+10316]
	je	$L81823

; 928  : 		// Choose the start position of the camera
; 929  : 		CAMNODE *node1, *node2;
; 930  : 		node1 = &CAM_CameraNode[camera->Object->player->ValidRailCamNode];

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10312]
	imul	eax, 40					; 00000028H
	add	eax, OFFSET FLAT:?CAM_CameraNode@@3PAUCamNodeStruct@@A ; CAM_CameraNode
	mov	DWORD PTR _node1$81824[ebp], eax

; 931  : 		node2 = &CAM_CameraNode[node1->Link];

	mov	eax, DWORD PTR _node1$81824[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:?CAM_CameraNode@@3PAUCamNodeStruct@@A ; CAM_CameraNode
	mov	DWORD PTR _node2$81825[ebp], ecx

; 932  : 		VecMinusVec(&node1->Pos, &camera->Object->body.Centre.Pos, &dR);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _node1$81824[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _node1$81824[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _node1$81824[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dR$[ebp+8]

; 933  : 		VecMinusVec(&node2->Pos, &camera->Object->body.Centre.Pos, &dR2);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _node2$81825[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR2$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _node2$81825[ebp]
	fld	DWORD PTR [edx+12]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dR2$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _node2$81825[ebp]
	fld	DWORD PTR [edx+16]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dR2$[ebp+8]

; 934  : 		if (VecDotVec(&dR, &dR) < VecDotVec(&dR2, &dR2)) {

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR2$[ebp]
	fmul	DWORD PTR _dR2$[ebp]
	fld	DWORD PTR _dR2$[ebp+4]
	fmul	DWORD PTR _dR2$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR2$[ebp+8]
	fmul	DWORD PTR _dR2$[ebp+8]
	faddp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81826

; 935  : 			camera->Object->player->ValidRailCamNode = camera->Object->player->LastValidRailCamNode = node1->Link;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR _node1$81824[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+10316], ecx
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	edx, DWORD PTR [eax+588]
	mov	eax, DWORD PTR [ecx+10316]
	mov	DWORD PTR [edx+10312], eax
$L81826:

; 936  : 		}
; 937  : 		CopyVec(&CAM_CameraNode[camera->Object->player->ValidRailCamNode].Pos, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10312]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[eax+8]
	mov	DWORD PTR [ecx+68], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10312]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[eax+12]
	mov	DWORD PTR [ecx+72], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10312]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[eax+16]
	mov	DWORD PTR [ecx+76], edx

; 938  : 		camera->ZoomMod = CAM_CameraNode[camera->Object->player->ValidRailCamNode].ZoomMod;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10312]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[eax+20]
	mov	DWORD PTR [ecx+176], edx
$L81823:

; 939  : 	}
; 940  : 	CAM_StartNode = &CAM_CameraNode[camera->Object->player->ValidRailCamNode];

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10312]
	imul	eax, 40					; 00000028H
	add	eax, OFFSET FLAT:?CAM_CameraNode@@3PAUCamNodeStruct@@A ; CAM_CameraNode
	mov	DWORD PTR ?CAM_StartNode@@3PAUCamNodeStruct@@A, eax ; CAM_StartNode

; 941  : 	CAM_EndNode = &CAM_CameraNode[CAM_CameraNode[camera->Object->player->ValidRailCamNode].Link];

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [edx+10312]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[eax+24]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:?CAM_CameraNode@@3PAUCamNodeStruct@@A ; CAM_CameraNode
	mov	DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A, ecx ; CAM_EndNode

; 942  : 
; 943  : 	// Housekeeping
; 944  : 	CopyVec(&camera->WPos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+88], edx

; 945  : 
; 946  : 	// Get the vector connecting the start and end nodes
; 947  : 	VecMinusVec(&CAM_EndNode->Pos, &CAM_StartNode->Pos, &dR);

	mov	eax, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	mov	ecx, DWORD PTR ?CAM_StartNode@@3PAUCamNodeStruct@@A ; CAM_StartNode
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	mov	ecx, DWORD PTR ?CAM_StartNode@@3PAUCamNodeStruct@@A ; CAM_StartNode
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	mov	ecx, DWORD PTR ?CAM_StartNode@@3PAUCamNodeStruct@@A ; CAM_StartNode
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [ecx+16]
	fstp	DWORD PTR _dR$[ebp+8]

; 948  : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 949  : 	if (dRLen < SMALL_REAL) {

	fld	DWORD PTR _dRLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81828

; 950  : 		return;

	jmp	$L81817
$L81828:

; 951  : 	}
; 952  : 	VecDivScalar(&dR, dRLen);

	fld	DWORD PTR _dR$[ebp]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp+4]
	fld	DWORD PTR _dR$[ebp+8]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp+8]

; 953  : 
; 954  : 	// Get object's velocity along the line of the node path
; 955  : 	velDot = VecDotVec(&camera->Object->body.Centre.Vel, &dR);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR [edx+164]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR [eax+36]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR [edx+40]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _velDot$[ebp]

; 956  : 
; 957  : 	// Move camera along the path
; 958  : 	VecPlusEqScalarVec(&camera->WPos, -velDot * TimeStep, &dR);

	fld	DWORD PTR _velDot$[ebp]
	fchs
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+68]
	fld	DWORD PTR _velDot$[ebp]
	fchs
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+72]
	fld	DWORD PTR _velDot$[ebp]
	fchs
	fmul	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+76]

; 959  : 
; 960  : 	// Set the zoom factor
; 961  : 	camera->ZoomMod = CAM_StartNode->ZoomMod;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?CAM_StartNode@@3PAUCamNodeStruct@@A ; CAM_StartNode
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+176], edx

; 962  : 
; 963  : 	// See if it has reached the end
; 964  : 	VecMinusVec(&camera->WPos, &CAM_EndNode->Pos, &dR2);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR2$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dR2$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+16]
	fstp	DWORD PTR _dR2$[ebp+8]

; 965  : 	//if (VecDotVec(&dR, &dR2) > ZERO) {
; 966  : 	//	SetCameraRail(camera, camera->Object, CAM_RAIL_STATIC_NEAREST);
; 967  : 	//	return;
; 968  : 	//}
; 969  : 
; 970  : 	if (TimeStep > SMALL_REAL) {

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81829

; 971  : 		VecMinusVec(&camera->WPos, &camera->OldWPos, &camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+100]

; 972  : 		VecDivScalar(&camera->Vel, TimeStep);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+92]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+96]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+100]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+100]

; 973  : 	} else {

	jmp	SHORT $L81817
$L81829:

; 974  : 		SetVecZero(&camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+96], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+100], 0
$L81817:

; 975  : 	}
; 976  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraDynamicNodePos@@YAXPAUCameraStruct@@@Z ENDP	; CameraDynamicNodePos
_TEXT	ENDS
PUBLIC	?CameraStartEndNodes@@YA_NPAUCameraStruct@@@Z	; CameraStartEndNodes
; Function compile flags: /Odt /ZI
;	COMDAT ?CameraStartEndNodes@@YA_NPAUCameraStruct@@@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
?CameraStartEndNodes@@YA_NPAUCameraStruct@@@Z PROC NEAR	; CameraStartEndNodes, COMDAT

; 985  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 986  : 
; 987  : 	// Find the nearest node of type MONORAIL
; 988  : 	CAM_EndNode = NearestNode(CAMNODE_MONORAIL, &camera->Object->body.Centre.Pos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 20					; 00000014H
	push	ecx
	push	0
	call	?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z ; NearestNode
	add	esp, 8
	mov	DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A, eax ; CAM_EndNode

; 989  : 	if (CAM_EndNode == NULL) {

	cmp	DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A, 0 ; CAM_EndNode
	jne	SHORT $L81834

; 990  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81833
$L81834:

; 991  : 	}
; 992  : 
; 993  : 	// Node should always be attached to another
; 994  : 	if (CAM_EndNode->Link == -1) {

	mov	eax, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $L81835

; 995  : 		return FALSE;

	xor	al, al
	jmp	SHORT $L81833
$L81835:

; 996  : 	}
; 997  : 
; 998  : 	// Set the start node
; 999  : 	CAM_StartNode = &CAM_CameraNode[CAM_EndNode->Link];

	mov	eax, DWORD PTR ?CAM_EndNode@@3PAUCamNodeStruct@@A ; CAM_EndNode
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 40					; 00000028H
	add	ecx, OFFSET FLAT:?CAM_CameraNode@@3PAUCamNodeStruct@@A ; CAM_CameraNode
	mov	DWORD PTR ?CAM_StartNode@@3PAUCamNodeStruct@@A, ecx ; CAM_StartNode

; 1000 : 
; 1001 : 	return TRUE;

	mov	al, 1
$L81833:

; 1002 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraStartEndNodes@@YA_NPAUCameraStruct@@@Z ENDP	; CameraStartEndNodes
_TEXT	ENDS
PUBLIC	__real@41800000
PUBLIC	__real@40800000
EXTRN	?TimeFactor@@3MA:DWORD				; TimeFactor
EXTRN	__imp__GetKeyState@4:NEAR
EXTRN	?Mouse@@3U_DIMOUSESTATE@@A:BYTE			; Mouse
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraFreedomPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_add$ = -28						; size = 4
_vec2$ = -24						; size = 12
_vec$ = -12						; size = 12
_camera$ = 8						; size = 4
?CameraFreedomPos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraFreedomPos, COMDAT

; 1009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1010 : 	VEC vec, vec2;
; 1011 : 	REAL add;
; 1012 : #ifdef _N64
; 1013 : 	BUTTONS	Buttons;
; 1014 : 
; 1015 : 	// Read controller
; 1016 : 	CRD_GetButtons(1, &Buttons);
; 1017 : #endif
; 1018 : 
; 1019 : 	CopyVec(&camera->WPos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+88], edx

; 1020 : 
; 1021 : 	// get pos
; 1022 : 	add = 16 * TimeFactor;

	fld	DWORD PTR __real@41800000
	fmul	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fstp	DWORD PTR _add$[ebp]

; 1023 : #ifdef _PC
; 1024 : 	if (GetKeyState(VK_SCROLL) & 1) add *= 4;

	push	145					; 00000091H
	call	DWORD PTR __imp__GetKeyState@4
	movsx	eax, ax
	and	eax, 1
	je	SHORT $L81842
	fld	DWORD PTR _add$[ebp]
	fmul	DWORD PTR __real@40800000
	fstp	DWORD PTR _add$[ebp]
$L81842:

; 1025 : #endif
; 1026 : 	if (CAMERA_RIGHT) vec.v[X] = add;

	movsx	eax, BYTE PTR ?Keys@@3PADA+32
	test	eax, eax
	je	SHORT $L81843
	mov	eax, DWORD PTR _add$[ebp]
	mov	DWORD PTR _vec$[ebp], eax

; 1027 : 	else if (CAMERA_LEFT) vec.v[X] = -add;

	jmp	SHORT $L81844
$L81843:
	movsx	eax, BYTE PTR ?Keys@@3PADA+30
	test	eax, eax
	je	SHORT $L81845
	fld	DWORD PTR _add$[ebp]
	fchs
	fstp	DWORD PTR _vec$[ebp]

; 1028 : 	else vec.v[X] = 0;

	jmp	SHORT $L81844
$L81845:
	mov	DWORD PTR _vec$[ebp], 0
$L81844:

; 1029 : 
; 1030 : 	if (CAMERA_DOWN) vec.v[Y] = add;

	movsx	eax, BYTE PTR ?Keys@@3PADA+31
	test	eax, eax
	je	SHORT $L81847
	mov	eax, DWORD PTR _add$[ebp]
	mov	DWORD PTR _vec$[ebp+4], eax

; 1031 : 	else if (CAMERA_UP) vec.v[Y] = -add;

	jmp	SHORT $L81848
$L81847:
	movsx	eax, BYTE PTR ?Keys@@3PADA+17
	test	eax, eax
	je	SHORT $L81849
	fld	DWORD PTR _add$[ebp]
	fchs
	fstp	DWORD PTR _vec$[ebp+4]

; 1032 : 	else vec.v[Y] = 0;

	jmp	SHORT $L81848
$L81849:
	mov	DWORD PTR _vec$[ebp+4], 0
$L81848:

; 1033 : 
; 1034 : #ifdef _PC
; 1035 : 	if (CAMERA_FORWARDS || Mouse.rgbButtons[0]) vec.v[Z] = add;

	movsx	eax, BYTE PTR ?Keys@@3PADA+18
	test	eax, eax
	jne	SHORT $L81852
	movzx	eax, BYTE PTR ?Mouse@@3U_DIMOUSESTATE@@A+12
	test	eax, eax
	je	SHORT $L81851
$L81852:
	mov	eax, DWORD PTR _add$[ebp]
	mov	DWORD PTR _vec$[ebp+8], eax

; 1036 : 	else if (CAMERA_BACKWARDS || Mouse.rgbButtons[1]) vec.v[Z] = -add;

	jmp	SHORT $L81853
$L81851:
	movsx	eax, BYTE PTR ?Keys@@3PADA+16
	test	eax, eax
	jne	SHORT $L81855
	movzx	eax, BYTE PTR ?Mouse@@3U_DIMOUSESTATE@@A+13
	test	eax, eax
	je	SHORT $L81854
$L81855:
	fld	DWORD PTR _add$[ebp]
	fchs
	fstp	DWORD PTR _vec$[ebp+8]

; 1037 : #endif
; 1038 : #ifdef _N64
; 1039 : 	if (CAMERA_FORWARDS) vec.v[Z] = add;
; 1040 : 	else if (CAMERA_BACKWARDS) vec.v[Z] = -add;
; 1041 : #endif
; 1042 : 	else vec.v[Z] = 0;

	jmp	SHORT $L81853
$L81854:
	mov	DWORD PTR _vec$[ebp+8], 0
$L81853:

; 1043 : 
; 1044 : 	RotVector(&camera->WMatrix, &vec, &vec2);

	lea	eax, DWORD PTR _vec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1045 : 	AddVector(&camera->WPos, &vec2, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _vec2$[ebp]
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _vec2$[ebp+4]
	fadd	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _vec2$[ebp+8]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+76]

; 1046 : 
; 1047 : 	if (TimeStep > SMALL_REAL) {

	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81857

; 1048 : 		VecMinusVec(&camera->WPos, &camera->OldWPos, &camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [edx+100]

; 1049 : 		VecDivScalar(&camera->Vel, TimeStep);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+92]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+96]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+100]
	fdiv	DWORD PTR ?TimeStep@@3MA		; TimeStep
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1050 : 	} else {

	jmp	SHORT $L81838
$L81857:

; 1051 : 		SetVecZero(&camera->Vel);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+96], 0
	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+100], 0
$L81838:

; 1052 : 	}
; 1053 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraFreedomPos@@YAXPAUCameraStruct@@@Z ENDP		; CameraFreedomPos
_TEXT	ENDS
PUBLIC	__real@45400000
EXTRN	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z:NEAR	; RotMatrixZYX
EXTRN	?MulMatrix@@YAXPATMatrixUnion@@00@Z:NEAR	; MulMatrix
EXTRN	?CopyMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; CopyMatrix
;	COMDAT __real@45400000
CONST	SEGMENT
__real@45400000 DD 045400000r			; 3072
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraMouseLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
tv404 = -148						; size = 4
__mul$81868 = -80					; size = 4
__mul$81866 = -76					; size = 4
_mat2$ = -72						; size = 36
_mat$ = -36						; size = 36
_camera$ = 8						; size = 4
?CameraMouseLook@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraMouseLook, COMDAT

; 1056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 1057 : 	MAT mat, mat2;
; 1058 : #ifdef _N64
; 1059 : 	long	JoyX, JoyY;
; 1060 : 
; 1061 : 	// Read controller
; 1062 : 	CRD_GetJoyXY(1, &JoyX, &JoyY);
; 1063 : 	RotMatrixZYX(&mat, (REAL)-JoyY / 3072, -(REAL)JoyX / 3072, 0);
; 1064 : #endif
; 1065 : 
; 1066 : #ifdef _PC
; 1067 : 	RotMatrixZYX(&mat, (REAL)-Mouse.lY / 3072, -(REAL)Mouse.lX / 3072, 0);

	push	0
	fild	DWORD PTR ?Mouse@@3U_DIMOUSESTATE@@A
	fchs
	fdiv	DWORD PTR __real@45400000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR ?Mouse@@3U_DIMOUSESTATE@@A+4
	neg	eax
	mov	DWORD PTR tv404[ebp], eax
	fild	DWORD PTR tv404[ebp]
	fdiv	DWORD PTR __real@45400000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 1068 : #endif
; 1069 : 	MulMatrix(&camera->WMatrix, &mat, &mat2);

	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 1070 : 	CopyMatrix(&mat2, &camera->WMatrix);

	mov	eax, DWORD PTR _camera$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 1071 : 
; 1072 : 	camera->WMatrix.m[RY] = 0;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1073 : 	NormalizeVector(&camera->WMatrix.mv[X]);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+16]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+24]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81866[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __mul$81866[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __mul$81866[ebp]
	fmul	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __mul$81866[ebp]
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+24]

; 1074 : 	CrossProduct(&camera->WMatrix.mv[Z], &camera->WMatrix.mv[X], &camera->WMatrix.mv[Y]);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+48]
	fmul	DWORD PTR [eax+20]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+40]
	fmul	DWORD PTR [eax+24]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+44]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+36]

; 1075 : 	NormalizeVector(&camera->WMatrix.mv[Y]);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+32]
	fmul	DWORD PTR [eax+32]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [ecx+36]
	fmul	DWORD PTR [edx+36]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$81868[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __mul$81868[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __mul$81868[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __mul$81868[ebp]
	fmul	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+36]

; 1076 : 	CrossProduct(&camera->WMatrix.mv[X], &camera->WMatrix.mv[Y], &camera->WMatrix.mv[Z]);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+20]
	fmul	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [eax+32]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+36]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+16]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _camera$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+28]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+48]

; 1077 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraMouseLook@@YAXPAUCameraStruct@@@Z ENDP		; CameraMouseLook
_TEXT	ENDS
PUBLIC	__real@441fc000
PUBLIC	__real@43ef8000
;	COMDAT __real@441fc000
CONST	SEGMENT
__real@441fc000 DD 0441fc000r			; 639
CONST	ENDS
;	COMDAT __real@43ef8000
CONST	SEGMENT
__real@43ef8000 DD 043ef8000r			; 479
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CameraEditPos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_vec2$ = -28						; size = 12
_vec$ = -16						; size = 12
_add$ = -4						; size = 4
_camera$ = 8						; size = 4
?CameraEditPos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraEditPos, COMDAT

; 1084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1085 : 	REAL add;
; 1086 : 	VEC vec, vec2;
; 1087 : 
; 1088 : // update mouse ptr
; 1089 : 
; 1090 : 	MouseXrel = (REAL)Mouse.lX / 3;

	fild	DWORD PTR ?Mouse@@3U_DIMOUSESTATE@@A
	fdiv	DWORD PTR __real@40400000
	fstp	DWORD PTR ?MouseXrel@@3MA		; MouseXrel

; 1091 : 	MouseYrel = (REAL)Mouse.lY / 3;

	fild	DWORD PTR ?Mouse@@3U_DIMOUSESTATE@@A+4
	fdiv	DWORD PTR __real@40400000
	fstp	DWORD PTR ?MouseYrel@@3MA		; MouseYrel

; 1092 : 	MouseXpos += MouseXrel;

	fld	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fadd	DWORD PTR ?MouseXrel@@3MA		; MouseXrel
	fstp	DWORD PTR ?MouseXpos@@3MA		; MouseXpos

; 1093 : 	MouseYpos += MouseYrel;

	fld	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fadd	DWORD PTR ?MouseYrel@@3MA		; MouseYrel
	fstp	DWORD PTR ?MouseYpos@@3MA		; MouseYpos

; 1094 : 	if (MouseXpos < 0) MouseXpos = 0, MouseXrel = 0;

	fld	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81878
	mov	DWORD PTR ?MouseXpos@@3MA, 0
	mov	DWORD PTR ?MouseXrel@@3MA, 0
$L81878:

; 1095 : 	if (MouseXpos > 639) MouseXpos = 639, MouseXrel = 0;

	fld	DWORD PTR ?MouseXpos@@3MA		; MouseXpos
	fcomp	DWORD PTR __real@441fc000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81879
	mov	DWORD PTR ?MouseXpos@@3MA, 1142931456	; 441fc000H
	mov	DWORD PTR ?MouseXrel@@3MA, 0
$L81879:

; 1096 : 	if (MouseYpos < 0) MouseYpos = 0, MouseYrel = 0;

	fld	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L81880
	mov	DWORD PTR ?MouseYpos@@3MA, 0
	mov	DWORD PTR ?MouseYrel@@3MA, 0
$L81880:

; 1097 : 	if (MouseYpos > 479) MouseYpos = 479, MouseYrel = 0;

	fld	DWORD PTR ?MouseYpos@@3MA		; MouseYpos
	fcomp	DWORD PTR __real@43ef8000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81881
	mov	DWORD PTR ?MouseYpos@@3MA, 1139769344	; 43ef8000H
	mov	DWORD PTR ?MouseYrel@@3MA, 0
$L81881:

; 1098 : 
; 1099 : // update mouse buttons
; 1100 : 
; 1101 : 	MouseLastLeft = MouseLeft;

	mov	al, BYTE PTR ?MouseLeft@@3DA		; MouseLeft
	mov	BYTE PTR ?MouseLastLeft@@3DA, al	; MouseLastLeft

; 1102 : 	MouseLastRight = MouseRight;

	mov	al, BYTE PTR ?MouseRight@@3DA		; MouseRight
	mov	BYTE PTR ?MouseLastRight@@3DA, al	; MouseLastRight

; 1103 : 
; 1104 : 	MouseLeft = Mouse.rgbButtons[0];

	mov	al, BYTE PTR ?Mouse@@3U_DIMOUSESTATE@@A+12
	mov	BYTE PTR ?MouseLeft@@3DA, al		; MouseLeft

; 1105 : 	MouseRight = Mouse.rgbButtons[1];

	mov	al, BYTE PTR ?Mouse@@3U_DIMOUSESTATE@@A+13
	mov	BYTE PTR ?MouseRight@@3DA, al		; MouseRight

; 1106 : 
; 1107 : // slide camera?
; 1108 : 
; 1109 : 	add = 16 * TimeFactor;

	fld	DWORD PTR __real@41800000
	fmul	DWORD PTR ?TimeFactor@@3MA		; TimeFactor
	fstp	DWORD PTR _add$[ebp]

; 1110 : 	if (GetKeyState(VK_SCROLL) & 1) add *= 4;

	push	145					; 00000091H
	call	DWORD PTR __imp__GetKeyState@4
	movsx	eax, ax
	and	eax, 1
	je	SHORT $L81882
	fld	DWORD PTR _add$[ebp]
	fmul	DWORD PTR __real@40800000
	fstp	DWORD PTR _add$[ebp]
$L81882:

; 1111 : 
; 1112 : 	if (CAMERA_RIGHT) vec.v[X] = add;

	movsx	eax, BYTE PTR ?Keys@@3PADA+32
	test	eax, eax
	je	SHORT $L81883
	mov	eax, DWORD PTR _add$[ebp]
	mov	DWORD PTR _vec$[ebp], eax

; 1113 : 	else if (CAMERA_LEFT) vec.v[X] = -add;

	jmp	SHORT $L81884
$L81883:
	movsx	eax, BYTE PTR ?Keys@@3PADA+30
	test	eax, eax
	je	SHORT $L81885
	fld	DWORD PTR _add$[ebp]
	fchs
	fstp	DWORD PTR _vec$[ebp]

; 1114 : 	else vec.v[X] = 0;

	jmp	SHORT $L81884
$L81885:
	mov	DWORD PTR _vec$[ebp], 0
$L81884:

; 1115 : 
; 1116 : 	if (CAMERA_DOWN) vec.v[Y] = add;

	movsx	eax, BYTE PTR ?Keys@@3PADA+31
	test	eax, eax
	je	SHORT $L81887
	mov	eax, DWORD PTR _add$[ebp]
	mov	DWORD PTR _vec$[ebp+4], eax

; 1117 : 	else if (CAMERA_UP) vec.v[Y] = -add;

	jmp	SHORT $L81888
$L81887:
	movsx	eax, BYTE PTR ?Keys@@3PADA+17
	test	eax, eax
	je	SHORT $L81889
	fld	DWORD PTR _add$[ebp]
	fchs
	fstp	DWORD PTR _vec$[ebp+4]

; 1118 : 	else vec.v[Y] = 0;

	jmp	SHORT $L81888
$L81889:
	mov	DWORD PTR _vec$[ebp+4], 0
$L81888:

; 1119 : 
; 1120 : 	if (CAMERA_FORWARDS) vec.v[Z] = add;

	movsx	eax, BYTE PTR ?Keys@@3PADA+18
	test	eax, eax
	je	SHORT $L81891
	mov	eax, DWORD PTR _add$[ebp]
	mov	DWORD PTR _vec$[ebp+8], eax

; 1121 : 	else if (CAMERA_BACKWARDS) vec.v[Z] = -add;

	jmp	SHORT $L81892
$L81891:
	movsx	eax, BYTE PTR ?Keys@@3PADA+16
	test	eax, eax
	je	SHORT $L81893
	fld	DWORD PTR _add$[ebp]
	fchs
	fstp	DWORD PTR _vec$[ebp+8]

; 1122 : 	else vec.v[Z] = 0;

	jmp	SHORT $L81892
$L81893:
	mov	DWORD PTR _vec$[ebp+8], 0
$L81892:

; 1123 : 
; 1124 : 	CameraEditXrel = vec.v[X];

	mov	eax, DWORD PTR _vec$[ebp]
	mov	DWORD PTR ?CameraEditXrel@@3MA, eax

; 1125 : 	CameraEditYrel = vec.v[Y];

	mov	eax, DWORD PTR _vec$[ebp+4]
	mov	DWORD PTR ?CameraEditYrel@@3MA, eax

; 1126 : 	CameraEditZrel = vec.v[Z];

	mov	eax, DWORD PTR _vec$[ebp+8]
	mov	DWORD PTR ?CameraEditZrel@@3MA, eax

; 1127 : 
; 1128 : 	RotVector(&camera->WMatrix, &vec, &vec2);

	lea	eax, DWORD PTR _vec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _camera$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1129 : 	AddVector(&camera->WPos, &vec2, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _vec2$[ebp]
	fadd	DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _vec2$[ebp+4]
	fadd	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _vec2$[ebp+8]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+76]

; 1130 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraEditPos@@YAXPAUCameraStruct@@@Z ENDP		; CameraEditPos
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?CameraNullLook@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
?CameraNullLook@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraNullLook, COMDAT

; 1134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1135 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraNullLook@@YAXPAUCameraStruct@@@Z ENDP		; CameraNullLook
_TEXT	ENDS
PUBLIC	?SetCameraView@@YAXPATMatrixUnion@@PAUVectorStruct@@M@Z ; SetCameraView
PUBLIC	__real@46fffe00
PUBLIC	__real@3c23d70a
PUBLIC	__real@3ba3d70a
EXTRN	?GameSettings@@3UGAME_SETTINGS@@A:BYTE		; GameSettings
EXTRN	_rand:NEAR
EXTRN	?TransposeMatrix@@YAXPATMatrixUnion@@0@Z:NEAR	; TransposeMatrix
EXTRN	?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z:NEAR ; BuildPlane
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SetCameraView@@YAXPATMatrixUnion@@PAUVectorStruct@@M@Z
_TEXT	SEGMENT
tv277 = -208						; size = 4
tv275 = -204						; size = 4
tv273 = -200						; size = 4
_mat2$ = -132						; size = 36
_mat$ = -96						; size = 36
_br$ = -60						; size = 12
_bl$ = -48						; size = 12
_tr$ = -36						; size = 12
_tl$ = -24						; size = 12
_vec$ = -12						; size = 12
_cammat$ = 8						; size = 4
_campos$ = 12						; size = 4
_shake$ = 16						; size = 4
?SetCameraView@@YAXPATMatrixUnion@@PAUVectorStruct@@M@Z PROC NEAR ; SetCameraView, COMDAT

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 1143 : 	VEC vec, tl, tr, bl, br;
; 1144 : 	MAT mat, mat2;
; 1145 : #ifdef _N64
; 1146 :     u16		perspNorm;
; 1147 : #endif
; 1148 : 
; 1149 : // save camera pos + matrix
; 1150 : 	CopyVec(campos, &ViewCameraPos);

	mov	eax, DWORD PTR _campos$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?ViewCameraPos@@3UVectorStruct@@A, ecx
	mov	eax, DWORD PTR _campos$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR ?ViewCameraPos@@3UVectorStruct@@A+4, ecx
	mov	eax, DWORD PTR _campos$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR ?ViewCameraPos@@3UVectorStruct@@A+8, ecx

; 1151 : 	CopyMatrix(cammat, &ViewCameraMatrix);

	push	OFFSET FLAT:?ViewCameraMatrix@@3TMatrixUnion@@A ; ViewCameraMatrix
	mov	eax, DWORD PTR _cammat$[ebp]
	push	eax
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 1152 : 
; 1153 : // build scaled eye matrix / trans
; 1154 : 
; 1155 : 	if (shake)

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _shake$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$L81910

; 1156 : 	{
; 1157 : 		RotMatrixZYX(&mat2, (frand(0.01f) - 0.005f) * shake, (frand(0.01f) - 0.005f) * shake, (frand(0.01f) - 0.005f) * shake);

	call	_rand
	mov	DWORD PTR tv273[ebp], eax
	fild	DWORD PTR tv273[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3c23d70a
	fsub	DWORD PTR __real@3ba3d70a
	fmul	DWORD PTR _shake$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_rand
	mov	DWORD PTR tv275[ebp], eax
	fild	DWORD PTR tv275[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3c23d70a
	fsub	DWORD PTR __real@3ba3d70a
	fmul	DWORD PTR _shake$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_rand
	mov	DWORD PTR tv277[ebp], eax
	fild	DWORD PTR tv277[ebp]
	fdiv	DWORD PTR __real@46fffe00
	fmul	DWORD PTR __real@3c23d70a
	fsub	DWORD PTR __real@3ba3d70a
	fmul	DWORD PTR _shake$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _mat2$[ebp]
	push	eax
	call	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z	; RotMatrixZYX
	add	esp, 16					; 00000010H

; 1158 : 		MulMatrix(cammat, &mat2, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cammat$[ebp]
	push	edx
	call	?MulMatrix@@YAXPATMatrixUnion@@00@Z	; MulMatrix
	add	esp, 12					; 0000000cH

; 1159 : 	}
; 1160 : 	else

	jmp	SHORT $L81914
$L81910:

; 1161 : 	{
; 1162 : 		CopyMatrix(cammat, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cammat$[ebp]
	push	ecx
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8
$L81914:

; 1163 : 	}
; 1164 : 
; 1165 : 	mat.m[RX] *= RenderSettings.MatScaleX;

	fld	DWORD PTR _mat$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+20
	fstp	DWORD PTR _mat$[ebp]

; 1166 : 	mat.m[RY] *= RenderSettings.MatScaleX;

	fld	DWORD PTR _mat$[ebp+4]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+20
	fstp	DWORD PTR _mat$[ebp+4]

; 1167 : 	mat.m[RZ] *= RenderSettings.MatScaleX;

	fld	DWORD PTR _mat$[ebp+8]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+20
	fstp	DWORD PTR _mat$[ebp+8]

; 1168 : 	mat.m[UX] *= RenderSettings.MatScaleY;

	fld	DWORD PTR _mat$[ebp+12]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+24
	fstp	DWORD PTR _mat$[ebp+12]

; 1169 : 	mat.m[UY] *= RenderSettings.MatScaleY;

	fld	DWORD PTR _mat$[ebp+16]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+24
	fstp	DWORD PTR _mat$[ebp+16]

; 1170 : 	mat.m[UZ] *= RenderSettings.MatScaleY;

	fld	DWORD PTR _mat$[ebp+20]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+24
	fstp	DWORD PTR _mat$[ebp+20]

; 1171 : 
; 1172 : 	if (GameSettings.Mirrored)

	cmp	DWORD PTR ?GameSettings@@3UGAME_SETTINGS@@A+16, 0
	je	SHORT $L81915

; 1173 : 	{
; 1174 : 		mat.m[RX] = -mat.m[RX];

	fld	DWORD PTR _mat$[ebp]
	fchs
	fstp	DWORD PTR _mat$[ebp]

; 1175 : 		mat.m[RY] = -mat.m[RY];

	fld	DWORD PTR _mat$[ebp+4]
	fchs
	fstp	DWORD PTR _mat$[ebp+4]

; 1176 : 		mat.m[RZ] = -mat.m[RZ];

	fld	DWORD PTR _mat$[ebp+8]
	fchs
	fstp	DWORD PTR _mat$[ebp+8]
$L81915:

; 1177 : 	}
; 1178 : 
; 1179 : 	TransposeMatrix(&mat, &ViewMatrixScaled);

	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?TransposeMatrix@@YAXPATMatrixUnion@@0@Z ; TransposeMatrix
	add	esp, 8

; 1180 : 
; 1181 : 	SetVector(&vec, -campos->v[X], -campos->v[Y], -campos->v[Z]);

	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR [eax]
	fchs
	fstp	DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	fstp	DWORD PTR _vec$[ebp+4]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	fstp	DWORD PTR _vec$[ebp+8]

; 1182 : 	RotVector(&ViewMatrixScaled, &vec, &ViewTransScaled);

	push	OFFSET FLAT:?ViewTransScaled@@3UVectorStruct@@A ; ViewTransScaled
	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1183 : 
; 1184 : // build unscaled eye matrix / trans
; 1185 : 
; 1186 : 	TransposeMatrix(cammat, &ViewMatrix);

	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	mov	eax, DWORD PTR _cammat$[ebp]
	push	eax
	call	?TransposeMatrix@@YAXPATMatrixUnion@@0@Z ; TransposeMatrix
	add	esp, 8

; 1187 : 	RotVector(&ViewMatrix, &vec, &ViewTrans);

	push	OFFSET FLAT:?ViewTrans@@3UVectorStruct@@A ; ViewTrans
	lea	eax, DWORD PTR _vec$[ebp]
	push	eax
	push	OFFSET FLAT:?ViewMatrix@@3TMatrixUnion@@A ; ViewMatrix
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1188 : 
; 1189 : // build camera view frustum planes
; 1190 : 
; 1191 : #ifdef _PC
; 1192 : 	SetVector(&vec, -REAL_SCREEN_XHALF, -REAL_SCREEN_YHALF, RenderSettings.GeomPers);

	mov	DWORD PTR _vec$[ebp], -1012924416	; c3a00000H
	mov	DWORD PTR _vec$[ebp+4], -1016070144	; c3700000H
	mov	eax, DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	DWORD PTR _vec$[ebp+8], eax

; 1193 : 	RotVector(cammat, &vec, &tl);

	lea	eax, DWORD PTR _tl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cammat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1194 : 	AddVector(&tl, campos, &tl);

	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _tl$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _tl$[ebp]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _tl$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _tl$[ebp+4]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _tl$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _tl$[ebp+8]

; 1195 : 	SetVector(&vec, REAL_SCREEN_XHALF, -REAL_SCREEN_YHALF, RenderSettings.GeomPers);

	mov	DWORD PTR _vec$[ebp], 1134559232	; 43a00000H
	mov	DWORD PTR _vec$[ebp+4], -1016070144	; c3700000H
	mov	eax, DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	DWORD PTR _vec$[ebp+8], eax

; 1196 : 	RotVector(cammat, &vec, &tr);

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cammat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1197 : 	AddVector(&tr, campos, &tr);

	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _tr$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _tr$[ebp]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _tr$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _tr$[ebp+4]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _tr$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _tr$[ebp+8]

; 1198 : 	SetVector(&vec, -REAL_SCREEN_XHALF, REAL_SCREEN_YHALF, RenderSettings.GeomPers);

	mov	DWORD PTR _vec$[ebp], -1012924416	; c3a00000H
	mov	DWORD PTR _vec$[ebp+4], 1131413504	; 43700000H
	mov	eax, DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	DWORD PTR _vec$[ebp+8], eax

; 1199 : 	RotVector(cammat, &vec, &bl);

	lea	eax, DWORD PTR _bl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cammat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1200 : 	AddVector(&bl, campos, &bl);

	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _bl$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _bl$[ebp]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _bl$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _bl$[ebp+4]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _bl$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _bl$[ebp+8]

; 1201 : 	SetVector(&vec, REAL_SCREEN_XHALF, REAL_SCREEN_YHALF, RenderSettings.GeomPers);

	mov	DWORD PTR _vec$[ebp], 1134559232	; 43a00000H
	mov	DWORD PTR _vec$[ebp+4], 1131413504	; 43700000H
	mov	eax, DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	mov	DWORD PTR _vec$[ebp+8], eax

; 1202 : 	RotVector(cammat, &vec, &br);

	lea	eax, DWORD PTR _br$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cammat$[ebp]
	push	edx
	call	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
	add	esp, 12					; 0000000cH

; 1203 : 	AddVector(&br, campos, &br);

	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _br$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _br$[ebp]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _br$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _br$[ebp+4]
	mov	eax, DWORD PTR _campos$[ebp]
	fld	DWORD PTR _br$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _br$[ebp+8]

; 1204 : #endif
; 1205 : #ifdef _N64
; 1206 : 	SetVector(&vec, -GFX_ScrInfo.XCentre, -GFX_ScrInfo.YCentre, RenderSettings.GeomPers);
; 1207 : 	RotVector(cammat, &vec, &tl);
; 1208 : 	AddVector(&tl, campos, &tl);
; 1209 : 	SetVector(&vec, GFX_ScrInfo.XCentre, -GFX_ScrInfo.YCentre, RenderSettings.GeomPers);
; 1210 : 	RotVector(cammat, &vec, &tr);
; 1211 : 	AddVector(&tr, campos, &tr);
; 1212 : 	SetVector(&vec, -GFX_ScrInfo.XCentre, GFX_ScrInfo.YCentre, RenderSettings.GeomPers);
; 1213 : 	RotVector(cammat, &vec, &bl);
; 1214 : 	AddVector(&bl, campos, &bl);
; 1215 : 	SetVector(&vec, GFX_ScrInfo.XCentre, GFX_ScrInfo.YCentre, RenderSettings.GeomPers);
; 1216 : 	RotVector(cammat, &vec, &br);
; 1217 : 	AddVector(&br, campos, &br);
; 1218 : #endif
; 1219 : 
; 1220 : 	BuildPlane(campos, &tl, &bl, &CameraPlaneLeft);

	push	OFFSET FLAT:?CameraPlaneLeft@@3UPlaneStruct@@A ; CameraPlaneLeft
	lea	eax, DWORD PTR _bl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campos$[ebp]
	push	edx
	call	?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z ; BuildPlane
	add	esp, 16					; 00000010H

; 1221 : 	BuildPlane(campos, &tr, &tl, &CameraPlaneTop);

	push	OFFSET FLAT:?CameraPlaneTop@@3UPlaneStruct@@A ; CameraPlaneTop
	lea	eax, DWORD PTR _tl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campos$[ebp]
	push	edx
	call	?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z ; BuildPlane
	add	esp, 16					; 00000010H

; 1222 : 	BuildPlane(campos, &br, &tr, &CameraPlaneRight);

	push	OFFSET FLAT:?CameraPlaneRight@@3UPlaneStruct@@A ; CameraPlaneRight
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _br$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campos$[ebp]
	push	edx
	call	?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z ; BuildPlane
	add	esp, 16					; 00000010H

; 1223 : 	BuildPlane(campos, &bl, &br, &CameraPlaneBottom);

	push	OFFSET FLAT:?CameraPlaneBottom@@3UPlaneStruct@@A ; CameraPlaneBottom
	lea	eax, DWORD PTR _br$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campos$[ebp]
	push	edx
	call	?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z ; BuildPlane
	add	esp, 16					; 00000010H

; 1224 : 
; 1225 : // build mirrored scaled eye matrix
; 1226 : 
; 1227 : 	CopyMatrix(&ViewMatrixScaled, &ViewMatrixScaledMirrorY);

	push	OFFSET FLAT:?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A ; ViewMatrixScaledMirrorY
	push	OFFSET FLAT:?ViewMatrixScaled@@3TMatrixUnion@@A ; ViewMatrixScaled
	call	?CopyMatrix@@YAXPATMatrixUnion@@0@Z	; CopyMatrix
	add	esp, 8

; 1228 : 	ViewMatrixScaledMirrorY.m[UX] = -ViewMatrixScaledMirrorY.m[UX];

	fld	DWORD PTR ?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A+12
	fchs
	fstp	DWORD PTR ?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A+12

; 1229 : 	ViewMatrixScaledMirrorY.m[UY] = -ViewMatrixScaledMirrorY.m[UY];

	fld	DWORD PTR ?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A+16
	fchs
	fstp	DWORD PTR ?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A+16

; 1230 : 	ViewMatrixScaledMirrorY.m[UZ] = -ViewMatrixScaledMirrorY.m[UZ];

	fld	DWORD PTR ?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A+20
	fchs
	fstp	DWORD PTR ?ViewMatrixScaledMirrorY@@3TMatrixUnion@@A+20

; 1231 : 
; 1232 : #ifdef _N64
; 1233 : 	// Setup the N64 camera RSP matrices
; 1234 :     guPerspective(projlistp, &perspNorm, RenderSettings.PersAngle - ViewAngle, 1.3333333, RenderSettings.NearClip, RenderSettings.FarClip, 0.5);
; 1235 :     gSPPerspNormalize(glistp++, perspNorm);		   
; 1236 :     gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(projlistp++),G_MTX_PROJECTION|G_MTX_LOAD|G_MTX_NOPUSH);
; 1237 : 	guScale(mlistp, 1.0, 1.0, 1.0);
; 1238 :     gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(mlistp++), G_MTX_PROJECTION|G_MTX_MUL|G_MTX_NOPUSH);
; 1239 : 	GEM_NegateMatYZ(&ViewMatrix, &mat);
; 1240 : 	GEM_ConvF3toS4(&mat, viewlistp);
; 1241 :     gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(viewlistp++),G_MTX_PROJECTION|G_MTX_MUL|G_MTX_NOPUSH);
; 1242 : 	guTranslate(mlistp, -campos->v[0], -campos->v[1], -campos->v[2]);
; 1243 :     gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(mlistp++), G_MTX_PROJECTION|G_MTX_MUL|G_MTX_NOPUSH);
; 1244 : #endif
; 1245 : 
; 1246 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCameraView@@YAXPATMatrixUnion@@PAUVectorStruct@@M@Z ENDP ; SetCameraView
_TEXT	ENDS
PUBLIC	?SetViewport@@YAXMMMMM@Z			; SetViewport
PUBLIC	??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@	; `string'
PUBLIC	__real@40000000
PUBLIC	__real@44200000
PUBLIC	__real@43f00000
PUBLIC	__real@4b000000
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
EXTRN	_memset:NEAR
EXTRN	?ErrorDX@@YAXJPAD@Z:NEAR			; ErrorDX
EXTRN	?ScreenLeftClip@@3MA:DWORD			; ScreenLeftClip
EXTRN	?ScreenRightClip@@3MA:DWORD			; ScreenRightClip
EXTRN	?ScreenTopClip@@3MA:DWORD			; ScreenTopClip
EXTRN	?ScreenBottomClip@@3MA:DWORD			; ScreenBottomClip
EXTRN	?ScreenLeftClipGuard@@3MA:DWORD			; ScreenLeftClipGuard
EXTRN	?ScreenRightClipGuard@@3MA:DWORD		; ScreenRightClipGuard
EXTRN	?ScreenTopClipGuard@@3MA:DWORD			; ScreenTopClipGuard
EXTRN	?ScreenBottomClipGuard@@3MA:DWORD		; ScreenBottomClipGuard
EXTRN	?D3Dviewport@@3PAUIDirect3DViewport3@@A:DWORD	; D3Dviewport
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@44200000
CONST	SEGMENT
__real@44200000 DD 044200000r			; 640
CONST	ENDS
;	COMDAT __real@43f00000
CONST	SEGMENT
__real@43f00000 DD 043f00000r			; 480
CONST	ENDS
;	COMDAT __real@4b000000
CONST	SEGMENT
__real@4b000000 DD 04b000000r			; 8.38861e+006
CONST	ENDS
;	COMDAT ??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@
CONST	SEGMENT
??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@ DB 'Can''t set viewport', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SetViewport@@YAXMMMMM@Z
_TEXT	SEGMENT
__temp$81946 = -80					; size = 4
__temp$81943 = -76					; size = 4
__temp$81940 = -72					; size = 4
__temp$81937 = -68					; size = 4
__temp$81934 = -64					; size = 4
__temp$81931 = -60					; size = 4
__temp$81928 = -56					; size = 4
__temp$81925 = -52					; size = 4
_vd$ = -48						; size = 44
_r$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xsize$ = 16						; size = 4
_ysize$ = 20						; size = 4
_pers$ = 24						; size = 4
?SetViewport@@YAXMMMMM@Z PROC NEAR			; SetViewport, COMDAT

; 1254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 1255 : 	HRESULT r;
; 1256 : 	D3DVIEWPORT2 vd;
; 1257 : 
; 1258 : // set geom vars
; 1259 : 
; 1260 : 	RenderSettings.GeomPers = pers;

	mov	eax, DWORD PTR _pers$[ebp]
	mov	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A, eax

; 1261 : 	RenderSettings.GeomCentreX = x + xsize / 2;

	fld	DWORD PTR _xsize$[ebp]
	fdiv	DWORD PTR __real@40000000
	fadd	DWORD PTR _x$[ebp]
	fstp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+4

; 1262 : 	RenderSettings.GeomCentreY = y + ysize / 2;

	fld	DWORD PTR _ysize$[ebp]
	fdiv	DWORD PTR __real@40000000
	fadd	DWORD PTR _y$[ebp]
	fstp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+8

; 1263 : 	RenderSettings.GeomScaleX = xsize / REAL_SCREEN_XSIZE;

	fld	DWORD PTR _xsize$[ebp]
	fdiv	DWORD PTR __real@44200000
	fstp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+12

; 1264 : 	RenderSettings.GeomScaleY = ysize / REAL_SCREEN_YSIZE;

	fld	DWORD PTR _ysize$[ebp]
	fdiv	DWORD PTR __real@43f00000
	fstp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+16

; 1265 : 	RenderSettings.MatScaleX = RenderSettings.GeomScaleX * RenderSettings.GeomPers;

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+12
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fstp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+20

; 1266 : 	RenderSettings.MatScaleY = RenderSettings.GeomScaleY * RenderSettings.GeomPers;

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+16
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A
	fstp	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+24

; 1267 : 
; 1268 : // set clip vars
; 1269 : 
; 1270 : 	ScreenLeftClip = ScreenLeftClipGuard = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR ?ScreenLeftClipGuard@@3MA, eax
	mov	ecx, DWORD PTR ?ScreenLeftClipGuard@@3MA
	mov	DWORD PTR ?ScreenLeftClip@@3MA, ecx

; 1271 : 	ScreenRightClip = ScreenRightClipGuard = x + xsize - 1;

	fld	DWORD PTR _x$[ebp]
	fadd	DWORD PTR _xsize$[ebp]
	fsub	DWORD PTR __real@3f800000
	fstp	DWORD PTR ?ScreenRightClipGuard@@3MA	; ScreenRightClipGuard
	mov	eax, DWORD PTR ?ScreenRightClipGuard@@3MA
	mov	DWORD PTR ?ScreenRightClip@@3MA, eax

; 1272 : 	ScreenTopClip = ScreenTopClipGuard = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR ?ScreenTopClipGuard@@3MA, eax
	mov	ecx, DWORD PTR ?ScreenTopClipGuard@@3MA
	mov	DWORD PTR ?ScreenTopClip@@3MA, ecx

; 1273 : 	ScreenBottomClip = ScreenBottomClipGuard = y + ysize - 1;

	fld	DWORD PTR _y$[ebp]
	fadd	DWORD PTR _ysize$[ebp]
	fsub	DWORD PTR __real@3f800000
	fstp	DWORD PTR ?ScreenBottomClipGuard@@3MA	; ScreenBottomClipGuard
	mov	eax, DWORD PTR ?ScreenBottomClipGuard@@3MA
	mov	DWORD PTR ?ScreenBottomClip@@3MA, eax

; 1274 : 
; 1275 : //	if (ScreenLeftClipGuard == 0 && D3Dcaps.dvGuardBandLeft != 0) ScreenLeftClipGuard = D3Dcaps.dvGuardBandLeft;
; 1276 : //	if (ScreenRightClipGuard == (REAL)(ScreenXsize - 1) && D3Dcaps.dvGuardBandRight != 0) ScreenRightClipGuard = D3Dcaps.dvGuardBandRight;
; 1277 : //	if (ScreenTopClipGuard == 0 && D3Dcaps.dvGuardBandTop != 0) ScreenTopClipGuard = D3Dcaps.dvGuardBandTop;
; 1278 : //	if (ScreenBottomClipGuard == (REAL)(ScreenYsize - 1) && D3Dcaps.dvGuardBandBottom != 0) ScreenBottomClipGuard = D3Dcaps.dvGuardBandBottom;
; 1279 : 
; 1280 : // set viewport clear rect
; 1281 : 
; 1282 : 	FTOL(x, ViewportRect.x1);

	fld	DWORD PTR _x$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81925[ebp]
	mov	eax, DWORD PTR __temp$81925[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A, eax

; 1283 : 	FTOL(y, ViewportRect.y1);

	fld	DWORD PTR _y$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81928[ebp]
	mov	eax, DWORD PTR __temp$81928[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+4, eax

; 1284 : 	FTOL(x + xsize, ViewportRect.x2);

	fld	DWORD PTR _x$[ebp]
	fadd	DWORD PTR _xsize$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81931[ebp]
	mov	eax, DWORD PTR __temp$81931[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+8, eax

; 1285 : 	FTOL(y + ysize, ViewportRect.y2);

	fld	DWORD PTR _y$[ebp]
	fadd	DWORD PTR _ysize$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81934[ebp]
	mov	eax, DWORD PTR __temp$81934[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR ?ViewportRect@@3U_D3DRECT@@A+12, eax

; 1286 : 
; 1287 : // set dx viewport
; 1288 : 
; 1289 : 	ZeroMemory(&vd, sizeof(vd));

	push	44					; 0000002cH
	push	0
	lea	eax, DWORD PTR _vd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1290 : 	vd.dwSize = sizeof(vd);

	mov	DWORD PTR _vd$[ebp], 44			; 0000002cH

; 1291 : 
; 1292 : 	FTOL(x, vd.dwX);

	fld	DWORD PTR _x$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81937[ebp]
	mov	eax, DWORD PTR __temp$81937[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _vd$[ebp+4], eax

; 1293 : 	FTOL(y, vd.dwY);

	fld	DWORD PTR _y$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81940[ebp]
	mov	eax, DWORD PTR __temp$81940[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _vd$[ebp+8], eax

; 1294 : 	FTOL(xsize, vd.dwWidth);

	fld	DWORD PTR _xsize$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81943[ebp]
	mov	eax, DWORD PTR __temp$81943[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _vd$[ebp+12], eax

; 1295 : 	FTOL(ysize, vd.dwHeight);

	fld	DWORD PTR _ysize$[ebp]
	fadd	DWORD PTR __real@4b000000
	fstp	DWORD PTR __temp$81946[ebp]
	mov	eax, DWORD PTR __temp$81946[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _vd$[ebp+16], eax

; 1296 : 
; 1297 :     vd.dvClipX = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _vd$[ebp+20], eax

; 1298 :     vd.dvClipY = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _vd$[ebp+24], eax

; 1299 :     vd.dvClipWidth = xsize;

	mov	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _vd$[ebp+28], eax

; 1300 :     vd.dvClipHeight = ysize;

	mov	eax, DWORD PTR _ysize$[ebp]
	mov	DWORD PTR _vd$[ebp+32], eax

; 1301 :     vd.dvMinZ = 0;

	mov	DWORD PTR _vd$[ebp+36], 0

; 1302 :     vd.dvMaxZ = 1;

	mov	DWORD PTR _vd$[ebp+40], 1065353216	; 3f800000H

; 1303 : 
; 1304 :     r = D3Dviewport->SetViewport2(&vd);

	lea	eax, DWORD PTR _vd$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Dviewport@@3PAUIDirect3DViewport3@@A ; D3Dviewport
	push	eax
	call	DWORD PTR [edx+68]
	mov	DWORD PTR _r$[ebp], eax

; 1305 : 	if (r != DD_OK)

	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $L81922

; 1306 : 	{
; 1307 : 		ErrorDX(r, "Can't set viewport");

	push	OFFSET FLAT:??_C@_0BD@OJBPLIHG@Can?8t?5set?5viewport?$AA@
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?ErrorDX@@YAXJPAD@Z			; ErrorDX
	add	esp, 8

; 1308 : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame
$L81922:

; 1309 : 	}
; 1310 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetViewport@@YAXMMMMM@Z ENDP				; SetViewport
_TEXT	ENDS
PUBLIC	?AddCamera@@YAPAUCameraStruct@@MMMMJ@Z		; AddCamera
EXTRN	?ScreenXsize@@3KA:DWORD				; ScreenXsize
EXTRN	?ScreenYsize@@3KA:DWORD				; ScreenYsize
; Function compile flags: /Odt /ZI
;	COMDAT ?AddCamera@@YAPAUCameraStruct@@MMMMJ@Z
_TEXT	SEGMENT
tv172 = -84						; size = 8
tv160 = -84						; size = 8
tv147 = -84						; size = 8
tv143 = -84						; size = 8
_scaley$ = -12						; size = 4
_scalex$ = -8						; size = 4
_i$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xsize$ = 16						; size = 4
_ysize$ = 20						; size = 4
_flag$ = 24						; size = 4
?AddCamera@@YAPAUCameraStruct@@MMMMJ@Z PROC NEAR	; AddCamera, COMDAT

; 1318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1319 : 	long i;
; 1320 : 	REAL scalex, scaley;
; 1321 : 
; 1322 : // find a free camera
; 1323 : 
; 1324 : 	for (i = 0 ; i < MAX_CAMERAS ; i++) if (Camera[i].Flag == CAMERA_FLAG_FREE)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81961
$L81962:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81961:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$L81963
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	cmp	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+344], 0
	jne	$L81964

; 1325 : 	{
; 1326 : 
; 1327 : // set info
; 1328 : 
; 1329 : #ifdef _PC
; 1330 : 		scalex = (REAL)ScreenXsize / REAL_SCREEN_XSIZE;

	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR tv143[ebp], eax
	mov	DWORD PTR tv143[ebp+4], 0
	fild	QWORD PTR tv143[ebp]
	fdiv	DWORD PTR __real@44200000
	fstp	DWORD PTR _scalex$[ebp]

; 1331 : 		scaley = (REAL)ScreenYsize / REAL_SCREEN_YSIZE;

	mov	eax, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR tv147[ebp], eax
	mov	DWORD PTR tv147[ebp+4], 0
	fild	QWORD PTR tv147[ebp]
	fdiv	DWORD PTR __real@43f00000
	fstp	DWORD PTR _scaley$[ebp]

; 1332 : 		Camera[i].X = x * scalex;

	fld	DWORD PTR _x$[ebp]
	fmul	DWORD PTR _scalex$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	fstp	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+328]

; 1333 : 		Camera[i].Y = y * scaley;

	fld	DWORD PTR _y$[ebp]
	fmul	DWORD PTR _scaley$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	fstp	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+332]

; 1334 : 		if (!xsize) Camera[i].Xsize = (REAL)ScreenXsize;

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _xsize$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81967
	mov	eax, DWORD PTR ?ScreenXsize@@3KA	; ScreenXsize
	mov	DWORD PTR tv160[ebp], eax
	mov	DWORD PTR tv160[ebp+4], 0
	fild	QWORD PTR tv160[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 348				; 0000015cH
	fstp	DWORD PTR ?Camera@@3PAUCameraStruct@@A[ecx+336]

; 1335 : 		else Camera[i].Xsize = xsize * scalex;

	jmp	SHORT $L81969
$L81967:
	fld	DWORD PTR _xsize$[ebp]
	fmul	DWORD PTR _scalex$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	fstp	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+336]
$L81969:

; 1336 : 		if (!ysize) Camera[i].Ysize = (REAL)ScreenYsize;

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _ysize$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L81970
	mov	eax, DWORD PTR ?ScreenYsize@@3KA	; ScreenYsize
	mov	DWORD PTR tv172[ebp], eax
	mov	DWORD PTR tv172[ebp+4], 0
	fild	QWORD PTR tv172[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 348				; 0000015cH
	fstp	DWORD PTR ?Camera@@3PAUCameraStruct@@A[ecx+340]

; 1337 : 		else Camera[i].Ysize = ysize * scaley;

	jmp	SHORT $L81972
$L81970:
	fld	DWORD PTR _ysize$[ebp]
	fmul	DWORD PTR _scaley$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	fstp	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+340]
$L81972:

; 1338 : #endif
; 1339 : #ifdef _N64
; 1340 : 		Camera[i].X = x;
; 1341 : 		Camera[i].Y = y;
; 1342 : 		Camera[i].Xsize = xsize;
; 1343 : 		Camera[i].Ysize = ysize;
; 1344 : #endif
; 1345 : 		Camera[i].Flag = flag;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	ecx, DWORD PTR _flag$[ebp]
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+344], ecx

; 1346 : 
; 1347 : 		Camera[i].Shake = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+188], 0

; 1348 : 		
; 1349 : // return this camera
; 1350 : 
; 1351 : 		return &Camera[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	add	eax, OFFSET FLAT:?Camera@@3PAUCameraStruct@@A ; Camera
	jmp	SHORT $L81957
$L81964:

; 1352 : 	}
; 1353 : 
; 1354 : // return null
; 1355 : 
; 1356 : 	return NULL;

	jmp	$L81962
$L81963:
	xor	eax, eax
$L81957:

; 1357 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCamera@@YAPAUCameraStruct@@MMMMJ@Z ENDP		; AddCamera
_TEXT	ENDS
PUBLIC	?RemoveCamera@@YAXPAUCameraStruct@@@Z		; RemoveCamera
; Function compile flags: /Odt /ZI
;	COMDAT ?RemoveCamera@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
?RemoveCamera@@YAXPAUCameraStruct@@@Z PROC NEAR		; RemoveCamera, COMDAT

; 1364 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1365 : 	camera->Flag = CAMERA_FLAG_FREE;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+344], 0

; 1366 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveCamera@@YAXPAUCameraStruct@@@Z ENDP		; RemoveCamera
_TEXT	ENDS
PUBLIC	?InitCameras@@YAXXZ				; InitCameras
EXTRN	?SetMatUnit@@YAXPATMatrixUnion@@@Z:NEAR		; SetMatUnit
; Function compile flags: /Odt /ZI
;	COMDAT ?InitCameras@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?InitCameras@@YAXXZ PROC NEAR				; InitCameras, COMDAT

; 1373 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1374 : 	long i;
; 1375 : 
; 1376 : 	for (i = 0 ; i < MAX_CAMERAS ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81980
$L81981:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81980:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$L81978

; 1377 : 	{
; 1378 : 		Camera[i].Type = -1;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax], -1

; 1379 : 		Camera[i].SubType = -1;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+4], -1

; 1380 : 		Camera[i].Flag = CAMERA_FLAG_FREE;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+344], 0

; 1381 : 		SetVecZero(&Camera[i].WPos);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+68], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+72], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+76], 0

; 1382 : 		SetMatUnit(&Camera[i].WMatrix);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	add	eax, OFFSET FLAT:?Camera@@3PAUCameraStruct@@A+16
	push	eax
	call	?SetMatUnit@@YAXPATMatrixUnion@@@Z	; SetMatUnit
	add	esp, 4

; 1383 : 		Camera[i].Lens = ZERO;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+168], 0

; 1384 : 
; 1385 : 		SetVecZero(&Camera[i].PosOffset);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+116], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+120], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+124], 0

; 1386 : 		SetVecZero(&Camera[i].WorldPosOffset);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+128], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+132], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+136], 0

; 1387 : 		SetVecZero(&Camera[i].Vel);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+92], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+96], 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+100], 0

; 1388 : 
; 1389 : 		Camera[i].CalcCamPos = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+8], 0

; 1390 : 		Camera[i].CalcCamLook = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 348				; 0000015cH
	mov	DWORD PTR ?Camera@@3PAUCameraStruct@@A[eax+12], 0

; 1391 : 	}

	jmp	$L81981
$L81978:

; 1392 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitCameras@@YAXXZ ENDP				; InitCameras
_TEXT	ENDS
PUBLIC	?SetProjMatrix@@YAXMMM@Z			; SetProjMatrix
PUBLIC	__real@43340000
PUBLIC	__real@3f000000
EXTRN	?D3Ddevice@@3PAUIDirect3DDevice3@@A:DWORD	; D3Ddevice
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SetProjMatrix@@YAXMMM@Z
_TEXT	SEGMENT
_mat$ = -76						; size = 64
_q$ = -12						; size = 4
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_n$ = 8							; size = 4
_f$ = 12						; size = 4
_fov$ = 16						; size = 4
?SetProjMatrix@@YAXMMM@Z PROC NEAR			; SetProjMatrix, COMDAT

; 1399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi

; 1400 : 	REAL c, s, q;
; 1401 : 	D3DMATRIX mat;
; 1402 : 
; 1403 : 	fov = fov * PI / 180;

	fld	DWORD PTR _fov$[ebp]
	fmul	DWORD PTR __real@40490fdb
	fdiv	DWORD PTR __real@43340000
	fstp	DWORD PTR _fov$[ebp]

; 1404 : 
; 1405 : 	c = (REAL)cos(fov * 0.5f);

	fld	DWORD PTR _fov$[ebp]
	fmul	DWORD PTR __real@3f000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 1406 : 	s = (REAL)sin(fov * 0.5f);

	fld	DWORD PTR _fov$[ebp]
	fmul	DWORD PTR __real@3f000000
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 1407 : 	q = s / (1.0f - n / f);

	fld	DWORD PTR _n$[ebp]
	fdiv	DWORD PTR _f$[ebp]
	fsubr	DWORD PTR __real@3f800000
	fdivr	DWORD PTR _s$[ebp]
	fstp	DWORD PTR _q$[ebp]

; 1408 : 
; 1409 : 	mat._11 = c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _mat$[ebp], eax

; 1410 : 	mat._12 = 0;

	mov	DWORD PTR _mat$[ebp+4], 0

; 1411 : 	mat._13 = 0;

	mov	DWORD PTR _mat$[ebp+8], 0

; 1412 : 	mat._14 = 0;

	mov	DWORD PTR _mat$[ebp+12], 0

; 1413 : 
; 1414 : 	mat._21 = 0;

	mov	DWORD PTR _mat$[ebp+16], 0

; 1415 : 	mat._22 = -c;

	fld	DWORD PTR _c$[ebp]
	fchs
	fstp	DWORD PTR _mat$[ebp+20]

; 1416 : 	mat._23 = 0;

	mov	DWORD PTR _mat$[ebp+24], 0

; 1417 : 	mat._24 = 0;

	mov	DWORD PTR _mat$[ebp+28], 0

; 1418 : 
; 1419 : 	mat._31 = 0;

	mov	DWORD PTR _mat$[ebp+32], 0

; 1420 : 	mat._32 = 0;

	mov	DWORD PTR _mat$[ebp+36], 0

; 1421 : 	mat._33 = q;

	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR _mat$[ebp+40], eax

; 1422 : 	mat._34 = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _mat$[ebp+44], eax

; 1423 : 
; 1424 : 	mat._41 = 0;

	mov	DWORD PTR _mat$[ebp+48], 0

; 1425 : 	mat._42 = 0;

	mov	DWORD PTR _mat$[ebp+52], 0

; 1426 : 	mat._43 = -q * n;

	fld	DWORD PTR _q$[ebp]
	fchs
	fmul	DWORD PTR _n$[ebp]
	fstp	DWORD PTR _mat$[ebp+56]

; 1427 : 	mat._44 = 0;

	mov	DWORD PTR _mat$[ebp+60], 0

; 1428 : 
; 1429 : 	D3Ddevice->SetTransform(D3DTRANSFORMSTATE_PROJECTION, &mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?D3Ddevice@@3PAUIDirect3DDevice3@@A ; D3Ddevice
	push	eax
	call	DWORD PTR [edx+100]

; 1430 : } 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetProjMatrix@@YAXMMM@Z ENDP				; SetProjMatrix
_TEXT	ENDS
PUBLIC	?LoadCameraNodes@@YAJPAU_iobuf@@@Z		; LoadCameraNodes
PUBLIC	?__LINE__Var@?1??LoadCameraNodes@@YAJPAU_iobuf@@@Z@4JA ; `LoadCameraNodes'::`2'::__LINE__Var
PUBLIC	__real@47800000
PUBLIC	__real@3a83126f
EXTRN	_fread:NEAR
EXTRN	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z:NEAR ; SetObjectVisiMask
;	COMDAT ?__LINE__Var@?1??LoadCameraNodes@@YAJPAU_iobuf@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadCameraNodes@@YAJPAU_iobuf@@@Z@4JA DD 05a1H ; `LoadCameraNodes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadCameraNodes@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
tv81 = -141						; size = 1
_bbox$ = -76						; size = 24
_fnode$ = -52						; size = 36
_cameraNode$ = -16					; size = 4
_nRead$ = -12						; size = 4
_nNodes$ = -8						; size = 4
_iNode$ = -4						; size = 4
_fp$ = 8						; size = 4
?LoadCameraNodes@@YAJPAU_iobuf@@@Z PROC NEAR		; LoadCameraNodes, COMDAT

; 1441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 1442 : 	long			iNode, nNodes;
; 1443 : 	size_t			nRead;
; 1444 : 	CAMNODE			*cameraNode;
; 1445 : 	FILE_CAM_NODE	fnode;
; 1446 : 	BOUNDING_BOX	bbox;
; 1447 : 	Assert(fp != NULL);

	push	OFFSET FLAT:??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadCameraNodes@@YAJPAU_iobuf@@@Z@4JA
	add	eax, 6
	push	eax
	cmp	DWORD PTR _fp$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1448 : 
; 1449 : 	// Read in the number of nodes
; 1450 : 	nRead = fread(&nNodes, sizeof(long), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _nNodes$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 1451 : 	if (nRead < 1) {

	cmp	DWORD PTR _nRead$[ebp], 1
	jae	SHORT $L82005

; 1452 : 		return -1;

	or	eax, -1
	jmp	$L81996
$L82005:

; 1453 : 	}
; 1454 : 
; 1455 : 	Assert((nNodes >= 0) && (nNodes < CAMERA_MAX_NODES));

	cmp	DWORD PTR _nNodes$[ebp], 0
	jl	SHORT $L82335
	cmp	DWORD PTR _nNodes$[ebp], 1024		; 00000400H
	jge	SHORT $L82335
	mov	BYTE PTR tv81[ebp], 1
	jmp	SHORT $L82336
$L82335:
	mov	BYTE PTR tv81[ebp], 0
$L82336:
	push	OFFSET FLAT:??_C@_0IL@DEODLMMH@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadCameraNodes@@YAJPAU_iobuf@@@Z@4JA
	add	eax, 14					; 0000000eH
	push	eax
	mov	cl, BYTE PTR tv81[ebp]
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1456 : 
; 1457 : 	// Load in the nodes
; 1458 : 	for (iNode = 0; iNode < nNodes; iNode++) {

	mov	DWORD PTR _iNode$[ebp], 0
	jmp	SHORT $L82006
$L82007:
	mov	eax, DWORD PTR _iNode$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNode$[ebp], eax
$L82006:
	mov	eax, DWORD PTR _iNode$[ebp]
	cmp	eax, DWORD PTR _nNodes$[ebp]
	jge	$L82008

; 1459 : 		cameraNode = &CAM_CameraNode[iNode];

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 40					; 00000028H
	add	eax, OFFSET FLAT:?CAM_CameraNode@@3PAUCamNodeStruct@@A ; CAM_CameraNode
	mov	DWORD PTR _cameraNode$[ebp], eax

; 1460 : 
; 1461 : 		nRead = fread(&fnode, sizeof(fnode), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	36					; 00000024H
	lea	ecx, DWORD PTR _fnode$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 1462 : 		if (nRead < 1) {

	cmp	DWORD PTR _nRead$[ebp], 1
	jae	SHORT $L82009

; 1463 : 			return -1;

	or	eax, -1
	jmp	$L81996
$L82009:

; 1464 : 		}
; 1465 : 
; 1466 : 		cameraNode->Type = fnode.Type;

	mov	eax, DWORD PTR _cameraNode$[ebp]
	mov	ecx, DWORD PTR _fnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1467 : 		cameraNode->Pos.v[X] = fnode.x / 65536.0f;

	fild	DWORD PTR _fnode$[ebp+4]
	fdiv	DWORD PTR __real@47800000
	mov	eax, DWORD PTR _cameraNode$[ebp]
	fstp	DWORD PTR [eax+8]

; 1468 : 		cameraNode->Pos.v[Y] = fnode.y / 65536.0f;

	fild	DWORD PTR _fnode$[ebp+8]
	fdiv	DWORD PTR __real@47800000
	mov	eax, DWORD PTR _cameraNode$[ebp]
	fstp	DWORD PTR [eax+12]

; 1469 : 		cameraNode->Pos.v[Z] = fnode.z / 65536.0f;

	fild	DWORD PTR _fnode$[ebp+12]
	fdiv	DWORD PTR __real@47800000
	mov	eax, DWORD PTR _cameraNode$[ebp]
	fstp	DWORD PTR [eax+16]

; 1470 : 		cameraNode->ZoomMod = MulScalar(Real(0.001), fnode.ZoomFactor);

	fild	DWORD PTR _fnode$[ebp+16]
	fmul	DWORD PTR __real@3a83126f
	mov	eax, DWORD PTR _cameraNode$[ebp]
	fstp	DWORD PTR [eax+20]

; 1471 : 		cameraNode->Link = fnode.Link;

	mov	eax, DWORD PTR _cameraNode$[ebp]
	mov	ecx, DWORD PTR _fnode$[ebp+20]
	mov	DWORD PTR [eax+24], ecx

; 1472 : 		cameraNode->ID = fnode.ID;

	mov	eax, DWORD PTR _cameraNode$[ebp]
	mov	ecx, DWORD PTR _fnode$[ebp+32]
	mov	DWORD PTR [eax+4], ecx

; 1473 : 
; 1474 : 		// visimask
; 1475 : 		bbox.Xmin = bbox.Xmax =	cameraNode->Pos.v[X];

	mov	eax, DWORD PTR _cameraNode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _bbox$[ebp+4], ecx
	mov	edx, DWORD PTR _bbox$[ebp+4]
	mov	DWORD PTR _bbox$[ebp], edx

; 1476 : 		bbox.Ymin = bbox.Ymax =	cameraNode->Pos.v[Y];

	mov	eax, DWORD PTR _cameraNode$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _bbox$[ebp+12], ecx
	mov	edx, DWORD PTR _bbox$[ebp+12]
	mov	DWORD PTR _bbox$[ebp+8], edx

; 1477 : 		bbox.Zmin = bbox.Zmax =	cameraNode->Pos.v[Z];

	mov	eax, DWORD PTR _cameraNode$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _bbox$[ebp+20], ecx
	mov	edx, DWORD PTR _bbox$[ebp+20]
	mov	DWORD PTR _bbox$[ebp+16], edx

; 1478 : 		cameraNode->VisiMask = SetObjectVisiMask(&bbox);

	lea	eax, DWORD PTR _bbox$[ebp]
	push	eax
	call	?SetObjectVisiMask@@YA_KPAUBoundingBoxStruct@@@Z ; SetObjectVisiMask
	add	esp, 4
	mov	ecx, DWORD PTR _cameraNode$[ebp]
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+36], edx

; 1479 : 	}

	jmp	$L82007
$L82008:

; 1480 : 
; 1481 : 	return nNodes;

	mov	eax, DWORD PTR _nNodes$[ebp]
$L81996:

; 1482 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadCameraNodes@@YAJPAU_iobuf@@@Z ENDP			; LoadCameraNodes
_TEXT	ENDS
PUBLIC	?TriggerCamera@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z ; TriggerCamera
; Function compile flags: /Odt /ZI
;	COMDAT ?TriggerCamera@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z
_TEXT	SEGMENT
_car$ = -8						; size = 4
_iNode$ = -4						; size = 4
_player$ = 8						; size = 4
_flag$ = 12						; size = 4
_n$ = 16						; size = 4
_vec$ = 20						; size = 4
?TriggerCamera@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z PROC NEAR ; TriggerCamera, COMDAT

; 1576 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1577 : 	long iNode;
; 1578 : 	CAR	*car;
; 1579 : 
; 1580 : 	car = &player->car;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 1581 : 
; 1582 : 	if ((player->LastValidRailCamNode != -1) && 
; 1583 : 		((CAM_CameraNode[player->LastValidRailCamNode].ID == n) || (CAM_CameraNode[CAM_CameraNode[player->LastValidRailCamNode].Link].ID == n))) 

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+10316], -1
	je	SHORT $L82019
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+10316]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[ecx+4]
	cmp	edx, DWORD PTR _n$[ebp]
	je	SHORT $L82020
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+10316]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[ecx+24]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[edx+4]
	cmp	eax, DWORD PTR _n$[ebp]
	jne	SHORT $L82019
$L82020:

; 1584 : 	{
; 1585 : 		player->ValidRailCamNode = player->LastValidRailCamNode;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+10316]
	mov	DWORD PTR [eax+10312], edx

; 1586 : 		return;

	jmp	SHORT $L82016
$L82019:

; 1587 : 	}
; 1588 : 	
; 1589 : 	for (iNode = 0; iNode < CAM_NCameraNodes; iNode++) {

	mov	DWORD PTR _iNode$[ebp], 0
	jmp	SHORT $L82021
$L82022:
	mov	eax, DWORD PTR _iNode$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNode$[ebp], eax
$L82021:
	mov	eax, DWORD PTR _iNode$[ebp]
	cmp	eax, DWORD PTR ?CAM_NCameraNodes@@3JA	; CAM_NCameraNodes
	jge	SHORT $L82016

; 1590 : 		if (CAM_CameraNode[iNode].ID == n) {

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR ?CAM_CameraNode@@3PAUCamNodeStruct@@A[eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $L82024

; 1591 : 			player->ValidRailCamNode = iNode;

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR _iNode$[ebp]
	mov	DWORD PTR [eax+10312], ecx

; 1592 : 			return;

	jmp	SHORT $L82016
$L82024:

; 1593 : 		}
; 1594 : 	}

	jmp	SHORT $L82022
$L82016:

; 1595 : 
; 1596 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TriggerCamera@@YAXPAUPlayerStruct@@JJPAUVectorStruct@@@Z ENDP ; TriggerCamera
_TEXT	ENDS
PUBLIC	__real@bf000000
EXTRN	?BaseGeomPers@@3MA:DWORD			; BaseGeomPers
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CalcCamZoom@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_dRLen$ = -16						; size = 4
_dR$ = -12						; size = 12
_camera$ = 8						; size = 4
?CalcCamZoom@@YAXPAUCameraStruct@@@Z PROC NEAR		; CalcCamZoom, COMDAT

; 1605 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1606 : 	VEC dR;
; 1607 : 	REAL dRLen;
; 1608 : 
; 1609 : 	VecMinusVec(&camera->WPos, &camera->Object->body.Centre.Pos, &dR);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+68]
	fsub	DWORD PTR [ecx+20]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+72]
	fsub	DWORD PTR [ecx+24]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [edx+76]
	fsub	DWORD PTR [ecx+28]
	fstp	DWORD PTR _dR$[ebp+8]

; 1610 : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 1611 : 
; 1612 : 	camera->Lens = camera->ZoomMod * (dRLen - BaseGeomPers);

	fld	DWORD PTR _dRLen$[ebp]
	fsub	DWORD PTR ?BaseGeomPers@@3MA		; BaseGeomPers
	mov	eax, DWORD PTR _camera$[ebp]
	fmul	DWORD PTR [eax+176]
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+168]

; 1613 : 	if (camera->Lens < MIN_LENS) camera->Lens = MIN_LENS;

	fld	DWORD PTR __real@bf000000
	fmul	DWORD PTR ?BaseGeomPers@@3MA		; BaseGeomPers
	mov	eax, DWORD PTR _camera$[ebp]
	fcomp	DWORD PTR [eax+168]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82027
	fld	DWORD PTR __real@bf000000
	fmul	DWORD PTR ?BaseGeomPers@@3MA		; BaseGeomPers
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+168]
$L82027:

; 1614 : 
; 1615 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcCamZoom@@YAXPAUCameraStruct@@@Z ENDP		; CalcCamZoom
_TEXT	ENDS
EXTRN	?SetCameraVisiMask@@YAXPAUVectorStruct@@@Z:NEAR	; SetCameraVisiMask
EXTRN	?CamVisiMask@@3_KA:QWORD			; CamVisiMask
; Function compile flags: /Odt /ZI
;	COMDAT ?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z
_TEXT	SEGMENT
tv147 = -112						; size = 8
_tempmask$ = -40					; size = 8
_nearNode$ = -32					; size = 4
_node$ = -28						; size = 4
_dR$ = -24						; size = 12
_nearDist$ = -12					; size = 4
_dist$ = -8						; size = 4
_iNode$ = -4						; size = 4
_type$ = 8						; size = 4
_pos$ = 12						; size = 4
?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z PROC NEAR ; NearestNode, COMDAT

; 1625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 1626 : 	int iNode;
; 1627 : 	REAL dist, nearDist;
; 1628 : 	VEC	dR;
; 1629 : 	CAMNODE *node, *nearNode;
; 1630 : 	VISIMASK tempmask;
; 1631 : 
; 1632 : 	nearNode = NULL;

	mov	DWORD PTR _nearNode$[ebp], 0

; 1633 : 	nearDist = LARGEDIST;

	mov	DWORD PTR _nearDist$[ebp], 1232348160	; 49742400H

; 1634 : 
; 1635 : 	tempmask = CamVisiMask;

	mov	eax, DWORD PTR ?CamVisiMask@@3_KA
	mov	DWORD PTR _tempmask$[ebp], eax
	mov	ecx, DWORD PTR ?CamVisiMask@@3_KA+4
	mov	DWORD PTR _tempmask$[ebp+4], ecx

; 1636 : 	SetCameraVisiMask(pos);

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?SetCameraVisiMask@@YAXPAUVectorStruct@@@Z ; SetCameraVisiMask
	add	esp, 4

; 1637 : 
; 1638 : 	for (iNode = 0; iNode < CAM_NCameraNodes; iNode++) {

	mov	DWORD PTR _iNode$[ebp], 0
	jmp	SHORT $L82043
$L82044:
	mov	eax, DWORD PTR _iNode$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNode$[ebp], eax
$L82043:
	mov	eax, DWORD PTR _iNode$[ebp]
	cmp	eax, DWORD PTR ?CAM_NCameraNodes@@3JA	; CAM_NCameraNodes
	jge	$L82045

; 1639 : 		node = &CAM_CameraNode[iNode];

	mov	eax, DWORD PTR _iNode$[ebp]
	imul	eax, 40					; 00000028H
	add	eax, OFFSET FLAT:?CAM_CameraNode@@3PAUCamNodeStruct@@A ; CAM_CameraNode
	mov	DWORD PTR _node$[ebp], eax

; 1640 : 
; 1641 : 		// good visimask?
; 1642 : 		if (CamVisiMask & node->VisiMask) continue;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR ?CamVisiMask@@3_KA
	and	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?CamVisiMask@@3_KA+4
	and	edx, DWORD PTR [eax+36]
	mov	DWORD PTR tv147[ebp], ecx
	mov	DWORD PTR tv147[ebp+4], edx
	mov	eax, DWORD PTR tv147[ebp]
	or	eax, DWORD PTR tv147[ebp+4]
	je	SHORT $L82046
	jmp	SHORT $L82044
$L82046:

; 1643 : 
; 1644 : 		// is this node of the desired type?
; 1645 : 		if ((type != -1) && (node->Type != type)) continue;

	cmp	DWORD PTR _type$[ebp], -1
	je	SHORT $L82047
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _type$[ebp]
	je	SHORT $L82047
	jmp	SHORT $L82044
$L82047:

; 1646 : 
; 1647 : 		// Get distance to node from pos
; 1648 : 		VecMinusVec(pos, &node->Pos, &dR);

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+16]
	fstp	DWORD PTR _dR$[ebp+8]

; 1649 : 		dist = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 1650 : 
; 1651 : 		// see if it is the closest so far
; 1652 : 		if (dist < nearDist) {

	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR _nearDist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82049

; 1653 : 			nearDist = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _nearDist$[ebp], eax

; 1654 : 			nearNode = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _nearNode$[ebp], eax
$L82049:

; 1655 : 		}
; 1656 : 	}

	jmp	$L82044
$L82045:

; 1657 : 
; 1658 : 	CamVisiMask = tempmask;

	mov	eax, DWORD PTR _tempmask$[ebp]
	mov	DWORD PTR ?CamVisiMask@@3_KA, eax
	mov	ecx, DWORD PTR _tempmask$[ebp+4]
	mov	DWORD PTR ?CamVisiMask@@3_KA+4, ecx

; 1659 : 
; 1660 : 	return nearNode;

	mov	eax, DWORD PTR _nearNode$[ebp]

; 1661 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z ENDP ; NearestNode
_TEXT	ENDS
_BSS	SEGMENT
?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A DD 01H DUP (?) ; `CameraNearestNodePos'::`2'::node
?oldNode@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A DD 01H DUP (?) ; `CameraNearestNodePos'::`2'::oldNode
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?CameraNearestNodePos@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_camera$ = 8						; size = 4
?CameraNearestNodePos@@YAXPAUCameraStruct@@@Z PROC NEAR	; CameraNearestNodePos, COMDAT

; 1671 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1672 : 	static CAMNODE *node, *oldNode;
; 1673 : 
; 1674 : 
; 1675 : 	// Make sure the camera is attached to an object
; 1676 : 	if (camera->Object == NULL) {

	mov	eax, DWORD PTR _camera$[ebp]
	cmp	DWORD PTR [eax+164], 0
	jne	SHORT $L82057

; 1677 : 		return;

	jmp	$L82052
$L82057:

; 1678 : 	}
; 1679 : 
; 1680 : 	// find the nearest node
; 1681 : 	oldNode = node;

	mov	eax, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	DWORD PTR ?oldNode@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A, eax

; 1682 : 	node = NearestNode(CAMNODE_STATIC, &camera->Object->body.Centre.Pos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 20					; 00000014H
	push	ecx
	push	1
	call	?NearestNode@@YAPAUCamNodeStruct@@JPAUVectorStruct@@@Z ; NearestNode
	add	esp, 8
	mov	DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A, eax

; 1683 : 	if (node == NULL) {

	cmp	DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A, 0
	jne	SHORT $L82058

; 1684 : 		return;

	jmp	$L82052
$L82058:

; 1685 : 	}
; 1686 : 	if (node != oldNode) {

	mov	eax, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	cmp	eax, DWORD PTR ?oldNode@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	je	SHORT $L82059

; 1687 : 		node = node;

	mov	eax, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A, eax
$L82059:

; 1688 : 	}
; 1689 : 
; 1690 : 	// Put camera at node position
; 1691 : 	CopyVec(&node->Pos, &camera->WPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+76], edx

; 1692 : 	CopyVec(&node->Pos, &camera->OldWPos);

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+84], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+88], edx

; 1693 : 
; 1694 : 	// Set zoom factor
; 1695 : 	camera->ZoomMod = node->ZoomMod;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR ?node@?1??CameraNearestNodePos@@YAXPAUCameraStruct@@@Z@4PAUCamNodeStruct@@A
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+176], edx
$L82052:

; 1696 : 
; 1697 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CameraNearestNodePos@@YAXPAUCameraStruct@@@Z ENDP	; CameraNearestNodePos
_TEXT	ENDS
PUBLIC	__real@41a00000
PUBLIC	__real@c3a00000
PUBLIC	__real@c3700000
PUBLIC	__real@43a00000
PUBLIC	__real@43700000
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@c3a00000
CONST	SEGMENT
__real@c3a00000 DD 0c3a00000r			; -320
CONST	ENDS
;	COMDAT __real@c3700000
CONST	SEGMENT
__real@c3700000 DD 0c3700000r			; -240
CONST	ENDS
;	COMDAT __real@43a00000
CONST	SEGMENT
__real@43a00000 DD 043a00000r			; 320
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CalcCameraCollPoly@@YAXPAUCameraStruct@@@Z
_TEXT	SEGMENT
_cPos$ = -24						; size = 12
_screenPos$ = -12					; size = 12
_camera$ = 8						; size = 4
?CalcCameraCollPoly@@YAXPAUCameraStruct@@@Z PROC NEAR	; CalcCameraCollPoly, COMDAT

; 1707 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1708 : 	VEC screenPos, cPos;
; 1709 : 
; 1710 : 	// calculate the mid-point of the camera plane
; 1711 : 	VecPlusScalarVec(&camera->WPos, RenderSettings.NearClip + 20, &camera->WMatrix.mv[L], &screenPos);

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fadd	DWORD PTR __real@41a00000
	mov	eax, DWORD PTR _camera$[ebp]
	fmul	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [ecx+68]
	fstp	DWORD PTR _screenPos$[ebp]
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fadd	DWORD PTR __real@41a00000
	mov	eax, DWORD PTR _camera$[ebp]
	fmul	DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [ecx+72]
	fstp	DWORD PTR _screenPos$[ebp+4]
	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+28
	fadd	DWORD PTR __real@41a00000
	mov	eax, DWORD PTR _camera$[ebp]
	fmul	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _camera$[ebp]
	fadd	DWORD PTR [ecx+76]
	fstp	DWORD PTR _screenPos$[ebp+8]

; 1712 : 
; 1713 : 	// Calculate the face plane
; 1714 : 	SetPlane(&camera->CollPoly.Plane, 
; 1715 : 		camera->WMatrix.m[LX],
; 1716 : 		camera->WMatrix.m[LY],
; 1717 : 		camera->WMatrix.m[LZ],
; 1718 : 		-VecDotVec(&screenPos, &camera->WMatrix.mv[L]));

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+200], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+204], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+208], edx
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _screenPos$[ebp]
	fmul	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _screenPos$[ebp+4]
	fmul	DWORD PTR [ecx+44]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _screenPos$[ebp+8]
	fmul	DWORD PTR [edx+48]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+212]

; 1719 : 
; 1720 : 	// Calculate the edge plane
; 1721 : 	VecPlusScalarVec(&screenPos, -REAL_SCREEN_XHALF, &camera->WMatrix.mv[R], &cPos);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@c3a00000
	fmul	DWORD PTR [eax+16]
	fadd	DWORD PTR _screenPos$[ebp]
	fstp	DWORD PTR _cPos$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@c3a00000
	fmul	DWORD PTR [eax+20]
	fadd	DWORD PTR _screenPos$[ebp+4]
	fstp	DWORD PTR _cPos$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@c3a00000
	fmul	DWORD PTR [eax+24]
	fadd	DWORD PTR _screenPos$[ebp+8]
	fstp	DWORD PTR _cPos$[ebp+8]

; 1722 : 	SetPlane(&camera->CollPoly.EdgePlane[0], 
; 1723 : 		-camera->WMatrix.m[RX],
; 1724 : 		-camera->WMatrix.m[RY],
; 1725 : 		-camera->WMatrix.m[RZ],
; 1726 : 		VecDotVec(&cPos, &camera->WMatrix.mv[R]));

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+16]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+216]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+20]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+220]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+224]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+4]
	fmul	DWORD PTR [ecx+20]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+228]

; 1727 : 
; 1728 : 	VecPlusScalarVec(&screenPos, -REAL_SCREEN_YHALF, &camera->WMatrix.mv[U], &cPos);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@c3700000
	fmul	DWORD PTR [eax+28]
	fadd	DWORD PTR _screenPos$[ebp]
	fstp	DWORD PTR _cPos$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@c3700000
	fmul	DWORD PTR [eax+32]
	fadd	DWORD PTR _screenPos$[ebp+4]
	fstp	DWORD PTR _cPos$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@c3700000
	fmul	DWORD PTR [eax+36]
	fadd	DWORD PTR _screenPos$[ebp+8]
	fstp	DWORD PTR _cPos$[ebp+8]

; 1729 : 	SetPlane(&camera->CollPoly.EdgePlane[1], 
; 1730 : 		-camera->WMatrix.m[UX],
; 1731 : 		-camera->WMatrix.m[UY],
; 1732 : 		-camera->WMatrix.m[UZ],
; 1733 : 		VecDotVec(&cPos, &camera->WMatrix.mv[U]));

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+232]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+32]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+36]
	fchs
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+240]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+4]
	fmul	DWORD PTR [ecx+32]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+8]
	fmul	DWORD PTR [edx+36]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+244]

; 1734 : 
; 1735 : 	VecPlusScalarVec(&screenPos, REAL_SCREEN_XHALF, &camera->WMatrix.mv[R], &cPos);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@43a00000
	fmul	DWORD PTR [eax+16]
	fadd	DWORD PTR _screenPos$[ebp]
	fstp	DWORD PTR _cPos$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@43a00000
	fmul	DWORD PTR [eax+20]
	fadd	DWORD PTR _screenPos$[ebp+4]
	fstp	DWORD PTR _cPos$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@43a00000
	fmul	DWORD PTR [eax+24]
	fadd	DWORD PTR _screenPos$[ebp+8]
	fstp	DWORD PTR _cPos$[ebp+8]

; 1736 : 	SetPlane(&camera->CollPoly.EdgePlane[2], 
; 1737 : 		camera->WMatrix.m[RX],
; 1738 : 		camera->WMatrix.m[RY],
; 1739 : 		camera->WMatrix.m[RZ],
; 1740 : 		-VecDotVec(&cPos, &camera->WMatrix.mv[R]));

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+248], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+252], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+256], edx
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+4]
	fmul	DWORD PTR [ecx+20]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+260]

; 1741 : 
; 1742 : 	VecPlusScalarVec(&screenPos, REAL_SCREEN_YHALF, &camera->WMatrix.mv[U], &cPos);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@43700000
	fmul	DWORD PTR [eax+28]
	fadd	DWORD PTR _screenPos$[ebp]
	fstp	DWORD PTR _cPos$[ebp]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@43700000
	fmul	DWORD PTR [eax+32]
	fadd	DWORD PTR _screenPos$[ebp+4]
	fstp	DWORD PTR _cPos$[ebp+4]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR __real@43700000
	fmul	DWORD PTR [eax+36]
	fadd	DWORD PTR _screenPos$[ebp+8]
	fstp	DWORD PTR _cPos$[ebp+8]

; 1743 : 	SetPlane(&camera->CollPoly.EdgePlane[3], 
; 1744 : 		camera->WMatrix.m[UX],
; 1745 : 		camera->WMatrix.m[UY],
; 1746 : 		camera->WMatrix.m[UZ],
; 1747 : 		-VecDotVec(&cPos, &camera->WMatrix.mv[U]));

	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+264], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+268], edx
	mov	eax, DWORD PTR _camera$[ebp]
	mov	ecx, DWORD PTR _camera$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+272], edx
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+4]
	fmul	DWORD PTR [ecx+32]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _camera$[ebp]
	fld	DWORD PTR _cPos$[ebp+8]
	fmul	DWORD PTR [edx+36]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [eax+276]

; 1748 : 
; 1749 : 	// Set other stuff
; 1750 : 	camera->CollPoly.Type = QUAD;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+192], 1

; 1751 : 	camera->CollPoly.Material = MATERIAL_GLASS;

	mov	eax, DWORD PTR _camera$[ebp]
	mov	DWORD PTR [eax+196], 9

; 1752 : 
; 1753 : 	SetBBox(&camera->CollPoly.BBox, 
; 1754 : 		camera->WPos.v[X] - REAL_SCREEN_XHALF,
; 1755 : 		camera->WPos.v[X] + REAL_SCREEN_XHALF,
; 1756 : 		camera->WPos.v[Y] - REAL_SCREEN_XHALF,
; 1757 : 		camera->WPos.v[Y] + REAL_SCREEN_XHALF,
; 1758 : 		camera->WPos.v[Z] - REAL_SCREEN_XHALF,
; 1759 : 		camera->WPos.v[Z] + REAL_SCREEN_XHALF);

	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fsub	DWORD PTR __real@43a00000
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+280]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+68]
	fadd	DWORD PTR __real@43a00000
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+284]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR __real@43a00000
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+288]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+72]
	fadd	DWORD PTR __real@43a00000
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+292]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fsub	DWORD PTR __real@43a00000
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+296]
	mov	eax, DWORD PTR _camera$[ebp]
	fld	DWORD PTR [eax+76]
	fadd	DWORD PTR __real@43a00000
	mov	ecx, DWORD PTR _camera$[ebp]
	fstp	DWORD PTR [ecx+300]

; 1760 : 
; 1761 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcCameraCollPoly@@YAXPAUCameraStruct@@@Z ENDP	; CalcCameraCollPoly
_TEXT	ENDS
END
