; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\Geom.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NearPointOnLine@@YAMPAUVectorStruct@@000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotMatrixX@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotMatrixY@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotMatrixZ@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotTransPersVectorZleave@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotTransPersVectorZbias@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MulMatrix@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransposeMatrix@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyMatrix@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildMatrixFromLook@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Interpolate3D@@YAXPAUVectorStruct@@00M0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QuadInterpVec@@YAXPAUVectorStruct@@M0M0MM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LInterpVec@@YAXPAUVectorStruct@@M0MM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatMulThisVec@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatMulTransMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransMatMulMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatMulMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildRotation3D@@YAXMMMMPATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotationX@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotationY@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotationZ@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyMat@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMatUnit@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMatZero@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatMulScalar@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SwapVecs@@YAXPAUVectorStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransMat@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvertMat@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatPlusMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatPlusEqScalarMat@@YAXPATMatrixUnion@@M0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildMatFromVec@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildPlane2@@YAXPAUVectorStruct@@0PAUPlaneStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QuatRotVec@@YAXPAUQuaternionStruct@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TestLinePoint@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?BaseGeomPers@@3MA				; BaseGeomPers
PUBLIC	?ScreenLeftClip@@3MA				; ScreenLeftClip
PUBLIC	?ScreenRightClip@@3MA				; ScreenRightClip
PUBLIC	?ScreenTopClip@@3MA				; ScreenTopClip
PUBLIC	?ScreenBottomClip@@3MA				; ScreenBottomClip
PUBLIC	?ScreenLeftClipGuard@@3MA			; ScreenLeftClipGuard
PUBLIC	?ScreenRightClipGuard@@3MA			; ScreenRightClipGuard
PUBLIC	?ScreenTopClipGuard@@3MA			; ScreenTopClipGuard
PUBLIC	?ScreenBottomClipGuard@@3MA			; ScreenBottomClipGuard
PUBLIC	?IdentityMatrix@@3TMatrixUnion@@A		; IdentityMatrix
PUBLIC	?Identity@@3TMatrixUnion@@A			; Identity
PUBLIC	?ZeroVector@@3UVectorStruct@@A			; ZeroVector
PUBLIC	?DownVec@@3UVectorStruct@@A			; DownVec
PUBLIC	?UpVec@@3UVectorStruct@@A			; UpVec
PUBLIC	?RightVec@@3UVectorStruct@@A			; RightVec
PUBLIC	?LeftVec@@3UVectorStruct@@A			; LeftVec
PUBLIC	?LookVec@@3UVectorStruct@@A			; LookVec
PUBLIC	?NegLookVec@@3UVectorStruct@@A			; NegLookVec
PUBLIC	?IdentityQuat@@3UQuaternionStruct@@A		; IdentityQuat
_BSS	SEGMENT
?ScreenLeftClip@@3MA DD 01H DUP (?)			; ScreenLeftClip
?ScreenRightClip@@3MA DD 01H DUP (?)			; ScreenRightClip
?ScreenTopClip@@3MA DD 01H DUP (?)			; ScreenTopClip
?ScreenBottomClip@@3MA DD 01H DUP (?)			; ScreenBottomClip
?ScreenLeftClipGuard@@3MA DD 01H DUP (?)		; ScreenLeftClipGuard
?ScreenRightClipGuard@@3MA DD 01H DUP (?)		; ScreenRightClipGuard
?ScreenTopClipGuard@@3MA DD 01H DUP (?)			; ScreenTopClipGuard
?ScreenBottomClipGuard@@3MA DD 01H DUP (?)		; ScreenBottomClipGuard
?ZeroVector@@3UVectorStruct@@A DB 0cH DUP (?)		; ZeroVector
_BSS	ENDS
_DATA	SEGMENT
?BaseGeomPers@@3MA DD 044200000r		; 640	; BaseGeomPers
?IdentityMatrix@@3TMatrixUnion@@A DD 03f800000r	; 1	; IdentityMatrix
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?Identity@@3TMatrixUnion@@A DD 03f800000r	; 1	; Identity
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?DownVec@@3UVectorStruct@@A DD 000000000r	; 0	; DownVec
	DD	03f800000r			; 1
	DD	000000000r			; 0
?UpVec@@3UVectorStruct@@A DD 000000000r		; 0	; UpVec
	DD	0bf800000r			; -1
	DD	000000000r			; 0
?RightVec@@3UVectorStruct@@A DD 03f800000r	; 1	; RightVec
	DD	000000000r			; 0
	DD	000000000r			; 0
?LeftVec@@3UVectorStruct@@A DD 0bf800000r	; -1	; LeftVec
	DD	000000000r			; 0
	DD	000000000r			; 0
?LookVec@@3UVectorStruct@@A DD 000000000r	; 0	; LookVec
	DD	000000000r			; 0
	DD	03f800000r			; 1
?NegLookVec@@3UVectorStruct@@A DD 000000000r	; 0	; NegLookVec
	DD	000000000r			; 0
	DD	0bf800000r			; -1
?IdentityQuat@@3UQuaternionStruct@@A DD 000000000r ; 0	; IdentityQuat
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
PUBLIC	?NearPointOnLine@@YAMPAUVectorStruct@@000@Z	; NearPointOnLine
EXTRN	__fltused:NEAR
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\geom.cpp
;	COMDAT ?NearPointOnLine@@YAMPAUVectorStruct@@000@Z
_TEXT	SEGMENT
_rP$ = -36						; size = 12
_dR$ = -24						; size = 12
_t$ = -12						; size = 4
_rPdR$ = -8						; size = 4
_dRdR$ = -4						; size = 4
_r0$ = 8						; size = 4
_r1$ = 12						; size = 4
_p$ = 16						; size = 4
_rN$ = 20						; size = 4
?NearPointOnLine@@YAMPAUVectorStruct@@000@Z PROC NEAR	; NearPointOnLine, COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 43   : 	REAL	dRdR, rPdR, t;
; 44   : 	VEC	dR, rP;
; 45   : 
; 46   : 	VecMinusVec(r0, p, &rP);

	mov	eax, DWORD PTR _r0$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _rP$[ebp]
	mov	eax, DWORD PTR _r0$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _rP$[ebp+4]
	mov	eax, DWORD PTR _r0$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _rP$[ebp+8]

; 47   : 	VecMinusVec(r1, r0, &dR);

	mov	eax, DWORD PTR _r1$[ebp]
	mov	ecx, DWORD PTR _r0$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _r1$[ebp]
	mov	ecx, DWORD PTR _r0$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _r1$[ebp]
	mov	ecx, DWORD PTR _r0$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 48   : 
; 49   : 	dRdR = VecDotVec(&dR, &dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dRdR$[ebp]

; 50   : 	rPdR = VecDotVec(&rP, &dR);

	fld	DWORD PTR _rP$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _rP$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _rP$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rPdR$[ebp]

; 51   : 
; 52   : 	t = - rPdR / dRdR;

	fld	DWORD PTR _rPdR$[ebp]
	fchs
	fdiv	DWORD PTR _dRdR$[ebp]
	fstp	DWORD PTR _t$[ebp]

; 53   : 
; 54   : 	VecPlusScalarVec(r0, t, &dR, rN);

	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _r0$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rN$[ebp]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _r0$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rN$[ebp]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _r0$[ebp]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rN$[ebp]
	fstp	DWORD PTR [ecx+8]

; 55   : 
; 56   : 	return t;

	fld	DWORD PTR _t$[ebp]

; 57   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NearPointOnLine@@YAMPAUVectorStruct@@000@Z ENDP	; NearPointOnLine
_TEXT	ENDS
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?RotMatrixX@@YAXPATMatrixUnion@@M@Z		; RotMatrixX
PUBLIC	__real@40c90fdb
PUBLIC	?sin@@YAMM@Z					; sin
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RotMatrixX@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_mat$ = 8						; size = 4
_rot$ = 12						; size = 4
?RotMatrixX@@YAXPATMatrixUnion@@M@Z PROC NEAR		; RotMatrixX, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 66   : 	REAL c, s;
; 67   : 
; 68   : 	rot *= RAD;

	fld	DWORD PTR _rot$[ebp]
	fmul	DWORD PTR __real@40c90fdb
	fstp	DWORD PTR _rot$[ebp]

; 69   : 	c = (REAL)cos(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 70   : 	s = (REAL)sin(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 71   : 	
; 72   : 	mat->m[RX] = 1;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 73   : 	mat->m[RY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+4], 0

; 74   : 	mat->m[RZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0

; 75   : 
; 76   : 	mat->m[UX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+12], 0

; 77   : 	mat->m[UY] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 78   : 	mat->m[UZ] = -s;

	fld	DWORD PTR _s$[ebp]
	fchs
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+20]

; 79   : 
; 80   : 	mat->m[LX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+24], 0

; 81   : 	mat->m[LY] = s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 82   : 	mat->m[LZ] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotMatrixX@@YAXPATMatrixUnion@@M@Z ENDP		; RotMatrixX
_TEXT	ENDS
PUBLIC	?RotMatrixY@@YAXPATMatrixUnion@@M@Z		; RotMatrixY
; Function compile flags: /Odt /ZI
;	COMDAT ?RotMatrixY@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_mat$ = 8						; size = 4
_rot$ = 12						; size = 4
?RotMatrixY@@YAXPATMatrixUnion@@M@Z PROC NEAR		; RotMatrixY, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 91   : 	REAL c, s;
; 92   : 
; 93   : 	rot *= RAD;

	fld	DWORD PTR _rot$[ebp]
	fmul	DWORD PTR __real@40c90fdb
	fstp	DWORD PTR _rot$[ebp]

; 94   : 	c = (REAL)cos(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 95   : 	s = (REAL)sin(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 96   : 
; 97   : 	mat->m[RX] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], ecx

; 98   : 	mat->m[RY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+4], 0

; 99   : 	mat->m[RZ] = s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 100  : 
; 101  : 	mat->m[UX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+12], 0

; 102  : 	mat->m[UY] = 1;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H

; 103  : 	mat->m[UZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+20], 0

; 104  : 
; 105  : 	mat->m[LX] = -s;

	fld	DWORD PTR _s$[ebp]
	fchs
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+24]

; 106  : 	mat->m[LY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+28], 0

; 107  : 	mat->m[LZ] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotMatrixY@@YAXPATMatrixUnion@@M@Z ENDP		; RotMatrixY
_TEXT	ENDS
PUBLIC	?RotMatrixZ@@YAXPATMatrixUnion@@M@Z		; RotMatrixZ
; Function compile flags: /Odt /ZI
;	COMDAT ?RotMatrixZ@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_mat$ = 8						; size = 4
_rot$ = 12						; size = 4
?RotMatrixZ@@YAXPATMatrixUnion@@M@Z PROC NEAR		; RotMatrixZ, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 116  : 	REAL c, s;
; 117  : 
; 118  : 	rot *= RAD;

	fld	DWORD PTR _rot$[ebp]
	fmul	DWORD PTR __real@40c90fdb
	fstp	DWORD PTR _rot$[ebp]

; 119  : 	c = (REAL)cos(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 120  : 	s = (REAL)sin(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 121  : 
; 122  : 	mat->m[RX] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], ecx

; 123  : 	mat->m[RY] = -s;

	fld	DWORD PTR _s$[ebp]
	fchs
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+4]

; 124  : 	mat->m[RZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0

; 125  : 
; 126  : 	mat->m[UX] = s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 127  : 	mat->m[UY] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 128  : 	mat->m[UZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+20], 0

; 129  : 
; 130  : 	mat->m[LX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+24], 0

; 131  : 	mat->m[LY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+28], 0

; 132  : 	mat->m[LZ] = 1;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H

; 133  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotMatrixZ@@YAXPATMatrixUnion@@M@Z ENDP		; RotMatrixZ
_TEXT	ENDS
PUBLIC	?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z		; RotMatrixZYX
; Function compile flags: /Odt /ZI
;	COMDAT ?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z
_TEXT	SEGMENT
_sz$ = -24						; size = 4
_sy$ = -20						; size = 4
_sx$ = -16						; size = 4
_cz$ = -12						; size = 4
_cy$ = -8						; size = 4
_cx$ = -4						; size = 4
_mat$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z PROC NEAR	; RotMatrixZYX, COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 141  : 	REAL cx, cy, cz, sx, sy, sz;
; 142  : 
; 143  : 	cx = (REAL)cos(x * RAD);

	fld	DWORD PTR _x$[ebp]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cx$[ebp]

; 144  : 	cy = (REAL)cos(-y * RAD);

	fld	DWORD PTR _y$[ebp]
	fchs
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cy$[ebp]

; 145  : 	cz = (REAL)cos(z * RAD);

	fld	DWORD PTR _z$[ebp]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cz$[ebp]

; 146  : 	sx = (REAL)sin(x * RAD);

	fld	DWORD PTR _x$[ebp]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sx$[ebp]

; 147  : 	sy = (REAL)sin(-y * RAD);

	fld	DWORD PTR _y$[ebp]
	fchs
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sy$[ebp]

; 148  : 	sz = (REAL)sin(z * RAD);

	fld	DWORD PTR _z$[ebp]
	fmul	DWORD PTR __real@40c90fdb
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sz$[ebp]

; 149  : 
; 150  : 	mat->m[RX] = cy * cz;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _cz$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax]

; 151  : 	mat->m[RY] = -cy * sz;

	fld	DWORD PTR _cy$[ebp]
	fchs
	fmul	DWORD PTR _sz$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+4]

; 152  : 	mat->m[RZ] = -sy;

	fld	DWORD PTR _sy$[ebp]
	fchs
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+8]

; 153  : 
; 154  : 	mat->m[UX] = cx * sz - sx * sy * cz;

	fld	DWORD PTR _cx$[ebp]
	fmul	DWORD PTR _sz$[ebp]
	fld	DWORD PTR _sx$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _cz$[ebp]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+12]

; 155  : 	mat->m[UY] = sx * sy * sz + cx * cz;

	fld	DWORD PTR _sx$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _sz$[ebp]
	fld	DWORD PTR _cx$[ebp]
	fmul	DWORD PTR _cz$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+16]

; 156  : 	mat->m[UZ] = -sx * cy;

	fld	DWORD PTR _sx$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+20]

; 157  : 
; 158  : 	mat->m[LX] = cx * sy * cz + sx * sz;

	fld	DWORD PTR _cx$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _cz$[ebp]
	fld	DWORD PTR _sx$[ebp]
	fmul	DWORD PTR _sz$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+24]

; 159  : 	mat->m[LY] = sx * cz - cx * sy * sz;

	fld	DWORD PTR _sx$[ebp]
	fmul	DWORD PTR _cz$[ebp]
	fld	DWORD PTR _cx$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _sz$[ebp]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+28]

; 160  : 	mat->m[LZ] = cx * cy;

	fld	DWORD PTR _cx$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+32]

; 161  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotMatrixZYX@@YAXPATMatrixUnion@@MMM@Z ENDP		; RotMatrixZYX
_TEXT	ENDS
PUBLIC	?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; RotVector
; Function compile flags: /Odt /ZI
;	COMDAT ?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_in$ = 12						; size = 4
_out$ = 16						; size = 4
?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z PROC NEAR ; RotVector, COMDAT

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : 	out->v[X] = in->v[X] * mat->m[RX] + in->v[Y] * mat->m[UX] + in->v[Z] * mat->m[LX];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax]

; 170  : 	out->v[Y] = in->v[X] * mat->m[RY] + in->v[Y] * mat->m[UY] + in->v[Z] * mat->m[LY];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+4]

; 171  : 	out->v[Z] = in->v[X] * mat->m[RZ] + in->v[Y] * mat->m[UZ] + in->v[Z] * mat->m[LZ];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+8]

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ENDP ; RotVector
_TEXT	ENDS
PUBLIC	?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; TransposeRotVector
; Function compile flags: /Odt /ZI
;	COMDAT ?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_in$ = 12						; size = 4
_out$ = 16						; size = 4
?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z PROC NEAR ; TransposeRotVector, COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 180  : 	out->v[X] = in->v[X] * mat->m[RX] + in->v[Y] * mat->m[RY] + in->v[Z] * mat->m[RZ];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax]

; 181  : 	out->v[Y] = in->v[X] * mat->m[UX] + in->v[Y] * mat->m[UY] + in->v[Z] * mat->m[UZ];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+4]

; 182  : 	out->v[Z] = in->v[X] * mat->m[LX] + in->v[Y] * mat->m[LY] + in->v[Z] * mat->m[LZ];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+8]

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransposeRotVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ENDP ; TransposeRotVector
_TEXT	ENDS
PUBLIC	?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ; RotTransVector
; Function compile flags: /Odt /ZI
;	COMDAT ?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_trans$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z PROC NEAR ; RotTransVector, COMDAT

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 191  : 	out->v[X] = in->v[X] * mat->m[RX] + in->v[Y] * mat->m[UX] + in->v[Z] * mat->m[LX] + trans->v[X];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx]

; 192  : 	out->v[Y] = in->v[X] * mat->m[RY] + in->v[Y] * mat->m[UY] + in->v[Z] * mat->m[LY] + trans->v[Y];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx+4]

; 193  : 	out->v[Z] = in->v[X] * mat->m[RZ] + in->v[Y] * mat->m[UZ] + in->v[Z] * mat->m[LZ] + trans->v[Z];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx+8]

; 194  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotTransVector@@YAXPATMatrixUnion@@PAUVectorStruct@@11@Z ENDP ; RotTransVector
_TEXT	ENDS
PUBLIC	?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVector
PUBLIC	__real@3f800000
EXTRN	?RenderSettings@@3URENDER_SETTINGS@@A:BYTE	; RenderSettings
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT
_z$ = -4						; size = 4
_mat$ = 8						; size = 4
_trans$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z PROC NEAR ; RotTransPersVector, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 202  : 	REAL z;
; 203  : 
; 204  : 	z = in->v[X] * mat->m[RZ] + in->v[Y] * mat->m[UZ] + in->v[Z] * mat->m[LZ] + trans->v[Z];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _z$[ebp]

; 205  : 	if (z < 1) z = 1;

	fld	DWORD PTR _z$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76396
	mov	DWORD PTR _z$[ebp], 1065353216		; 3f800000H
$L76396:

; 206  : 
; 207  : 	out[0] = (in->v[X] * mat->m[RX] + in->v[Y] * mat->m[UX] + in->v[Z] * mat->m[LX] + trans->v[X]) / z + RenderSettings.GeomCentreX;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+4
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx]

; 208  : 	out[1] = (in->v[X] * mat->m[RY] + in->v[Y] * mat->m[UY] + in->v[Z] * mat->m[LY] + trans->v[Y]) / z + RenderSettings.GeomCentreY;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+4]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+8
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx+4]

; 209  : 
; 210  : 	out[3] = 1 / z;

	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+12]

; 211  : 	out[2] = GET_ZBUFFER(z);

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+36
	fmul	DWORD PTR _z$[ebp]
	fdivr	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+44
	fsubr	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+40
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+8]

; 212  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotTransPersVector@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ENDP ; RotTransPersVector
_TEXT	ENDS
PUBLIC	?RotTransPersVectorZleave@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ; RotTransPersVectorZleave
; Function compile flags: /Odt /ZI
;	COMDAT ?RotTransPersVectorZleave@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT
_z$ = -4						; size = 4
_mat$ = 8						; size = 4
_trans$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
?RotTransPersVectorZleave@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z PROC NEAR ; RotTransPersVectorZleave, COMDAT

; 219  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 220  : 	REAL z;
; 221  : 
; 222  : 	z = in->v[X] * mat->m[RZ] + in->v[Y] * mat->m[UZ] + in->v[Z] * mat->m[LZ] + trans->v[Z];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _z$[ebp]

; 223  : 	out[0] = (in->v[X] * mat->m[RX] + in->v[Y] * mat->m[UX] + in->v[Z] * mat->m[LX] + trans->v[X]) / z + RenderSettings.GeomCentreX;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+4
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx]

; 224  : 	out[1] = (in->v[X] * mat->m[RY] + in->v[Y] * mat->m[UY] + in->v[Z] * mat->m[LY] + trans->v[Y]) / z + RenderSettings.GeomCentreY;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+4]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+8
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx+4]

; 225  : 
; 226  : 	out[3] = 1 / z;

	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+12]

; 227  : 	out[2] = GET_ZBUFFER(z);

	fld	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+36
	fmul	DWORD PTR _z$[ebp]
	fdivr	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+44
	fsubr	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+40
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+8]

; 228  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotTransPersVectorZleave@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAM@Z ENDP ; RotTransPersVectorZleave
_TEXT	ENDS
PUBLIC	?RotTransPersVectorZbias@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAMM@Z ; RotTransPersVectorZbias
; Function compile flags: /Odt /ZI
;	COMDAT ?RotTransPersVectorZbias@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAMM@Z
_TEXT	SEGMENT
_z$ = -4						; size = 4
_mat$ = 8						; size = 4
_trans$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
_zbias$ = 24						; size = 4
?RotTransPersVectorZbias@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAMM@Z PROC NEAR ; RotTransPersVectorZbias, COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 236  : 	REAL z;
; 237  : 
; 238  : 	z = in->v[X] * mat->m[RZ] + in->v[Y] * mat->m[UZ] + in->v[Z] * mat->m[LZ] + trans->v[Z];

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _z$[ebp]

; 239  : 	if (z < 1) z = 1;

	fld	DWORD PTR _z$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76412
	mov	DWORD PTR _z$[ebp], 1065353216		; 3f800000H
$L76412:

; 240  : 
; 241  : 	out[0] = (in->v[X] * mat->m[RX] + in->v[Y] * mat->m[UX] + in->v[Z] * mat->m[LX] + trans->v[X]) / z + RenderSettings.GeomCentreX;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+4
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx]

; 242  : 	out[1] = (in->v[X] * mat->m[RY] + in->v[Y] * mat->m[UY] + in->v[Z] * mat->m[LY] + trans->v[Y]) / z + RenderSettings.GeomCentreY;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _trans$[ebp]
	fadd	DWORD PTR [eax+4]
	fdiv	DWORD PTR _z$[ebp]
	fadd	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+8
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx+4]

; 243  : 
; 244  : 	out[3] = 1 / z;

	fld	DWORD PTR __real@3f800000
	fdiv	DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+12]

; 245  : 	out[2] = GET_ZBUFFER(z + zbias);

	fld	DWORD PTR _z$[ebp]
	fadd	DWORD PTR _zbias$[ebp]
	fmul	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+36
	fdivr	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+44
	fsubr	DWORD PTR ?RenderSettings@@3URENDER_SETTINGS@@A+40
	mov	eax, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [eax+8]

; 246  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotTransPersVectorZbias@@YAXPATMatrixUnion@@PAUVectorStruct@@1PAMM@Z ENDP ; RotTransPersVectorZbias
_TEXT	ENDS
PUBLIC	?MulMatrix@@YAXPATMatrixUnion@@00@Z		; MulMatrix
; Function compile flags: /Odt /ZI
;	COMDAT ?MulMatrix@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT
_k$ = -3						; size = 1
_j$ = -2						; size = 1
_i$ = -1						; size = 1
_one$ = 8						; size = 4
_two$ = 12						; size = 4
_out$ = 16						; size = 4
?MulMatrix@@YAXPATMatrixUnion@@00@Z PROC NEAR		; MulMatrix, COMDAT

; 253  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 254  : 	char i, j, k;
; 255  : 
; 256  : 	for (i = 0 ; i < 9 ; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L76421
$L76422:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L76421:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 9
	jge	SHORT $L76423

; 257  : 		out->m[i] = 0;

	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	jmp	SHORT $L76422
$L76423:

; 258  : 
; 259  : 	for (i = 0 ; i < 3 ; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $L76424
$L76425:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$L76424:
	movsx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 3
	jge	$L76417

; 260  : 		for (j = 0 ; j < 3 ; j++)

	mov	BYTE PTR _j$[ebp], 0
	jmp	SHORT $L76427
$L76428:
	mov	al, BYTE PTR _j$[ebp]
	add	al, 1
	mov	BYTE PTR _j$[ebp], al
$L76427:
	movsx	eax, BYTE PTR _j$[ebp]
	cmp	eax, 3
	jge	SHORT $L76429

; 261  : 			for (k = 0 ; k < 3 ; k++)

	mov	BYTE PTR _k$[ebp], 0
	jmp	SHORT $L76430
$L76431:
	mov	al, BYTE PTR _k$[ebp]
	add	al, 1
	mov	BYTE PTR _k$[ebp], al
$L76430:
	movsx	eax, BYTE PTR _k$[ebp]
	cmp	eax, 3
	jge	SHORT $L76432

; 262  : 				out->m[i * 3 + j] += one->m[k * 3 + j] * two->m[i * 3 + k];

	movsx	eax, BYTE PTR _i$[ebp]
	imul	eax, 3
	movsx	ecx, BYTE PTR _j$[ebp]
	add	eax, ecx
	movsx	edx, BYTE PTR _k$[ebp]
	imul	edx, 3
	movsx	ecx, BYTE PTR _j$[ebp]
	add	edx, ecx
	movsx	ecx, BYTE PTR _i$[ebp]
	imul	ecx, 3
	movsx	esi, BYTE PTR _k$[ebp]
	add	ecx, esi
	mov	esi, DWORD PTR _one$[ebp]
	mov	edi, DWORD PTR _two$[ebp]
	fld	DWORD PTR [esi+edx*4]
	fmul	DWORD PTR [edi+ecx*4]
	mov	edx, DWORD PTR _out$[ebp]
	fadd	DWORD PTR [edx+eax*4]
	movsx	eax, BYTE PTR _j$[ebp]
	movsx	ecx, BYTE PTR _i$[ebp]
	imul	ecx, 3
	add	ecx, eax
	mov	edx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [edx+ecx*4]
	jmp	SHORT $L76431
$L76432:
	jmp	SHORT $L76428
$L76429:
	jmp	$L76425
$L76417:

; 263  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MulMatrix@@YAXPATMatrixUnion@@00@Z ENDP		; MulMatrix
_TEXT	ENDS
PUBLIC	?TransposeMatrix@@YAXPATMatrixUnion@@0@Z	; TransposeMatrix
; Function compile flags: /Odt /ZI
;	COMDAT ?TransposeMatrix@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?TransposeMatrix@@YAXPATMatrixUnion@@0@Z PROC NEAR	; TransposeMatrix, COMDAT

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 271  : 	out->m[RX] = in->m[RX];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 272  : 	out->m[RY] = in->m[UX];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 273  : 	out->m[RZ] = in->m[LX];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx

; 274  : 	out->m[UX] = in->m[RY];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx

; 275  : 	out->m[UY] = in->m[UY];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 276  : 	out->m[UZ] = in->m[LY];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+20], edx

; 277  : 	out->m[LX] = in->m[RZ];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx

; 278  : 	out->m[LY] = in->m[UZ];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+28], edx

; 279  : 	out->m[LZ] = in->m[LZ];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransposeMatrix@@YAXPATMatrixUnion@@0@Z ENDP		; TransposeMatrix
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ; BuildLookMatrixForward
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z
_TEXT	SEGMENT
__mul$76444 = -8					; size = 4
__mul$76442 = -4					; size = 4
_pos$ = 8						; size = 4
_look$ = 12						; size = 4
_mat$ = 16						; size = 4
?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z PROC NEAR ; BuildLookMatrixForward, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 288  : 
; 289  : // get forward vector
; 290  : 
; 291  : 	SubVector(look, pos, &mat->mv[Z]);

	mov	eax, DWORD PTR _look$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _look$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [edx+28]
	mov	eax, DWORD PTR _look$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [edx+32]

; 292  : 	NormalizeVector(&mat->mv[Z]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76442[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76442[ebp]
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76442[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76442[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+32]

; 293  : 
; 294  : // get right vector
; 295  : 
; 296  : 	mat->m[RX] = mat->m[LZ];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax], edx

; 297  : 	mat->m[RY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+4], 0

; 298  : 	mat->m[RZ] = -mat->m[LX];

	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 299  : 	NormalizeVector(&mat->mv[X]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76444[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76444[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76444[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76444[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 300  : 
; 301  : // get up vector
; 302  : 
; 303  : 	CrossProduct(&mat->mv[Z], &mat->mv[X], &mat->mv[Y]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+32]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+20]

; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildLookMatrixForward@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ENDP ; BuildLookMatrixForward
_TEXT	ENDS
PUBLIC	?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ; BuildLookMatrixDown
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z
_TEXT	SEGMENT
__mul$76453 = -8					; size = 4
__mul$76451 = -4					; size = 4
_pos$ = 8						; size = 4
_look$ = 12						; size = 4
_mat$ = 16						; size = 4
?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z PROC NEAR ; BuildLookMatrixDown, COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 312  : 
; 313  : // get up vector
; 314  : 
; 315  : 	SubVector(look, pos, &mat->mv[Y]);

	mov	eax, DWORD PTR _look$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _look$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _look$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [edx+20]

; 316  : 	NormalizeVector(&mat->mv[Y]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76451[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76451[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76451[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76451[ebp]
	fmul	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+20]

; 317  : 
; 318  : // get right vector
; 319  : 
; 320  : 	mat->m[RX] = -mat->m[UZ];

	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+20]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx]

; 321  : 	mat->m[RY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+4], 0

; 322  : 	mat->m[RZ] = mat->m[UX];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 323  : 	NormalizeVector(&mat->mv[X]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76453[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76453[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76453[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76453[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 324  : 
; 325  : // get forward vector
; 326  : 
; 327  : 	CrossProduct(&mat->mv[X], &mat->mv[Y], &mat->mv[Z]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+20]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+32]

; 328  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildLookMatrixDown@@YAXPAUVectorStruct@@0PATMatrixUnion@@@Z ENDP ; BuildLookMatrixDown
_TEXT	ENDS
PUBLIC	_cosf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC NEAR					; cos, COMDAT

; 549  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_cosf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
EXTRN	_cos:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _cosf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_cosf	PROC NEAR					; COMDAT

; 444  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cos
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
PUBLIC	?CopyMatrix@@YAXPATMatrixUnion@@0@Z		; CopyMatrix
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\geom.cpp
;	COMDAT ?CopyMatrix@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?CopyMatrix@@YAXPATMatrixUnion@@0@Z PROC NEAR		; CopyMatrix, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 336  : 	dest->m[XX] = src->m[XX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 337  : 	dest->m[XY] = src->m[XY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 338  : 	dest->m[XZ] = src->m[XZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 339  : 
; 340  : 	dest->m[YX] = src->m[YX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 341  : 	dest->m[YY] = src->m[YY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 342  : 	dest->m[YZ] = src->m[YZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 343  : 
; 344  : 	dest->m[ZX] = src->m[ZX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 345  : 	dest->m[ZY] = src->m[ZY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 346  : 	dest->m[ZZ] = src->m[ZZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 347  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyMatrix@@YAXPATMatrixUnion@@0@Z ENDP		; CopyMatrix
_TEXT	ENDS
PUBLIC	_sinf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC NEAR					; sin, COMDAT

; 575  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sinf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
EXTRN	_sin:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sinf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sinf	PROC NEAR					; COMDAT

; 466  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?BuildMatrixFromLook@@YAXPATMatrixUnion@@@Z	; BuildMatrixFromLook
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\geom.cpp
;	COMDAT ?BuildMatrixFromLook@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT
tv271 = -72						; size = 4
tv246 = -72						; size = 4
tv235 = -72						; size = 4
__mul$76468 = -4					; size = 4
_matrix$ = 8						; size = 4
?BuildMatrixFromLook@@YAXPATMatrixUnion@@@Z PROC NEAR	; BuildMatrixFromLook, COMDAT

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 357  : 
; 358  : 	// Choose an up vector perpendicular to the look vector
; 359  : 	if (fabs(matrix->m[LX]) < fabs(matrix->m[LY])) {

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv235[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv235[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76462

; 360  : 		if (fabs(matrix->m[LX]) < fabs(matrix->m[LZ])) {	// either X or Z is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv246[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv246[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76463

; 361  : 			matrix->m[UX] = 0.0f;					// look[X] is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax+12], 0

; 362  : 			matrix->m[UY] = matrix->m[LZ];

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+16], edx

; 363  : 			matrix->m[UZ] = -matrix->m[LY];

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+20]

; 364  : 		} else {

	jmp	SHORT $L76464
$L76463:

; 365  : 			matrix->m[UX] = -matrix->m[LY];		// look[Z] is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+28]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+12]

; 366  : 			matrix->m[UY] = matrix->m[LX];

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+16], edx

; 367  : 			matrix->m[UZ] = 0.0f;

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax+20], 0
$L76464:

; 368  : 		}
; 369  : 	} else {										// either Y or Z is smallest

	jmp	SHORT $L76465
$L76462:

; 370  : 		if (fabs(matrix->m[LY]) < fabs(matrix->m[LZ])) {

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv271[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv271[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76466

; 371  : 			matrix->m[UX] = matrix->m[LZ];		// Y is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+12], edx

; 372  : 			matrix->m[UY] = 0.0f;

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax+16], 0

; 373  : 			matrix->m[UZ] = -matrix->m[LX];

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+20]

; 374  : 		} else {

	jmp	SHORT $L76465
$L76466:

; 375  : 			matrix->m[UX] = matrix->m[LY];		// Z is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx

; 376  : 			matrix->m[UY] = -matrix->m[LX];

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+24]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+16]

; 377  : 			matrix->m[UZ] = 0.0f;

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax+20], 0
$L76465:

; 378  : 		}
; 379  : 	}
; 380  : 	NormalizeVector(&matrix->mv[U])

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76468[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR __mul$76468[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR __mul$76468[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR __mul$76468[ebp]
	fmul	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+20]

; 381  : 
; 382  : 	// Calculate a right vector from the up and look vectors
; 383  : 	CrossProduct(&matrix->mv[L], &matrix->mv[U], &matrix->mv[R]);

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx+32]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [eax+20]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+8]

; 384  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildMatrixFromLook@@YAXPATMatrixUnion@@@Z ENDP	; BuildMatrixFromLook
_TEXT	ENDS
PUBLIC	_fabsf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC NEAR					; fabs, COMDAT

; 555  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_fabsf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
EXTRN	_fabs:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _fabsf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC NEAR					; COMDAT

; 450  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z	; BuildMatrixFromUp
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\geom.cpp
;	COMDAT ?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT
tv238 = -72						; size = 4
tv213 = -72						; size = 4
tv202 = -72						; size = 4
__mul$76479 = -4					; size = 4
_matrix$ = 8						; size = 4
?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z PROC NEAR	; BuildMatrixFromUp, COMDAT

; 388  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 389  : 
; 390  : 	// Choose a right vector perpendicular to the up vector
; 391  : 	if (fabs(matrix->m[UX]) < fabs(matrix->m[UY])) {

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv202[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv202[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76473

; 392  : 		if (fabs(matrix->m[UX]) < fabs(matrix->m[UZ])) {	// either X or Z is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv213[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv213[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76474

; 393  : 			matrix->m[RX] = 0.0f;					// look[X] is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax], 0

; 394  : 			matrix->m[RY] = matrix->m[UZ];

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx

; 395  : 			matrix->m[RZ] = -matrix->m[UY];

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+16]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+8]

; 396  : 		} else {

	jmp	SHORT $L76475
$L76474:

; 397  : 			matrix->m[RX] = -matrix->m[UY];		// look[Z] is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+16]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx]

; 398  : 			matrix->m[RY] = matrix->m[UX];

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 399  : 			matrix->m[RZ] = 0.0f;

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax+8], 0
$L76475:

; 400  : 		}
; 401  : 	} else {										// either Y or Z is smallest

	jmp	SHORT $L76476
$L76473:

; 402  : 		if (fabs(matrix->m[UY]) < fabs(matrix->m[UZ])) {

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv238[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv238[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76477

; 403  : 			matrix->m[RX] = matrix->m[UZ];		// Y is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx

; 404  : 			matrix->m[RY] = 0.0f;

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax+4], 0

; 405  : 			matrix->m[RZ] = -matrix->m[UX];

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+8]

; 406  : 		} else {

	jmp	SHORT $L76476
$L76477:

; 407  : 			matrix->m[RX] = matrix->m[UY];		// Z is smallest

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 408  : 			matrix->m[RY] = -matrix->m[UX];

	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+4]

; 409  : 			matrix->m[RZ] = 0.0f;

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	DWORD PTR [eax+8], 0
$L76476:

; 410  : 		}
; 411  : 	}
; 412  : 	NormalizeVector(&matrix->mv[R])

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	mov	edx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76479[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR __mul$76479[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR __mul$76479[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR __mul$76479[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+8]

; 413  : 
; 414  : 	// Calculate a right vector from the up and look vectors
; 415  : 	CrossProduct(&matrix->mv[R], &matrix->mv[U], &matrix->mv[L]);

	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+20]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _matrix$[ebp]
	mov	ecx, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _matrix$[ebp]
	mov	eax, DWORD PTR _matrix$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matrix$[ebp]
	fstp	DWORD PTR [ecx+32]

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildMatrixFromUp@@YAXPATMatrixUnion@@@Z ENDP		; BuildMatrixFromUp
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@c0800000
PUBLIC	__real@40800000
PUBLIC	?Interpolate3D@@YAXPAUVectorStruct@@00M0@Z	; Interpolate3D
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@c0800000
CONST	SEGMENT
__real@c0800000 DD 0c0800000r			; -4
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?Interpolate3D@@YAXPAUVectorStruct@@00M0@Z
_TEXT	SEGMENT
_tSq$ = -4						; size = 4
_r0$ = 8						; size = 4
_r1$ = 12						; size = 4
_r2$ = 16						; size = 4
_t$ = 20						; size = 4
_rt$ = 24						; size = 4
?Interpolate3D@@YAXPAUVectorStruct@@00M0@Z PROC NEAR	; Interpolate3D, COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 434  : 	/*rt[X] = t2Sq * (r0[X] - r1[X] + r2[X]) -
; 435  : 		t * (3.0f * r0[X] - r1[X] + r2[X]) +
; 436  : 		r0[X];
; 437  : 	rt[Y] = t2Sq * (r0[Y] - r1[Y] + r2[Y]) -
; 438  : 		t * (3.0f * r0[Y] - r1[Y] + r2[Y]) +
; 439  : 		r0[Y];
; 440  : 	rt[Z] = t2Sq * (r0[Z] - r1[Z] + r2[Z]) -
; 441  : 		t * (3.0f * r0[Z] - r1[Z] + r2[Z]) +
; 442  : 		r0[Z];*/
; 443  : 	REAL tSq = t * t;

	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _t$[ebp]
	fstp	DWORD PTR _tSq$[ebp]

; 444  : 
; 445  : 	rt->v[X] = r0->v[X] * (2.0f * tSq - 3.0f * t + 1.0f) +
; 446  : 		r1->v[X] * (-4.0f * tSq + 4.0f * t) +
; 447  : 		r2->v[X] * (2.0f * tSq - t);

	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _tSq$[ebp]
	fld	DWORD PTR __real@40400000
	fmul	DWORD PTR _t$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _r0$[ebp]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR __real@c0800000
	fmul	DWORD PTR _tSq$[ebp]
	fld	DWORD PTR __real@40800000
	fmul	DWORD PTR _t$[ebp]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _r1$[ebp]
	fmul	DWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _tSq$[ebp]
	fsub	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _r2$[ebp]
	fmul	DWORD PTR [edx]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [eax]

; 448  : 	rt->v[Y] = r0->v[Y] * (2.0f * tSq - 3.0f * t + 1.0f) +
; 449  : 		r1->v[Y] * (-4.0f * tSq + 4.0f * t) +
; 450  : 		r2->v[Y] * (2.0f * tSq - t);

	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _tSq$[ebp]
	fld	DWORD PTR __real@40400000
	fmul	DWORD PTR _t$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _r0$[ebp]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR __real@c0800000
	fmul	DWORD PTR _tSq$[ebp]
	fld	DWORD PTR __real@40800000
	fmul	DWORD PTR _t$[ebp]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _r1$[ebp]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _tSq$[ebp]
	fsub	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _r2$[ebp]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [eax+4]

; 451  : 	rt->v[Z] = r0->v[Z] * (2.0f * tSq - 3.0f * t + 1.0f) +
; 452  : 		r1->v[Z] * (-4.0f * tSq + 4.0f * t) +
; 453  : 		r2->v[Z] * (2.0f * tSq - t);

	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _tSq$[ebp]
	fld	DWORD PTR __real@40400000
	fmul	DWORD PTR _t$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _r0$[ebp]
	fmul	DWORD PTR [eax+8]
	fld	DWORD PTR __real@c0800000
	fmul	DWORD PTR _tSq$[ebp]
	fld	DWORD PTR __real@40800000
	fmul	DWORD PTR _t$[ebp]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _r1$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR __real@40000000
	fmul	DWORD PTR _tSq$[ebp]
	fsub	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _r2$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [eax+8]

; 454  : 
; 455  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Interpolate3D@@YAXPAUVectorStruct@@00M0@Z ENDP		; Interpolate3D
_TEXT	ENDS
PUBLIC	?QuadInterpVec@@YAXPAUVectorStruct@@M0M0MM0@Z	; QuadInterpVec
; Function compile flags: /Odt /ZI
;	COMDAT ?QuadInterpVec@@YAXPAUVectorStruct@@M0M0MM0@Z
_TEXT	SEGMENT
_c$ = -12						; size = 4
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_r0$ = 8						; size = 4
_t0$ = 12						; size = 4
_r1$ = 16						; size = 4
_t1$ = 20						; size = 4
_r2$ = 24						; size = 4
_t2$ = 28						; size = 4
_t$ = 32						; size = 4
_rt$ = 36						; size = 4
?QuadInterpVec@@YAXPAUVectorStruct@@M0M0MM0@Z PROC NEAR	; QuadInterpVec, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 468  : 	REAL a, b, c;
; 469  : 
; 470  : 	a = ((t - t1) * (t - t2)) / ((t0 - t1) * (t0 - t2));

	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t1$[ebp]
	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t2$[ebp]
	fmulp	ST(1), ST(0)
	fld	DWORD PTR _t0$[ebp]
	fsub	DWORD PTR _t1$[ebp]
	fld	DWORD PTR _t0$[ebp]
	fsub	DWORD PTR _t2$[ebp]
	fmulp	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _a$[ebp]

; 471  : 	b = ((t - t0) * (t - t2)) / ((t1 - t0) * (t1 - t2));

	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t0$[ebp]
	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t2$[ebp]
	fmulp	ST(1), ST(0)
	fld	DWORD PTR _t1$[ebp]
	fsub	DWORD PTR _t0$[ebp]
	fld	DWORD PTR _t1$[ebp]
	fsub	DWORD PTR _t2$[ebp]
	fmulp	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _b$[ebp]

; 472  : 	c = ((t - t0) * (t - t1)) / ((t2 - t0) * (t2 - t1));

	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t0$[ebp]
	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t1$[ebp]
	fmulp	ST(1), ST(0)
	fld	DWORD PTR _t2$[ebp]
	fsub	DWORD PTR _t0$[ebp]
	fld	DWORD PTR _t2$[ebp]
	fsub	DWORD PTR _t1$[ebp]
	fmulp	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _c$[ebp]

; 473  : 
; 474  : 	rt->v[X] = a * r0->v[X] + b * r1->v[X] + c * r2->v[X];

	mov	eax, DWORD PTR _r0$[ebp]
	fld	DWORD PTR _a$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _r1$[ebp]
	fld	DWORD PTR _b$[ebp]
	fmul	DWORD PTR [ecx]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _r2$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR [edx]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [eax]

; 475  : 	rt->v[Y] = a * r0->v[Y] + b * r1->v[Y] + c * r2->v[Y];

	mov	eax, DWORD PTR _r0$[ebp]
	fld	DWORD PTR _a$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _r1$[ebp]
	fld	DWORD PTR _b$[ebp]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _r2$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [eax+4]

; 476  : 	rt->v[Z] = a * r0->v[Z] + b * r1->v[Z] + c * r2->v[Z];

	mov	eax, DWORD PTR _r0$[ebp]
	fld	DWORD PTR _a$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _r1$[ebp]
	fld	DWORD PTR _b$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _r2$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [eax+8]

; 477  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?QuadInterpVec@@YAXPAUVectorStruct@@M0M0MM0@Z ENDP	; QuadInterpVec
_TEXT	ENDS
PUBLIC	?LInterpVec@@YAXPAUVectorStruct@@M0MM0@Z	; LInterpVec
; Function compile flags: /Odt /ZI
;	COMDAT ?LInterpVec@@YAXPAUVectorStruct@@M0MM0@Z
_TEXT	SEGMENT
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_r0$ = 8						; size = 4
_t0$ = 12						; size = 4
_r1$ = 16						; size = 4
_t1$ = 20						; size = 4
_t$ = 24						; size = 4
_rt$ = 28						; size = 4
?LInterpVec@@YAXPAUVectorStruct@@M0MM0@Z PROC NEAR	; LInterpVec, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 488  : 	REAL a, b;
; 489  : 
; 490  : 	a = (t - t1) / (t0 - t1);

	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t1$[ebp]
	fld	DWORD PTR _t0$[ebp]
	fsub	DWORD PTR _t1$[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _a$[ebp]

; 491  : 	b = (t - t0) / (t1 - t0);

	fld	DWORD PTR _t$[ebp]
	fsub	DWORD PTR _t0$[ebp]
	fld	DWORD PTR _t1$[ebp]
	fsub	DWORD PTR _t0$[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _b$[ebp]

; 492  : 
; 493  : 	rt->v[X] = a * r0->v[X] + b * r1->v[X];

	mov	eax, DWORD PTR _r0$[ebp]
	fld	DWORD PTR _a$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _r1$[ebp]
	fld	DWORD PTR _b$[ebp]
	fmul	DWORD PTR [ecx]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [edx]

; 494  : 	rt->v[Y] = a * r0->v[Y] + b * r1->v[Y];

	mov	eax, DWORD PTR _r0$[ebp]
	fld	DWORD PTR _a$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _r1$[ebp]
	fld	DWORD PTR _b$[ebp]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [edx+4]

; 495  : 	rt->v[Z] = a * r0->v[Z] + b * r1->v[Z];

	mov	eax, DWORD PTR _r0$[ebp]
	fld	DWORD PTR _a$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _r1$[ebp]
	fld	DWORD PTR _b$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _rt$[ebp]
	fstp	DWORD PTR [edx+8]

; 496  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LInterpVec@@YAXPAUVectorStruct@@M0MM0@Z ENDP		; LInterpVec
_TEXT	ENDS
PUBLIC	?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ; MatMulVec
; Function compile flags: /Odt /ZI
;	COMDAT ?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT
_mIn$ = 8						; size = 4
_vIn$ = 12						; size = 4
_vOut$ = 16						; size = 4
?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z PROC NEAR ; MatMulVec, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 505  : 	vOut->v[X] =
; 506  : 		mIn->m[XX] * vIn->v[X] +
; 507  : 		mIn->m[XY] * vIn->v[Y] +
; 508  : 		mIn->m[XZ] * vIn->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [eax]

; 509  : 	vOut->v[Y] =
; 510  : 		mIn->m[YX] * vIn->v[X] +
; 511  : 		mIn->m[YY] * vIn->v[Y] +
; 512  : 		mIn->m[YZ] * vIn->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [eax+4]

; 513  : 	vOut->v[Z] =
; 514  : 		mIn->m[ZX] * vIn->v[X] +
; 515  : 		mIn->m[ZY] * vIn->v[Y] +
; 516  : 		mIn->m[ZZ] * vIn->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [eax+8]

; 517  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatMulVec@@YAXPATMatrixUnion@@PAUVectorStruct@@1@Z ENDP ; MatMulVec
_TEXT	ENDS
PUBLIC	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
; Function compile flags: /Odt /ZI
;	COMDAT ?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z
_TEXT	SEGMENT
_vIn$ = 8						; size = 4
_mIn$ = 12						; size = 4
_vOut$ = 16						; size = 4
?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z PROC NEAR ; VecMulMat, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 521  : 	vOut->v[X] =
; 522  : 		mIn->m[XX] * vIn->v[X] +
; 523  : 		mIn->m[YX] * vIn->v[Y] +
; 524  : 		mIn->m[ZX] * vIn->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [edx+12]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [ecx+24]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [eax]

; 525  : 	vOut->v[Y] =
; 526  : 		mIn->m[XY] * vIn->v[X] +
; 527  : 		mIn->m[YY] * vIn->v[Y] +
; 528  : 		mIn->m[ZY] * vIn->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [ecx+28]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [eax+4]

; 529  : 	vOut->v[Z] =
; 530  : 		mIn->m[XZ] * vIn->v[X] +
; 531  : 		mIn->m[YZ] * vIn->v[Y] +
; 532  : 		mIn->m[ZZ] * vIn->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [eax+8]

; 533  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ENDP ; VecMulMat
_TEXT	ENDS
PUBLIC	?MatMulThisVec@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ; MatMulThisVec
; Function compile flags: /Odt /ZI
;	COMDAT ?MatMulThisVec@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_vecTemp$ = -12						; size = 12
_mIn$ = 8						; size = 4
_vInOut$ = 12						; size = 4
?MatMulThisVec@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z PROC NEAR ; MatMulThisVec, COMDAT

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 542  : 	VEC vecTemp;
; 543  : 	vecTemp.v[X] =
; 544  : 		mIn->m[XX] * vInOut->v[X] +
; 545  : 		mIn->m[XY] * vInOut->v[Y] +
; 546  : 		mIn->m[XZ] * vInOut->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vecTemp$[ebp]

; 547  : 	vecTemp.v[Y] =
; 548  : 		mIn->m[YX] * vInOut->v[X] +
; 549  : 		mIn->m[YY] * vInOut->v[Y] +
; 550  : 		mIn->m[YZ] * vInOut->v[Z]; 

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vecTemp$[ebp+4]

; 551  : 	vecTemp.v[Z] =
; 552  : 		mIn->m[ZX] * vInOut->v[X] +
; 553  : 		mIn->m[ZY] * vInOut->v[Y] +
; 554  : 		mIn->m[ZZ] * vInOut->v[Z];

	mov	eax, DWORD PTR _mIn$[ebp]
	mov	ecx, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mIn$[ebp]
	mov	eax, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mIn$[ebp]
	mov	edx, DWORD PTR _vInOut$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _vecTemp$[ebp+8]

; 555  : 	vInOut->v[X] = vecTemp.v[X];	

	mov	eax, DWORD PTR _vInOut$[ebp]
	mov	ecx, DWORD PTR _vecTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 556  : 	vInOut->v[Y] = vecTemp.v[Y];	

	mov	eax, DWORD PTR _vInOut$[ebp]
	mov	ecx, DWORD PTR _vecTemp$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 557  : 	vInOut->v[Z] = vecTemp.v[Z];	

	mov	eax, DWORD PTR _vInOut$[ebp]
	mov	ecx, DWORD PTR _vecTemp$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 558  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatMulThisVec@@YAXPATMatrixUnion@@PAUVectorStruct@@@Z ENDP ; MatMulThisVec
_TEXT	ENDS
PUBLIC	?MatMulTransMat@@YAXPATMatrixUnion@@00@Z	; MatMulTransMat
; Function compile flags: /Odt /ZI
;	COMDAT ?MatMulTransMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT
_mLeft$ = 8						; size = 4
_mRight$ = 12						; size = 4
_mOut$ = 16						; size = 4
?MatMulTransMat@@YAXPATMatrixUnion@@00@Z PROC NEAR	; MatMulTransMat, COMDAT

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 567  : 	mOut->m[XX] = 
; 568  : 		mLeft->m[XX] * mRight->m[XX] + 
; 569  : 		mLeft->m[XY] * mRight->m[XY] + 
; 570  : 		mLeft->m[XZ] * mRight->m[XZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax]

; 571  : 	mOut->m[XY] = 
; 572  : 		mLeft->m[XX] * mRight->m[YX] + 
; 573  : 		mLeft->m[XY] * mRight->m[YY] + 
; 574  : 		mLeft->m[XZ] * mRight->m[YZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+4]

; 575  : 	mOut->m[XZ] = 
; 576  : 		mLeft->m[XX] * mRight->m[ZX] + 
; 577  : 		mLeft->m[XY] * mRight->m[ZY] + 
; 578  : 		mLeft->m[XZ] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+8]

; 579  : 
; 580  : 	mOut->m[YX] = 
; 581  : 		mLeft->m[YX] * mRight->m[XX] + 
; 582  : 		mLeft->m[YY] * mRight->m[XY] + 
; 583  : 		mLeft->m[YZ] * mRight->m[XZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+12]

; 584  : 	mOut->m[YY] = 
; 585  : 		mLeft->m[YX] * mRight->m[YX] + 
; 586  : 		mLeft->m[YY] * mRight->m[YY] + 
; 587  : 		mLeft->m[YZ] * mRight->m[YZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+16]

; 588  : 	mOut->m[YZ] = 
; 589  : 		mLeft->m[YX] * mRight->m[ZX] + 
; 590  : 		mLeft->m[YY] * mRight->m[ZY] + 
; 591  : 		mLeft->m[YZ] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+20]

; 592  : 
; 593  : 	mOut->m[ZX] = 
; 594  : 		mLeft->m[ZX] * mRight->m[XX] + 
; 595  : 		mLeft->m[ZY] * mRight->m[XY] + 
; 596  : 		mLeft->m[ZZ] * mRight->m[XZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+24]

; 597  : 	mOut->m[ZY] = 
; 598  : 		mLeft->m[ZX] * mRight->m[YX] + 
; 599  : 		mLeft->m[ZY] * mRight->m[YY] + 
; 600  : 		mLeft->m[ZZ] * mRight->m[YZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+20]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+28]

; 601  : 	mOut->m[ZZ] = 
; 602  : 		mLeft->m[ZX] * mRight->m[ZX] + 
; 603  : 		mLeft->m[ZY] * mRight->m[ZY] + 
; 604  : 		mLeft->m[ZZ] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+32]

; 605  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatMulTransMat@@YAXPATMatrixUnion@@00@Z ENDP		; MatMulTransMat
_TEXT	ENDS
PUBLIC	?TransMatMulMat@@YAXPATMatrixUnion@@00@Z	; TransMatMulMat
; Function compile flags: /Odt /ZI
;	COMDAT ?TransMatMulMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT
_mLeft$ = 8						; size = 4
_mRight$ = 12						; size = 4
_mOut$ = 16						; size = 4
?TransMatMulMat@@YAXPATMatrixUnion@@00@Z PROC NEAR	; TransMatMulMat, COMDAT

; 608  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 609  : 	mOut->m[XX] = 
; 610  : 		mLeft->m[XX] * mRight->m[XX] + 
; 611  : 		mLeft->m[YX] * mRight->m[YX] + 
; 612  : 		mLeft->m[ZX] * mRight->m[ZX];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+12]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+24]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax]

; 613  : 	mOut->m[XY] = 
; 614  : 		mLeft->m[XX] * mRight->m[XY] + 
; 615  : 		mLeft->m[YX] * mRight->m[YY] + 
; 616  : 		mLeft->m[ZX] * mRight->m[ZY];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+12]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+24]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+4]

; 617  : 	mOut->m[XZ] = 
; 618  : 		mLeft->m[XX] * mRight->m[XZ] + 
; 619  : 		mLeft->m[YX] * mRight->m[YZ] + 
; 620  : 		mLeft->m[ZX] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+12]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+24]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+8]

; 621  : 
; 622  : 	mOut->m[YX] = 
; 623  : 		mLeft->m[XY] * mRight->m[XX] + 
; 624  : 		mLeft->m[YY] * mRight->m[YX] + 
; 625  : 		mLeft->m[ZY] * mRight->m[ZX];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+28]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+12]

; 626  : 	mOut->m[YY] = 
; 627  : 		mLeft->m[XY] * mRight->m[XY] + 
; 628  : 		mLeft->m[YY] * mRight->m[YY] + 
; 629  : 		mLeft->m[ZY] * mRight->m[ZY];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+28]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+16]

; 630  : 	mOut->m[YZ] = 
; 631  : 		mLeft->m[XY] * mRight->m[XZ] + 
; 632  : 		mLeft->m[YY] * mRight->m[YZ] + 
; 633  : 		mLeft->m[ZY] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+28]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+20]

; 634  : 
; 635  : 	mOut->m[ZX] = 
; 636  : 		mLeft->m[XZ] * mRight->m[XX] + 
; 637  : 		mLeft->m[YZ] * mRight->m[YX] + 
; 638  : 		mLeft->m[ZZ] * mRight->m[ZX];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+24]

; 639  : 	mOut->m[ZY] = 
; 640  : 		mLeft->m[XZ] * mRight->m[XY] + 
; 641  : 		mLeft->m[YZ] * mRight->m[YY] + 
; 642  : 		mLeft->m[ZZ] * mRight->m[ZY];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+28]

; 643  : 	mOut->m[ZZ] = 
; 644  : 		mLeft->m[XZ] * mRight->m[XZ] + 
; 645  : 		mLeft->m[YZ] * mRight->m[YZ] + 
; 646  : 		mLeft->m[ZZ] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+32]

; 647  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransMatMulMat@@YAXPATMatrixUnion@@00@Z ENDP		; TransMatMulMat
_TEXT	ENDS
PUBLIC	?MatMulMat@@YAXPATMatrixUnion@@00@Z		; MatMulMat
; Function compile flags: /Odt /ZI
;	COMDAT ?MatMulMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT
_mLeft$ = 8						; size = 4
_mRight$ = 12						; size = 4
_mOut$ = 16						; size = 4
?MatMulMat@@YAXPATMatrixUnion@@00@Z PROC NEAR		; MatMulMat, COMDAT

; 650  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 651  : 	mOut->m[XX] = 
; 652  : 		mLeft->m[XX] * mRight->m[XX] + 
; 653  : 		mLeft->m[XY] * mRight->m[YX] + 
; 654  : 		mLeft->m[XZ] * mRight->m[ZX];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax]

; 655  : 	mOut->m[XY] = 
; 656  : 		mLeft->m[XX] * mRight->m[XY] + 
; 657  : 		mLeft->m[XY] * mRight->m[YY] + 
; 658  : 		mLeft->m[XZ] * mRight->m[ZY];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+4]

; 659  : 	mOut->m[XZ] = 
; 660  : 		mLeft->m[XX] * mRight->m[XZ] + 
; 661  : 		mLeft->m[XY] * mRight->m[YZ] + 
; 662  : 		mLeft->m[XZ] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+8]

; 663  : 
; 664  : 	mOut->m[YX] = 
; 665  : 		mLeft->m[YX] * mRight->m[XX] + 
; 666  : 		mLeft->m[YY] * mRight->m[YX] + 
; 667  : 		mLeft->m[YZ] * mRight->m[ZX];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+12]

; 668  : 	mOut->m[YY] = 
; 669  : 		mLeft->m[YX] * mRight->m[XY] + 
; 670  : 		mLeft->m[YY] * mRight->m[YY] + 
; 671  : 		mLeft->m[YZ] * mRight->m[ZY];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+16]

; 672  : 	mOut->m[YZ] = 
; 673  : 		mLeft->m[YX] * mRight->m[XZ] + 
; 674  : 		mLeft->m[YY] * mRight->m[YZ] + 
; 675  : 		mLeft->m[YZ] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+20]

; 676  : 
; 677  : 	mOut->m[ZX] = 
; 678  : 		mLeft->m[ZX] * mRight->m[XX] + 
; 679  : 		mLeft->m[ZY] * mRight->m[YX] + 
; 680  : 		mLeft->m[ZZ] * mRight->m[ZX];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+24]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+24]

; 681  : 	mOut->m[ZY] = 
; 682  : 		mLeft->m[ZX] * mRight->m[XY] + 
; 683  : 		mLeft->m[ZY] * mRight->m[YY] + 
; 684  : 		mLeft->m[ZZ] * mRight->m[ZY];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+28]

; 685  : 	mOut->m[ZZ] = 
; 686  : 		mLeft->m[ZX] * mRight->m[XZ] + 
; 687  : 		mLeft->m[ZY] * mRight->m[YZ] + 
; 688  : 		mLeft->m[ZZ] * mRight->m[ZZ];

	mov	eax, DWORD PTR _mLeft$[ebp]
	mov	ecx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _mLeft$[ebp]
	mov	eax, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mLeft$[ebp]
	mov	edx, DWORD PTR _mRight$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _mOut$[ebp]
	fstp	DWORD PTR [eax+32]

; 689  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatMulMat@@YAXPATMatrixUnion@@00@Z ENDP		; MatMulMat
_TEXT	ENDS
PUBLIC	?BuildRotation3D@@YAXMMMMPATMatrixUnion@@@Z	; BuildRotation3D
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildRotation3D@@YAXMMMMPATMatrixUnion@@@Z
_TEXT	SEGMENT
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_axisX$ = 8						; size = 4
_axisY$ = 12						; size = 4
_axisZ$ = 16						; size = 4
_angle$ = 20						; size = 4
_matOut$ = 24						; size = 4
?BuildRotation3D@@YAXMMMMPATMatrixUnion@@@Z PROC NEAR	; BuildRotation3D, COMDAT

; 699  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 700  : 	REAL c, s;
; 701  : 
; 702  : 	c = (REAL) cos(angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 703  : 	s = (REAL) sin(angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 704  : 
; 705  : 	matOut->m[XX] = axisX * axisX - c * axisX * axisX + c;

	fld	DWORD PTR _axisX$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax]

; 706  : 	matOut->m[XY] = axisX * axisY - c * axisX * axisY - s * axisZ;

	fld	DWORD PTR _axisX$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+4]

; 707  : 	matOut->m[XZ] = axisX * axisZ - c * axisX * axisZ + s * axisY;

	fld	DWORD PTR _axisX$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+8]

; 708  : 	matOut->m[YX] = axisY * axisX - c * axisY * axisX + s * axisZ;

	fld	DWORD PTR _axisY$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+12]

; 709  : 	matOut->m[YY] = axisY * axisY - c * axisY * axisY + c;

	fld	DWORD PTR _axisY$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+16]

; 710  : 	matOut->m[YZ] = axisY * axisZ - c * axisY * axisZ - s * axisX;

	fld	DWORD PTR _axisY$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+20]

; 711  : 	matOut->m[ZX] = axisZ * axisX - c * axisZ * axisX - s * axisY;

	fld	DWORD PTR _axisZ$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+24]

; 712  : 	matOut->m[ZY] = axisZ * axisY - c * axisZ * axisY + s * axisX;

	fld	DWORD PTR _axisZ$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fmul	DWORD PTR _axisY$[ebp]
	fsubp	ST(1), ST(0)
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR _axisX$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+28]

; 713  : 	matOut->m[ZZ] = axisZ * axisZ - c * axisZ * axisZ + c;

	fld	DWORD PTR _axisZ$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fld	DWORD PTR _c$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fmul	DWORD PTR _axisZ$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [eax+32]

; 714  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildRotation3D@@YAXMMMMPATMatrixUnion@@@Z ENDP	; BuildRotation3D
_TEXT	ENDS
PUBLIC	?RotationX@@YAXPATMatrixUnion@@M@Z		; RotationX
; Function compile flags: /Odt /ZI
;	COMDAT ?RotationX@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_mat$ = 8						; size = 4
_rot$ = 12						; size = 4
?RotationX@@YAXPATMatrixUnion@@M@Z PROC NEAR		; RotationX, COMDAT

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 725  : 	REAL c, s;
; 726  : 
; 727  : 	c = (REAL)cos(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 728  : 	s = (REAL)sin(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 729  : 	
; 730  : 	mat->m[RX] = 1;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 731  : 	mat->m[RY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+4], 0

; 732  : 	mat->m[RZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0

; 733  : 
; 734  : 	mat->m[UX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+12], 0

; 735  : 	mat->m[UY] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 736  : 	mat->m[UZ] = -s;

	fld	DWORD PTR _s$[ebp]
	fchs
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+20]

; 737  : 
; 738  : 	mat->m[LX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+24], 0

; 739  : 	mat->m[LY] = s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 740  : 	mat->m[LZ] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 741  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotationX@@YAXPATMatrixUnion@@M@Z ENDP			; RotationX
_TEXT	ENDS
PUBLIC	?RotationY@@YAXPATMatrixUnion@@M@Z		; RotationY
; Function compile flags: /Odt /ZI
;	COMDAT ?RotationY@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_mat$ = 8						; size = 4
_rot$ = 12						; size = 4
?RotationY@@YAXPATMatrixUnion@@M@Z PROC NEAR		; RotationY, COMDAT

; 750  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 751  : 	REAL c, s;
; 752  : 
; 753  : 	c = (REAL)cos(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 754  : 	s = (REAL)sin(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 755  : 
; 756  : 	mat->m[RX] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], ecx

; 757  : 	mat->m[RY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+4], 0

; 758  : 	mat->m[RZ] = s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 759  : 
; 760  : 	mat->m[UX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+12], 0

; 761  : 	mat->m[UY] = 1;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H

; 762  : 	mat->m[UZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+20], 0

; 763  : 
; 764  : 	mat->m[LX] = -s;

	fld	DWORD PTR _s$[ebp]
	fchs
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+24]

; 765  : 	mat->m[LY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+28], 0

; 766  : 	mat->m[LZ] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 767  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotationY@@YAXPATMatrixUnion@@M@Z ENDP			; RotationY
_TEXT	ENDS
PUBLIC	?RotationZ@@YAXPATMatrixUnion@@M@Z		; RotationZ
; Function compile flags: /Odt /ZI
;	COMDAT ?RotationZ@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_mat$ = 8						; size = 4
_rot$ = 12						; size = 4
?RotationZ@@YAXPATMatrixUnion@@M@Z PROC NEAR		; RotationZ, COMDAT

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 777  : 	REAL c, s;
; 778  : 
; 779  : 	c = (REAL)cos(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 780  : 	s = (REAL)sin(rot);

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 781  : 
; 782  : 	mat->m[RX] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], ecx

; 783  : 	mat->m[RY] = -s;

	fld	DWORD PTR _s$[ebp]
	fchs
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+4]

; 784  : 	mat->m[RZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0

; 785  : 
; 786  : 	mat->m[UX] = s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 787  : 	mat->m[UY] = c;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 788  : 	mat->m[UZ] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+20], 0

; 789  : 
; 790  : 	mat->m[LX] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+24], 0

; 791  : 	mat->m[LY] = 0;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+28], 0

; 792  : 	mat->m[LZ] = 1;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H

; 793  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotationZ@@YAXPATMatrixUnion@@M@Z ENDP			; RotationZ
_TEXT	ENDS
PUBLIC	?CopyMat@@YAXPATMatrixUnion@@0@Z		; CopyMat
; Function compile flags: /Odt /ZI
;	COMDAT ?CopyMat@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?CopyMat@@YAXPATMatrixUnion@@0@Z PROC NEAR		; CopyMat, COMDAT

; 799  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 800  : 	dest->m[XX] = src->m[XX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 801  : 	dest->m[XY] = src->m[XY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 802  : 	dest->m[XZ] = src->m[XZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 803  : 
; 804  : 	dest->m[YX] = src->m[YX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 805  : 	dest->m[YY] = src->m[YY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 806  : 	dest->m[YZ] = src->m[YZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 807  : 
; 808  : 	dest->m[ZX] = src->m[ZX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 809  : 	dest->m[ZY] = src->m[ZY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 810  : 	dest->m[ZZ] = src->m[ZZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 811  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyMat@@YAXPATMatrixUnion@@0@Z ENDP			; CopyMat
_TEXT	ENDS
PUBLIC	?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z		; SetMat
; Function compile flags: /Odt /ZI
;	COMDAT ?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_xx$ = 12						; size = 4
_xy$ = 16						; size = 4
_xz$ = 20						; size = 4
_yx$ = 24						; size = 4
_yy$ = 28						; size = 4
_yz$ = 32						; size = 4
_zx$ = 36						; size = 4
_zy$ = 40						; size = 4
_zz$ = 44						; size = 4
?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z PROC NEAR	; SetMat, COMDAT

; 818  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 819  : 	mat->m[XX] = xx;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _xx$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 	mat->m[XY] = xy;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _xy$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 821  : 	mat->m[XZ] = xz;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _xz$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 822  : 
; 823  : 	mat->m[YX] = yx;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _yx$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 824  : 	mat->m[YY] = yy;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _yy$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 825  : 	mat->m[YZ] = yz;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _yz$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 826  : 
; 827  : 	mat->m[ZX] = zx;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _zx$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 828  : 	mat->m[ZY] = zy;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _zy$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 829  : 	mat->m[ZZ] = zz;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _zz$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 830  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMat@@YAXPATMatrixUnion@@MMMMMMMMM@Z ENDP		; SetMat
_TEXT	ENDS
PUBLIC	?SetMatUnit@@YAXPATMatrixUnion@@@Z		; SetMatUnit
; Function compile flags: /Odt /ZI
;	COMDAT ?SetMatUnit@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
?SetMatUnit@@YAXPATMatrixUnion@@@Z PROC NEAR		; SetMatUnit, COMDAT

; 837  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 838  : 	mat->m[XX] = mat->m[YY] = mat->m[ZZ] = (REAL)1.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+16], 1065353216		; 3f800000H
	mov	edx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [edx], 1065353216		; 3f800000H

; 839  : 	mat->m[XY] = mat->m[XZ] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 840  : 	mat->m[YX] = mat->m[YZ] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 841  : 	mat->m[ZX] = mat->m[ZY] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 842  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMatUnit@@YAXPATMatrixUnion@@@Z ENDP			; SetMatUnit
_TEXT	ENDS
PUBLIC	?SetMatZero@@YAXPATMatrixUnion@@@Z		; SetMatZero
; Function compile flags: /Odt /ZI
;	COMDAT ?SetMatZero@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
?SetMatZero@@YAXPATMatrixUnion@@@Z PROC NEAR		; SetMatZero, COMDAT

; 845  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 846  : 	mat->m[XX] = mat->m[YY] = mat->m[ZZ] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [edx], 0

; 847  : 	mat->m[XY] = mat->m[XZ] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 848  : 	mat->m[YX] = mat->m[YZ] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 849  : 	mat->m[ZX] = mat->m[ZY] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 850  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMatZero@@YAXPATMatrixUnion@@@Z ENDP			; SetMatZero
_TEXT	ENDS
PUBLIC	?MatMulScalar@@YAXPATMatrixUnion@@M@Z		; MatMulScalar
; Function compile flags: /Odt /ZI
;	COMDAT ?MatMulScalar@@YAXPATMatrixUnion@@M@Z
_TEXT	SEGMENT
_iEl$ = -4						; size = 4
_mat$ = 8						; size = 4
_scalar$ = 12						; size = 4
?MatMulScalar@@YAXPATMatrixUnion@@M@Z PROC NEAR		; MatMulScalar, COMDAT

; 857  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 858  : 	int iEl;
; 859  : 
; 860  : 	for (iEl = 0; iEl < 9; iEl++) {

	mov	DWORD PTR _iEl$[ebp], 0
	jmp	SHORT $L76612
$L76613:
	mov	eax, DWORD PTR _iEl$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEl$[ebp], eax
$L76612:
	cmp	DWORD PTR _iEl$[ebp], 9
	jge	SHORT $L76610

; 861  : 		mat->m[iEl] *= scalar;

	mov	eax, DWORD PTR _iEl$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _iEl$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+edx*4]

; 862  : 	}

	jmp	SHORT $L76613
$L76610:

; 863  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatMulScalar@@YAXPATMatrixUnion@@M@Z ENDP		; MatMulScalar
_TEXT	ENDS
PUBLIC	?BuildCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z ; BuildCrossMat
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
_vec$ = 8						; size = 4
_mat$ = 12						; size = 4
?BuildCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z PROC NEAR ; BuildCrossMat, COMDAT

; 871  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 872  : 	mat->m[XX] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax], 0

; 873  : 	mat->m[XY] = -vec->v[Z];

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+4]

; 874  : 	mat->m[XZ] = vec->v[Y];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 875  : 	
; 876  : 	mat->m[YX] = vec->v[Z];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 877  : 	mat->m[YY] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+16], 0

; 878  : 	mat->m[YZ] = -vec->v[X];

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+20]

; 879  : 
; 880  : 	mat->m[ZX] = -vec->v[Y];

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+24]

; 881  : 	mat->m[ZY] = vec->v[X];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+28], edx

; 882  : 	mat->m[ZZ] = (REAL)0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+32], 0

; 883  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z ENDP ; BuildCrossMat
_TEXT	ENDS
PUBLIC	?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z ; VecCrossMat
; Function compile flags: /Odt /ZI
;	COMDAT ?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z
_TEXT	SEGMENT
_vecLeft$ = 8						; size = 4
_matRight$ = 12						; size = 4
_matOut$ = 16						; size = 4
?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z PROC NEAR ; VecCrossMat, COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 891  : 
; 892  : 	matOut->m[XX] = vecLeft->v[Y] * matRight->m[ZX] - vecLeft->v[Z] * matRight->m[YX];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx]

; 893  : 	matOut->m[XY] = vecLeft->v[Y] * matRight->m[ZY] - vecLeft->v[Z] * matRight->m[YY];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+4]

; 894  : 	matOut->m[XZ] = vecLeft->v[Y] * matRight->m[ZZ] - vecLeft->v[Z] * matRight->m[YZ];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+20]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+8]

; 895  : 
; 896  : 	matOut->m[YX] = vecLeft->v[Z] * matRight->m[XX] - vecLeft->v[X] * matRight->m[ZX];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+24]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+12]

; 897  : 	matOut->m[YY] = vecLeft->v[Z] * matRight->m[XY] - vecLeft->v[X] * matRight->m[ZY];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+28]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+16]

; 898  : 	matOut->m[YZ] = vecLeft->v[Z] * matRight->m[XZ] - vecLeft->v[X] * matRight->m[ZZ];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+32]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+20]

; 899  : 
; 900  : 	matOut->m[ZX] = vecLeft->v[X] * matRight->m[YX] - vecLeft->v[Y] * matRight->m[XX];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+24]

; 901  : 	matOut->m[ZY] = vecLeft->v[X] * matRight->m[YY] - vecLeft->v[Y] * matRight->m[XY];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+28]

; 902  : 	matOut->m[ZZ] = vecLeft->v[X] * matRight->m[YZ] - vecLeft->v[Y] * matRight->m[XZ];

	mov	eax, DWORD PTR _vecLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _vecLeft$[ebp]
	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+32]

; 903  : 
; 904  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VecCrossMat@@YAXPAUVectorStruct@@PATMatrixUnion@@1@Z ENDP ; VecCrossMat
_TEXT	ENDS
PUBLIC	?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z ; MatCrossVec
; Function compile flags: /Odt /ZI
;	COMDAT ?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z
_TEXT	SEGMENT
_matLeft$ = 8						; size = 4
_vecRight$ = 12						; size = 4
_matOut$ = 16						; size = 4
?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z PROC NEAR ; MatCrossVec, COMDAT

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 908  : 
; 909  : 	matOut->m[XX] = - vecRight->v[Y] * matLeft->m[XZ] + vecRight->v[Z] * matLeft->m[XY];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx]

; 910  : 	matOut->m[XY] = - vecRight->v[Z] * matLeft->m[XX] + vecRight->v[X] * matLeft->m[XZ];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+4]

; 911  : 	matOut->m[XZ] = - vecRight->v[X] * matLeft->m[XY] + vecRight->v[Y] * matLeft->m[XX];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+8]

; 912  : 
; 913  : 	matOut->m[YX] = - vecRight->v[Y] * matLeft->m[YZ] + vecRight->v[Z] * matLeft->m[YY];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+12]

; 914  : 	matOut->m[YY] = - vecRight->v[Z] * matLeft->m[YX] + vecRight->v[X] * matLeft->m[YZ];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+20]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+16]

; 915  : 	matOut->m[YZ] = - vecRight->v[X] * matLeft->m[YY] + vecRight->v[Y] * matLeft->m[YX];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+20]

; 916  : 
; 917  : 	matOut->m[ZX] = - vecRight->v[Y] * matLeft->m[ZZ] + vecRight->v[Z] * matLeft->m[ZY];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+24]

; 918  : 	matOut->m[ZY] = - vecRight->v[Z] * matLeft->m[ZX] + vecRight->v[X] * matLeft->m[ZZ];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+32]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+28]

; 919  : 	matOut->m[ZZ] = - vecRight->v[X] * matLeft->m[ZY] + vecRight->v[Y] * matLeft->m[ZX];

	mov	eax, DWORD PTR _vecRight$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _vecRight$[ebp]
	mov	eax, DWORD PTR _matLeft$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [ecx+32]

; 920  : 
; 921  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatCrossVec@@YAXPATMatrixUnion@@PAUVectorStruct@@0@Z ENDP ; MatCrossVec
_TEXT	ENDS
PUBLIC	?SwapVecs@@YAXPAUVectorStruct@@0@Z		; SwapVecs
; Function compile flags: /Odt /ZI
;	COMDAT ?SwapVecs@@YAXPAUVectorStruct@@0@Z
_TEXT	SEGMENT
_store$ = -12						; size = 12
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?SwapVecs@@YAXPAUVectorStruct@@0@Z PROC NEAR		; SwapVecs, COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 929  : 	VEC store;
; 930  : 	store.v[X] = a->v[X];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _store$[ebp], ecx

; 931  : 	store.v[Y] = a->v[Y];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _store$[ebp+4], ecx

; 932  : 	store.v[Z] = a->v[Z];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _store$[ebp+8], ecx

; 933  : 
; 934  : 	a->v[X] = b->v[X];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 935  : 	a->v[Y] = b->v[Y];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 936  : 	a->v[Z] = b->v[Z];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 937  : 
; 938  : 	b->v[X] = store.v[X];

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _store$[ebp]
	mov	DWORD PTR [eax], ecx

; 939  : 	b->v[Y] = store.v[Y];

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _store$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 940  : 	b->v[Z] = store.v[Z];

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _store$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 941  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SwapVecs@@YAXPAUVectorStruct@@0@Z ENDP			; SwapVecs
_TEXT	ENDS
PUBLIC	?TransMat@@YAXPATMatrixUnion@@0@Z		; TransMat
; Function compile flags: /Odt /ZI
;	COMDAT ?TransMat@@YAXPATMatrixUnion@@0@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?TransMat@@YAXPATMatrixUnion@@0@Z PROC NEAR		; TransMat, COMDAT

; 951  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 952  : 	dest->m[XX] = src->m[XX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 953  : 	dest->m[XY] = src->m[YX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 954  : 	dest->m[XZ] = src->m[ZX];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx

; 955  : 
; 956  : 	dest->m[YX] = src->m[XY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx

; 957  : 	dest->m[YY] = src->m[YY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 958  : 	dest->m[YZ] = src->m[ZY];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+20], edx

; 959  : 
; 960  : 	dest->m[ZX] = src->m[XZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx

; 961  : 	dest->m[ZY] = src->m[YZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+28], edx

; 962  : 	dest->m[ZZ] = src->m[ZZ];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 963  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransMat@@YAXPATMatrixUnion@@0@Z ENDP			; TransMat
_TEXT	ENDS
PUBLIC	?InvertMat@@YAXPATMatrixUnion@@@Z		; InvertMat
PUBLIC	__real@00000000
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?InvertMat@@YAXPATMatrixUnion@@@Z
_TEXT	SEGMENT
tv139 = -160						; size = 4
tv89 = -156						; size = 4
_pivotCandidate$ = -88					; size = 4
_j$ = -84						; size = 4
_i$ = -80						; size = 4
_tmpReal$ = -76						; size = 4
_b$ = -72						; size = 36
_a$ = -36						; size = 36
_mat$ = 8						; size = 4
?InvertMat@@YAXPATMatrixUnion@@@Z PROC NEAR		; InvertMat, COMDAT

; 974  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi

; 975  : 
; 976  : 	// As workMat evolves towards identity
; 977  : 	// mat evolves towards inverse
; 978  : 	MAT	a;
; 979  : 	MAT	b;
; 980  : 	REAL	tmpReal;
; 981  : 
; 982  : 	int i, j;
; 983  : 	int pivotCandidate;							// Row with largest pivot candidate
; 984  : 
; 985  : 	CopyMat(mat, &a);

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8

; 986  : 	SetMatUnit(&b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?SetMatUnit@@YAXPATMatrixUnion@@@Z	; SetMatUnit
	add	esp, 4

; 987  : 
; 988  : 
; 989  : 	// Loop over columns from left to right, eliminating above and below diagonal
; 990  : 	for (j = 0; j < 3; ++j) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L76650
$L76651:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L76650:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$L76652

; 991  : 		pivotCandidate = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _pivotCandidate$[ebp], eax

; 992  : 		
; 993  : 		for (i = j + 1; i < 3; ++i) {

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L76653
$L76654:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76653:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L76655

; 994  : 			if (abs(a.mv[i].v[j]) > abs(a.mv[pivotCandidate].v[j])) {

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77136
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fstp	DWORD PTR tv89[ebp]
	jmp	SHORT $L77137
$L77136:
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv89[ebp]
$L77137:
	mov	eax, DWORD PTR _pivotCandidate$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L77138
	mov	eax, DWORD PTR _pivotCandidate$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fstp	DWORD PTR tv139[ebp]
	jmp	SHORT $L77139
$L77138:
	mov	eax, DWORD PTR _pivotCandidate$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR [ecx+edx*4]
	fchs
	fstp	DWORD PTR tv139[ebp]
$L77139:
	fld	DWORD PTR tv89[ebp]
	fcomp	DWORD PTR tv139[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76656

; 995  : 				pivotCandidate = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _pivotCandidate$[ebp], eax
$L76656:

; 996  : 			}
; 997  : 		}

	jmp	$L76654
$L76655:

; 998  : 
; 999  : 		// Swap rows `pivotCandidate' and `j' in workMat and mat to put pivot on diagonal
; 1000 : 		SwapVecs(&a.mv[pivotCandidate], &a.mv[j]);

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _pivotCandidate$[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR _a$[ebp+edx]
	push	eax
	call	?SwapVecs@@YAXPAUVectorStruct@@0@Z	; SwapVecs
	add	esp, 8

; 1001 : 		SwapVecs(&b.mv[pivotCandidate], &b.mv[j]);

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _b$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _pivotCandidate$[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR _b$[ebp+edx]
	push	eax
	call	?SwapVecs@@YAXPAUVectorStruct@@0@Z	; SwapVecs
	add	esp, 8

; 1002 : 
; 1003 : 		// Scale row `j' to have a unit diagonal
; 1004 : 		if (a.mv[j].v[j] == (REAL)0.0) {

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR [ecx+edx*4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L76658

; 1005 : 			// Cannot get inverse of this matrix as rows are linearly dependent
; 1006 : 			SetMatZero(mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	?SetMatZero@@YAXPATMatrixUnion@@@Z	; SetMatZero
	add	esp, 4

; 1007 : 			return;

	jmp	$L76643
$L76658:

; 1008 : 		}
; 1009 : 		tmpReal = a.mv[j].v[j];

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tmpReal$[ebp], eax

; 1010 : 		VecDivScalar(&b.mv[j], tmpReal);

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	fld	DWORD PTR _b$[ebp+eax]
	fdiv	DWORD PTR _tmpReal$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fstp	DWORD PTR _b$[ebp+ecx]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	fld	DWORD PTR _b$[ebp+eax+4]
	fdiv	DWORD PTR _tmpReal$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fstp	DWORD PTR _b$[ebp+ecx+4]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	fld	DWORD PTR _b$[ebp+eax+8]
	fdiv	DWORD PTR _tmpReal$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fstp	DWORD PTR _b$[ebp+ecx+8]

; 1011 : 		VecDivScalar(&a.mv[j], tmpReal);

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	fld	DWORD PTR _a$[ebp+eax]
	fdiv	DWORD PTR _tmpReal$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fstp	DWORD PTR _a$[ebp+ecx]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	fld	DWORD PTR _a$[ebp+eax+4]
	fdiv	DWORD PTR _tmpReal$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fstp	DWORD PTR _a$[ebp+ecx+4]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 12					; 0000000cH
	fld	DWORD PTR _a$[ebp+eax+8]
	fdiv	DWORD PTR _tmpReal$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fstp	DWORD PTR _a$[ebp+ecx+8]

; 1012 : 
; 1013 : 		// Eliminate off-diagonal elements in column `j'
; 1014 : 		for (i = 0; i < 3; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L76659
$L76660:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L76659:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$L76661

; 1015 : 			if (i != j) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _j$[ebp]
	je	$L76662

; 1016 : 				tmpReal = a.mv[i].v[j];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tmpReal$[ebp], eax

; 1017 : 				b.mv[i].v[X] -= tmpReal * b.mv[j].v[X];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fld	DWORD PTR _tmpReal$[ebp]
	fmul	DWORD PTR _b$[ebp+ecx]
	fsubr	DWORD PTR _b$[ebp+eax]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	fstp	DWORD PTR _b$[ebp+edx]

; 1018 : 				b.mv[i].v[Y] -= tmpReal * b.mv[j].v[Y];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fld	DWORD PTR _tmpReal$[ebp]
	fmul	DWORD PTR _b$[ebp+ecx+4]
	fsubr	DWORD PTR _b$[ebp+eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	fstp	DWORD PTR _b$[ebp+edx+4]

; 1019 : 				b.mv[i].v[Z] -= tmpReal * b.mv[j].v[Z];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fld	DWORD PTR _tmpReal$[ebp]
	fmul	DWORD PTR _b$[ebp+ecx+8]
	fsubr	DWORD PTR _b$[ebp+eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	fstp	DWORD PTR _b$[ebp+edx+8]

; 1020 : 				
; 1021 : 				a.mv[i].v[X] -= tmpReal * a.mv[j].v[X];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fld	DWORD PTR _tmpReal$[ebp]
	fmul	DWORD PTR _a$[ebp+ecx]
	fsubr	DWORD PTR _a$[ebp+eax]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	fstp	DWORD PTR _a$[ebp+edx]

; 1022 : 				a.mv[i].v[Y] -= tmpReal * a.mv[j].v[Y];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fld	DWORD PTR _tmpReal$[ebp]
	fmul	DWORD PTR _a$[ebp+ecx+4]
	fsubr	DWORD PTR _a$[ebp+eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	fstp	DWORD PTR _a$[ebp+edx+4]

; 1023 : 				a.mv[i].v[Z] -= tmpReal * a.mv[j].v[Z];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 12					; 0000000cH
	fld	DWORD PTR _tmpReal$[ebp]
	fmul	DWORD PTR _a$[ebp+ecx+8]
	fsubr	DWORD PTR _a$[ebp+eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	fstp	DWORD PTR _a$[ebp+edx+8]
$L76662:

; 1024 : 			}
; 1025 : 		}

	jmp	$L76660
$L76661:

; 1026 : 	}

	jmp	$L76651
$L76652:

; 1027 : 
; 1028 : 	CopyMat(&b, mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	?CopyMat@@YAXPATMatrixUnion@@0@Z	; CopyMat
	add	esp, 8
$L76643:

; 1029 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InvertMat@@YAXPATMatrixUnion@@@Z ENDP			; InvertMat
_TEXT	ENDS
PUBLIC	?MatPlusMat@@YAXPATMatrixUnion@@00@Z		; MatPlusMat
; Function compile flags: /Odt /ZI
;	COMDAT ?MatPlusMat@@YAXPATMatrixUnion@@00@Z
_TEXT	SEGMENT
_matLeft$ = 8						; size = 4
_matRight$ = 12						; size = 4
_matOut$ = 16						; size = 4
?MatPlusMat@@YAXPATMatrixUnion@@00@Z PROC NEAR		; MatPlusMat, COMDAT

; 1038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1039 : 	matOut->m[XX] = matLeft->m[XX] + matRight->m[XX];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx]

; 1040 : 	matOut->m[XY] = matLeft->m[XY] + matRight->m[XY];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+4]

; 1041 : 	matOut->m[XZ] = matLeft->m[XZ] + matRight->m[XZ];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+8]

; 1042 : 
; 1043 : 	matOut->m[YX] = matLeft->m[YX] + matRight->m[YX];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+12]

; 1044 : 	matOut->m[YY] = matLeft->m[YY] + matRight->m[YY];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+16]

; 1045 : 	matOut->m[YZ] = matLeft->m[YZ] + matRight->m[YZ];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+20]

; 1046 : 
; 1047 : 	matOut->m[ZX] = matLeft->m[ZX] + matRight->m[ZX];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+24]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+24]

; 1048 : 	matOut->m[ZY] = matLeft->m[ZY] + matRight->m[ZY];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+28]

; 1049 : 	matOut->m[ZZ] = matLeft->m[ZZ] + matRight->m[ZZ];

	mov	eax, DWORD PTR _matLeft$[ebp]
	mov	ecx, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR [eax+32]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _matOut$[ebp]
	fstp	DWORD PTR [edx+32]

; 1050 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatPlusMat@@YAXPATMatrixUnion@@00@Z ENDP		; MatPlusMat
_TEXT	ENDS
PUBLIC	?MatPlusEqScalarMat@@YAXPATMatrixUnion@@M0@Z	; MatPlusEqScalarMat
; Function compile flags: /Odt /ZI
;	COMDAT ?MatPlusEqScalarMat@@YAXPATMatrixUnion@@M0@Z
_TEXT	SEGMENT
_matLeft$ = 8						; size = 4
_scalar$ = 12						; size = 4
_matRight$ = 16						; size = 4
?MatPlusEqScalarMat@@YAXPATMatrixUnion@@M0@Z PROC NEAR	; MatPlusEqScalarMat, COMDAT

; 1053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1054 : 	matLeft->m[XX] += scalar * matRight->m[XX];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx]

; 1055 : 	matLeft->m[XY] += scalar * matRight->m[XY];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+4]

; 1056 : 	matLeft->m[XZ] += scalar * matRight->m[XZ];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+8]

; 1057 : 
; 1058 : 	matLeft->m[YX] += scalar * matRight->m[YX];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+12]

; 1059 : 	matLeft->m[YY] += scalar * matRight->m[YY];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+16]

; 1060 : 	matLeft->m[YZ] += scalar * matRight->m[YZ];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+20]

; 1061 : 
; 1062 : 	matLeft->m[ZX] += scalar * matRight->m[ZX];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+24]

; 1063 : 	matLeft->m[ZY] += scalar * matRight->m[ZY];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+28]

; 1064 : 	matLeft->m[ZZ] += scalar * matRight->m[ZZ];

	mov	eax, DWORD PTR _matRight$[ebp]
	fld	DWORD PTR _scalar$[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _matLeft$[ebp]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _matLeft$[ebp]
	fstp	DWORD PTR [edx+32]

; 1065 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatPlusEqScalarMat@@YAXPATMatrixUnion@@M0@Z ENDP	; MatPlusEqScalarMat
_TEXT	ENDS
PUBLIC	?BuildMatFromVec@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z ; BuildMatFromVec
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildMatFromVec@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
tv293 = -76						; size = 4
tv268 = -76						; size = 4
tv257 = -76						; size = 4
__mul$76685 = -8					; size = 4
__mul$76683 = -4					; size = 4
_vec$ = 8						; size = 4
_mat$ = 12						; size = 4
?BuildMatFromVec@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z PROC NEAR ; BuildMatFromVec, COMDAT

; 1074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1075 : 	mat->m[UX] = vec->v[X];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx

; 1076 : 	mat->m[UY] = vec->v[Y];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx

; 1077 : 	mat->m[UZ] = vec->v[Z];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+20], edx

; 1078 : 	
; 1079 : 	// Choose a right vector perpendicular to the up vector
; 1080 : 	if (fabs(mat->m[UX]) < fabs(mat->m[UY])) {

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv257[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv257[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76677

; 1081 : 		if (fabs(mat->m[UX]) < fabs(mat->m[UZ])) {	// either X or Z is smallest

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv268[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv268[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76678

; 1082 : 			mat->m[RX] = 0.0f;					// up[X] is smallest

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax], 0

; 1083 : 			mat->m[RY] = mat->m[UZ];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx

; 1084 : 			mat->m[RZ] = -mat->m[UY];

	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+16]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1085 : 		} else {

	jmp	SHORT $L76679
$L76678:

; 1086 : 			mat->m[RX] = -mat->m[UY];		// up[Z] is smallest

	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+16]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx]

; 1087 : 			mat->m[RY] = mat->m[UX];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 1088 : 			mat->m[RZ] = 0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0
$L76679:

; 1089 : 		}
; 1090 : 	} else {										// either Y or Z is smallest

	jmp	SHORT $L76680
$L76677:

; 1091 : 		if (fabs(mat->m[UY]) < fabs(mat->m[UZ])) {

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	?fabs@@YAMM@Z				; fabs
	fstp	DWORD PTR tv293[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fcomp	DWORD PTR tv293[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76681

; 1092 : 			mat->m[RX] = mat->m[UZ];		// Y is smallest

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx

; 1093 : 			mat->m[RY] = 0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1094 : 			mat->m[RZ] = -mat->m[UX];

	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1095 : 		} else {

	jmp	SHORT $L76680
$L76681:

; 1096 : 			mat->m[RX] = mat->m[UY];		// Z is smallest

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 1097 : 			mat->m[RY] = -mat->m[UX];

	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+4]

; 1098 : 			mat->m[RZ] = 0.0f;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR [eax+8], 0
$L76680:

; 1099 : 		}
; 1100 : 	}
; 1101 : 	NormalizeVec(&mat->mv[R])

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76683[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76683[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76683[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76683[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1102 : 
; 1103 : 	// Calculate a right vector from the up and look vectors
; 1104 : 	CrossProduct(&mat->mv[R], &mat->mv[U], &mat->mv[L]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+20]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+32]

; 1105 : 	NormalizeVec(&mat->mv[L]);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76685[ebp]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76685[ebp]
	fmul	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76685[ebp]
	fmul	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _mat$[ebp]
	fld	DWORD PTR __mul$76685[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+32]

; 1106 : 
; 1107 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildMatFromVec@@YAXPAUVectorStruct@@PATMatrixUnion@@@Z ENDP ; BuildMatFromVec
_TEXT	ENDS
PUBLIC	?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z ; MovePlane
; Function compile flags: /Odt /ZI
;	COMDAT ?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_plane$ = 8						; size = 4
_dR$ = 12						; size = 4
?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z PROC NEAR ; MovePlane, COMDAT

; 1118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1119 : 	plane->v[D] -= VecDotVec(dR, PlaneNormal(plane));

	mov	eax, DWORD PTR _dR$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _dR$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _plane$[ebp]
	fsubr	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [ecx+12]

; 1120 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z ENDP	; MovePlane
_TEXT	ENDS
PUBLIC	?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z ; PlaneIntersect3
EXTRN	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z:NEAR ; SolveLinearEquations
_BSS	SEGMENT
_GEO_Coef DB	01008H DUP (?)
_GEO_Res DB	084H DUP (?)
_GEO_Soln DB	084H DUP (?)
_GEO_Work DB	084H DUP (?)
_GEO_OrigCol DD	020H DUP (?)
_GEO_OrigRow DD	020H DUP (?)
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z
_TEXT	SEGMENT
_nSolved$ = -4						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_p3$ = 16						; size = 4
_r$ = 20						; size = 4
?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z PROC NEAR ; PlaneIntersect3, COMDAT

; 1138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1139 : 	int	nSolved;
; 1140 : 
; 1141 : 	// Build the plane equations for the solver
; 1142 : 	SetBigMatSize(&GEO_Coef, 3, 3);

	mov	DWORD PTR _GEO_Coef+4096, 3
	mov	DWORD PTR _GEO_Coef+4100, 3

; 1143 : 	SetBigVecSize(&GEO_Res, 3);

	mov	DWORD PTR _GEO_Res+128, 3

; 1144 : 	SetBigVecSize(&GEO_Soln, 3);

	mov	DWORD PTR _GEO_Soln+128, 3

; 1145 : 
; 1146 : 	GEO_Coef.m[0][A] = p1->v[A];

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _GEO_Coef, ecx

; 1147 : 	GEO_Coef.m[0][B] = p1->v[B];

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _GEO_Coef+4, ecx

; 1148 : 	GEO_Coef.m[0][C] = p1->v[C];

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _GEO_Coef+8, ecx

; 1149 : 	GEO_Res.v[0] = -p1->v[D];

	mov	eax, DWORD PTR _p1$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	fstp	DWORD PTR _GEO_Res

; 1150 : 
; 1151 : 	GEO_Coef.m[1][A] = p2->v[A];

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _GEO_Coef+128, ecx

; 1152 : 	GEO_Coef.m[1][B] = p2->v[B];

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _GEO_Coef+132, ecx

; 1153 : 	GEO_Coef.m[1][C] = p2->v[C];

	mov	eax, DWORD PTR _p2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _GEO_Coef+136, ecx

; 1154 : 	GEO_Res.v[1] = -p2->v[D];

	mov	eax, DWORD PTR _p2$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	fstp	DWORD PTR _GEO_Res+4

; 1155 : 
; 1156 : 	GEO_Coef.m[2][A] = p3->v[A];

	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _GEO_Coef+256, ecx

; 1157 : 	GEO_Coef.m[2][B] = p3->v[B];

	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _GEO_Coef+260, ecx

; 1158 : 	GEO_Coef.m[2][C] = p3->v[C];

	mov	eax, DWORD PTR _p3$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _GEO_Coef+264, ecx

; 1159 : 	GEO_Res.v[2] = -p3->v[D];

	mov	eax, DWORD PTR _p3$[ebp]
	fld	DWORD PTR [eax+12]
	fchs
	fstp	DWORD PTR _GEO_Res+8

; 1160 : 
; 1161 : 	nSolved = SolveLinearEquations(&GEO_Coef, &GEO_Res, ZERO, Real(0.0001), GEO_OrigRow, GEO_OrigCol, &GEO_Work, &GEO_Soln);

	push	OFFSET FLAT:_GEO_Soln
	push	OFFSET FLAT:_GEO_Work
	push	OFFSET FLAT:_GEO_OrigCol
	push	OFFSET FLAT:_GEO_OrigRow
	push	953267991				; 38d1b717H
	push	0
	push	OFFSET FLAT:_GEO_Res
	push	OFFSET FLAT:_GEO_Coef
	call	?SolveLinearEquations@@YAHPAUBIGMAT@@PAUBIGVEC@@MMPAH211@Z ; SolveLinearEquations
	add	esp, 32					; 00000020H
	mov	DWORD PTR _nSolved$[ebp], eax

; 1162 : 	if (nSolved < 3) {

	cmp	DWORD PTR _nSolved$[ebp], 3
	jge	SHORT $L76708

; 1163 : 		return FALSE;

	xor	al, al
	jmp	SHORT $L76705
$L76708:

; 1164 : 	} else {
; 1165 : 		SetVec(r, GEO_Soln.v[0], GEO_Soln.v[1], GEO_Soln.v[2]);

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _GEO_Soln
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _GEO_Soln+4
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _GEO_Soln+8
	mov	DWORD PTR [eax+8], ecx

; 1166 : 		return TRUE;

	mov	al, 1
$L76705:

; 1167 : 	}
; 1168 : 
; 1169 : 	/*REAL	numerator;
; 1170 : 	VEC	denominator;
; 1171 : 
; 1172 : 	numerator = p1->v[D] - p2->v[D] - p3->v[D];
; 1173 : 	VecMinusVec(PlaneNormal(p3), PlaneNormal(p1), &denominator);
; 1174 : 	VecPlusEqVec(&denominator, PlaneNormal(p2));
; 1175 : 
; 1176 : 	if (denominator.v[X] < SMALL_REAL) {
; 1177 : 		SetVecZero(r);
; 1178 : 		return FALSE;
; 1179 : 	}
; 1180 : 	r->v[X] = numerator / denominator.v[X];
; 1181 : 
; 1182 : 	if (denominator.v[Y] < SMALL_REAL) {
; 1183 : 		SetVecZero(r);
; 1184 : 		return FALSE;
; 1185 : 	}
; 1186 : 	r->v[Y] = numerator / denominator.v[Y];
; 1187 : 	
; 1188 : 	if (denominator.v[Z] < SMALL_REAL) {
; 1189 : 		SetVecZero(r);
; 1190 : 		return FALSE;
; 1191 : 	}
; 1192 : 	r->v[Z] = numerator / denominator.v[Z];
; 1193 : 
; 1194 : 	return TRUE;*/
; 1195 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z ENDP ; PlaneIntersect3
_TEXT	ENDS
PUBLIC	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
; Function compile flags: /Odt /ZI
;	COMDAT ?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z
_TEXT	SEGMENT
_plane$ = 8						; size = 4
_rotMat$ = 12						; size = 4
_dR$ = 16						; size = 4
_pOut$ = 20						; size = 4
?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z PROC NEAR ; RotTransPlane, COMDAT

; 1205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1206 : 	VecMulMat(PlaneNormal(plane), rotMat, PlaneNormal(pOut));

	mov	eax, DWORD PTR _pOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rotMat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _plane$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1207 : 
; 1208 : 	pOut->v[D] = plane->v[D] - VecDotVec(dR, PlaneNormal(pOut));

	mov	eax, DWORD PTR _dR$[ebp]
	mov	ecx, DWORD PTR _pOut$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _pOut$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _dR$[ebp]
	mov	edx, DWORD PTR _pOut$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _plane$[ebp]
	fsubr	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _pOut$[ebp]
	fstp	DWORD PTR [ecx+12]

; 1209 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ENDP ; RotTransPlane
_TEXT	ENDS
PUBLIC	?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z ; BuildPlane
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z
_TEXT	SEGMENT
__mul$76732 = -28					; size = 4
_vec2$ = -24						; size = 12
_vec1$ = -12						; size = 12
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_p$ = 20						; size = 4
?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z PROC NEAR ; BuildPlane, COMDAT

; 1216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1217 : 	VEC vec1, vec2;
; 1218 : 
; 1219 : // build plane normal
; 1220 : 
; 1221 : 	SubVector(b, a, &vec1)

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _vec1$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _vec1$[ebp+4]
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _vec1$[ebp+8]

; 1222 : 	SubVector(c, a, &vec2)

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _vec2$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _vec2$[ebp+4]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _vec2$[ebp+8]

; 1223 : 	CrossProduct(&vec1, &vec2, (VEC*)p);

	fld	DWORD PTR _vec1$[ebp+4]
	fmul	DWORD PTR _vec2$[ebp+8]
	fld	DWORD PTR _vec1$[ebp+8]
	fmul	DWORD PTR _vec2$[ebp+4]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR _vec1$[ebp+8]
	fmul	DWORD PTR _vec2$[ebp]
	fld	DWORD PTR _vec1$[ebp]
	fmul	DWORD PTR _vec2$[ebp+8]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR _vec1$[ebp]
	fmul	DWORD PTR _vec2$[ebp+4]
	fld	DWORD PTR _vec1$[ebp+4]
	fmul	DWORD PTR _vec2$[ebp]
	fsubp	ST(1), ST(0)
	mov	eax, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [eax+8]

; 1224 : 	NormalizeVector((VEC*)p);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fdivr	DWORD PTR __real@3f800000
	fstp	DWORD PTR __mul$76732[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR __mul$76732[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR __mul$76732[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR __mul$76732[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1225 : 
; 1226 : // build plane W
; 1227 : 
; 1228 : 	AddVector(a, b, &vec1);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _vec1$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	fstp	DWORD PTR _vec1$[ebp+4]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR _vec1$[ebp+8]

; 1229 : 	AddVector(&vec1, c, &vec1);

	mov	eax, DWORD PTR _c$[ebp]
	fld	DWORD PTR _vec1$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _vec1$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	fld	DWORD PTR _vec1$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _vec1$[ebp+4]
	mov	eax, DWORD PTR _c$[ebp]
	fld	DWORD PTR _vec1$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _vec1$[ebp+8]

; 1230 : 	p->v[D] = -DotProduct((VEC*)p, &vec1) / 3.0f;

	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR _vec1$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _vec1$[ebp+4]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR _vec1$[ebp+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fdiv	DWORD PTR __real@40400000
	mov	eax, DWORD PTR _p$[ebp]
	fstp	DWORD PTR [eax+12]

; 1231 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildPlane@@YAXPAUVectorStruct@@00PAUPlaneStruct@@@Z ENDP ; BuildPlane
_TEXT	ENDS
PUBLIC	?BuildPlane2@@YAXPAUVectorStruct@@0PAUPlaneStruct@@@Z ; BuildPlane2
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildPlane2@@YAXPAUVectorStruct@@0PAUPlaneStruct@@@Z
_TEXT	SEGMENT
_normal$ = 8						; size = 4
_pt$ = 12						; size = 4
_plane$ = 16						; size = 4
?BuildPlane2@@YAXPAUVectorStruct@@0PAUPlaneStruct@@@Z PROC NEAR ; BuildPlane2, COMDAT

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1241 : 	CopyVec(normal, PlaneNormal(plane));

	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1242 : 	plane->v[D] = -VecDotVec(pt, normal);

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [eax+12]

; 1243 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildPlane2@@YAXPAUVectorStruct@@0PAUPlaneStruct@@@Z ENDP ; BuildPlane2
_TEXT	ENDS
PUBLIC	?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z ; QuatToMat
; Function compile flags: /Odt /ZI
;	COMDAT ?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
_tReal2$ = -8						; size = 4
_tReal1$ = -4						; size = 4
_quat$ = 8						; size = 4
_mat$ = 12						; size = 4
?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z PROC NEAR ; QuatToMat, COMDAT

; 1253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1254 : 	REAL tReal1, tReal2;
; 1255 : 
; 1256 : 	mat->m[XX] = ONE - 2 * (quat->v[VY] * quat->v[VY] + quat->v[VZ] * quat->v[VZ]);

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quat$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx]

; 1257 : 	mat->m[YY] = ONE - 2 * (quat->v[VX] * quat->v[VX] + quat->v[VZ] * quat->v[VZ]);

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _quat$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+16]

; 1258 : 	mat->m[ZZ] = ONE - 2 * (quat->v[VX] * quat->v[VX] + quat->v[VY] * quat->v[VY]);

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _quat$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [ecx+32]

; 1259 : 
; 1260 : 	tReal1 = quat->v[VX] * quat->v[VY];

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR _tReal1$[ebp]

; 1261 : 	tReal2 = quat->v[S] * quat->v[VZ];

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+8]
	fstp	DWORD PTR _tReal2$[ebp]

; 1262 : 	mat->m[YX] = 2 * (tReal1 - tReal2);

	fld	DWORD PTR _tReal1$[ebp]
	fsub	DWORD PTR _tReal2$[ebp]
	fadd	ST(0), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+12]

; 1263 : 	mat->m[XY] = 2 * (tReal1 + tReal2);

	fld	DWORD PTR _tReal1$[ebp]
	fadd	DWORD PTR _tReal2$[ebp]
	fadd	ST(0), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+4]

; 1264 : 
; 1265 : 	tReal1 = quat->v[VX] * quat->v[VZ];

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	fstp	DWORD PTR _tReal1$[ebp]

; 1266 : 	tReal2 = quat->v[S] * quat->v[VY];

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR _tReal2$[ebp]

; 1267 : 	mat->m[ZX] = 2 * (tReal1 + tReal2);

	fld	DWORD PTR _tReal1$[ebp]
	fadd	DWORD PTR _tReal2$[ebp]
	fadd	ST(0), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+24]

; 1268 : 	mat->m[XZ] = 2 * (tReal1 - tReal2);

	fld	DWORD PTR _tReal1$[ebp]
	fsub	DWORD PTR _tReal2$[ebp]
	fadd	ST(0), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+8]

; 1269 : 
; 1270 : 	tReal1 = quat->v[VY] * quat->v[VZ];

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+8]
	fstp	DWORD PTR _tReal1$[ebp]

; 1271 : 	tReal2 = quat->v[S] * quat->v[VX];

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _tReal2$[ebp]

; 1272 : 	mat->m[ZY] = 2 * (tReal1 - tReal2);

	fld	DWORD PTR _tReal1$[ebp]
	fsub	DWORD PTR _tReal2$[ebp]
	fadd	ST(0), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+28]

; 1273 : 	mat->m[YZ] = 2 * (tReal1 + tReal2);

	fld	DWORD PTR _tReal1$[ebp]
	fadd	DWORD PTR _tReal2$[ebp]
	fadd	ST(0), ST(0)
	mov	eax, DWORD PTR _mat$[ebp]
	fstp	DWORD PTR [eax+20]

; 1274 : 
; 1275 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?QuatToMat@@YAXPAUQuaternionStruct@@PATMatrixUnion@@@Z ENDP ; QuatToMat
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z ; MatToQuat
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z
_TEXT	SEGMENT
tv130 = -80						; size = 4
_i$ = -12						; size = 4
_s$ = -8						; size = 4
_tr$ = -4						; size = 4
_mat$ = 8						; size = 4
_quat$ = 12						; size = 4
?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z PROC NEAR ; MatToQuat, COMDAT

; 1285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1286 : 	REAL	tr, s;
; 1287 : 	int		i = XX;

	mov	DWORD PTR _i$[ebp], 0

; 1288 : 
; 1289 : 	tr = mat->m[XX] + mat->m[YY] + mat->m[ZZ];

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _mat$[ebp]
	fadd	DWORD PTR [edx+32]
	fstp	DWORD PTR _tr$[ebp]

; 1290 : 
; 1291 : 	if (tr >= 0) {

	fld	DWORD PTR _tr$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L76767

; 1292 : 
; 1293 : 		s = (REAL)sqrt(tr + ONE);

	fld	DWORD PTR _tr$[ebp]
	fadd	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 1294 : 		quat->v[S]  = HALF * s;

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [eax+12]

; 1295 : 		s = HALF / s;

	fld	DWORD PTR __real@3f000000
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR _s$[ebp]

; 1296 : 		quat->v[VX] = (mat->m[YZ] - mat->m[ZY]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+28]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx]

; 1297 : 		quat->v[VY] = (mat->m[ZX] - mat->m[XZ]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+4]

; 1298 : 		quat->v[VZ] = (mat->m[XY] - mat->m[YX]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+12]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+8]

; 1299 : 
; 1300 : 	} else {

	jmp	$L76763
$L76767:

; 1301 : 		if (mat->m[YY] > mat->m[XX]) {

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+16]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76770

; 1302 : 			i = YY;

	mov	DWORD PTR _i$[ebp], 4
$L76770:

; 1303 : 		}
; 1304 : 		if (mat->m[ZZ] > mat->m[i]) {

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+32]
	fcomp	DWORD PTR [edx+ecx*4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L76771

; 1305 : 			i = ZZ;

	mov	DWORD PTR _i$[ebp], 8
$L76771:

; 1306 : 		}
; 1307 : 
; 1308 : 		switch(i) {

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv130[ebp], eax
	cmp	DWORD PTR tv130[ebp], 0
	je	SHORT $L76776
	cmp	DWORD PTR tv130[ebp], 4
	je	$L76778
	cmp	DWORD PTR tv130[ebp], 8
	je	$L76780
	jmp	$L76763
$L76776:

; 1309 : 
; 1310 : 		case XX:
; 1311 : 			
; 1312 : 			s = (REAL)sqrt((mat->m[XX] - (mat->m[YY] + mat->m[ZZ])) + 1);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _mat$[ebp]
	fsubr	DWORD PTR [edx]
	fadd	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 1313 : 			quat->v[VX] = HALF * s;

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [eax]

; 1314 : 			s = HALF / s;

	fld	DWORD PTR __real@3f000000
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR _s$[ebp]

; 1315 : 			quat->v[VY] = (mat->m[YX] + mat->m[XY]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+4]

; 1316 : 			quat->v[VZ] = (mat->m[XZ] + mat->m[ZX]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+24]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+8]

; 1317 : 			quat->v[S] = (mat->m[YZ] - mat->m[ZY]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [ecx+28]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+12]

; 1318 : 			break;

	jmp	$L76763
$L76778:

; 1319 : 
; 1320 : 		case YY:
; 1321 : 
; 1322 : 			s = (REAL)sqrt((mat->m[YY] - (mat->m[ZZ] + mat->m[XX])) + 1);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+32]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _mat$[ebp]
	fsubr	DWORD PTR [edx+16]
	fadd	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 1323 : 			quat->v[VY] = HALF * s;

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [eax+4]

; 1324 : 			s = HALF / s;

	fld	DWORD PTR __real@3f000000
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR _s$[ebp]

; 1325 : 			quat->v[VZ] = (mat->m[ZY] + mat->m[YZ]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR [ecx+20]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+8]

; 1326 : 			quat->v[VX] = (mat->m[YX] + mat->m[XY]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx]

; 1327 : 			quat->v[S] = (mat->m[ZX] - mat->m[XZ]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+12]

; 1328 : 			break;

	jmp	SHORT $L76763
$L76780:

; 1329 : 
; 1330 : 		case ZZ:
; 1331 : 
; 1332 : 			s = (REAL)sqrt((mat->m[ZZ] - (mat->m[XX] + mat->m[YY])) + 1);

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _mat$[ebp]
	fsubr	DWORD PTR [edx+32]
	fadd	DWORD PTR __real@3f800000
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 1333 : 			quat->v[VZ] = HALF * s;

	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [eax+8]

; 1334 : 			s = HALF / s;

	fld	DWORD PTR __real@3f000000
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR _s$[ebp]

; 1335 : 			quat->v[VX] = (mat->m[XZ] + mat->m[ZX]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+24]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx]

; 1336 : 			quat->v[VY] = (mat->m[ZY] + mat->m[YZ]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR [ecx+20]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+4]

; 1337 : 			quat->v[S] = (mat->m[XY] - mat->m[YX]) * s;

	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+12]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+12]
$L76763:

; 1338 : 			break;
; 1339 : 
; 1340 : 		}
; 1341 : 	}
; 1342 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MatToQuat@@YAXPATMatrixUnion@@PAUQuaternionStruct@@@Z ENDP ; MatToQuat
_TEXT	ENDS
PUBLIC	__real@c0000000
PUBLIC	?QuatRotVec@@YAXPAUQuaternionStruct@@PAUVectorStruct@@1@Z ; QuatRotVec
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?QuatRotVec@@YAXPAUQuaternionStruct@@PAUVectorStruct@@1@Z
_TEXT	SEGMENT
_cross$ = -20						; size = 12
_dot$ = -8						; size = 4
_sQ2$ = -4						; size = 4
_quat$ = 8						; size = 4
_vIn$ = 12						; size = 4
_vOut$ = 16						; size = 4
?QuatRotVec@@YAXPAUQuaternionStruct@@PAUVectorStruct@@1@Z PROC NEAR ; QuatRotVec, COMDAT

; 1352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1353 : 	REAL	sQ2;
; 1354 : 	REAL	dot;
; 1355 : 	VEC	cross;
; 1356 : 
; 1357 : 	sQ2 = quat->v[S] * quat->v[S];

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR _sQ2$[ebp]

; 1358 : 	dot = VecDotVec(vIn, VecOfQuat(quat));

	mov	eax, DWORD PTR _vIn$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vIn$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vIn$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dot$[ebp]

; 1359 : 	VecCrossVec(vIn, VecOfQuat(quat), &cross);

	mov	eax, DWORD PTR _vIn$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vIn$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _cross$[ebp]
	mov	eax, DWORD PTR _vIn$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vIn$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _cross$[ebp+4]
	mov	eax, DWORD PTR _vIn$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vIn$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _cross$[ebp+8]

; 1360 : 
; 1361 : 	VecCrossVec(&cross, VecOfQuat(quat), vOut)

	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _cross$[ebp+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _cross$[ebp+8]
	fmul	DWORD PTR [ecx+4]
	fsubp	ST(1), ST(0)
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _cross$[ebp+8]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _cross$[ebp]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _cross$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _cross$[ebp+4]
	fmul	DWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+8]

; 1362 : 	VecPlusEqScalarVec(vOut, sQ2, vIn);

	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR _sQ2$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR _sQ2$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vIn$[ebp]
	fld	DWORD PTR _sQ2$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+8]

; 1363 : 	VecPlusEqScalarVec(vOut, -2 * quat->v[S], &cross);

	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR __real@c0000000
	fmul	DWORD PTR [eax+12]
	fmul	DWORD PTR _cross$[ebp]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR __real@c0000000
	fmul	DWORD PTR [eax+12]
	fmul	DWORD PTR _cross$[ebp+4]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR __real@c0000000
	fmul	DWORD PTR [eax+12]
	fmul	DWORD PTR _cross$[ebp+8]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+8]

; 1364 : 	VecPlusEqScalarVec(vOut, dot, VecOfQuat(quat));

	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _dot$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _dot$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR _dot$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vOut$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vOut$[ebp]
	fstp	DWORD PTR [edx+8]

; 1365 : 
; 1366 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?QuatRotVec@@YAXPAUQuaternionStruct@@PAUVectorStruct@@1@Z ENDP ; QuatRotVec
_TEXT	ENDS
PUBLIC	?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z	; LerpQuat
; Function compile flags: /Odt /ZI
;	COMDAT ?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z
_TEXT	SEGMENT
_q0$ = 8						; size = 4
_q1$ = 12						; size = 4
_t$ = 16						; size = 4
_qt$ = 20						; size = 4
?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z PROC NEAR	; LerpQuat, COMDAT

; 1376 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1377 : 	qt->v[VX] = (ONE - t) * q0->v[VX] + t * q1->v[VX];

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _q0$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR [ecx]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx]

; 1378 : 	qt->v[VY] = (ONE - t) * q0->v[VY] + t * q1->v[VY];

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _q0$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx+4]

; 1379 : 	qt->v[VZ] = (ONE - t) * q0->v[VZ] + t * q1->v[VZ];

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _q0$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx+8]

; 1380 : 	qt->v[S] = (ONE - t) * q0->v[S] + t * q1->v[S];

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _q0$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx+12]

; 1381 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ENDP		; LerpQuat
_TEXT	ENDS
PUBLIC	__real@3c23d70a
PUBLIC	?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z	; SLerpQuat
PUBLIC	_acosf
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z
_TEXT	SEGMENT
_sintT$ = -16						; size = 4
_sin1mtT$ = -12						; size = 4
_sinT$ = -8						; size = 4
_theta$ = -4						; size = 4
_q0$ = 8						; size = 4
_q1$ = 12						; size = 4
_t$ = 16						; size = 4
_qt$ = 20						; size = 4
?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z PROC NEAR	; SLerpQuat, COMDAT

; 1392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1393 : 	REAL theta, sinT, sin1mtT, sintT;
; 1394 : 
; 1395 : 	theta = (REAL)acosf(QuatDotQuat(q0, q1));

	mov	eax, DWORD PTR _q0$[ebp]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _q0$[ebp]
	mov	eax, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _q0$[ebp]
	mov	edx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _q0$[ebp]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	_acosf
	add	esp, 4
	fstp	DWORD PTR _theta$[ebp]

; 1396 : 
; 1397 : 	// for small angles, spherical interpolation same as linear
; 1398 : 	if (theta < SLERP_SMALL_ANGLE) {

	fld	DWORD PTR _theta$[ebp]
	fcomp	DWORD PTR __real@3c23d70a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76826

; 1399 : 		sinT = ZERO;

	mov	DWORD PTR _sinT$[ebp], 0

; 1400 : 		sintT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _sintT$[ebp], eax

; 1401 : 		sin1mtT = (ONE - t);

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _t$[ebp]
	fstp	DWORD PTR _sin1mtT$[ebp]

; 1402 : 	} else {

	jmp	SHORT $L76827
$L76826:

; 1403 : 		sinT = (REAL)sin(theta);

	mov	eax, DWORD PTR _theta$[ebp]
	push	eax
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinT$[ebp]

; 1404 : 		sintT = (REAL)sin(t * theta);

	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _theta$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sintT$[ebp]

; 1405 : 		sin1mtT = (REAL)sin((ONE - t) * theta);

	fld	DWORD PTR __real@3f800000
	fsub	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _theta$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sin1mtT$[ebp]

; 1406 : 		sin1mtT /= sinT;

	fld	DWORD PTR _sin1mtT$[ebp]
	fdiv	DWORD PTR _sinT$[ebp]
	fstp	DWORD PTR _sin1mtT$[ebp]

; 1407 : 		sintT /= sinT;

	fld	DWORD PTR _sintT$[ebp]
	fdiv	DWORD PTR _sinT$[ebp]
	fstp	DWORD PTR _sintT$[ebp]
$L76827:

; 1408 : 	}
; 1409 : 
; 1410 : 	qt->v[VX] = sin1mtT * q0->v[VX] + sintT * q1->v[VX];

	mov	eax, DWORD PTR _q0$[ebp]
	fld	DWORD PTR _sin1mtT$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _sintT$[ebp]
	fmul	DWORD PTR [ecx]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx]

; 1411 : 	qt->v[VY] = sin1mtT * q0->v[VY] + sintT * q1->v[VY];

	mov	eax, DWORD PTR _q0$[ebp]
	fld	DWORD PTR _sin1mtT$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _sintT$[ebp]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx+4]

; 1412 : 	qt->v[VZ] = sin1mtT * q0->v[VZ] + sintT * q1->v[VZ];

	mov	eax, DWORD PTR _q0$[ebp]
	fld	DWORD PTR _sin1mtT$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _sintT$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx+8]

; 1413 : 	qt->v[S] = sin1mtT * q0->v[S] + sintT * q1->v[S];

	mov	eax, DWORD PTR _q0$[ebp]
	fld	DWORD PTR _sin1mtT$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR _sintT$[ebp]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _qt$[ebp]
	fstp	DWORD PTR [edx+12]

; 1414 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SLerpQuat@@YAXPAUQuaternionStruct@@0M0@Z ENDP		; SLerpQuat
_TEXT	ENDS
EXTRN	_acos:NEAR
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_acosf	PROC NEAR					; COMDAT

; 434  :         {return ((float)acos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_acos
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_acosf	ENDP
_TEXT	ENDS
PUBLIC	?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z	; LinePoint
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\geom.cpp
;	COMDAT ?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z
_TEXT	SEGMENT
_t$ = -44						; size = 4
_dd$ = -40						; size = 4
_rPdR$ = -36						; size = 4
_dRdR$ = -32						; size = 4
_rPrP$ = -28						; size = 4
_dR$ = -24						; size = 12
_rP$ = -12						; size = 12
_p$ = 8							; size = 4
_d$ = 12						; size = 4
_r0$ = 16						; size = 4
_r1$ = 20						; size = 4
_t1$ = 24						; size = 4
_t2$ = 28						; size = 4
?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z PROC NEAR	; LinePoint, COMDAT

; 1426 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1427 : 	VEC	rP, dR;
; 1428 : 	REAL	rPrP, dRdR, rPdR, dd, t;
; 1429 : 
; 1430 : 	VecMinusVec(r1, r0, &dR);

	mov	eax, DWORD PTR _r1$[ebp]
	mov	ecx, DWORD PTR _r0$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _r1$[ebp]
	mov	ecx, DWORD PTR _r0$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _r1$[ebp]
	mov	ecx, DWORD PTR _r0$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 1431 : 	VecMinusVec(r0, p, &rP);

	mov	eax, DWORD PTR _r0$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _rP$[ebp]
	mov	eax, DWORD PTR _r0$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _rP$[ebp+4]
	mov	eax, DWORD PTR _r0$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _rP$[ebp+8]

; 1432 : 	
; 1433 : 	dd = d * d;

	fld	DWORD PTR _d$[ebp]
	fmul	DWORD PTR _d$[ebp]
	fstp	DWORD PTR _dd$[ebp]

; 1434 : 	rPrP = VecDotVec(&rP, &rP);

	fld	DWORD PTR _rP$[ebp]
	fmul	DWORD PTR _rP$[ebp]
	fld	DWORD PTR _rP$[ebp+4]
	fmul	DWORD PTR _rP$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _rP$[ebp+8]
	fmul	DWORD PTR _rP$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rPrP$[ebp]

; 1435 : 	dRdR = VecDotVec(&dR, &dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dRdR$[ebp]

; 1436 : 	rPdR = VecDotVec(&rP, &dR);

	fld	DWORD PTR _rP$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _rP$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _rP$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rPdR$[ebp]

; 1437 : 
; 1438 : 	t = Real(4) * (rPdR * rPdR - dRdR * (rPrP - dd));

	fld	DWORD PTR _rPdR$[ebp]
	fmul	DWORD PTR _rPdR$[ebp]
	fld	DWORD PTR _rPrP$[ebp]
	fsub	DWORD PTR _dd$[ebp]
	fmul	DWORD PTR _dRdR$[ebp]
	fsubp	ST(1), ST(0)
	fmul	DWORD PTR __real@40800000
	fstp	DWORD PTR _t$[ebp]

; 1439 : 
; 1440 : 	if (t < ZERO) return FALSE;

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L76847
	xor	al, al
	jmp	SHORT $L76838
$L76847:

; 1441 : 	t = (REAL)sqrt(t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _t$[ebp]

; 1442 : 
; 1443 : 	*t1 = (-rPdR + HALF * t) / dRdR;

	fld	DWORD PTR _rPdR$[ebp]
	fchs
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _t$[ebp]
	faddp	ST(1), ST(0)
	fdiv	DWORD PTR _dRdR$[ebp]
	mov	eax, DWORD PTR _t1$[ebp]
	fstp	DWORD PTR [eax]

; 1444 : 	*t2 = (-rPdR - HALF * t) / dRdR;

	fld	DWORD PTR _rPdR$[ebp]
	fchs
	fld	DWORD PTR __real@3f000000
	fmul	DWORD PTR _t$[ebp]
	fsubp	ST(1), ST(0)
	fdiv	DWORD PTR _dRdR$[ebp]
	mov	eax, DWORD PTR _t2$[ebp]
	fstp	DWORD PTR [eax]

; 1445 : 
; 1446 : 	return TRUE;

	mov	al, 1
$L76838:

; 1447 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z ENDP		; LinePoint
_TEXT	ENDS
PUBLIC	?TestLinePoint@@YAXXZ				; TestLinePoint
; Function compile flags: /Odt /ZI
;	COMDAT ?TestLinePoint@@YAXXZ
_TEXT	SEGMENT
_t2$ = -44						; size = 4
_t1$ = -40						; size = 4
_p$ = -36						; size = 12
_r1$ = -24						; size = 12
_r0$ = -12						; size = 12
?TestLinePoint@@YAXXZ PROC NEAR				; TestLinePoint, COMDAT

; 1450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1451 : 	VEC	r0, r1, p;
; 1452 : 	REAL	t1, t2;
; 1453 : 
; 1454 : 
; 1455 : 	SetVec(&r0, ZERO, ZERO, ZERO);

	mov	DWORD PTR _r0$[ebp], 0
	mov	DWORD PTR _r0$[ebp+4], 0
	mov	DWORD PTR _r0$[ebp+8], 0

; 1456 : 	SetVec(&r1, ONE, ZERO, ZERO);

	mov	DWORD PTR _r1$[ebp], 1065353216		; 3f800000H
	mov	DWORD PTR _r1$[ebp+4], 0
	mov	DWORD PTR _r1$[ebp+8], 0

; 1457 : 
; 1458 : 	SetVec(&p, HALF, ONE, ZERO);

	mov	DWORD PTR _p$[ebp], 1056964608		; 3f000000H
	mov	DWORD PTR _p$[ebp+4], 1065353216	; 3f800000H
	mov	DWORD PTR _p$[ebp+8], 0

; 1459 : 
; 1460 : 	LinePoint(&p, ONE, &r0, &r1, &t1, &t2);

	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r1$[ebp]
	push	edx
	lea	eax, DWORD PTR _r0$[ebp]
	push	eax
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z ; LinePoint
	add	esp, 24					; 00000018H

; 1461 : 
; 1462 : 	LinePoint(&p, 1.1f, &r0, &r1, &t1, &t2);

	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r1$[ebp]
	push	edx
	lea	eax, DWORD PTR _r0$[ebp]
	push	eax
	push	1066192077				; 3f8ccccdH
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z ; LinePoint
	add	esp, 24					; 00000018H

; 1463 : 
; 1464 : 	LinePoint(&p, 2.0f, &r0, &r1, &t1, &t2);

	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r1$[ebp]
	push	edx
	lea	eax, DWORD PTR _r0$[ebp]
	push	eax
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z ; LinePoint
	add	esp, 24					; 00000018H

; 1465 : 
; 1466 : 	SetVec(&p, ONE, ONE, ZERO);

	mov	DWORD PTR _p$[ebp], 1065353216		; 3f800000H
	mov	DWORD PTR _p$[ebp+4], 1065353216	; 3f800000H
	mov	DWORD PTR _p$[ebp+8], 0

; 1467 : 
; 1468 : 	LinePoint(&p, ONE, &r0, &r1, &t1, &t2);

	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r1$[ebp]
	push	edx
	lea	eax, DWORD PTR _r0$[ebp]
	push	eax
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z ; LinePoint
	add	esp, 24					; 00000018H

; 1469 : 
; 1470 : 	LinePoint(&p, 1.1f, &r0, &r1, &t1, &t2);

	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r1$[ebp]
	push	edx
	lea	eax, DWORD PTR _r0$[ebp]
	push	eax
	push	1066192077				; 3f8ccccdH
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z ; LinePoint
	add	esp, 24					; 00000018H

; 1471 : 
; 1472 : 	LinePoint(&p, 2.0f, &r0, &r1, &t1, &t2);

	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r1$[ebp]
	push	edx
	lea	eax, DWORD PTR _r0$[ebp]
	push	eax
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?LinePoint@@YA_NPAUVectorStruct@@M00PAM1@Z ; LinePoint
	add	esp, 24					; 00000018H

; 1473 : 
; 1474 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TestLinePoint@@YAXXZ ENDP				; TestLinePoint
_TEXT	ENDS
PUBLIC	?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z	; FindIntersection
; Function compile flags: /Odt /ZI
;	COMDAT ?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z
_TEXT	SEGMENT
_diff$ = -16						; size = 12
_mul$ = -4						; size = 4
_point1$ = 8						; size = 4
_dist1$ = 12						; size = 4
_point2$ = 16						; size = 4
_dist2$ = 20						; size = 4
_out$ = 24						; size = 4
?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z PROC NEAR	; FindIntersection, COMDAT

; 1482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1483 : 	REAL mul;
; 1484 : 	VEC diff;
; 1485 : 
; 1486 : // get diff vector, mul
; 1487 : 
; 1488 : 	SubVector(point2, point1, &diff);

	mov	eax, DWORD PTR _point2$[ebp]
	mov	ecx, DWORD PTR _point1$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _diff$[ebp]
	mov	eax, DWORD PTR _point2$[ebp]
	mov	ecx, DWORD PTR _point1$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _diff$[ebp+4]
	mov	eax, DWORD PTR _point2$[ebp]
	mov	ecx, DWORD PTR _point1$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _diff$[ebp+8]

; 1489 : 	mul = -dist1 / (dist2 - dist1);

	fld	DWORD PTR _dist1$[ebp]
	fchs
	fld	DWORD PTR _dist2$[ebp]
	fsub	DWORD PTR _dist1$[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _mul$[ebp]

; 1490 : 
; 1491 : // get intersection
; 1492 : 
; 1493 : 	out->v[X] = point1->v[X] + diff.v[X] * mul;

	fld	DWORD PTR _diff$[ebp]
	fmul	DWORD PTR _mul$[ebp]
	mov	eax, DWORD PTR _point1$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx]

; 1494 : 	out->v[Y] = point1->v[Y] + diff.v[Y] * mul;

	fld	DWORD PTR _diff$[ebp+4]
	fmul	DWORD PTR _mul$[ebp]
	mov	eax, DWORD PTR _point1$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx+4]

; 1495 : 	out->v[Z] = point1->v[Z] + diff.v[Z] * mul;

	fld	DWORD PTR _diff$[ebp+8]
	fmul	DWORD PTR _mul$[ebp]
	mov	eax, DWORD PTR _point1$[ebp]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _out$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1496 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FindIntersection@@YAXPAUVectorStruct@@M0M0@Z ENDP	; FindIntersection
_TEXT	ENDS
END
