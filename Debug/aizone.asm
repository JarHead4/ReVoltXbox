; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\aizone.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@LBIGCPLA@Can?8t?5alloc?5memory?5for?5AI?5zones?$CB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@BJGOLJL@Can?8t?5alloc?5memory?5for?5AI?5zone?5h@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadAiZones@@YAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeAiZones@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateCarAiZone@@YADPAUPlayerStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??FreeAiZones@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadAiZones@@YAXPAD@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?AiZoneNum@@3JA					; AiZoneNum
PUBLIC	?AiZoneNumID@@3JA				; AiZoneNumID
PUBLIC	?AiZones@@3PAUAIZONE@@A				; AiZones
PUBLIC	?AiZoneHeaders@@3PAUAIZONE_HEADER@@A		; AiZoneHeaders
_BSS	SEGMENT
?AiZoneNum@@3JA DD 01H DUP (?)				; AiZoneNum
?AiZoneNumID@@3JA DD 01H DUP (?)			; AiZoneNumID
?AiZones@@3PAUAIZONE@@A DD 01H DUP (?)			; AiZones
?AiZoneHeaders@@3PAUAIZONE_HEADER@@A DD 01H DUP (?)	; AiZoneHeaders
_BSS	ENDS
PUBLIC	?LoadAiZones@@YAXPAD@Z				; LoadAiZones
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?__LINE__Var@?1??LoadAiZones@@YAXPAD@Z@4JA	; `LoadAiZones'::`2'::__LINE__Var
PUBLIC	??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	??_C@_0CB@LBIGCPLA@Can?8t?5alloc?5memory?5for?5AI?5zones?$CB@ ; `string'
PUBLIC	??_C@_0CI@BJGOLJL@Can?8t?5alloc?5memory?5for?5AI?5zone?5h@ ; `string'
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	__fltused:NEAR
EXTRN	?Box@@YAJPAD0J@Z:NEAR				; Box
EXTRN	?QuitGame@@3DA:BYTE				; QuitGame
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
;	COMDAT ??_C@_02JDPG@rb?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\aizone.cpp
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\aizon'
	DB	'e.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??LoadAiZones@@YAXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadAiZones@@YAXPAD@Z@4JA DD 01eH	; `LoadAiZones'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@LBIGCPLA@Can?8t?5alloc?5memory?5for?5AI?5zones?$CB@
CONST	SEGMENT
??_C@_0CB@LBIGCPLA@Can?8t?5alloc?5memory?5for?5AI?5zones?$CB@ DB 'Can''t '
	DB	'alloc memory for AI zones!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BJGOLJL@Can?8t?5alloc?5memory?5for?5AI?5zone?5h@
CONST	SEGMENT
??_C@_0CI@BJGOLJL@Can?8t?5alloc?5memory?5for?5AI?5zone?5h@ DB 'Can''t all'
	DB	'oc memory for AI zone headers!', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadAiZones@@YAXPAD@Z
_TEXT	SEGMENT
_zone$ = -160						; size = 80
_taz$ = -80						; size = 64
_fp$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?LoadAiZones@@YAXPAD@Z PROC NEAR			; LoadAiZones, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi

; 31   : 	long i, j, k;
; 32   : 	FILE *fp;
; 33   : 	FILE_ZONE taz;
; 34   : 	AIZONE zone;
; 35   : 
; 36   : // zero mem ptrs
; 37   : 
; 38   : 	AiZones = NULL;

	mov	DWORD PTR ?AiZones@@3PAUAIZONE@@A, 0	; AiZones

; 39   : 	AiZoneHeaders = NULL;

	mov	DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A, 0 ; AiZoneHeaders

; 40   : 
; 41   : // open zone file
; 42   : 
; 43   : 	fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 44   : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L81102

; 45   : 	{
; 46   : 		return;

	jmp	$L81094
$L81102:

; 47   : 	}
; 48   : 
; 49   : // read zone num
; 50   : 
; 51   : 	fread(&AiZoneNum, sizeof(AiZoneNum), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	push	OFFSET FLAT:?AiZoneNum@@3JA		; AiZoneNum
	call	_fread
	add	esp, 16					; 00000010H

; 52   : 	if (!AiZoneNum)

	cmp	DWORD PTR ?AiZoneNum@@3JA, 0		; AiZoneNum
	jne	SHORT $L81103

; 53   : 	{
; 54   : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 55   : 		return;

	jmp	$L81094
$L81103:

; 56   : 	}
; 57   : 
; 58   : // alloc ram for zones
; 59   : 
; 60   : 	AiZones = (AIZONE*)malloc(sizeof(AIZONE) * AiZoneNum);

	push	OFFSET FLAT:??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadAiZones@@YAXPAD@Z@4JA
	add	eax, 30					; 0000001eH
	push	eax
	mov	ecx, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	imul	ecx, 80					; 00000050H
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?AiZones@@3PAUAIZONE@@A, eax	; AiZones

; 61   : 	if (!AiZones)

	cmp	DWORD PTR ?AiZones@@3PAUAIZONE@@A, 0	; AiZones
	jne	SHORT $L81108

; 62   : 	{
; 63   : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 64   : 		Box(NULL, "Can't alloc memory for AI zones!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CB@LBIGCPLA@Can?8t?5alloc?5memory?5for?5AI?5zones?$CB@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 65   : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 66   : 		return;

	jmp	$L81094
$L81108:

; 67   : 	}
; 68   : 
; 69   : // load and convert each file zone
; 70   : 
; 71   : 	for (i = 0 ; i < AiZoneNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81110
$L81111:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81110:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	jge	$L81112

; 72   : 	{
; 73   : 
; 74   : // read file zone
; 75   : 
; 76   : 		fread(&taz, sizeof(taz), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	64					; 00000040H
	lea	ecx, DWORD PTR _taz$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 77   : 
; 78   : // set ID
; 79   : 
; 80   : 		AiZones[i].ID = taz.ID;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 81   : 
; 82   : // set XYZ size
; 83   : 
; 84   : 		AiZones[i].Size[0] = taz.Size[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+52]
	mov	DWORD PTR [ecx+eax+16], edx

; 85   : 		AiZones[i].Size[1] = taz.Size[1];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+56]
	mov	DWORD PTR [ecx+eax+20], edx

; 86   : 		AiZones[i].Size[2] = taz.Size[2];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+60]
	mov	DWORD PTR [ecx+eax+24], edx

; 87   : 
; 88   : // save Ccentre pos
; 89   : 
; 90   : 		AiZones[i].Pos = taz.Pos;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR _taz$[ebp+4]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _taz$[ebp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _taz$[ebp+12]
	mov	DWORD PTR [edx+8], eax

; 91   : 
; 92   : // build 3 planes
; 93   : 
; 94   : 		AiZones[i].Plane[0].v[A] = taz.Matrix.m[RX];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+16]
	mov	DWORD PTR [ecx+eax+28], edx

; 95   : 		AiZones[i].Plane[0].v[B] = taz.Matrix.m[RY];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+20]
	mov	DWORD PTR [ecx+eax+32], edx

; 96   : 		AiZones[i].Plane[0].v[C] = taz.Matrix.m[RZ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+24]
	mov	DWORD PTR [ecx+eax+36], edx

; 97   : 		AiZones[i].Plane[0].v[D] = -DotProduct(&taz.Matrix.mv[R], &taz.Pos);

	fld	DWORD PTR _taz$[ebp+16]
	fmul	DWORD PTR _taz$[ebp+4]
	fld	DWORD PTR _taz$[ebp+20]
	fmul	DWORD PTR _taz$[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _taz$[ebp+24]
	fmul	DWORD PTR _taz$[ebp+12]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	fstp	DWORD PTR [ecx+eax+40]

; 98   : 
; 99   : 		AiZones[i].Plane[1].v[A] = taz.Matrix.m[UX];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+28]
	mov	DWORD PTR [ecx+eax+44], edx

; 100  : 		AiZones[i].Plane[1].v[B] = taz.Matrix.m[UY];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+32]
	mov	DWORD PTR [ecx+eax+48], edx

; 101  : 		AiZones[i].Plane[1].v[C] = taz.Matrix.m[UZ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+36]
	mov	DWORD PTR [ecx+eax+52], edx

; 102  : 		AiZones[i].Plane[1].v[D] = -DotProduct(&taz.Matrix.mv[U], &taz.Pos);

	fld	DWORD PTR _taz$[ebp+28]
	fmul	DWORD PTR _taz$[ebp+4]
	fld	DWORD PTR _taz$[ebp+32]
	fmul	DWORD PTR _taz$[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _taz$[ebp+36]
	fmul	DWORD PTR _taz$[ebp+12]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	fstp	DWORD PTR [ecx+eax+56]

; 103  : 
; 104  : 		AiZones[i].Plane[2].v[A] = taz.Matrix.m[LX];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+40]
	mov	DWORD PTR [ecx+eax+60], edx

; 105  : 		AiZones[i].Plane[2].v[B] = taz.Matrix.m[LY];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+44]
	mov	DWORD PTR [ecx+eax+64], edx

; 106  : 		AiZones[i].Plane[2].v[C] = taz.Matrix.m[LZ];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR _taz$[ebp+48]
	mov	DWORD PTR [ecx+eax+68], edx

; 107  : 		AiZones[i].Plane[2].v[D] = -DotProduct(&taz.Matrix.mv[L], &taz.Pos);

	fld	DWORD PTR _taz$[ebp+40]
	fmul	DWORD PTR _taz$[ebp+4]
	fld	DWORD PTR _taz$[ebp+44]
	fmul	DWORD PTR _taz$[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _taz$[ebp+48]
	fmul	DWORD PTR _taz$[ebp+12]
	faddp	ST(1), ST(0)
	fchs
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	fstp	DWORD PTR [ecx+eax+72]

; 108  : 	}

	jmp	$L81111
$L81112:

; 109  : 
; 110  : // sort zones
; 111  : 
; 112  : 	for (i = AiZoneNum - 1 ; i ; i--) for (j = 0 ; j < i ; j++) if (AiZones[j].ID > AiZones[j + 1].ID)

	mov	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L81113
$L81114:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81113:
	cmp	DWORD PTR _i$[ebp], 0
	je	$L81115
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81116
$L81117:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81116:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	SHORT $L81118
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	imul	ecx, 80					; 00000050H
	mov	edx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	esi, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	eax, DWORD PTR [edx+eax]
	cmp	eax, DWORD PTR [esi+ecx]
	jle	SHORT $L81119

; 113  : 	{
; 114  : 		zone = AiZones[j];

	mov	esi, DWORD PTR _j$[ebp]
	imul	esi, 80					; 00000050H
	add	esi, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	ecx, 20					; 00000014H
	lea	edi, DWORD PTR _zone$[ebp]
	rep movsd

; 115  : 		AiZones[j] = AiZones[j + 1];

	mov	esi, DWORD PTR _j$[ebp]
	add	esi, 1
	imul	esi, 80					; 00000050H
	add	esi, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edi, DWORD PTR _j$[ebp]
	imul	edi, 80					; 00000050H
	add	edi, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	ecx, 20					; 00000014H
	rep movsd

; 116  : 		AiZones[j + 1] = zone;

	mov	edi, DWORD PTR _j$[ebp]
	add	edi, 1
	imul	edi, 80					; 00000050H
	add	edi, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	ecx, 20					; 00000014H
	lea	esi, DWORD PTR _zone$[ebp]
	rep movsd
$L81119:

; 117  : 	}
; 118  : 
; 119  : // set zone ID num
; 120  : 
; 121  : 	AiZoneNumID = AiZones[AiZoneNum - 1].ID + 1;

	jmp	$L81117
$L81118:
	jmp	$L81114
$L81115:
	mov	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	sub	eax, 1
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, 1
	mov	DWORD PTR ?AiZoneNumID@@3JA, edx	; AiZoneNumID

; 122  : 
; 123  : // alloc memory for zone headers
; 124  : 
; 125  : 	AiZoneHeaders = (AIZONE_HEADER*)malloc(sizeof(AIZONE_HEADER) * AiZoneNumID);

	push	OFFSET FLAT:??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadAiZones@@YAXPAD@Z@4JA
	add	eax, 95					; 0000005fH
	push	eax
	mov	ecx, DWORD PTR ?AiZoneNumID@@3JA	; AiZoneNumID
	shl	ecx, 3
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A, eax ; AiZoneHeaders

; 126  : 	if (!AiZoneHeaders)

	cmp	DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A, 0 ; AiZoneHeaders
	jne	SHORT $L81122

; 127  : 	{
; 128  : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 129  : 		Box(NULL, "Can't alloc memory for AI zone headers!", MB_OK);

	push	0
	push	OFFSET FLAT:??_C@_0CI@BJGOLJL@Can?8t?5alloc?5memory?5for?5AI?5zone?5h@
	push	0
	call	?Box@@YAJPAD0J@Z			; Box
	add	esp, 12					; 0000000cH

; 130  : 		QuitGame = TRUE;

	mov	BYTE PTR ?QuitGame@@3DA, 1		; QuitGame

; 131  : 		return;

	jmp	$L81094
$L81122:

; 132  : 	}
; 133  : 
; 134  : // setup zone headers
; 135  : 
; 136  : 	for (i = 0 ; i < AiZoneNumID ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81124
$L81125:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L81124:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?AiZoneNumID@@3JA	; AiZoneNumID
	jge	$L81126

; 137  : 	{
; 138  : 		j = 0;

	mov	DWORD PTR _j$[ebp], 0
$L81128:

; 139  : 		while (AiZones[j].ID != i && j < AiZoneNum) j++;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR [ecx+eax]
	cmp	edx, DWORD PTR _i$[ebp]
	je	SHORT $L81129
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	jge	SHORT $L81129
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $L81128
$L81129:

; 140  : 		if (j == AiZoneNum)

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	jne	SHORT $L81130

; 141  : 		{
; 142  : 			AiZoneHeaders[i].Zones = AiZones;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A ; AiZoneHeaders
	mov	edx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	DWORD PTR [ecx+eax*8+4], edx

; 143  : 			AiZoneHeaders[i].Count = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A ; AiZoneHeaders
	mov	DWORD PTR [ecx+eax*8], 0

; 144  : 		}
; 145  : 		else

	jmp	SHORT $L81131
$L81130:

; 146  : 		{	
; 147  : 			AiZoneHeaders[i].Zones = &AiZones[j];

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 80					; 00000050H
	add	eax, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A ; AiZoneHeaders
	mov	DWORD PTR [edx+ecx*8+4], eax

; 148  : 			k = 0;

	mov	DWORD PTR _k$[ebp], 0
$L81133:

; 149  : 			while (AiZones[j].ID == i && j < AiZoneNum) j++, k++;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	mov	edx, DWORD PTR [ecx+eax]
	cmp	edx, DWORD PTR _i$[ebp]
	jne	SHORT $L81134
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?AiZoneNum@@3JA		; AiZoneNum
	jge	SHORT $L81134
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $L81133
$L81134:

; 150  : 			AiZoneHeaders[i].Count = k;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A ; AiZoneHeaders
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx
$L81131:

; 151  : 		}
; 152  : 	}

	jmp	$L81125
$L81126:

; 153  : 
; 154  : // close file
; 155  : 
; 156  : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$L81094:

; 157  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadAiZones@@YAXPAD@Z ENDP				; LoadAiZones
_TEXT	ENDS
PUBLIC	?FreeAiZones@@YAXXZ				; FreeAiZones
PUBLIC	?__LINE__Var@?1??FreeAiZones@@YAXXZ@4JA		; `FreeAiZones'::`2'::__LINE__Var
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??FreeAiZones@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??FreeAiZones@@YAXXZ@4JA DD 012bH	; `FreeAiZones'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?FreeAiZones@@YAXXZ
_TEXT	SEGMENT
?FreeAiZones@@YAXXZ PROC NEAR				; FreeAiZones, COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 300  : 	free(AiZones);

	push	OFFSET FLAT:??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeAiZones@@YAXXZ@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR ?AiZones@@3PAUAIZONE@@A	; AiZones
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 301  : 	free(AiZoneHeaders);

	push	OFFSET FLAT:??_C@_0IL@BNNGMCCO@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeAiZones@@YAXXZ@4JA
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A ; AiZoneHeaders
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 302  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeAiZones@@YAXXZ ENDP				; FreeAiZones
_TEXT	ENDS
PUBLIC	?UpdateCarAiZone@@YADPAUPlayerStruct@@@Z	; UpdateCarAiZone
EXTRN	?ResetTriggerFlags@@YAXJ@Z:NEAR			; ResetTriggerFlags
EXTRN	?PLR_LocalPlayer@@3PAUPlayerStruct@@A:DWORD	; PLR_LocalPlayer
; Function compile flags: /Odt /ZI
;	COMDAT ?UpdateCarAiZone@@YADPAUPlayerStruct@@@Z
_TEXT	SEGMENT
_car$ = -28						; size = 4
_zone$ = -24						; size = 4
_dist$ = -20						; size = 4
_nextzone$ = -16					; size = 4
_flag$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_Player$ = 8						; size = 4
?UpdateCarAiZone@@YADPAUPlayerStruct@@@Z PROC NEAR	; UpdateCarAiZone, COMDAT

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 310  : 	long i, j, flag, nextzone;
; 311  : 	float dist;
; 312  : 	AIZONE *zone;
; 313  : 	CAR *car = &Player->car;

	mov	eax, DWORD PTR _Player$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], eax

; 314  : 
; 315  : // quit if no zones
; 316  : 
; 317  : 	if (!AiZones)

	cmp	DWORD PTR ?AiZones@@3PAUAIZONE@@A, 0	; AiZones
	jne	SHORT $L81149

; 318  : 		return FALSE;

	xor	al, al
	jmp	$L81141
$L81149:

; 319  : 
; 320  : // loop thru all zones with next ID
; 321  : 
; 322  : 	nextzone = (Player->CarAI.ZoneID + 1) % AiZoneNumID;

	mov	eax, DWORD PTR _Player$[ebp]
	mov	eax, DWORD PTR [eax+10120]
	add	eax, 1
	cdq
	idiv	DWORD PTR ?AiZoneNumID@@3JA		; AiZoneNumID
	mov	DWORD PTR _nextzone$[ebp], edx

; 323  : 	zone = AiZoneHeaders[nextzone].Zones;

	mov	eax, DWORD PTR _nextzone$[ebp]
	mov	ecx, DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A ; AiZoneHeaders
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _zone$[ebp], edx

; 324  : 
; 325  : 	for (i = 0 ; i < AiZoneHeaders[nextzone].Count ; i++, zone++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L81150
$L81151:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _zone$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _zone$[ebp], ecx
$L81150:
	mov	eax, DWORD PTR _nextzone$[ebp]
	mov	ecx, DWORD PTR ?AiZoneHeaders@@3PAUAIZONE_HEADER@@A ; AiZoneHeaders
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*8]
	jge	$L81152

; 326  : 	{
; 327  : 
; 328  : // test car against next zones
; 329  : 
; 330  : 		flag = FALSE;

	mov	DWORD PTR _flag$[ebp], 0

; 331  : 		for (j = 0 ; j < 3 ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L81153
$L81154:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L81153:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$L81155

; 332  : 		{
; 333  : 			dist = PlaneDist(&zone->Plane[j], &car->Body->Centre.Pos);

	mov	eax, DWORD PTR _car$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _zone$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [eax+edx+28]
	mov	ecx, DWORD PTR _car$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _zone$[ebp]
	fld	DWORD PTR [edx+24]
	fmul	DWORD PTR [ecx+eax+32]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _car$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _zone$[ebp]
	fld	DWORD PTR [eax+28]
	fmul	DWORD PTR [edx+ecx+36]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _zone$[ebp]
	fadd	DWORD PTR [ecx+eax+40]
	fstp	DWORD PTR _dist$[ebp]

; 334  : 			if (dist < -zone->Size[j] || dist > zone->Size[j])

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _zone$[ebp]
	fld	DWORD PTR [ecx+eax*4+16]
	fchs
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L81157
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _zone$[ebp]
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR [ecx+eax*4+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81156
$L81157:

; 335  : 			{
; 336  : 				flag = TRUE;

	mov	DWORD PTR _flag$[ebp], 1

; 337  : 				break;

	jmp	SHORT $L81155
$L81156:

; 338  : 			}
; 339  : 		}

	jmp	$L81154
$L81155:

; 340  : 
; 341  : // entered next zone?
; 342  : 
; 343  : 		if (!flag)

	cmp	DWORD PTR _flag$[ebp], 0
	jne	SHORT $L81158

; 344  : 		{
; 345  : 
; 346  : // yep, completed lap?
; 347  : 
; 348  : 			if (!(Player->CarAI.ZoneID = nextzone))

	mov	eax, DWORD PTR _Player$[ebp]
	mov	ecx, DWORD PTR _nextzone$[ebp]
	mov	DWORD PTR [eax+10120], ecx
	cmp	DWORD PTR _nextzone$[ebp], 0
	jne	SHORT $L81159

; 349  : 			{
; 350  : 				if (car == &PLR_LocalPlayer->car)

	mov	eax, DWORD PTR ?PLR_LocalPlayer@@3PAUPlayerStruct@@A ; PLR_LocalPlayer
	add	eax, 44					; 0000002cH
	cmp	DWORD PTR _car$[ebp], eax
	jne	SHORT $L81160

; 351  : 					ResetTriggerFlags(TRIGGER_TRACK_DIR);

	push	2
	call	?ResetTriggerFlags@@YAXJ@Z		; ResetTriggerFlags
	add	esp, 4
$L81160:

; 352  : 
; 353  : 				return TRUE;

	mov	al, 1
	jmp	SHORT $L81141
$L81159:

; 354  : 			}
; 355  : 
; 356  : // nope!
; 357  : 
; 358  : 			return FALSE;

	xor	al, al
	jmp	SHORT $L81141
$L81158:

; 359  : 		}
; 360  : 	}

	jmp	$L81151
$L81152:

; 361  : 
; 362  : //	return false
; 363  : 
; 364  : 	return FALSE;

	xor	al, al
$L81141:

; 365  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateCarAiZone@@YADPAUPlayerStruct@@@Z ENDP		; UpdateCarAiZone
_TEXT	ENDS
END
