; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\NewColl.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustWheelColl@@YAXPAUWheelCollInfoStruct@@PAUMaterialStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_DoObjectCollisions@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_AllObjectColls@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_DummyColl@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_BodyWorldColl@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_CarWorldColl@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_BodyCarColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_CarBodyColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_CarCarColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_DummyCollHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_BodyCollHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?COL_CarCollHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCollGrids@@YAPAUCOLLGRID@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyCollGrids@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PosToCollGridCoords@@YAJPAUVectorStruct@@PAJ1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PosToCollGridNum@@YAJPAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadGridInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExpandBBox@@YAXPAUBBOX@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PosDirPlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeCollSkin@@YAXPAUCollSkinStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateConvex@@YAPAUConvexStruct@@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyConvex@@YAXPAUConvexStruct@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroySpheres@@YAXPAUSphereStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LineToConvexColl@@YAPAUPlaneStruct@@PAUVectorStruct@@0PAUConvexStruct@@PAM2@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ModifyShift@@YAXPAUVectorStruct@@M0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SphereInCollPolyBounds@@YA_NPAUVectorStruct@@MPAUCollPolyStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CorrugationAmp@@YAMPAUCorrugationStruct@@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LineOfSight@@YA_NPAUVectorStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LineOfSightDist@@YA_NPAUVectorStruct@@0PAMPAPAUPlaneStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LineOfSightObj@@YA_NPAUVectorStruct@@0PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LineOfSightConvex@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LineOfSightSphere@@YA_NPAUVectorStruct@@M00PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCollPolyVertices@@YAHPAUCollPolyStruct@@PAUVectorStruct@@111@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotTransCollPolys@@YAXPAUCollPolyStruct@@HPATMatrixUnion@@PAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DestroySpheres@@YAXPAUSphereStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateConvex@@YAPAUConvexStruct@@F@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyCollGrids@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateCollGrids@@YAPAUCOLLGRID@@J@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CreateCollPolys@@YAPAUCollPolyStruct@@F@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??COL_CarCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??COL_CarBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??COL_BodyCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??COL_CarWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??COL_BodyWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??COL_AllObjectColls@@YAXXZ@4JA@b6a299de
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?COL_WorldCollPoly@@3PAUCollPolyStruct@@A	; COL_WorldCollPoly
PUBLIC	?COL_NWorldCollPolys@@3FA			; COL_NWorldCollPolys
PUBLIC	?COL_InstanceCollPoly@@3PAUCollPolyStruct@@A	; COL_InstanceCollPoly
PUBLIC	?COL_NInstanceCollPolys@@3FA			; COL_NInstanceCollPolys
PUBLIC	?COL_CollGridData@@3UCOLLGRID_DATA@@A		; COL_CollGridData
PUBLIC	?COL_CollGrid@@3PAUCOLLGRID@@A			; COL_CollGrid
PUBLIC	?COL_NCollGrids@@3JA				; COL_NCollGrids
PUBLIC	?COL_NWheelColls@@3HA				; COL_NWheelColls
PUBLIC	?COL_NWheelDone@@3HA				; COL_NWheelDone
PUBLIC	?COL_NBodyColls@@3HA				; COL_NBodyColls
PUBLIC	?COL_NBodyDone@@3HA				; COL_NBodyDone
PUBLIC	?COL_NCollsTested@@3HA				; COL_NCollsTested
PUBLIC	?COL_MaterialInfo@@3PAUMaterialStruct@@A	; COL_MaterialInfo
PUBLIC	?COL_CorrugationInfo@@3PAUCorrugationStruct@@A	; COL_CorrugationInfo
PUBLIC	?COL_DustInfo@@3PAUDustStruct@@A		; COL_DustInfo
PUBLIC	?NonPlanarCount@@3HA				; NonPlanarCount
PUBLIC	?QuadCollCount@@3HA				; QuadCollCount
PUBLIC	?TriCollCount@@3HA				; TriCollCount
PUBLIC	?COL_BodyCollInfo@@3PAUBodyCollInfoStruct@@A	; COL_BodyCollInfo
PUBLIC	?COL_WheelCollInfo@@3PAUWheelCollInfoStruct@@A	; COL_WheelCollInfo
PUBLIC	?COL_ThisBodyColl@@3PAPAUBodyCollInfoStruct@@A	; COL_ThisBodyColl
PUBLIC	?COL_NThisBodyColls@@3HA			; COL_NThisBodyColls
PUBLIC	?DummyPlane@@3UPlaneStruct@@A			; DummyPlane
PUBLIC	?DummyReal@@3MA					; DummyReal
_BSS	SEGMENT
?COL_WorldCollPoly@@3PAUCollPolyStruct@@A DD 01H DUP (?) ; COL_WorldCollPoly
?COL_NWorldCollPolys@@3FA DW 01H DUP (?)		; COL_NWorldCollPolys
	ALIGN	4

?COL_InstanceCollPoly@@3PAUCollPolyStruct@@A DD 01H DUP (?) ; COL_InstanceCollPoly
?COL_NInstanceCollPolys@@3FA DW 01H DUP (?)		; COL_NInstanceCollPolys
	ALIGN	4

?COL_CollGridData@@3UCOLLGRID_DATA@@A DB 014H DUP (?)	; COL_CollGridData
?COL_CollGrid@@3PAUCOLLGRID@@A DD 01H DUP (?)		; COL_CollGrid
?COL_NCollGrids@@3JA DD 01H DUP (?)			; COL_NCollGrids
?COL_NWheelColls@@3HA DD 01H DUP (?)			; COL_NWheelColls
?COL_NWheelDone@@3HA DD 01H DUP (?)			; COL_NWheelDone
?COL_NBodyColls@@3HA DD 01H DUP (?)			; COL_NBodyColls
?COL_NBodyDone@@3HA DD 01H DUP (?)			; COL_NBodyDone
?COL_NCollsTested@@3HA DD 01H DUP (?)			; COL_NCollsTested
?NonPlanarCount@@3HA DD 01H DUP (?)			; NonPlanarCount
?QuadCollCount@@3HA DD 01H DUP (?)			; QuadCollCount
?TriCollCount@@3HA DD 01H DUP (?)			; TriCollCount
?COL_BodyCollInfo@@3PAUBodyCollInfoStruct@@A DB 0dac0H DUP (?) ; COL_BodyCollInfo
?COL_WheelCollInfo@@3PAUWheelCollInfoStruct@@A DB 02bc0H DUP (?) ; COL_WheelCollInfo
?COL_ThisBodyColl@@3PAPAUBodyCollInfoStruct@@A DD 020H DUP (?) ; COL_ThisBodyColl
?COL_NThisBodyColls@@3HA DD 01H DUP (?)			; COL_NThisBodyColls
?DummyPlane@@3UPlaneStruct@@A DB 010H DUP (?)		; DummyPlane
?DummyReal@@3MA DD 01H DUP (?)				; DummyReal
_BSS	ENDS
_DATA	SEGMENT
_COL_ObjObjColl DD FLAT:?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_BodyCarColl@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_CarBodyColl@@YA_NPAUobject_def@@0@Z
	DD	FLAT:?COL_CarCarColl@@YA_NPAUobject_def@@0@Z
_COL_ObjWorldColl DD FLAT:?COL_DummyColl@@YAXPAUobject_def@@@Z
	DD	FLAT:?COL_BodyWorldColl@@YAXPAUobject_def@@@Z
	DD	FLAT:?COL_CarWorldColl@@YAXPAUobject_def@@@Z
?COL_MaterialInfo@@3PAUMaterialStruct@@A DD 03H		; COL_MaterialInfo
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	0707070H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03H
	DD	03f4ccccdr			; 0.8
	DD	03f666666r			; 0.9
	DD	03e4ccccdr			; 0.2
	DD	0707070H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03H
	DD	03f666666r			; 0.9
	DD	03f666666r			; 0.9
	DD	03e4ccccdr			; 0.2
	DD	0909090H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02H
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	0404040H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	022H
	DD	03f000000r			; 0.5
	DD	03f19999ar			; 0.6
	DD	000000000r			; 0
	DD	0402040H
	DD	00H
	DD	02H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02H
	DD	03f333333r			; 0.7
	DD	03f666666r			; 0.9
	DD	03dcccccdr			; 0.1
	DD	0404040H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02H
	DD	03f800000r			; 1
	DD	03f333333r			; 0.7
	DD	000000000r			; 0
	DD	0202020H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02H
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	000000000r			; 0
	DD	0202020H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	04H
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	00H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03H
	DD	03f333333r			; 0.7
	DD	03f4ccccdr			; 0.8
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03H
	DD	03e99999ar			; 0.3
	DD	03e99999ar			; 0.3
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03H
	DD	03f4ccccdr			; 0.8
	DD	03f4ccccdr			; 0.8
	DD	03ecccccdr			; 0.4
	DD	0505050H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02bH
	DD	03f333333r			; 0.7
	DD	03f000000r			; 0.5
	DD	000000000r			; 0
	DD	0207010H
	DD	03H
	DD	03H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bH
	DD	03f4ccccdr			; 0.8
	DD	03f4ccccdr			; 0.8
	DD	03ecccccdr			; 0.4
	DD	0505050H
	DD	03H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02bH
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	01H
	DD	01H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02bH
	DD	03f666666r			; 0.9
	DD	03f19999ar			; 0.6
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	02H
	DD	01H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	018H
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	00H
	DD	03H
	DD	00H
	DD	0c38fb0a4r			; -287.38
	DD	0c300beb8r			; -128.745
	DD	043c230a4r			; 388.38
	DD	018H
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	00H
	DD	03H
	DD	00H
	DD	0438fb0a4r			; 287.38
	DD	04300beb8r			; 128.745
	DD	0c3c230a4r			; -388.38
	DD	02aH
	DD	03f666666r			; 0.9
	DD	03f19999ar			; 0.6
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	05H
	DD	04H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02aH
	DD	03f666666r			; 0.9
	DD	03f19999ar			; 0.6
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	06H
	DD	04H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	02aH
	DD	03f666666r			; 0.9
	DD	03f19999ar			; 0.6
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	07H
	DD	04H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03H
	DD	03ee66666r			; 0.45
	DD	03ee66666r			; 0.45
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03H
	DD	03f19999ar			; 0.6
	DD	03f19999ar			; 0.6
	DD	03e4ccccdr			; 0.2
	DD	0303030H
	DD	00H
	DD	00H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
?COL_CorrugationInfo@@3PAUCorrugationStruct@@A DD 000000000r ; 0 ; COL_CorrugationInfo
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040800000r			; 4
	DD	0428c0000r			; 70
	DD	0428c0000r			; 70
	DD	040200000r			; 2.5
	DD	042200000r			; 40
	DD	042200000r			; 40
	DD	03f800000r			; 1
	DD	042200000r			; 40
	DD	042200000r			; 40
	DD	03f800000r			; 1
	DD	042a00000r			; 80
	DD	042a00000r			; 80
	DD	03f800000r			; 1
	DD	042200000r			; 40
	DD	042200000r			; 40
	DD	03fc00000r			; 1.5
	DD	042a00000r			; 80
	DD	042a00000r			; 80
	DD	040000000r			; 2
	DD	042c80000r			; 100
	DD	042c80000r			; 100
?COL_DustInfo@@3PAUDustStruct@@A DD 0ffffffffH		; COL_DustInfo
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	04H
	DD	03e4ccccdr			; 0.2
	DD	03f19999ar			; 0.6
	DD	05H
	DD	03e4ccccdr			; 0.2
	DD	03f19999ar			; 0.6
	DD	06H
	DD	03e4ccccdr			; 0.2
	DD	03f19999ar			; 0.6
	DD	09H
	DD	03f19999ar			; 0.6
	DD	03f4ccccdr			; 0.8
_DATA	ENDS
PUBLIC	?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z ; AdjustBodyColl
EXTRN	__fltused:NEAR
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\newcoll.cpp
;	COMDAT ?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z
_TEXT	SEGMENT
_collInfo$ = 8						; size = 4
_material$ = 12						; size = 4
?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z PROC NEAR ; AdjustBodyColl, COMDAT

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 473  : 	if (material == NULL) return;

	cmp	DWORD PTR _material$[ebp], 0
	jne	SHORT $L81876
	jmp	SHORT $L81875
$L81876:

; 474  : 
; 475  : 	if (MaterialMoves(material)) {

	mov	eax, DWORD PTR _material$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 16					; 00000010H
	je	SHORT $L81875

; 476  : 		VecMinusEqVec(&collInfo->Vel, &material->Vel);

	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _material$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _material$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _collInfo$[ebp]
	mov	ecx, DWORD PTR _material$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _collInfo$[ebp]
	fstp	DWORD PTR [edx+56]
$L81875:

; 477  : 	}
; 478  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustBodyColl@@YAXPAUBodyCollInfoStruct@@PAUMaterialStruct@@@Z ENDP ; AdjustBodyColl
_TEXT	ENDS
PUBLIC	?AdjustWheelColl@@YAXPAUWheelCollInfoStruct@@PAUMaterialStruct@@@Z ; AdjustWheelColl
; Function compile flags: /Odt /ZI
;	COMDAT ?AdjustWheelColl@@YAXPAUWheelCollInfoStruct@@PAUMaterialStruct@@@Z
_TEXT	SEGMENT
_wheelColl$ = 8						; size = 4
_material$ = 12						; size = 4
?AdjustWheelColl@@YAXPAUWheelCollInfoStruct@@PAUMaterialStruct@@@Z PROC NEAR ; AdjustWheelColl, COMDAT

; 488  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 489  : 	if (material == NULL) return;

	cmp	DWORD PTR _material$[ebp], 0
	jne	SHORT $L81882
	jmp	SHORT $L81881
$L81882:

; 490  : 
; 491  : 	// Is material a conveyor belt?
; 492  : 	if (MaterialMoves(material)) {

	mov	eax, DWORD PTR _material$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 16					; 00000010H
	je	SHORT $L81883

; 493  : 		VecMinusEqVec(&wheelColl->Vel, &material->Vel);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _material$[ebp]
	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _material$[ebp]
	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR _material$[ebp]
	fld	DWORD PTR [eax+56]
	fsub	DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [edx+56]
$L81883:

; 494  : 	}
; 495  : 
; 496  : 	// Is material corrugated?
; 497  : 	if (MaterialCorrugated(material)) {

	mov	eax, DWORD PTR _material$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	je	SHORT $L81881

; 498  : 		wheelColl->Depth += CorrugationAmp(&COL_CorrugationInfo[material->Corrugation], wheelColl->WorldPos.v[X], wheelColl->WorldPos.v[Z]);

	mov	eax, DWORD PTR _wheelColl$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _wheelColl$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _material$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 12					; 0000000cH
	add	edx, OFFSET FLAT:?COL_CorrugationInfo@@3PAUCorrugationStruct@@A ; COL_CorrugationInfo
	push	edx
	call	?CorrugationAmp@@YAMPAUCorrugationStruct@@MM@Z ; CorrugationAmp
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _wheelColl$[ebp]
	fadd	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _wheelColl$[ebp]
	fstp	DWORD PTR [ecx+76]
$L81881:

; 499  : 	}
; 500  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustWheelColl@@YAXPAUWheelCollInfoStruct@@PAUMaterialStruct@@@Z ENDP ; AdjustWheelColl
_TEXT	ENDS
PUBLIC	?COL_DoObjectCollisions@@YAXXZ			; COL_DoObjectCollisions
EXTRN	?OBJ_ObjectHead@@3PAUobject_def@@A:DWORD	; OBJ_ObjectHead
; Function compile flags: /Odt /ZI
;	COMDAT ?COL_DoObjectCollisions@@YAXXZ
_TEXT	SEGMENT
_obj$ = -4						; size = 4
?COL_DoObjectCollisions@@YAXXZ PROC NEAR		; COL_DoObjectCollisions, COMDAT

; 508  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 509  : 	OBJECT	*obj;
; 510  : 
; 511  : 	COL_AllObjectColls();

	call	?COL_AllObjectColls@@YAXXZ		; COL_AllObjectColls

; 512  : 
; 513  : 	//CAR_AllCarColls();
; 514  : 
; 515  : 	for (obj = OBJ_ObjectHead; obj; obj = obj->next)

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj$[ebp], eax
	jmp	SHORT $L81889
$L81890:
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj$[ebp], ecx
$L81889:
	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $L81887

; 516  : 	{
; 517  : 		if (obj->collhandler)

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+692], 0
	je	SHORT $L81892

; 518  : 		{
; 519  : 			obj->collhandler(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	call	DWORD PTR [ecx+692]
	add	esp, 4
$L81892:

; 520  : 		}
; 521  : 	}

	jmp	SHORT $L81890
$L81887:

; 522  : 	
; 523  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_DoObjectCollisions@@YAXXZ ENDP			; COL_DoObjectCollisions
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??COL_AllObjectColls@@YAXXZ@4JA@b6a299de ; `COL_AllObjectColls'::`2'::__LINE__Var
PUBLIC	??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@ ; `string'
EXTRN	?DebugAssert@@YAX_NHPAD@Z:NEAR			; DebugAssert
EXTRN	?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A:BYTE ; OBJ_PairCollInfo
EXTRN	?ClearActivePairInfo@@YAXXZ:NEAR		; ClearActivePairInfo
;	COMDAT ??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\newco'
	DB	'll.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??COL_AllObjectColls@@YAXXZ@4JA@b6a299de
_DATA	SEGMENT
?__LINE__Var@?1??COL_AllObjectColls@@YAXXZ@4JA@b6a299de DD 0213H ; `COL_AllObjectColls'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?COL_AllObjectColls@@YAXXZ
_TEXT	SEGMENT
tv141 = -73						; size = 1
tv85 = -73						; size = 1
_obj2$ = -8						; size = 4
_obj1$ = -4						; size = 4
?COL_AllObjectColls@@YAXXZ PROC NEAR			; COL_AllObjectColls, COMDAT

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 532  : 	OBJECT *obj1, *obj2;
; 533  : 
; 534  : 	// initialisation
; 535  : 	COL_NBodyColls = 0;

	mov	DWORD PTR ?COL_NBodyColls@@3HA, 0	; COL_NBodyColls

; 536  : 	COL_NBodyDone = 0;

	mov	DWORD PTR ?COL_NBodyDone@@3HA, 0	; COL_NBodyDone

; 537  : 	COL_NWheelColls = 0;

	mov	DWORD PTR ?COL_NWheelColls@@3HA, 0	; COL_NWheelColls

; 538  : 	COL_NWheelDone = 0;

	mov	DWORD PTR ?COL_NWheelDone@@3HA, 0	; COL_NWheelDone

; 539  : 	ClearActivePairInfo();

	call	?ClearActivePairInfo@@YAXXZ		; ClearActivePairInfo

; 540  : 	for (obj1 = OBJ_ObjectHead; obj1 != NULL; obj1 = obj1->next) {

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj1$[ebp], eax
	jmp	SHORT $L81898
$L81899:
	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj1$[ebp], ecx
$L81898:
	cmp	DWORD PTR _obj1$[ebp], 0
	je	SHORT $L81900

; 541  : 		obj1->body.NBodyColls = 0;

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	DWORD PTR [eax+516], 0

; 542  : 		obj1->body.BodyCollHead = NULL;

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	DWORD PTR [eax+512], 0

; 543  : 		if (obj1->CollType == COLL_TYPE_CAR) {

	mov	eax, DWORD PTR _obj1$[ebp]
	cmp	DWORD PTR [eax+660], 2
	jne	SHORT $L81901

; 544  : 			obj1->player->car.NWheelColls = 0;

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+3624], 0

; 545  : 			obj1->player->car.WheelCollHead = NULL;

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [ecx+3620], 0
$L81901:

; 546  : 		}
; 547  : 	}

	jmp	SHORT $L81899
$L81900:

; 548  : 	
; 549  : 	// loop over all object pairs
; 550  : 	for (obj1 = OBJ_ObjectHead; obj1 != NULL; obj1 = obj1->next) {

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj1$[ebp], eax
	jmp	SHORT $L81902
$L81903:
	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj1$[ebp], ecx
$L81902:
	cmp	DWORD PTR _obj1$[ebp], 0
	je	$L81895

; 551  : 
; 552  : 		Assert(obj1->CollType >= 0 && obj1->CollType < MAX_COLL_TYPES);

	mov	eax, DWORD PTR _obj1$[ebp]
	cmp	DWORD PTR [eax+660], 0
	jl	SHORT $L82991
	mov	ecx, DWORD PTR _obj1$[ebp]
	cmp	DWORD PTR [ecx+660], 3
	jge	SHORT $L82991
	mov	BYTE PTR tv85[ebp], 1
	jmp	SHORT $L82992
$L82991:
	mov	BYTE PTR tv85[ebp], 0
$L82992:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??COL_AllObjectColls@@YAXXZ@4JA@b6a299de
	add	edx, 21					; 00000015H
	push	edx
	mov	al, BYTE PTR tv85[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 553  : 
; 554  : 		// object-world collision if allowed for this object
; 555  : 		if (obj1->body.CollSkin.AllowWorldColls) {

	mov	eax, DWORD PTR _obj1$[ebp]
	movzx	ecx, BYTE PTR [eax+476]
	test	ecx, ecx
	je	SHORT $L81907

; 556  : 			COL_ObjWorldColl[obj1->CollType](obj1);

	mov	eax, DWORD PTR _obj1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj1$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	call	DWORD PTR _COL_ObjWorldColl[edx*4]
	add	esp, 4
$L81907:

; 557  : 		}
; 558  : 
; 559  : 		// Make sure this object is allowed to collide with objects
; 560  : 		if (!obj1->body.CollSkin.AllowObjColls) continue;

	mov	eax, DWORD PTR _obj1$[ebp]
	movzx	ecx, BYTE PTR [eax+477]
	test	ecx, ecx
	jne	SHORT $L81908
	jmp	$L81903
$L81908:

; 561  : 
; 562  : 		for (obj2 = obj1->next; obj2 != NULL; obj2 = obj2->next) {

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj2$[ebp], ecx
	jmp	SHORT $L81909
$L81910:
	mov	eax, DWORD PTR _obj2$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj2$[ebp], ecx
$L81909:
	cmp	DWORD PTR _obj2$[ebp], 0
	je	$L81911

; 563  : 		
; 564  : 			Assert(obj2->CollType >= 0 && obj2->CollType < MAX_COLL_TYPES);

	mov	eax, DWORD PTR _obj2$[ebp]
	cmp	DWORD PTR [eax+660], 0
	jl	SHORT $L82993
	mov	ecx, DWORD PTR _obj2$[ebp]
	cmp	DWORD PTR [ecx+660], 3
	jge	SHORT $L82993
	mov	BYTE PTR tv141[ebp], 1
	jmp	SHORT $L82994
$L82993:
	mov	BYTE PTR tv141[ebp], 0
$L82994:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??COL_AllObjectColls@@YAXXZ@4JA@b6a299de
	add	edx, 33					; 00000021H
	push	edx
	mov	al, BYTE PTR tv141[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 565  : 
; 566  : 			// Make sure this object is allowed to collide with objects
; 567  : 			if (!obj2->body.CollSkin.AllowObjColls) continue;

	mov	eax, DWORD PTR _obj2$[ebp]
	movzx	ecx, BYTE PTR [eax+477]
	test	ecx, ecx
	jne	SHORT $L81912
	jmp	SHORT $L81910
$L81912:

; 568  : 
; 569  : 			// Do not test the same object pair twice
; 570  : 			if (IsPairTested(obj1, obj2)) continue;

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	shl	ecx, 9
	mov	edx, DWORD PTR _obj2$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	ecx, DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[ecx+eax*4]
	and	ecx, 1
	je	SHORT $L81913
	jmp	$L81910
$L81913:

; 571  : 			SetPairTested(obj1, obj2);

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	shl	ecx, 9
	mov	edx, DWORD PTR _obj2$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	ecx, DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[ecx+eax*4]
	or	ecx, 1
	mov	edx, DWORD PTR _obj2$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	edx, DWORD PTR [edx+576]
	shl	edx, 9
	mov	DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[edx+eax*4], ecx
	mov	eax, DWORD PTR _obj2$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	shl	ecx, 9
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	ecx, DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[ecx+eax*4]
	or	ecx, 1
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	edx, DWORD PTR _obj2$[ebp]
	mov	edx, DWORD PTR [edx+576]
	shl	edx, 9
	mov	DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[edx+eax*4], ecx

; 572  : 
; 573  : 			// Do the actual collision check
; 574  : 			if (COL_ObjObjColl[obj1->CollType][obj2->CollType](obj1, obj2)) {

	mov	eax, DWORD PTR _obj2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	eax, DWORD PTR [edx+660]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _obj2$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	call	DWORD PTR _COL_ObjObjColl[eax+edx*4]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $L81914

; 575  : 				SetPairCollided(obj1, obj2);

	mov	eax, DWORD PTR _obj1$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	shl	ecx, 9
	mov	edx, DWORD PTR _obj2$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	ecx, DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[ecx+eax*4]
	or	ecx, 2
	mov	edx, DWORD PTR _obj2$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	edx, DWORD PTR [edx+576]
	shl	edx, 9
	mov	DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[edx+eax*4], ecx
	mov	eax, DWORD PTR _obj2$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	shl	ecx, 9
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	ecx, DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[ecx+eax*4]
	or	ecx, 2
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	edx, DWORD PTR _obj2$[ebp]
	mov	edx, DWORD PTR [edx+576]
	shl	edx, 9
	mov	DWORD PTR ?OBJ_PairCollInfo@@3PAY0IA@UPairCollInfoStruct@@A[edx+eax*4], ecx
$L81914:

; 576  : 			}
; 577  : 		}

	jmp	$L81910
$L81911:

; 578  : 	}

	jmp	$L81903
$L81895:

; 579  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_AllObjectColls@@YAXXZ ENDP				; COL_AllObjectColls
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?COL_DummyColl@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?COL_DummyColl@@YAXPAUobject_def@@@Z PROC NEAR		; COL_DummyColl, COMDAT

; 583  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 584  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_DummyColl@@YAXPAUobject_def@@@Z ENDP		; COL_DummyColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??COL_BodyWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de ; `COL_BodyWorldColl'::`2'::__LINE__Var
EXTRN	?DetectBodyWorldColls@@YAXPAUNewBodyStruct@@@Z:NEAR ; DetectBodyWorldColls
;	COMDAT ?__LINE__Var@?1??COL_BodyWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de
_DATA	SEGMENT
?__LINE__Var@?1??COL_BodyWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de DD 024cH ; `COL_BodyWorldColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?COL_BodyWorldColl@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?COL_BodyWorldColl@@YAXPAUobject_def@@@Z PROC NEAR	; COL_BodyWorldColl, COMDAT

; 588  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 589  : 	Assert(obj->CollType == COLL_TYPE_BODY);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??COL_BodyWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [ecx+660], 1
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 590  : 	DetectBodyWorldColls(&obj->body);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?DetectBodyWorldColls@@YAXPAUNewBodyStruct@@@Z ; DetectBodyWorldColls
	add	esp, 4

; 591  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_BodyWorldColl@@YAXPAUobject_def@@@Z ENDP		; COL_BodyWorldColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??COL_CarWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de ; `COL_CarWorldColl'::`2'::__LINE__Var
EXTRN	?DetectCarWorldColls@@YAXPAUCarStruct@@@Z:NEAR	; DetectCarWorldColls
;	COMDAT ?__LINE__Var@?1??COL_CarWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de
_DATA	SEGMENT
?__LINE__Var@?1??COL_CarWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de DD 0253H ; `COL_CarWorldColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?COL_CarWorldColl@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?COL_CarWorldColl@@YAXPAUobject_def@@@Z PROC NEAR	; COL_CarWorldColl, COMDAT

; 595  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 596  : 	Assert(obj->CollType == COLL_TYPE_CAR);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??COL_CarWorldColl@@YAXPAUobject_def@@@Z@4JA@b6a299de
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [ecx+660], 2
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 597  : 	DetectCarWorldColls(&obj->player->car);

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	?DetectCarWorldColls@@YAXPAUCarStruct@@@Z ; DetectCarWorldColls
	add	esp, 4

; 598  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_CarWorldColl@@YAXPAUobject_def@@@Z ENDP		; COL_CarWorldColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de ; `COL_BodyBodyColl'::`2'::__LINE__Var
EXTRN	?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z:NEAR ; DetectBodyBodyColls
;	COMDAT ?__LINE__Var@?1??COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT
?__LINE__Var@?1??COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de DD 025aH ; `COL_BodyBodyColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT
tv71 = -65						; size = 1
_obj1$ = 8						; size = 4
_obj2$ = 12						; size = 4
?COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z PROC NEAR	; COL_BodyBodyColl, COMDAT

; 602  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 603  : 	Assert(obj1->CollType == COLL_TYPE_BODY && obj2->CollType == COLL_TYPE_BODY);

	mov	eax, DWORD PTR _obj1$[ebp]
	cmp	DWORD PTR [eax+660], 1
	jne	SHORT $L83003
	mov	ecx, DWORD PTR _obj2$[ebp]
	cmp	DWORD PTR [ecx+660], 1
	jne	SHORT $L83003
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $L83004
$L83003:
	mov	BYTE PTR tv71[ebp], 0
$L83004:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
	add	edx, 1
	push	edx
	mov	al, BYTE PTR tv71[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 604  : 	if (DetectBodyBodyColls(&obj1->body, &obj2->body) > 0) {

	mov	eax, DWORD PTR _obj2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj1$[ebp]
	push	ecx
	call	?DetectBodyBodyColls@@YAHPAUNewBodyStruct@@0@Z ; DetectBodyBodyColls
	add	esp, 8
	test	eax, eax
	jle	SHORT $L81931

; 605  : 		return TRUE;

	mov	al, 1
	jmp	SHORT $L81929
$L81931:

; 606  : 	}
; 607  : 	return FALSE;

	xor	al, al
$L81929:

; 608  : 
; 609  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_BodyBodyColl@@YA_NPAUobject_def@@0@Z ENDP		; COL_BodyBodyColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??COL_BodyCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de ; `COL_BodyCarColl'::`2'::__LINE__Var
EXTRN	?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z:NEAR ; DetectCarBodyColls
;	COMDAT ?__LINE__Var@?1??COL_BodyCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT
?__LINE__Var@?1??COL_BodyCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de DD 0265H ; `COL_BodyCarColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?COL_BodyCarColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT
tv71 = -65						; size = 1
_obj1$ = 8						; size = 4
_obj2$ = 12						; size = 4
?COL_BodyCarColl@@YA_NPAUobject_def@@0@Z PROC NEAR	; COL_BodyCarColl, COMDAT

; 613  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 614  : 	Assert(obj1->CollType == COLL_TYPE_BODY && obj2->CollType == COLL_TYPE_CAR);

	mov	eax, DWORD PTR _obj1$[ebp]
	cmp	DWORD PTR [eax+660], 1
	jne	SHORT $L83007
	mov	ecx, DWORD PTR _obj2$[ebp]
	cmp	DWORD PTR [ecx+660], 2
	jne	SHORT $L83007
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $L83008
$L83007:
	mov	BYTE PTR tv71[ebp], 0
$L83008:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??COL_BodyCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
	add	edx, 1
	push	edx
	mov	al, BYTE PTR tv71[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 615  : 	if (DetectCarBodyColls(&obj2->player->car, &obj1->body) > 0) {

	mov	eax, DWORD PTR _obj1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj2$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	add	edx, 44					; 0000002cH
	push	edx
	call	?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectCarBodyColls
	add	esp, 8
	test	eax, eax
	jle	SHORT $L81937

; 616  : 		return TRUE;

	mov	al, 1
	jmp	SHORT $L81935
$L81937:

; 617  : 	}
; 618  : 	return FALSE;

	xor	al, al
$L81935:

; 619  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_BodyCarColl@@YA_NPAUobject_def@@0@Z ENDP		; COL_BodyCarColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??COL_CarBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de ; `COL_CarBodyColl'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??COL_CarBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT
?__LINE__Var@?1??COL_CarBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de DD 026fH ; `COL_CarBodyColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?COL_CarBodyColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT
tv71 = -65						; size = 1
_obj1$ = 8						; size = 4
_obj2$ = 12						; size = 4
?COL_CarBodyColl@@YA_NPAUobject_def@@0@Z PROC NEAR	; COL_CarBodyColl, COMDAT

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 624  : 	Assert(obj1->CollType == COLL_TYPE_CAR && obj2->CollType == COLL_TYPE_BODY);

	mov	eax, DWORD PTR _obj1$[ebp]
	cmp	DWORD PTR [eax+660], 2
	jne	SHORT $L83011
	mov	ecx, DWORD PTR _obj2$[ebp]
	cmp	DWORD PTR [ecx+660], 1
	jne	SHORT $L83011
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $L83012
$L83011:
	mov	BYTE PTR tv71[ebp], 0
$L83012:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??COL_CarBodyColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
	add	edx, 1
	push	edx
	mov	al, BYTE PTR tv71[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 625  : 	if (DetectCarBodyColls(&obj1->player->car, &obj2->body) > 0) {

	mov	eax, DWORD PTR _obj2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj1$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	add	edx, 44					; 0000002cH
	push	edx
	call	?DetectCarBodyColls@@YAHPAUCarStruct@@PAUNewBodyStruct@@@Z ; DetectCarBodyColls
	add	esp, 8
	test	eax, eax
	jle	SHORT $L81943

; 626  : 		return TRUE;

	mov	al, 1
	jmp	SHORT $L81941
$L81943:

; 627  : 	}
; 628  : 	return FALSE;

	xor	al, al
$L81941:

; 629  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_CarBodyColl@@YA_NPAUobject_def@@0@Z ENDP		; COL_CarBodyColl
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??COL_CarCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de ; `COL_CarCarColl'::`2'::__LINE__Var
EXTRN	?DetectCarCarColls@@YAHPAUCarStruct@@0@Z:NEAR	; DetectCarCarColls
;	COMDAT ?__LINE__Var@?1??COL_CarCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
_DATA	SEGMENT
?__LINE__Var@?1??COL_CarCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de DD 0279H ; `COL_CarCarColl'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?COL_CarCarColl@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT
tv71 = -65						; size = 1
_obj1$ = 8						; size = 4
_obj2$ = 12						; size = 4
?COL_CarCarColl@@YA_NPAUobject_def@@0@Z PROC NEAR	; COL_CarCarColl, COMDAT

; 633  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 634  : 	Assert(obj1->CollType == COLL_TYPE_CAR && obj2->CollType == COLL_TYPE_CAR);

	mov	eax, DWORD PTR _obj1$[ebp]
	cmp	DWORD PTR [eax+660], 2
	jne	SHORT $L83015
	mov	ecx, DWORD PTR _obj2$[ebp]
	cmp	DWORD PTR [ecx+660], 2
	jne	SHORT $L83015
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $L83016
$L83015:
	mov	BYTE PTR tv71[ebp], 0
$L83016:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	edx, DWORD PTR ?__LINE__Var@?1??COL_CarCarColl@@YA_NPAUobject_def@@0@Z@4JA@b6a299de
	add	edx, 1
	push	edx
	mov	al, BYTE PTR tv71[ebp]
	push	eax
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 635  : 	if (DetectCarCarColls(&obj1->player->car, &obj2->player->car) > 0) {

	mov	eax, DWORD PTR _obj2$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _obj1$[ebp]
	mov	eax, DWORD PTR [edx+588]
	add	eax, 44					; 0000002cH
	push	eax
	call	?DetectCarCarColls@@YAHPAUCarStruct@@0@Z ; DetectCarCarColls
	add	esp, 8
	test	eax, eax
	jle	SHORT $L81949

; 636  : 		return TRUE;

	mov	al, 1
	jmp	SHORT $L81947
$L81949:

; 637  : 	}
; 638  : 	return FALSE;

	xor	al, al
$L81947:

; 639  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_CarCarColl@@YA_NPAUobject_def@@0@Z ENDP		; COL_CarCarColl
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z
_TEXT	SEGMENT
_obj1$ = 8						; size = 4
_obj2$ = 12						; size = 4
?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z PROC NEAR	; COL_Dummy2Coll, COMDAT

; 643  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 644  : 	return FALSE;

	xor	al, al

; 645  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_Dummy2Coll@@YA_NPAUobject_def@@0@Z ENDP		; COL_Dummy2Coll
_TEXT	ENDS
PUBLIC	?COL_DummyCollHandler@@YAXPAUobject_def@@@Z	; COL_DummyCollHandler
; Function compile flags: /Odt /ZI
;	COMDAT ?COL_DummyCollHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?COL_DummyCollHandler@@YAXPAUobject_def@@@Z PROC NEAR	; COL_DummyCollHandler, COMDAT

; 652  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 653  : 	// Errr.... no collisions probably
; 654  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_DummyCollHandler@@YAXPAUobject_def@@@Z ENDP	; COL_DummyCollHandler
_TEXT	ENDS
PUBLIC	__real@3d4ccccd
PUBLIC	?COL_BodyCollHandler@@YAXPAUobject_def@@@Z	; COL_BodyCollHandler
EXTRN	?AllFieldImpulses@@YAXPAUFieldDataStruct@@PAUVectorStruct@@1@Z:NEAR ; AllFieldImpulses
EXTRN	?PreProcessBodyColls@@YAXPAUNewBodyStruct@@@Z:NEAR ; PreProcessBodyColls
EXTRN	?ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z:NEAR ; ProcessBodyColls3
EXTRN	?PostProcessBodyColls@@YAXPAUNewBodyStruct@@@Z:NEAR ; PostProcessBodyColls
EXTRN	?BodyTurboBoost@@YAXPAUNewBodyStruct@@@Z:NEAR	; BodyTurboBoost
EXTRN	?TimeStep@@3MA:DWORD				; TimeStep
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?COL_BodyCollHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_fieldData$ = -60					; size = 32
_body$ = -28						; size = 4
_angImp$ = -24						; size = 12
_imp$ = -12						; size = 12
_obj$ = 8						; size = 4
?COL_BodyCollHandler@@YAXPAUobject_def@@@Z PROC NEAR	; COL_BodyCollHandler, COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 663  : 	VEC imp, angImp;
; 664  : 	NEWBODY *body = &obj->body;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	DWORD PTR _body$[ebp], eax

; 665  : 	FIELD_DATA fieldData;
; 666  : 
; 667  : 	// Reset necessary variables
; 668  : 	body->NWorldContacts = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+520], 0

; 669  : 	body->NOtherContacts = 0;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+524], 0

; 670  : 	if (body->LastScrapeTime > MAX_SCRAPE_TIME) {

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+540]
	fcomp	DWORD PTR __real@3d4ccccd
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L81965

; 671  : 		body->ScrapeMaterial = MATERIAL_NONE;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+536], -1

; 672  : 		body->LastScrapeTime = ZERO;

	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [eax+540], 0

; 673  : 	} else {

	jmp	SHORT $L81966
$L81965:

; 674  : 		body->LastScrapeTime += TimeStep;

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR ?TimeStep@@3MA		; TimeStep
	fadd	DWORD PTR [eax+540]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+540]
$L81966:

; 675  : 	}
; 676  : 
; 677  : 	// Apply Force fields
; 678  : 	fieldData.ObjectID = obj->ObjID;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	mov	DWORD PTR _fieldData$[ebp], ecx

; 679  : 	fieldData.Priority = obj->FieldPriority;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	DWORD PTR _fieldData$[ebp+4], ecx

; 680  : 	fieldData.Mass = body->Centre.Mass;

	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fieldData$[ebp+28], ecx

; 681  : 	fieldData.Pos = &body->Centre.Pos;

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _fieldData$[ebp+8], eax

; 682  : 	fieldData.Vel = &body->Centre.Vel;

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _fieldData$[ebp+12], eax

; 683  : 	fieldData.Mat = &body->Centre.WMatrix;

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _fieldData$[ebp+20], eax

; 684  : 	fieldData.AngVel = &body->AngVel;

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 332				; 0000014cH
	mov	DWORD PTR _fieldData$[ebp+16], eax

; 685  : 	fieldData.Quat = &body->Centre.Quat;

	mov	eax, DWORD PTR _body$[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR _fieldData$[ebp+24], eax

; 686  : 	AllFieldImpulses(&fieldData, &imp, &angImp);

	lea	eax, DWORD PTR _angImp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _imp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fieldData$[ebp]
	push	edx
	call	?AllFieldImpulses@@YAXPAUFieldDataStruct@@PAUVectorStruct@@1@Z ; AllFieldImpulses
	add	esp, 12					; 0000000cH

; 687  : 	VecPlusEqVec(&body->Centre.Impulse, &imp);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _imp$[ebp]
	fadd	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _imp$[ebp+4]
	fadd	DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _imp$[ebp+8]
	fadd	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+64]

; 688  : 	VecPlusEqVec(&body->AngImpulse, &angImp);

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _angImp$[ebp]
	fadd	DWORD PTR [eax+356]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+356]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _angImp$[ebp+4]
	fadd	DWORD PTR [eax+360]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR _angImp$[ebp+8]
	fadd	DWORD PTR [eax+364]
	mov	ecx, DWORD PTR _body$[ebp]
	fstp	DWORD PTR [ecx+364]

; 689  : 
; 690  : 
; 691  : 	// Apply Turbo boost
; 692  : 	BodyTurboBoost(body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?BodyTurboBoost@@YAXPAUNewBodyStruct@@@Z ; BodyTurboBoost
	add	esp, 4

; 693  : 	
; 694  : 	// Process collisions
; 695  : 	if (obj->body.NBodyColls > 0) {

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+516], 0
	jle	SHORT $L81959

; 696  : 		PreProcessBodyColls(body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?PreProcessBodyColls@@YAXPAUNewBodyStruct@@@Z ; PreProcessBodyColls
	add	esp, 4

; 697  : 		if (obj->body.NBodyColls > 0) {

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+516], 0
	jle	SHORT $L81959

; 698  : 			ProcessBodyColls3(body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?ProcessBodyColls3@@YAXPAUNewBodyStruct@@@Z ; ProcessBodyColls3
	add	esp, 4

; 699  : 			PostProcessBodyColls(body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?PostProcessBodyColls@@YAXPAUNewBodyStruct@@@Z ; PostProcessBodyColls
	add	esp, 4
$L81959:

; 700  : 		}
; 701  : 	}
; 702  : 
; 703  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_BodyCollHandler@@YAXPAUobject_def@@@Z ENDP		; COL_BodyCollHandler
_TEXT	ENDS
PUBLIC	?COL_CarCollHandler@@YAXPAUobject_def@@@Z	; COL_CarCollHandler
EXTRN	?PreProcessCarWheelColls@@YAXPAUCarStruct@@@Z:NEAR ; PreProcessCarWheelColls
EXTRN	?ProcessCarWheelColls@@YAXPAUCarStruct@@@Z:NEAR	; ProcessCarWheelColls
EXTRN	?PostProcessCarWheelColls@@YAXPAUCarStruct@@@Z:NEAR ; PostProcessCarWheelColls
EXTRN	?SetCarAngResistance@@YAXPAUCarStruct@@@Z:NEAR	; SetCarAngResistance
EXTRN	?CarDownForce@@YAXPAUCarStruct@@@Z:NEAR		; CarDownForce
EXTRN	?SpeedupImpulse@@YAXPAUCarStruct@@@Z:NEAR	; SpeedupImpulse
; Function compile flags: /Odt /ZI
;	COMDAT ?COL_CarCollHandler@@YAXPAUobject_def@@@Z
_TEXT	SEGMENT
_car$ = -4						; size = 4
_obj$ = 8						; size = 4
?COL_CarCollHandler@@YAXPAUobject_def@@@Z PROC NEAR	; COL_CarCollHandler, COMDAT

; 709  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 710  : 	CAR *car = &obj->player->car;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR _car$[ebp], ecx

; 711  : 
; 712  : 	// Reinitialise necessary stuff
; 713  : 	car->NWheelFloorContacts = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3588], 0

; 714  : 	car->NWheelsInContact = 0;

	mov	eax, DWORD PTR _car$[ebp]
	mov	DWORD PTR [eax+3584], 0

; 715  : 
; 716  : 	// Process wheel collisions
; 717  : 	if (obj->player->car.NWheelColls > 0) {

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	cmp	DWORD PTR [ecx+3624], 0
	jle	SHORT $L81973

; 718  : 		PreProcessCarWheelColls(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?PreProcessCarWheelColls@@YAXPAUCarStruct@@@Z ; PreProcessCarWheelColls
	add	esp, 4

; 719  : 		ProcessCarWheelColls(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?ProcessCarWheelColls@@YAXPAUCarStruct@@@Z ; ProcessCarWheelColls
	add	esp, 4

; 720  : //#ifndef _PSX
; 721  : 		PostProcessCarWheelColls(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?PostProcessCarWheelColls@@YAXPAUCarStruct@@@Z ; PostProcessCarWheelColls
	add	esp, 4
$L81973:

; 722  : //#endif
; 723  : 	}
; 724  : 
; 725  : 	// Add aerodynamic downforce
; 726  : 	CarDownForce(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?CarDownForce@@YAXPAUCarStruct@@@Z	; CarDownForce
	add	esp, 4

; 727  : 
; 728  : 	// Add speedup force
; 729  : #ifdef _PC
; 730  : 	SpeedupImpulse(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?SpeedupImpulse@@YAXPAUCarStruct@@@Z	; SpeedupImpulse
	add	esp, 4

; 731  : #endif
; 732  : 
; 733  : 	// Process body collisions
; 734  : 	COL_BodyCollHandler(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?COL_BodyCollHandler@@YAXPAUobject_def@@@Z ; COL_BodyCollHandler
	add	esp, 4

; 735  : 
; 736  : 	// Adjust air resistance if no wheels in contact with floor
; 737  : 	SetCarAngResistance(car);

	mov	eax, DWORD PTR _car$[ebp]
	push	eax
	call	?SetCarAngResistance@@YAXPAUCarStruct@@@Z ; SetCarAngResistance
	add	esp, 4

; 738  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?COL_CarCollHandler@@YAXPAUobject_def@@@Z ENDP		; COL_CarCollHandler
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??CreateCollPolys@@YAPAUCollPolyStruct@@F@Z@4JA ; `CreateCollPolys'::`2'::__LINE__Var
PUBLIC	?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z	; CreateCollPolys
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
;	COMDAT ?__LINE__Var@?1??CreateCollPolys@@YAPAUCollPolyStruct@@F@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateCollPolys@@YAPAUCollPolyStruct@@F@Z@4JA DD 02edH ; `CreateCollPolys'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z
_TEXT	SEGMENT
_nPolys$ = 8						; size = 2
?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z PROC NEAR	; CreateCollPolys, COMDAT

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 750  : 	return ((NEWCOLLPOLY *)malloc(sizeof(NEWCOLLPOLY) * nPolys));

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateCollPolys@@YAPAUCollPolyStruct@@F@Z@4JA
	add	eax, 1
	push	eax
	movsx	ecx, WORD PTR _nPolys$[ebp]
	imul	ecx, 112				; 00000070H
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH

; 751  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z ENDP		; CreateCollPolys
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z@4JA ; `DestroyCollPolys'::`2'::__LINE__Var
PUBLIC	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z	; DestroyCollPolys
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z@4JA DD 02f2H ; `DestroyCollPolys'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z
_TEXT	SEGMENT
_polys$ = 8						; size = 4
?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z PROC NEAR	; DestroyCollPolys, COMDAT

; 754  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 755  : 	free(polys);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _polys$[ebp]
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 756  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ENDP	; DestroyCollPolys
_TEXT	ENDS
PUBLIC	?CreateCollGrids@@YAPAUCOLLGRID@@J@Z		; CreateCollGrids
PUBLIC	?__LINE__Var@?1??CreateCollGrids@@YAPAUCOLLGRID@@J@Z@4JA ; `CreateCollGrids'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??CreateCollGrids@@YAPAUCOLLGRID@@J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateCollGrids@@YAPAUCOLLGRID@@J@Z@4JA DD 02ffH ; `CreateCollGrids'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateCollGrids@@YAPAUCOLLGRID@@J@Z
_TEXT	SEGMENT
_newGrids$ = -8						; size = 4
_iGrid$ = -4						; size = 4
_nGrids$ = 8						; size = 4
?CreateCollGrids@@YAPAUCOLLGRID@@J@Z PROC NEAR		; CreateCollGrids, COMDAT

; 767  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 768  : 	int iGrid;
; 769  : 	COLLGRID *newGrids;
; 770  : 
; 771  : 	newGrids = (COLLGRID *)malloc(sizeof(COLLGRID) * nGrids);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateCollGrids@@YAPAUCOLLGRID@@J@Z@4JA
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _nGrids$[ebp]
	imul	ecx, 12					; 0000000cH
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _newGrids$[ebp], eax

; 772  : 
; 773  : 	// initialise the grids
; 774  : 	if (newGrids != NULL) {

	cmp	DWORD PTR _newGrids$[ebp], 0
	je	SHORT $L81992

; 775  : 		for (iGrid = 0; iGrid < nGrids; iGrid++) {

	mov	DWORD PTR _iGrid$[ebp], 0
	jmp	SHORT $L81993
$L81994:
	mov	eax, DWORD PTR _iGrid$[ebp]
	add	eax, 1
	mov	DWORD PTR _iGrid$[ebp], eax
$L81993:
	mov	eax, DWORD PTR _iGrid$[ebp]
	cmp	eax, DWORD PTR _nGrids$[ebp]
	jge	SHORT $L81992

; 776  : 			newGrids[iGrid].NCollPolys = 0;

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _newGrids$[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 777  : #ifndef _PSX
; 778  : 			newGrids[iGrid].CollPolyPtr = NULL;

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _newGrids$[ebp]
	mov	DWORD PTR [ecx+eax+8], 0

; 779  : #else
; 780  : 			newGrids[iGrid].CollPolyIndices = NULL;
; 781  : #endif
; 782  : 		}

	jmp	SHORT $L81994
$L81992:

; 783  : 	}
; 784  : 
; 785  : 	return newGrids;

	mov	eax, DWORD PTR _newGrids$[ebp]

; 786  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCollGrids@@YAPAUCOLLGRID@@J@Z ENDP		; CreateCollGrids
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyCollGrids@@YAXXZ@4JA	; `DestroyCollGrids'::`2'::__LINE__Var
PUBLIC	?DestroyCollGrids@@YAXXZ			; DestroyCollGrids
;	COMDAT ?__LINE__Var@?1??DestroyCollGrids@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DestroyCollGrids@@YAXXZ@4JA DD 0315H	; `DestroyCollGrids'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DestroyCollGrids@@YAXXZ
_TEXT	SEGMENT
_iGrid$ = -4						; size = 4
?DestroyCollGrids@@YAXXZ PROC NEAR			; DestroyCollGrids, COMDAT

; 789  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 790  : 	int iGrid;
; 791  : 
; 792  : 	if (COL_CollGrid == NULL) return;

	cmp	DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A, 0 ; COL_CollGrid
	jne	SHORT $L81999
	jmp	SHORT $L81997
$L81999:

; 793  : 
; 794  : 	for (iGrid = 0; iGrid < COL_NCollGrids; iGrid++) {

	mov	DWORD PTR _iGrid$[ebp], 0
	jmp	SHORT $L82000
$L82001:
	mov	eax, DWORD PTR _iGrid$[ebp]
	add	eax, 1
	mov	DWORD PTR _iGrid$[ebp], eax
$L82000:
	mov	eax, DWORD PTR _iGrid$[ebp]
	cmp	eax, DWORD PTR ?COL_NCollGrids@@3JA	; COL_NCollGrids
	jge	SHORT $L82002

; 795  : #ifndef _PSX
; 796  : 		free(COL_CollGrid[iGrid].CollPolyPtr);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyCollGrids@@YAXXZ@4JA
	add	eax, 7
	push	eax
	mov	ecx, DWORD PTR _iGrid$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 797  : #else
; 798  : 		free(COL_CollGrid[iGrid].CollPolyIndices);
; 799  : #endif
; 800  : 	}

	jmp	SHORT $L82001
$L82002:

; 801  : 
; 802  : 	free(COL_CollGrid);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyCollGrids@@YAXXZ@4JA
	add	eax, 13					; 0000000dH
	push	eax
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 803  : 	COL_NCollGrids = 0;

	mov	DWORD PTR ?COL_NCollGrids@@3JA, 0	; COL_NCollGrids
$L81997:

; 804  : 
; 805  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyCollGrids@@YAXXZ ENDP				; DestroyCollGrids
_TEXT	ENDS
PUBLIC	?CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z	; CreateCollPolyPtrs
PUBLIC	?__LINE__Var@?1??CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z@4JA ; `CreateCollPolyPtrs'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z@4JA DD 0329H ; `CreateCollPolyPtrs'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z
_TEXT	SEGMENT
_nPtrs$ = 8						; size = 4
?CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z PROC NEAR ; CreateCollPolyPtrs, COMDAT

; 809  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 810  : 	return (NEWCOLLPOLY **)malloc(nPtrs * sizeof(NEWCOLLPOLY *));

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _nPtrs$[ebp]
	shl	ecx, 2
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH

; 811  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z ENDP	; CreateCollPolyPtrs
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	?PosToCollGridCoords@@YAJPAUVectorStruct@@PAJ1@Z ; PosToCollGridCoords
EXTRN	__ftol2:NEAR
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?PosToCollGridCoords@@YAJPAUVectorStruct@@PAJ1@Z
_TEXT	SEGMENT
_dZ$ = -8						; size = 4
_dX$ = -4						; size = 4
_pos$ = 8						; size = 4
_offsetX$ = 12						; size = 4
_offsetZ$ = 16						; size = 4
?PosToCollGridCoords@@YAJPAUVectorStruct@@PAJ1@Z PROC NEAR ; PosToCollGridCoords, COMDAT

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 828  : 	REAL	dX, dZ;
; 829  : 
; 830  : 	// Make sure the world is gridded (if not, world is one large grid)
; 831  : 	if ((COL_CollGridData.XNum == ZERO) && (COL_CollGridData.ZNum == ZERO)) {

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82017
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82017

; 832  : 		return 0;

	xor	eax, eax
	jmp	$L82014
$L82017:

; 833  : 	}
; 834  : 
; 835  : 	// Calculate grid index
; 836  : 	dX = pos->v[X] - COL_CollGridData.XStart;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	fstp	DWORD PTR _dX$[ebp]

; 837  : 	dZ = pos->v[Z] - COL_CollGridData.ZStart;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4
	fstp	DWORD PTR _dZ$[ebp]

; 838  : 	*offsetX = Int(DivScalar(dX, COL_CollGridData.GridSize));

	fld	DWORD PTR _dX$[ebp]
	fdiv	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	call	__ftol2
	mov	ecx, DWORD PTR _offsetX$[ebp]
	mov	DWORD PTR [ecx], eax

; 839  : 	*offsetZ = Int(DivScalar(dZ, COL_CollGridData.GridSize));

	fld	DWORD PTR _dZ$[ebp]
	fdiv	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	call	__ftol2
	mov	ecx, DWORD PTR _offsetZ$[ebp]
	mov	DWORD PTR [ecx], eax

; 840  : 
; 841  : 	// Make sure we are not outside the grid boundaries
; 842  : 	if ((*offsetX < 0L) || (*offsetX >= COL_CollGridData.XNum) ||
; 843  : 		(*offsetZ < 0L) || (*offsetZ >= COL_CollGridData.ZNum))

	mov	eax, DWORD PTR _offsetX$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $L82021
	mov	eax, DWORD PTR _offsetX$[ebp]
	fild	DWORD PTR [eax]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fnstsw	ax
	test	ah, 1
	je	SHORT $L82021
	mov	eax, DWORD PTR _offsetZ$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $L82021
	mov	eax, DWORD PTR _offsetZ$[ebp]
	fild	DWORD PTR [eax]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82020
$L82021:

; 844  : 	{
; 845  : 		return -1;

	mov	eax, -1
	jmp	SHORT $L82014
$L82020:

; 846  : 	}
; 847  : 
; 848  : 	return *offsetX + NearestInt(COL_CollGridData.XNum) * *offsetZ;

	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	mov	ecx, DWORD PTR _offsetZ$[ebp]
	imul	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _offsetX$[ebp]
	add	eax, DWORD PTR [edx]
$L82014:

; 849  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PosToCollGridCoords@@YAJPAUVectorStruct@@PAJ1@Z ENDP	; PosToCollGridCoords
_TEXT	ENDS
PUBLIC	?PosToCollGridNum@@YAJPAUVectorStruct@@@Z	; PosToCollGridNum
; Function compile flags: /Odt /ZI
;	COMDAT ?PosToCollGridNum@@YAJPAUVectorStruct@@@Z
_TEXT	SEGMENT
_offsetZ$ = -16						; size = 4
_offsetX$ = -12						; size = 4
_dZ$ = -8						; size = 4
_dX$ = -4						; size = 4
_pos$ = 8						; size = 4
?PosToCollGridNum@@YAJPAUVectorStruct@@@Z PROC NEAR	; PosToCollGridNum, COMDAT

; 853  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 854  : 	REAL	dX, dZ;
; 855  : 	long	offsetX, offsetZ;
; 856  : 
; 857  : 	// Make sure the world is gridded (if not, world is one large grid)
; 858  : 	if ((COL_CollGridData.XNum == ZERO) && (COL_CollGridData.ZNum == ZERO)) {

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82030
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L82030

; 859  : 		return 0;

	xor	eax, eax
	jmp	$L82025
$L82030:

; 860  : 	}
; 861  : 
; 862  : 	// Calculate grid index
; 863  : 	dX = pos->v[X] - COL_CollGridData.XStart;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	fstp	DWORD PTR _dX$[ebp]

; 864  : 	dZ = pos->v[Z] - COL_CollGridData.ZStart;

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4
	fstp	DWORD PTR _dZ$[ebp]

; 865  : 	offsetX = Int(DivScalar(dX, COL_CollGridData.GridSize));

	fld	DWORD PTR _dX$[ebp]
	fdiv	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	call	__ftol2
	mov	DWORD PTR _offsetX$[ebp], eax

; 866  : 	offsetZ = Int(DivScalar(dZ, COL_CollGridData.GridSize));

	fld	DWORD PTR _dZ$[ebp]
	fdiv	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	call	__ftol2
	mov	DWORD PTR _offsetZ$[ebp], eax

; 867  : 
; 868  : 	// Make sure we are not outside the grid boundaries
; 869  : 	if ((offsetX < 0L) || (offsetX >= COL_CollGridData.XNum) ||
; 870  : 		(offsetZ < 0L) || (offsetZ >= COL_CollGridData.ZNum))

	cmp	DWORD PTR _offsetX$[ebp], 0
	jl	SHORT $L82034
	fild	DWORD PTR _offsetX$[ebp]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fnstsw	ax
	test	ah, 1
	je	SHORT $L82034
	cmp	DWORD PTR _offsetZ$[ebp], 0
	jl	SHORT $L82034
	fild	DWORD PTR _offsetZ$[ebp]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82033
$L82034:

; 871  : 	{
; 872  : 		return -1;

	mov	eax, -1
	jmp	SHORT $L82025
$L82033:

; 873  : 	}
; 874  : 
; 875  : 	return offsetX + NearestInt(COL_CollGridData.XNum) * offsetZ;

	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	imul	eax, DWORD PTR _offsetZ$[ebp]
	add	eax, DWORD PTR _offsetX$[ebp]
$L82025:

; 876  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PosToCollGridNum@@YAJPAUVectorStruct@@@Z ENDP		; PosToCollGridNum
_TEXT	ENDS
PUBLIC	?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ; PosToCollGrid
; Function compile flags: /Odt /ZI
;	COMDAT ?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_gridNum$ = -4						; size = 4
_pos$ = 8						; size = 4
?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z PROC NEAR ; PosToCollGrid, COMDAT

; 879  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 880  : 	int gridNum;
; 881  : 
; 882  : 	gridNum = PosToCollGridNum(pos);

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?PosToCollGridNum@@YAJPAUVectorStruct@@@Z ; PosToCollGridNum
	add	esp, 4
	mov	DWORD PTR _gridNum$[ebp], eax

; 883  : 	if (gridNum < 0 ) {

	cmp	DWORD PTR _gridNum$[ebp], 0
	jge	SHORT $L82040

; 884  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L82038
$L82040:

; 885  : 	} else {
; 886  : 		return &COL_CollGrid[gridNum];

	mov	eax, DWORD PTR _gridNum$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
$L82038:

; 887  : 	}
; 888  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PosToCollGrid@@YAPAUCOLLGRID@@PAUVectorStruct@@@Z ENDP	; PosToCollGrid
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z@4JA ; `LoadNewCollPolys'::`2'::__LINE__Var
PUBLIC	?LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z ; LoadNewCollPolys
PUBLIC	?ExpandBBox@@YAXPAUBBOX@@M@Z			; ExpandBBox
EXTRN	_fread:NEAR
;	COMDAT ?__LINE__Var@?1??LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z@4JA DD 0383H ; `LoadNewCollPolys'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z
_TEXT	SEGMENT
tv137 = -81						; size = 1
_iPoly$ = -16						; size = 2
_nRead$ = -12						; size = 4
_polys$ = -8						; size = 4
_header$ = -4						; size = 2
_fp$ = 8						; size = 4
_nPolys$ = 12						; size = 4
?LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z PROC NEAR ; LoadNewCollPolys, COMDAT

; 899  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 900  : 	NEWCOLLPOLYHDR header;
; 901  : 	NEWCOLLPOLY * polys;
; 902  : 	size_t nRead;
; 903  : 	short iPoly;
; 904  : 
; 905  : 	// read the header
; 906  : 	nRead = fread(&header, sizeof(NEWCOLLPOLYHDR), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 907  : 	if (nRead < 1) {

	cmp	DWORD PTR _nRead$[ebp], 1
	jae	SHORT $L82051

; 908  : 		return NULL;

	xor	eax, eax
	jmp	$L82045
$L82051:

; 909  : 	}
; 910  : 
; 911  : 	// Allocate space for the polys
; 912  : 	if ((polys = CreateCollPolys(header.NPolys)) == NULL) {

	mov	ax, WORD PTR _header$[ebp]
	push	eax
	call	?CreateCollPolys@@YAPAUCollPolyStruct@@F@Z ; CreateCollPolys
	add	esp, 4
	mov	DWORD PTR _polys$[ebp], eax
	cmp	DWORD PTR _polys$[ebp], 0
	jne	SHORT $L82052

; 913  : 		return NULL;

	xor	eax, eax
	jmp	$L82045
$L82052:

; 914  : 	}
; 915  : 
; 916  : 	// Load in the poly info
; 917  : 	NonPlanarCount = 0;

	mov	DWORD PTR ?NonPlanarCount@@3HA, 0	; NonPlanarCount

; 918  : 	QuadCollCount = 0;

	mov	DWORD PTR ?QuadCollCount@@3HA, 0	; QuadCollCount

; 919  : 	TriCollCount = 0;

	mov	DWORD PTR ?TriCollCount@@3HA, 0		; TriCollCount

; 920  : 	for (iPoly = 0; iPoly < header.NPolys; iPoly++) {

	mov	WORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82053
$L82054:
	mov	ax, WORD PTR _iPoly$[ebp]
	add	ax, 1
	mov	WORD PTR _iPoly$[ebp], ax
$L82053:
	movsx	eax, WORD PTR _iPoly$[ebp]
	movsx	ecx, WORD PTR _header$[ebp]
	cmp	eax, ecx
	jge	$L82055

; 921  : 		nRead = fread(&polys[iPoly], sizeof(NEWCOLLPOLY), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	112					; 00000070H
	movsx	ecx, WORD PTR _iPoly$[ebp]
	imul	ecx, 112				; 00000070H
	add	ecx, DWORD PTR _polys$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 922  : 		if (nRead < 1) {

	cmp	DWORD PTR _nRead$[ebp], 1
	jae	SHORT $L82057

; 923  : 			*nPolys = iPoly;

	mov	eax, DWORD PTR _nPolys$[ebp]
	mov	cx, WORD PTR _iPoly$[ebp]
	mov	WORD PTR [eax], cx

; 924  : 			return polys;

	mov	eax, DWORD PTR _polys$[ebp]
	jmp	$L82045
$L82057:

; 925  : 		}
; 926  : 		
; 927  : 		// Expand the polys bounding box by the collision skin thickness
; 928  : 		ExpandBBox(&polys[iPoly].BBox, COLL_EPSILON);

	push	1073741824				; 40000000H
	movsx	eax, WORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _polys$[ebp]
	lea	edx, DWORD PTR [ecx+eax+88]
	push	edx
	call	?ExpandBBox@@YAXPAUBBOX@@M@Z		; ExpandBBox
	add	esp, 8

; 929  : 
; 930  : #if USE_DEBUG_ROUTINES
; 931  : 		// Make sure material type is valid (Debug)
; 932  : 		Assert((polys[iPoly].Material < MATERIAL_NTYPES) && (polys[iPoly].Material >= 0));

	movsx	eax, WORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _polys$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 23		; 00000017H
	jge	SHORT $L83050
	movsx	edx, WORD PTR _iPoly$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _polys$[ebp]
	cmp	DWORD PTR [eax+edx+4], 0
	jl	SHORT $L83050
	mov	BYTE PTR tv137[ebp], 1
	jmp	SHORT $L83051
$L83050:
	mov	BYTE PTR tv137[ebp], 0
$L83051:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	ecx, DWORD PTR ?__LINE__Var@?1??LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z@4JA
	add	ecx, 33					; 00000021H
	push	ecx
	mov	dl, BYTE PTR tv137[ebp]
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 933  : 		if (polys[iPoly].Material >= MATERIAL_NTYPES || polys[iPoly].Material < 0) {

	movsx	eax, WORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _polys$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 23		; 00000017H
	jge	SHORT $L82061
	movsx	eax, WORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _polys$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 0
	jge	SHORT $L82060
$L82061:

; 934  : 			polys[iPoly].Material = MATERIAL_DEFAULT;

	movsx	eax, WORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _polys$[ebp]
	mov	DWORD PTR [ecx+eax+4], 0
$L82060:

; 935  : 		}
; 936  : 
; 937  : #endif
; 938  : 
; 939  : 		// Count tris and quads
; 940  : 		if (IsPolyQuad(&polys[iPoly])) {

	movsx	eax, WORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _polys$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	and	edx, 1
	je	SHORT $L82062

; 941  : 			QuadCollCount++;

	mov	eax, DWORD PTR ?QuadCollCount@@3HA	; QuadCollCount
	add	eax, 1
	mov	DWORD PTR ?QuadCollCount@@3HA, eax	; QuadCollCount

; 942  : 		} else {

	jmp	SHORT $L82063
$L82062:

; 943  : 			TriCollCount++;

	mov	eax, DWORD PTR ?TriCollCount@@3HA	; TriCollCount
	add	eax, 1
	mov	DWORD PTR ?TriCollCount@@3HA, eax	; TriCollCount
$L82063:

; 944  : 		}
; 945  : 
; 946  : 
; 947  : 	}

	jmp	$L82054
$L82055:

; 948  : 
; 949  : 	//wsprintf(buf, "Quads: %d\nTris:  %d", QuadCollCount, TriCollCount);
; 950  : 	//Box("Oy", buf, MB_OK);
; 951  : 
; 952  : 	// Success!
; 953  : 	*nPolys = header.NPolys;

	mov	eax, DWORD PTR _nPolys$[ebp]
	mov	cx, WORD PTR _header$[ebp]
	mov	WORD PTR [eax], cx

; 954  : 
; 955  : 	
; 956  : 	return polys;

	mov	eax, DWORD PTR _polys$[ebp]
$L82045:

; 957  : 
; 958  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadNewCollPolys@@YAPAUCollPolyStruct@@PAU_iobuf@@PAF@Z ENDP ; LoadNewCollPolys
_TEXT	ENDS
PUBLIC	?LoadGridInfo@@YA_NPAU_iobuf@@@Z		; LoadGridInfo
EXTRN	?InstanceNum@@3JA:DWORD				; InstanceNum
EXTRN	?Instances@@3PAUINSTANCE@@A:BYTE		; Instances
; Function compile flags: /Odt /ZI
;	COMDAT ?LoadGridInfo@@YA_NPAU_iobuf@@@Z
_TEXT	SEGMENT
tv178 = -936						; size = 4
_instList$ = -868					; size = 800
_bBox$ = -68						; size = 24
_z1$ = -44						; size = 4
_x1$ = -40						; size = 4
_xCount$ = -36						; size = 4
_instance$ = -32					; size = 4
_nInstPolys$ = -28					; size = 4
_nextWorldPoly$ = -24					; size = 4
_instListSize$ = -20					; size = 4
_index$ = -16						; size = 4
_iInst$ = -12						; size = 4
_iGrid$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_fp$ = 8						; size = 4
?LoadGridInfo@@YA_NPAU_iobuf@@@Z PROC NEAR		; LoadGridInfo, COMDAT

; 962  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 936				; 000003a8H
	push	ebx
	push	esi
	push	edi

; 963  : #ifndef _PSX
; 964  : 	long iPoly, iGrid, iInst, index;
; 965  : 	int instListSize, nextWorldPoly;
; 966  : 	long nInstPolys;
; 967  : #else
; 968  : 	short iPoly, iGrid, iInst, index;
; 969  : 	short instListSize, nextWorldPoly;
; 970  : 	short nInstPolys;
; 971  : #endif
; 972  : 	INSTANCE *instance;
; 973  : 	int xCount;
; 974  : 	REAL x1, z1;
; 975  : 	BBOX bBox;
; 976  : #ifndef _PSX
; 977  : 	int instList[MAX_INSTANCES];
; 978  : #endif
; 979  : 
; 980  : 
; 981  : 	// Read grid header
; 982  : 	if (fread(&COL_CollGridData, sizeof(COLLGRID_DATA), 1, fp) < 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	20					; 00000014H
	push	OFFSET FLAT:?COL_CollGridData@@3UCOLLGRID_DATA@@A ; COL_CollGridData
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	$L82081

; 983  : 
; 984  : 		// No grid data, so set up one grid system
; 985  : 		COL_CollGridData.XStart = ZERO;

	mov	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A, 0

; 986  : 		COL_CollGridData.ZStart = ZERO;

	mov	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4, 0

; 987  : 		COL_CollGridData.XNum = ZERO;

	mov	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8, 0

; 988  : 		COL_CollGridData.ZNum = ZERO;

	mov	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12, 0

; 989  : 		COL_CollGridData.GridSize = LARGEDIST;

	mov	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16, 1232348160 ; 49742400H

; 990  : 
; 991  : 		COL_NCollGrids = 1;

	mov	DWORD PTR ?COL_NCollGrids@@3JA, 1	; COL_NCollGrids

; 992  : 		if ((COL_CollGrid = CreateCollGrids(COL_NCollGrids)) == NULL) {

	mov	eax, DWORD PTR ?COL_NCollGrids@@3JA	; COL_NCollGrids
	push	eax
	call	?CreateCollGrids@@YAPAUCOLLGRID@@J@Z	; CreateCollGrids
	add	esp, 4
	mov	DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A, eax ; COL_CollGrid
	cmp	DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A, 0 ; COL_CollGrid
	jne	SHORT $L82082

; 993  : 			DestroyCollPolys(COL_WorldCollPoly);

	mov	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	push	eax
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 994  : 			COL_WorldCollPoly = NULL;

	mov	DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A, 0 ; COL_WorldCollPoly

; 995  : 			COL_NWorldCollPolys = 0;

	mov	WORD PTR ?COL_NWorldCollPolys@@3FA, 0	; COL_NWorldCollPolys

; 996  : 			return FALSE;

	xor	al, al
	jmp	$L82066
$L82082:

; 997  : 		}
; 998  : 		COL_CollGrid[0].NCollPolys = COL_NWorldCollPolys;

	movsx	eax, WORD PTR ?COL_NWorldCollPolys@@3FA	; COL_NWorldCollPolys
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	DWORD PTR [ecx], eax

; 999  : 		COL_CollGrid[0].NWorldPolys = COL_CollGrid[0].NCollPolys;

	mov	eax, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 1000 : #ifndef _PSX
; 1001 : 		COL_CollGrid[0].CollPolyPtr = CreateCollPolyPtrs(COL_CollGrid[0].NCollPolys);

	mov	eax, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z ; CreateCollPolyPtrs
	add	esp, 4
	mov	edx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	DWORD PTR [edx+8], eax

; 1002 : 		if (COL_CollGrid[0].CollPolyPtr == NULL) {

	mov	eax, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L82083

; 1003 : #else
; 1004 : 		COL_CollGrid[0].CollPolyIndices = CreateCollPolyIndices(COL_CollGrid[0].NCollPolys);
; 1005 : 		if (COL_CollGrid[0].CollPolyIndices == NULL) {
; 1006 : #endif
; 1007 : 			DestroyCollGrids();

	call	?DestroyCollGrids@@YAXXZ		; DestroyCollGrids

; 1008 : 			DestroyCollPolys(COL_WorldCollPoly);

	mov	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	push	eax
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 1009 : 			COL_WorldCollPoly = NULL;

	mov	DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A, 0 ; COL_WorldCollPoly

; 1010 : 			COL_NCollGrids = 0;

	mov	DWORD PTR ?COL_NCollGrids@@3JA, 0	; COL_NCollGrids

; 1011 : 			COL_NWorldCollPolys = 0;

	mov	WORD PTR ?COL_NWorldCollPolys@@3FA, 0	; COL_NWorldCollPolys

; 1012 : 			return FALSE;

	xor	al, al
	jmp	$L82066
$L82083:

; 1013 : 		}
; 1014 : 		for (iPoly = 0; iPoly < COL_NWorldCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82084
$L82085:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82084:
	movsx	eax, WORD PTR ?COL_NWorldCollPolys@@3FA	; COL_NWorldCollPolys
	cmp	DWORD PTR _iPoly$[ebp], eax
	jge	SHORT $L82086

; 1015 : #ifndef _PSX
; 1016 : 			COL_CollGrid[0].CollPolyPtr[iPoly] = &COL_WorldCollPoly[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	add	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _iPoly$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1017 : #else
; 1018 : 			COL_CollGrid[0].CollPolyIndices[iPoly] = iPoly;
; 1019 : #endif
; 1020 : 		}

	jmp	SHORT $L82085
$L82086:

; 1021 : 
; 1022 : 		return FALSE;

	xor	al, al
	jmp	$L82066
$L82081:

; 1023 : 	}
; 1024 : 	
; 1025 : 
; 1026 : 	// Grid data exists, so read it all in
; 1027 : 	COL_NCollGrids = NearestInt(COL_CollGridData.XNum) * NearestInt(COL_CollGridData.ZNum);

	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	mov	esi, eax
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	imul	esi, eax
	mov	DWORD PTR ?COL_NCollGrids@@3JA, esi	; COL_NCollGrids

; 1028 : 	if ((COL_CollGrid = CreateCollGrids(COL_NCollGrids)) == NULL) {

	mov	eax, DWORD PTR ?COL_NCollGrids@@3JA	; COL_NCollGrids
	push	eax
	call	?CreateCollGrids@@YAPAUCOLLGRID@@J@Z	; CreateCollGrids
	add	esp, 4
	mov	DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A, eax ; COL_CollGrid
	cmp	DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A, 0 ; COL_CollGrid
	jne	SHORT $L82089

; 1029 : 		DestroyCollPolys(COL_WorldCollPoly);

	mov	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	push	eax
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 1030 : 		COL_WorldCollPoly = NULL;

	mov	DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A, 0 ; COL_WorldCollPoly

; 1031 : 		COL_NCollGrids = 0;

	mov	DWORD PTR ?COL_NCollGrids@@3JA, 0	; COL_NCollGrids

; 1032 : 		COL_NWorldCollPolys = 0;

	mov	WORD PTR ?COL_NWorldCollPolys@@3FA, 0	; COL_NWorldCollPolys

; 1033 : 		return FALSE;

	xor	al, al
	jmp	$L82066
$L82089:

; 1034 : 	}
; 1035 : 
; 1036 : 	x1 = COL_CollGridData.XStart;

	mov	eax, DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	mov	DWORD PTR _x1$[ebp], eax

; 1037 : 	z1 = COL_CollGridData.ZStart;

	mov	eax, DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4
	mov	DWORD PTR _z1$[ebp], eax

; 1038 : 	xCount = 0;

	mov	DWORD PTR _xCount$[ebp], 0

; 1039 : 	// Read in pointer list for each grid location
; 1040 : 	for (iGrid = 0; iGrid < COL_NCollGrids; iGrid++) {

	mov	DWORD PTR _iGrid$[ebp], 0
	jmp	SHORT $L82090
$L82091:
	mov	eax, DWORD PTR _iGrid$[ebp]
	add	eax, 1
	mov	DWORD PTR _iGrid$[ebp], eax
$L82090:
	mov	eax, DWORD PTR _iGrid$[ebp]
	cmp	eax, DWORD PTR ?COL_NCollGrids@@3JA	; COL_NCollGrids
	jge	$L82092

; 1041 : 
; 1042 : 		// Get number of polys in this grid volume
; 1043 : 		if (fread(&COL_CollGrid[iGrid].NCollPolys, sizeof(COL_CollGrid[iGrid].NCollPolys), 1, fp) < 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	mov	ecx, DWORD PTR _iGrid$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $L82093

; 1044 : 			DestroyCollGrids();

	call	?DestroyCollGrids@@YAXXZ		; DestroyCollGrids

; 1045 : 			DestroyCollPolys(COL_WorldCollPoly);

	mov	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	push	eax
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 1046 : 			COL_WorldCollPoly = NULL;

	mov	DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A, 0 ; COL_WorldCollPoly

; 1047 : 			COL_NCollGrids = 0;

	mov	DWORD PTR ?COL_NCollGrids@@3JA, 0	; COL_NCollGrids

; 1048 : 			COL_NWorldCollPolys = 0;

	mov	WORD PTR ?COL_NWorldCollPolys@@3FA, 0	; COL_NWorldCollPolys

; 1049 : 			return FALSE;

	xor	al, al
	jmp	$L82066
$L82093:

; 1050 : 		}
; 1051 : 
; 1052 : 		// See if any of the instances fall within this grid location and keep note of which ones
; 1053 : 		instListSize = 0;

	mov	DWORD PTR _instListSize$[ebp], 0

; 1054 : 		nInstPolys = 0;

	mov	DWORD PTR _nInstPolys$[ebp], 0

; 1055 : #ifndef _PSX
; 1056 : 		SetBBox(&bBox, x1, x1 + COL_CollGridData.GridSize, -LARGEDIST, LARGEDIST, z1, z1 + COL_CollGridData.GridSize);

	mov	eax, DWORD PTR _x1$[ebp]
	mov	DWORD PTR _bBox$[ebp], eax
	fld	DWORD PTR _x1$[ebp]
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fstp	DWORD PTR _bBox$[ebp+4]
	mov	DWORD PTR _bBox$[ebp+8], -915135488	; c9742400H
	mov	DWORD PTR _bBox$[ebp+12], 1232348160	; 49742400H
	mov	eax, DWORD PTR _z1$[ebp]
	mov	DWORD PTR _bBox$[ebp+16], eax
	fld	DWORD PTR _z1$[ebp]
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fstp	DWORD PTR _bBox$[ebp+20]

; 1057 : 		for (iInst = 0; iInst < InstanceNum; iInst++) {

	mov	DWORD PTR _iInst$[ebp], 0
	jmp	SHORT $L82094
$L82095:
	mov	eax, DWORD PTR _iInst$[ebp]
	add	eax, 1
	mov	DWORD PTR _iInst$[ebp], eax
$L82094:
	mov	eax, DWORD PTR _iInst$[ebp]
	cmp	eax, DWORD PTR ?InstanceNum@@3JA	; InstanceNum
	jge	$L82096

; 1058 : 			if (BBTestXZY(&bBox, (BBOX *)&Instances[iInst].Box)) {

	mov	eax, DWORD PTR _iInst$[ebp]
	imul	eax, 136				; 00000088H
	fld	DWORD PTR _bBox$[ebp]
	fcomp	DWORD PTR ?Instances@@3PAUINSTANCE@@A[eax+104]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L83054
	mov	ecx, DWORD PTR _iInst$[ebp]
	imul	ecx, 136				; 00000088H
	fld	DWORD PTR _bBox$[ebp+4]
	fcomp	DWORD PTR ?Instances@@3PAUINSTANCE@@A[ecx+100]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83054
	mov	edx, DWORD PTR _iInst$[ebp]
	imul	edx, 136				; 00000088H
	fld	DWORD PTR _bBox$[ebp+16]
	fcomp	DWORD PTR ?Instances@@3PAUINSTANCE@@A[edx+120]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83054
	mov	eax, DWORD PTR _iInst$[ebp]
	imul	eax, 136				; 00000088H
	fld	DWORD PTR _bBox$[ebp+20]
	fcomp	DWORD PTR ?Instances@@3PAUINSTANCE@@A[eax+116]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83054
	mov	ecx, DWORD PTR _iInst$[ebp]
	imul	ecx, 136				; 00000088H
	fld	DWORD PTR _bBox$[ebp+8]
	fcomp	DWORD PTR ?Instances@@3PAUINSTANCE@@A[ecx+112]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83054
	mov	edx, DWORD PTR _iInst$[ebp]
	imul	edx, 136				; 00000088H
	fld	DWORD PTR _bBox$[ebp+12]
	fcomp	DWORD PTR ?Instances@@3PAUINSTANCE@@A[edx+108]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83054
	mov	DWORD PTR tv178[ebp], 1
	jmp	SHORT $L83055
$L83054:
	mov	DWORD PTR tv178[ebp], 0
$L83055:
	cmp	DWORD PTR tv178[ebp], 0
	je	SHORT $L82103

; 1059 : 				instList[instListSize++] = iInst;

	mov	eax, DWORD PTR _instListSize$[ebp]
	mov	ecx, DWORD PTR _iInst$[ebp]
	mov	DWORD PTR _instList$[ebp+eax*4], ecx
	mov	edx, DWORD PTR _instListSize$[ebp]
	add	edx, 1
	mov	DWORD PTR _instListSize$[ebp], edx

; 1060 : 				nInstPolys += Instances[iInst].NCollPolys;

	mov	eax, DWORD PTR _iInst$[ebp]
	imul	eax, 136				; 00000088H
	movsx	ecx, WORD PTR ?Instances@@3PAUINSTANCE@@A[eax+128]
	add	ecx, DWORD PTR _nInstPolys$[ebp]
	mov	DWORD PTR _nInstPolys$[ebp], ecx
$L82103:

; 1061 : 			}
; 1062 : 		}

	jmp	$L82095
$L82096:

; 1063 : 		(++xCount) %= NearestInt(COL_CollGridData.XNum);

	mov	eax, DWORD PTR _xCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _xCount$[ebp], eax
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	mov	ecx, eax
	mov	eax, DWORD PTR _xCount$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _xCount$[ebp], edx

; 1064 : 		if (xCount == 0) {

	cmp	DWORD PTR _xCount$[ebp], 0
	jne	SHORT $L82105

; 1065 : 			x1 = COL_CollGridData.XStart;

	mov	eax, DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	mov	DWORD PTR _x1$[ebp], eax

; 1066 : 			z1 += COL_CollGridData.GridSize;

	fld	DWORD PTR _z1$[ebp]
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fstp	DWORD PTR _z1$[ebp]

; 1067 : 		} else {

	jmp	SHORT $L82106
$L82105:

; 1068 : 			x1 += COL_CollGridData.GridSize;

	fld	DWORD PTR _x1$[ebp]
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fstp	DWORD PTR _x1$[ebp]
$L82106:

; 1069 : 		}
; 1070 : #endif
; 1071 : 
; 1072 : 		// Allocate space for the pointers if necessary
; 1073 : 		if (COL_CollGrid[iGrid].NCollPolys + nInstPolys == 0) {

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, DWORD PTR _nInstPolys$[ebp]
	jne	SHORT $L82107

; 1074 : #ifndef _PSX
; 1075 : 			COL_CollGrid[iGrid].CollPolyPtr = NULL;

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	DWORD PTR [ecx+eax+8], 0

; 1076 : #else
; 1077 : 			COL_CollGrid[iGrid].CollPolyIndices = NULL;
; 1078 : #endif
; 1079 : 			continue;

	jmp	$L82091
$L82107:

; 1080 : 		} else {
; 1081 : #ifndef _PSX
; 1082 : 			COL_CollGrid[iGrid].CollPolyPtr = CreateCollPolyPtrs(COL_CollGrid[iGrid].NCollPolys + nInstPolys);

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, DWORD PTR _nInstPolys$[ebp]
	push	edx
	call	?CreateCollPolyPtrs@@YAPAPAUCollPolyStruct@@H@Z ; CreateCollPolyPtrs
	add	esp, 4
	mov	ecx, DWORD PTR _iGrid$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	DWORD PTR [edx+ecx+8], eax

; 1083 : 			if (COL_CollGrid[iGrid].CollPolyPtr == NULL) {

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	cmp	DWORD PTR [ecx+eax+8], 0
	jne	SHORT $L82108

; 1084 : #else
; 1085 : 			COL_CollGrid[iGrid].CollPolyIndices = CreateCollPolyIndices(COL_CollGrid[iGrid].NCollPolys);
; 1086 : 			if (COL_CollGrid[iGrid].CollPolyIndices == NULL) {
; 1087 : #endif
; 1088 : 				DestroyCollGrids();

	call	?DestroyCollGrids@@YAXXZ		; DestroyCollGrids

; 1089 : 				DestroyCollPolys(COL_WorldCollPoly);

	mov	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	push	eax
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 1090 : 				COL_WorldCollPoly = NULL;

	mov	DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A, 0 ; COL_WorldCollPoly

; 1091 : 				COL_NCollGrids = 0;

	mov	DWORD PTR ?COL_NCollGrids@@3JA, 0	; COL_NCollGrids

; 1092 : 				COL_NWorldCollPolys = 0;

	mov	WORD PTR ?COL_NWorldCollPolys@@3FA, 0	; COL_NWorldCollPolys

; 1093 : 				return FALSE;

	xor	al, al
	jmp	$L82066
$L82108:

; 1094 : 			}
; 1095 : 		}
; 1096 : 		
; 1097 : 		// Fill the pointer array with pointers to polys in grid volume
; 1098 : 		for (iPoly = 0; iPoly < COL_CollGrid[iGrid].NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82110
$L82111:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82110:
	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR _iPoly$[ebp]
	cmp	edx, DWORD PTR [ecx+eax]
	jge	SHORT $L82112

; 1099 : 			if (fread(&index, sizeof(index), 1, fp) < 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _index$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $L82113

; 1100 : 				DestroyCollGrids();

	call	?DestroyCollGrids@@YAXXZ		; DestroyCollGrids

; 1101 : 				DestroyCollPolys(COL_WorldCollPoly);

	mov	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	push	eax
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 1102 : 				COL_WorldCollPoly = NULL;

	mov	DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A, 0 ; COL_WorldCollPoly

; 1103 : 				COL_NCollGrids = 0;

	mov	DWORD PTR ?COL_NCollGrids@@3JA, 0	; COL_NCollGrids

; 1104 : 				COL_NWorldCollPolys = 0;

	mov	WORD PTR ?COL_NWorldCollPolys@@3FA, 0	; COL_NWorldCollPolys

; 1105 : 				return FALSE;

	xor	al, al
	jmp	$L82066
$L82113:

; 1106 : 			}
; 1107 : #ifndef _PSX
; 1108 : 			COL_CollGrid[iGrid].CollPolyPtr[iPoly] = &COL_WorldCollPoly[index];

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 112				; 00000070H
	add	eax, DWORD PTR ?COL_WorldCollPoly@@3PAUCollPolyStruct@@A ; COL_WorldCollPoly
	mov	ecx, DWORD PTR _iGrid$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	edx, DWORD PTR _iPoly$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1109 : #else
; 1110 : 			COL_CollGrid[iGrid].CollPolyIndices[iPoly] = index;
; 1111 : #endif
; 1112 : 		}

	jmp	$L82111
$L82112:

; 1113 : 
; 1114 : #ifndef _PSX
; 1115 : 		// Now add the instance polys at the end
; 1116 : 		nextWorldPoly = COL_CollGrid[iGrid].NCollPolys;

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _nextWorldPoly$[ebp], edx

; 1117 : 		for (iInst = 0; iInst < instListSize; iInst++) {

	mov	DWORD PTR _iInst$[ebp], 0
	jmp	SHORT $L82114
$L82115:
	mov	eax, DWORD PTR _iInst$[ebp]
	add	eax, 1
	mov	DWORD PTR _iInst$[ebp], eax
$L82114:
	mov	eax, DWORD PTR _iInst$[ebp]
	cmp	eax, DWORD PTR _instListSize$[ebp]
	jge	SHORT $L82116

; 1118 : 			instance = &Instances[instList[iInst]];

	mov	eax, DWORD PTR _iInst$[ebp]
	mov	ecx, DWORD PTR _instList$[ebp+eax*4]
	imul	ecx, 136				; 00000088H
	add	ecx, OFFSET FLAT:?Instances@@3PAUINSTANCE@@A ; Instances
	mov	DWORD PTR _instance$[ebp], ecx

; 1119 : 			for (iPoly = 0; iPoly < instance->NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82117
$L82118:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82117:
	mov	eax, DWORD PTR _instance$[ebp]
	movsx	ecx, WORD PTR [eax+128]
	cmp	DWORD PTR _iPoly$[ebp], ecx
	jge	SHORT $L82119

; 1120 : 				COL_CollGrid[iGrid].CollPolyPtr[nextWorldPoly++] = instance->CollPoly + iPoly;

	mov	eax, DWORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _instance$[ebp]
	add	eax, DWORD PTR [ecx+124]
	mov	edx, DWORD PTR _iGrid$[ebp]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR [ecx+edx+8]
	mov	ecx, DWORD PTR _nextWorldPoly$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edx, DWORD PTR _nextWorldPoly$[ebp]
	add	edx, 1
	mov	DWORD PTR _nextWorldPoly$[ebp], edx

; 1121 : 			}

	jmp	SHORT $L82118
$L82119:

; 1122 : 		}

	jmp	SHORT $L82115
$L82116:

; 1123 : 		COL_CollGrid[iGrid].NWorldPolys = COL_CollGrid[iGrid].NCollPolys;

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _iGrid$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	esi, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+4], eax

; 1124 : 		COL_CollGrid[iGrid].NCollPolys += nInstPolys;

	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, DWORD PTR _nInstPolys$[ebp]
	mov	eax, DWORD PTR _iGrid$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	DWORD PTR [ecx+eax], edx

; 1125 : #else
; 1126 : 		COL_CollGrid[iGrid].NWorldPolys = COL_CollGrid[iGrid].NCollPolys;
; 1127 : #endif
; 1128 : 
; 1129 : 	}

	jmp	$L82091
$L82092:

; 1130 : 
; 1131 : 	return TRUE;

	mov	al, 1
$L82066:

; 1132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadGridInfo@@YA_NPAU_iobuf@@@Z ENDP			; LoadGridInfo
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ExpandBBox@@YAXPAUBBOX@@M@Z
_TEXT	SEGMENT
_bBox$ = 8						; size = 4
_delta$ = 12						; size = 4
?ExpandBBox@@YAXPAUBBOX@@M@Z PROC NEAR			; ExpandBBox, COMDAT

; 1353 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1354 : 	bBox->XMin -= delta;

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _delta$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [ecx]

; 1355 : 	bBox->XMax += delta;

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR _delta$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [ecx+4]

; 1356 : 	bBox->YMin -= delta;

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR _delta$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1357 : 	bBox->YMax += delta;

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR _delta$[ebp]
	fadd	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [ecx+12]

; 1358 : 	bBox->ZMin -= delta;

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR _delta$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [ecx+16]

; 1359 : 	bBox->ZMax += delta;

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR _delta$[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [ecx+20]

; 1360 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ExpandBBox@@YAXPAUBBOX@@M@Z ENDP			; ExpandBBox
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3727c5ac
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z ; SphereCollPoly
_BSS	SEGMENT
_dist	DD	04H DUP (?)
_inside	DB	04H DUP (?)
_BSS	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z
_TEXT	SEGMENT
tv342 = -96						; size = 4
tv197 = -96						; size = 4
tv371 = -92						; size = 4
tv340 = -92						; size = 4
tv195 = -92						; size = 4
tv179 = -92						; size = 4
_i$ = -24						; size = 4
_outCount$ = -20					; size = 4
_nSides$ = -16						; size = 4
_dLen$ = -12						; size = 4
_newDist$ = -8						; size = 4
_oldDist$ = -4						; size = 4
_oldPos$ = 8						; size = 4
_newPos$ = 12						; size = 4
_radius$ = 16						; size = 4
_collPoly$ = 20						; size = 4
_plane$ = 24						; size = 4
_relPos$ = 28						; size = 4
_worldPos$ = 32						; size = 4
_depth$ = 36						; size = 4
_time$ = 40						; size = 4
?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z PROC NEAR ; SphereCollPoly, COMDAT

; 1374 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1375 : 	REAL	oldDist, newDist, dLen;
; 1376 : 	int		nSides, outCount, i;
; 1377 : 
; 1378 : 	// Make sure sphere is within "radius" of the plane of the polygon or on the inside
; 1379 : 	newDist = VecDotPlane(newPos, &collPoly->Plane);

	mov	eax, DWORD PTR _newPos$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _newPos$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _newPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _collPoly$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR _newDist$[ebp]

; 1380 : 	if (newDist - radius > COLL_EPSILON) return FALSE;

	fld	DWORD PTR _newDist$[ebp]
	fsub	DWORD PTR _radius$[ebp]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82144
	xor	al, al
	jmp	$L82136
$L82144:

; 1381 : 
; 1382 : 	// If we were inside the plane last time, probably no collision
; 1383 : 	oldDist = VecDotPlane(oldPos, &collPoly->Plane);

	mov	eax, DWORD PTR _oldPos$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _oldPos$[ebp]
	mov	eax, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _oldPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _collPoly$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR _oldDist$[ebp]

; 1384 : 	if (oldDist < -(radius + COLL_EPSILON)) return FALSE;

	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR __real@40000000
	fchs
	fcomp	DWORD PTR _oldDist$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82146
	xor	al, al
	jmp	$L82136
$L82146:

; 1385 : 
; 1386 : 	// Count the faces that the sphere centre is outside of, and store distances
; 1387 : 	outCount = 0;

	mov	DWORD PTR _outCount$[ebp], 0

; 1388 : 	if (IsPolyQuad(collPoly)) {

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	je	SHORT $L82147

; 1389 : 		nSides = 4;

	mov	DWORD PTR _nSides$[ebp], 4

; 1390 : 	} else {

	jmp	SHORT $L82148
$L82147:

; 1391 : 		nSides = 3;

	mov	DWORD PTR _nSides$[ebp], 3
$L82148:

; 1392 : 	}
; 1393 : 	for (i = 0; i < nSides; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82149
$L82150:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82149:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nSides$[ebp]
	jge	$L82151

; 1394 : 		inside[i] = ((dist[i] = VecDotPlane(newPos, &collPoly->EdgePlane[i])) < COLL_EPSILON);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _newPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+eax+24]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _newPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+eax+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _newPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+eax+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fadd	DWORD PTR [ecx+eax+36]
	mov	edx, DWORD PTR _i$[ebp]
	fstp	DWORD PTR _dist[edx*4]
	mov	eax, DWORD PTR _i$[ebp]
	fld	DWORD PTR _dist[eax*4]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83060
	mov	DWORD PTR tv179[ebp], 1
	jmp	SHORT $L83061
$L83060:
	mov	DWORD PTR tv179[ebp], 0
$L83061:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR tv179[ebp]
	mov	BYTE PTR _inside[ecx], dl

; 1395 : 		if (!inside[i]) {

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _inside[eax]
	test	ecx, ecx
	jne	SHORT $L82153

; 1396 : 			outCount++;

	mov	eax, DWORD PTR _outCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _outCount$[ebp], eax
$L82153:

; 1397 : 		}
; 1398 : 	}

	jmp	$L82150
$L82151:

; 1399 : 
; 1400 : 
; 1401 : 	// See if the centre is within the poly bounds
; 1402 : 	if (outCount == 0) {

	cmp	DWORD PTR _outCount$[ebp], 0
	jne	$L82154

; 1403 : 
; 1404 : 		// Get the collision depth
; 1405 : 		*depth = newDist - radius;

	fld	DWORD PTR _newDist$[ebp]
	fsub	DWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _depth$[ebp]
	fstp	DWORD PTR [eax]

; 1406 : 
; 1407 : 		// Get rough estimate of collision "time" (fraction of distance travelled at which collision occurred)
; 1408 : 		if (ApproxEqual(oldDist, newDist)) {

	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83062
	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fstp	DWORD PTR tv195[ebp]
	jmp	SHORT $L83063
$L83062:
	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fchs
	fstp	DWORD PTR tv195[ebp]
$L83063:
	fld	DWORD PTR tv195[ebp]
	fcomp	DWORD PTR __real@38d1b717
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83064
	mov	DWORD PTR tv197[ebp], 1
	jmp	SHORT $L83065
$L83064:
	mov	DWORD PTR tv197[ebp], 0
$L83065:
	cmp	DWORD PTR tv197[ebp], 0
	je	SHORT $L82155

; 1409 : 			*time = ZERO;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax], 0

; 1410 : 		} else {

	jmp	SHORT $L82156
$L82155:

; 1411 : 			*time = DivScalar(oldDist, (oldDist - newDist));

	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fdivr	DWORD PTR _oldDist$[ebp]
	mov	eax, DWORD PTR _time$[ebp]
	fstp	DWORD PTR [eax]
$L82156:

; 1412 : 		}
; 1413 : 
; 1414 : 		// Set the return parameters
; 1415 : 		CopyPlane(&collPoly->Plane, plane);

	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+12], edx

; 1416 : 		VecEqScalarVec(relPos, -radius, PlaneNormal(plane));

	fld	DWORD PTR _radius$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _relPos$[ebp]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR _radius$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _relPos$[ebp]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR _radius$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _relPos$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1417 : 		VecPlusScalarVec(newPos, -newDist, PlaneNormal(plane), worldPos);

	fld	DWORD PTR _newDist$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fstp	DWORD PTR [edx]
	fld	DWORD PTR _newDist$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fstp	DWORD PTR [edx+4]
	fld	DWORD PTR _newDist$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fstp	DWORD PTR [edx+8]

; 1418 : 
; 1419 : 		return TRUE;

	mov	al, 1
	jmp	$L82136
$L82154:

; 1420 : 	}
; 1421 : 
; 1422 : 	// Collision with an edge?
; 1423 : 	if (outCount == 1) {

	cmp	DWORD PTR _outCount$[ebp], 1
	jne	$L82163

; 1424 : 
; 1425 : 		// find the edge which is on the inside of the centre
; 1426 : 		for (i = 0; i < nSides; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82164
$L82165:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82164:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nSides$[ebp]
	jge	$L82166

; 1427 : 			if (inside[i]) continue;

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _inside[eax]
	test	ecx, ecx
	je	SHORT $L82167
	jmp	SHORT $L82165
$L82167:

; 1428 : 
; 1429 : 			// Calculate the coordinate of the point on the edge, nearest the centre
; 1430 : 			VecEqScalarVec(PlaneNormal(plane), -dist[i], PlaneNormal(&collPoly->EdgePlane[i]));

	mov	eax, DWORD PTR _i$[ebp]
	fld	DWORD PTR _dist[eax*4]
	fchs
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+ecx+24]
	mov	eax, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _i$[ebp]
	fld	DWORD PTR _dist[eax*4]
	fchs
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+ecx+28]
	mov	eax, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _i$[ebp]
	fld	DWORD PTR _dist[eax*4]
	fchs
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [edx+ecx+32]
	mov	eax, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [eax+8]

; 1431 : 			VecPlusEqScalarVec(PlaneNormal(plane), -newDist, PlaneNormal(&collPoly->Plane));

	fld	DWORD PTR _newDist$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [edx]
	fld	DWORD PTR _newDist$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [edx+4]
	fld	DWORD PTR _newDist$[ebp]
	fchs
	mov	eax, DWORD PTR _collPoly$[ebp]
	fmul	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [edx+8]

; 1432 : 			dLen = VecLen(PlaneNormal(plane));

	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _plane$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dLen$[ebp]

; 1433 : 			if (dLen > (radius)) {

	fld	DWORD PTR _dLen$[ebp]
	fcomp	DWORD PTR _radius$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82190

; 1434 : 				return FALSE;

	xor	al, al
	jmp	$L82136
$L82190:

; 1435 : 			}
; 1436 : 			VecPlusVec(PlaneNormal(plane), newPos, worldPos);

	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _newPos$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fstp	DWORD PTR [edx+8]

; 1437 : 
; 1438 : 			// Calculate the collision depth and time
; 1439 : 			*depth = dLen - radius;

	fld	DWORD PTR _dLen$[ebp]
	fsub	DWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _depth$[ebp]
	fstp	DWORD PTR [eax]

; 1440 : 
; 1441 : 			// Get rough estimate of collision "time" (fraction of distance travelled at which collision occurred)
; 1442 : 			if (ApproxEqual(oldDist, newDist)) { //dLen)) {

	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83066
	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fstp	DWORD PTR tv340[ebp]
	jmp	SHORT $L83067
$L83066:
	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fchs
	fstp	DWORD PTR tv340[ebp]
$L83067:
	fld	DWORD PTR tv340[ebp]
	fcomp	DWORD PTR __real@38d1b717
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83068
	mov	DWORD PTR tv342[ebp], 1
	jmp	SHORT $L83069
$L83068:
	mov	DWORD PTR tv342[ebp], 0
$L83069:
	cmp	DWORD PTR tv342[ebp], 0
	je	SHORT $L82194

; 1443 : 				*time = ZERO;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax], 0

; 1444 : 			} else {

	jmp	SHORT $L82166
$L82194:

; 1445 : 				*time = DivScalar(oldDist, (oldDist - newDist));

	fld	DWORD PTR _oldDist$[ebp]
	fsub	DWORD PTR _newDist$[ebp]
	fdivr	DWORD PTR _oldDist$[ebp]
	mov	eax, DWORD PTR _time$[ebp]
	fstp	DWORD PTR [eax]
$L82166:

; 1446 : 			}
; 1447 : 			
; 1448 : 			break;
; 1449 : 		}
; 1450 : 
; 1451 : 		// Chack that the point is within the bounding box 
; 1452 : 		// (approximation - eliminates need for voronoi regions)
; 1453 : 		if (!PointInBBox(worldPos, &collPoly->BBox)) {

	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _worldPos$[ebp]
	fld	DWORD PTR [eax+88]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83070
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _worldPos$[ebp]
	fld	DWORD PTR [edx+92]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83070
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fld	DWORD PTR [ecx+104]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83070
	mov	eax, DWORD PTR _collPoly$[ebp]
	mov	ecx, DWORD PTR _worldPos$[ebp]
	fld	DWORD PTR [eax+108]
	fcomp	DWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83070
	mov	edx, DWORD PTR _collPoly$[ebp]
	mov	eax, DWORD PTR _worldPos$[ebp]
	fld	DWORD PTR [edx+96]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83070
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR _worldPos$[ebp]
	fld	DWORD PTR [ecx+100]
	fcomp	DWORD PTR [edx+4]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83070
	mov	DWORD PTR tv371[ebp], 1
	jmp	SHORT $L83071
$L83070:
	mov	DWORD PTR tv371[ebp], 0
$L83071:
	cmp	DWORD PTR tv371[ebp], 0
	jne	SHORT $L82196

; 1454 : 			return FALSE;

	xor	al, al
	jmp	$L82136
$L82196:

; 1455 : 		}
; 1456 : 
; 1457 : 		// See if it is inside the tri or quad
; 1458 : 		for (i = 0; i < nSides; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L82197
$L82198:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L82197:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nSides$[ebp]
	jge	SHORT $L82199

; 1459 : 			if (!inside[i]) continue;

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _inside[eax]
	test	ecx, ecx
	jne	SHORT $L82200
	jmp	SHORT $L82198
$L82200:

; 1460 : 			
; 1461 : 			if (VecDotPlane(worldPos, &collPoly->EdgePlane[i]) > ZERO) {

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _worldPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+eax+24]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _worldPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+eax+28]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _worldPos$[ebp]
	mov	edx, DWORD PTR _collPoly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+eax+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collPoly$[ebp]
	fadd	DWORD PTR [ecx+eax+36]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82201

; 1462 : 				return FALSE;

	xor	al, al
	jmp	$L82136
$L82201:

; 1463 : 			}
; 1464 : 		}

	jmp	SHORT $L82198
$L82199:

; 1465 : 
; 1466 : 		// Collision with edge occurred
; 1467 : 		if (dLen > SMALL_REAL) {

	fld	DWORD PTR _dLen$[ebp]
	fcomp	DWORD PTR __real@3727c5ac
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82202

; 1468 : 			//CopyPlane(&collPoly->Plane, plane);
; 1469 : 			VecDivScalar(PlaneNormal(plane), -dLen);

	fld	DWORD PTR _dLen$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fdivr	DWORD PTR [eax]
	mov	ecx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR _dLen$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fdivr	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR _dLen$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fdivr	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _plane$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1470 : 		} else {

	jmp	SHORT $L82206
$L82202:

; 1471 : 			CopyPlane(&collPoly->Plane, plane);

	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR _collPoly$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+12], edx
$L82206:

; 1472 : 		}
; 1473 : 		VecEqScalarVec(relPos, -radius, PlaneNormal(plane));

	fld	DWORD PTR _radius$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _relPos$[ebp]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR _radius$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _relPos$[ebp]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR _radius$[ebp]
	fchs
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _relPos$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1474 : 
; 1475 : 
; 1476 : 		return TRUE;

	mov	al, 1
	jmp	SHORT $L82136
$L82163:

; 1477 : 	}
; 1478 : 
; 1479 : 	// Collision with vertex ignored
; 1480 : 
; 1481 : 	return FALSE;

	xor	al, al
$L82136:

; 1482 : 
; 1483 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SphereCollPoly@@YA_NPAUVectorStruct@@0MPAUCollPolyStruct@@PAUPlaneStruct@@00PAM3@Z ENDP ; SphereCollPoly
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC NEAR					; sqrt, COMDAT

; 579  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC NEAR					; COMDAT

; 470  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\newcoll.cpp
;	COMDAT ?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z
_TEXT	SEGMENT
tv94 = -88						; size = 4
tv95 = -84						; size = 4
tv147 = -80						; size = 4
tv90 = -80						; size = 4
tv145 = -76						; size = 4
tv135 = -76						; size = 4
tv131 = -76						; size = 4
tv91 = -76						; size = 4
_endDotPlane$ = -8					; size = 4
_startDotPlane$ = -4					; size = 4
_lStart$ = 8						; size = 4
_lEnd$ = 12						; size = 4
_plane$ = 16						; size = 4
_t$ = 20						; size = 4
_depth$ = 24						; size = 4
?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z PROC NEAR ; LinePlaneIntersect, COMDAT

; 1545 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1546 : 	REAL	startDotPlane;
; 1547 : 	REAL	endDotPlane;
; 1548 : 
; 1549 : 	startDotPlane = VecDotPlane(lStart, plane);

	mov	eax, DWORD PTR _lStart$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _lStart$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _lStart$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _startDotPlane$[ebp]

; 1550 : 	endDotPlane = VecDotPlane(lEnd, plane);

	mov	eax, DWORD PTR _lEnd$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _lEnd$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _lEnd$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _plane$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _endDotPlane$[ebp]

; 1551 : 
; 1552 : 	// No collision if both points on same side of plane and outside tolerance
; 1553 : 	if ((Sign(startDotPlane) == Sign(endDotPlane)) &&
; 1554 : 		(abs(startDotPlane) > COLL_EPSILON) && 
; 1555 : 		(abs(endDotPlane) > COLL_EPSILON)) return FALSE;

	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _startDotPlane$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L83086
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $L83087
$L83086:
	fld	DWORD PTR _startDotPlane$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83084
	mov	DWORD PTR tv90[ebp], -1
	jmp	SHORT $L83085
$L83084:
	mov	DWORD PTR tv90[ebp], 1
$L83085:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv91[ebp], eax
$L83087:
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _endDotPlane$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L83090
	mov	DWORD PTR tv95[ebp], 0
	jmp	SHORT $L83091
$L83090:
	fld	DWORD PTR _endDotPlane$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83088
	mov	DWORD PTR tv94[ebp], -1
	jmp	SHORT $L83089
$L83088:
	mov	DWORD PTR tv94[ebp], 1
$L83089:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], ecx
$L83091:
	mov	edx, DWORD PTR tv91[ebp]
	cmp	edx, DWORD PTR tv95[ebp]
	jne	SHORT $L82221
	fld	DWORD PTR _startDotPlane$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83092
	mov	eax, DWORD PTR _startDotPlane$[ebp]
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $L83093
$L83092:
	fld	DWORD PTR _startDotPlane$[ebp]
	fchs
	fstp	DWORD PTR tv131[ebp]
$L83093:
	fld	DWORD PTR tv131[ebp]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82221
	fld	DWORD PTR _endDotPlane$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83094
	mov	eax, DWORD PTR _endDotPlane$[ebp]
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $L83095
$L83094:
	fld	DWORD PTR _endDotPlane$[ebp]
	fchs
	fstp	DWORD PTR tv135[ebp]
$L83095:
	fld	DWORD PTR tv135[ebp]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82221
	xor	al, al
	jmp	SHORT $L82216
$L82221:

; 1556 : 
; 1557 : 	// No collision if moving away from plane normal
; 1558 : 	/*if (Sign(startDotPlane) == ONE) {
; 1559 : 		if (startDotPlane < endDotPlane) return FALSE;
; 1560 : 	} else {
; 1561 : 		if (startDotPlane > endDotPlane) return FALSE;
; 1562 : 	}*/
; 1563 : 
; 1564 : 	// Calculate the "time" of the collision
; 1565 : 
; 1566 : 	if (ApproxEqual(startDotPlane, endDotPlane)) {

	fld	DWORD PTR _startDotPlane$[ebp]
	fsub	DWORD PTR _endDotPlane$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83096
	fld	DWORD PTR _startDotPlane$[ebp]
	fsub	DWORD PTR _endDotPlane$[ebp]
	fstp	DWORD PTR tv145[ebp]
	jmp	SHORT $L83097
$L83096:
	fld	DWORD PTR _startDotPlane$[ebp]
	fsub	DWORD PTR _endDotPlane$[ebp]
	fchs
	fstp	DWORD PTR tv145[ebp]
$L83097:
	fld	DWORD PTR tv145[ebp]
	fcomp	DWORD PTR __real@38d1b717
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83098
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $L83099
$L83098:
	mov	DWORD PTR tv147[ebp], 0
$L83099:
	cmp	DWORD PTR tv147[ebp], 0
	je	SHORT $L82222

; 1567 : 		*t = ZERO;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax], 0

; 1568 : 	} else {

	jmp	SHORT $L82223
$L82222:

; 1569 : 		*t = DivScalar(startDotPlane, (startDotPlane - endDotPlane));

	fld	DWORD PTR _startDotPlane$[ebp]
	fsub	DWORD PTR _endDotPlane$[ebp]
	fdivr	DWORD PTR _startDotPlane$[ebp]
	mov	eax, DWORD PTR _t$[ebp]
	fstp	DWORD PTR [eax]
$L82223:

; 1570 : 	}
; 1571 : 	*depth = endDotPlane;

	mov	eax, DWORD PTR _depth$[ebp]
	mov	ecx, DWORD PTR _endDotPlane$[ebp]
	mov	DWORD PTR [eax], ecx

; 1572 : 
; 1573 : 	return TRUE;

	mov	al, 1
$L82216:

; 1574 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ENDP ; LinePlaneIntersect
_TEXT	ENDS
PUBLIC	?PosDirPlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM@Z ; PosDirPlaneIntersect
; Function compile flags: /Odt /ZI
;	COMDAT ?PosDirPlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM@Z
_TEXT	SEGMENT
tv86 = -76						; size = 4
_dirDotPlane$ = -8					; size = 4
_startDotPlane$ = -4					; size = 4
_lStart$ = 8						; size = 4
_dir$ = 12						; size = 4
_plane$ = 16						; size = 4
_t$ = 20						; size = 4
?PosDirPlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM@Z PROC NEAR ; PosDirPlaneIntersect, COMDAT

; 1586 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1587 : 	REAL	startDotPlane;
; 1588 : 	REAL	dirDotPlane;
; 1589 : 
; 1590 : 	startDotPlane = VecDotPlaneNorm(lStart, plane);

	mov	eax, DWORD PTR _lStart$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _lStart$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _lStart$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _startDotPlane$[ebp]

; 1591 : 	dirDotPlane = VecDotPlaneNorm(dir, plane);

	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _dirDotPlane$[ebp]

; 1592 : 
; 1593 : 	// No collision for lines parallel to plane surface
; 1594 : 	if (abs(dirDotPlane) < SIMILAR_REAL) return FALSE;

	fld	DWORD PTR _dirDotPlane$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83102
	mov	eax, DWORD PTR _dirDotPlane$[ebp]
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $L83103
$L83102:
	fld	DWORD PTR _dirDotPlane$[ebp]
	fchs
	fstp	DWORD PTR tv86[ebp]
$L83103:
	fld	DWORD PTR tv86[ebp]
	fcomp	DWORD PTR __real@38d1b717
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82232
	xor	al, al
	jmp	SHORT $L82229
$L82232:

; 1595 : 
; 1596 : 	// Calculate the "time" of the collision
; 1597 : 	*t = - DivScalar((plane->v[D] + startDotPlane), dirDotPlane);

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR _startDotPlane$[ebp]
	fadd	DWORD PTR [eax+12]
	fdiv	DWORD PTR _dirDotPlane$[ebp]
	fchs
	mov	ecx, DWORD PTR _t$[ebp]
	fstp	DWORD PTR [ecx]

; 1598 : 	return TRUE;

	mov	al, 1
$L82229:

; 1599 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PosDirPlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM@Z ENDP ; PosDirPlaneIntersect
_TEXT	ENDS
PUBLIC	?FreeCollSkin@@YAXPAUCollSkinStruct@@@Z		; FreeCollSkin
PUBLIC	?DestroyConvex@@YAXPAUConvexStruct@@H@Z		; DestroyConvex
PUBLIC	?DestroySpheres@@YAXPAUSphereStruct@@@Z		; DestroySpheres
; Function compile flags: /Odt /ZI
;	COMDAT ?FreeCollSkin@@YAXPAUCollSkinStruct@@@Z
_TEXT	SEGMENT
_collSkin$ = 8						; size = 4
?FreeCollSkin@@YAXPAUCollSkinStruct@@@Z PROC NEAR	; FreeCollSkin, COMDAT

; 1609 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1610 : 
; 1611 : 	DestroyConvex(collSkin->WorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1612 : 	DestroyConvex(collSkin->OldWorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1613 : 	collSkin->WorldConvex = NULL;

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1614 : 	collSkin->OldWorldConvex = NULL;

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1615 : 
; 1616 : 	DestroySpheres(collSkin->WorldSphere);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 1617 : 	DestroySpheres(collSkin->OldWorldSphere);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 1618 : 	collSkin->WorldSphere = NULL;

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1619 : 	collSkin->OldWorldSphere = NULL;

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1620 : 
; 1621 : 	DestroyCollPolys(collSkin->CollPoly);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?DestroyCollPolys@@YAXPAUCollPolyStruct@@@Z ; DestroyCollPolys
	add	esp, 4

; 1622 : 	collSkin->CollPoly = NULL;

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1623 : 	collSkin->NCollPolys = 0;

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	WORD PTR [eax+36], 0

; 1624 : 
; 1625 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeCollSkin@@YAXPAUCollSkinStruct@@@Z ENDP		; FreeCollSkin
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??CreateConvex@@YAPAUConvexStruct@@F@Z@4JA ; `CreateConvex'::`2'::__LINE__Var
PUBLIC	?CreateConvex@@YAPAUConvexStruct@@F@Z		; CreateConvex
;	COMDAT ?__LINE__Var@?1??CreateConvex@@YAPAUConvexStruct@@F@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateConvex@@YAPAUConvexStruct@@F@Z@4JA DD 0662H ; `CreateConvex'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateConvex@@YAPAUConvexStruct@@F@Z
_TEXT	SEGMENT
_skin$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_nConvex$ = 8						; size = 2
?CreateConvex@@YAPAUConvexStruct@@F@Z PROC NEAR		; CreateConvex, COMDAT

; 1634 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1635 : 	int iSkin;
; 1636 : 	CONVEX *skin;
; 1637 : 
; 1638 : 	Assert(nConvex > 0);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateConvex@@YAPAUConvexStruct@@F@Z@4JA
	add	eax, 4
	push	eax
	movsx	ecx, WORD PTR _nConvex$[ebp]
	test	ecx, ecx
	setg	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1639 : 
; 1640 : 	// Create the space for the required number of convex objects
; 1641 : 	if ((skin = (CONVEX *)malloc(sizeof(CONVEX) * nConvex)) == NULL) {

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateConvex@@YAPAUConvexStruct@@F@Z@4JA
	add	eax, 7
	push	eax
	movsx	ecx, WORD PTR _nConvex$[ebp]
	imul	ecx, 44					; 0000002cH
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _skin$[ebp], eax
	cmp	DWORD PTR _skin$[ebp], 0
	jne	SHORT $L82244

; 1642 : 		return NULL;

	xor	eax, eax
	jmp	$L82238
$L82244:

; 1643 : 	}
; 1644 : 
; 1645 : 	for (iSkin = 0; iSkin < nConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82245
$L82246:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82245:
	movsx	eax, WORD PTR _nConvex$[ebp]
	cmp	DWORD PTR _iSkin$[ebp], eax
	jge	SHORT $L82247

; 1646 : 		skin[iSkin].NPts = 0;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	WORD PTR [ecx+eax], 0

; 1647 : 		skin[iSkin].NEdges = 0;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	WORD PTR [ecx+eax+2], 0

; 1648 : 		skin[iSkin].NFaces = 0;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	WORD PTR [ecx+eax+4], 0

; 1649 : 		skin[iSkin].Pts = NULL;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	DWORD PTR [ecx+eax+32], 0

; 1650 : 		skin[iSkin].Edges = NULL;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	DWORD PTR [ecx+eax+36], 0

; 1651 : 		skin[iSkin].Faces = NULL;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	DWORD PTR [ecx+eax+40], 0

; 1652 : 	}

	jmp	SHORT $L82246
$L82247:

; 1653 : 
; 1654 : 	return skin;

	mov	eax, DWORD PTR _skin$[ebp]
$L82238:

; 1655 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateConvex@@YAPAUConvexStruct@@F@Z ENDP		; CreateConvex
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA ; `SetupConvex'::`2'::__LINE__Var
PUBLIC	?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z	; SetupConvex
;	COMDAT ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA DD 0682H ; `SetupConvex'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z
_TEXT	SEGMENT
tv73 = -65						; size = 1
_skin$ = 8						; size = 4
_nPts$ = 12						; size = 2
_extraPts$ = 16						; size = 2
_nEdges$ = 20						; size = 2
_nFaces$ = 24						; size = 2
?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z PROC NEAR	; SetupConvex, COMDAT

; 1666 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1667 : 	// Make sure the numbers are valid
; 1668 : 	Assert((nPts > 0) && (nEdges > 0) && (nFaces > 0));

	movsx	eax, WORD PTR _nPts$[ebp]
	test	eax, eax
	jle	SHORT $L83110
	movsx	ecx, WORD PTR _nEdges$[ebp]
	test	ecx, ecx
	jle	SHORT $L83110
	movsx	edx, WORD PTR _nFaces$[ebp]
	test	edx, edx
	jle	SHORT $L83110
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $L83111
$L83110:
	mov	BYTE PTR tv73[ebp], 0
$L83111:
	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
	add	eax, 2
	push	eax
	mov	cl, BYTE PTR tv73[ebp]
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 1669 : 
; 1670 : 	// Create space for vertex info
; 1671 : 	if (nPts != 0) {

	movsx	eax, WORD PTR _nPts$[ebp]
	test	eax, eax
	je	SHORT $L82256

; 1672 : 		if ((skin->Pts = (VERTEX *)malloc(sizeof(VERTEX) * (nPts + extraPts))) == NULL) {

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
	add	eax, 6
	push	eax
	movsx	ecx, WORD PTR _nPts$[ebp]
	movsx	edx, WORD PTR _extraPts$[ebp]
	add	ecx, edx
	imul	ecx, 12					; 0000000cH
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	DWORD PTR [ecx+32], eax
	mov	edx, DWORD PTR _skin$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $L82256

; 1673 : 			return FALSE;

	xor	al, al
	jmp	$L82254
$L82256:

; 1674 : 		}
; 1675 : 	}
; 1676 : 
; 1677 : 	// Create space for Edge vertex list (gives offset into point array)
; 1678 : 	if (nEdges != 0) {

	movsx	eax, WORD PTR _nEdges$[ebp]
	test	eax, eax
	je	SHORT $L82260

; 1679 : 		if ((skin->Edges = (EDGE *)malloc(sizeof(EDGE) * nEdges)) == NULL) {

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
	add	eax, 13					; 0000000dH
	push	eax
	movsx	ecx, WORD PTR _nEdges$[ebp]
	shl	ecx, 2
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _skin$[ebp]
	mov	DWORD PTR [edx+36], eax
	mov	eax, DWORD PTR _skin$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $L82260

; 1680 : 			free(skin->Pts);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 1681 : 			return FALSE;

	xor	al, al
	jmp	$L82254
$L82260:

; 1682 : 		}
; 1683 : 	}
; 1684 : 
; 1685 : 	// Create space for the Face vertex list
; 1686 : 	if (nFaces != 0) {

	movsx	eax, WORD PTR _nFaces$[ebp]
	test	eax, eax
	je	SHORT $L82264

; 1687 : 		if ((skin->Faces = (PLANE *)malloc(sizeof(PLANE) * nFaces)) == NULL) {

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
	add	eax, 21					; 00000015H
	push	eax
	movsx	ecx, WORD PTR _nFaces$[ebp]
	shl	ecx, 4
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _skin$[ebp]
	mov	DWORD PTR [edx+40], eax
	mov	eax, DWORD PTR _skin$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L82264

; 1688 : 			free(skin->Edges);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
	add	eax, 22					; 00000016H
	push	eax
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 1689 : 			free(skin->Pts);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z@4JA
	add	eax, 23					; 00000017H
	push	eax
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 1690 : 			return FALSE;

	xor	al, al
	jmp	SHORT $L82254
$L82264:

; 1691 : 		}
; 1692 : 	}
; 1693 : 
; 1694 : 	skin->NPts = nPts + extraPts;

	movsx	eax, WORD PTR _nPts$[ebp]
	movsx	ecx, WORD PTR _extraPts$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _skin$[ebp]
	mov	WORD PTR [edx], ax

; 1695 : 	skin->NEdges = nEdges;

	mov	eax, DWORD PTR _skin$[ebp]
	mov	cx, WORD PTR _nEdges$[ebp]
	mov	WORD PTR [eax+2], cx

; 1696 : 	skin->NFaces = nFaces;

	mov	eax, DWORD PTR _skin$[ebp]
	mov	cx, WORD PTR _nFaces$[ebp]
	mov	WORD PTR [eax+4], cx

; 1697 : 
; 1698 : 	return TRUE;

	mov	al, 1
$L82254:

; 1699 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z ENDP		; SetupConvex
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA ; `DestroyConvex'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA DD 06adH ; `DestroyConvex'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DestroyConvex@@YAXPAUConvexStruct@@H@Z
_TEXT	SEGMENT
_iSkin$ = -4						; size = 4
_skin$ = 8						; size = 4
_nSkins$ = 12						; size = 4
?DestroyConvex@@YAXPAUConvexStruct@@H@Z PROC NEAR	; DestroyConvex, COMDAT

; 1709 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1710 : 	int iSkin;
; 1711 : 
; 1712 : 	if ((skin == NULL) || (nSkins ==0)) return;

	cmp	DWORD PTR _skin$[ebp], 0
	je	SHORT $L82274
	cmp	DWORD PTR _nSkins$[ebp], 0
	jne	SHORT $L82273
$L82274:
	jmp	$L82271
$L82273:

; 1713 : 
; 1714 : 	for (iSkin = 0; iSkin < nSkins; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82275
$L82276:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82275:
	mov	eax, DWORD PTR _iSkin$[ebp]
	cmp	eax, DWORD PTR _nSkins$[ebp]
	jge	SHORT $L82277

; 1715 : 		free(skin[iSkin].Faces);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _skin$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 1716 : 		free(skin[iSkin].Edges);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA
	add	eax, 7
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _skin$[ebp]
	mov	eax, DWORD PTR [edx+ecx+36]
	push	eax
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 1717 : 		free(skin[iSkin].Pts);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _skin$[ebp]
	mov	eax, DWORD PTR [edx+ecx+32]
	push	eax
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 1718 : 	}

	jmp	SHORT $L82276
$L82277:

; 1719 : 	free(skin);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroyConvex@@YAXPAUConvexStruct@@H@Z@4JA
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _skin$[ebp]
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH
$L82271:

; 1720 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyConvex@@YAXPAUConvexStruct@@H@Z ENDP		; DestroyConvex
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DestroySpheres@@YAXPAUSphereStruct@@@Z@4JA ; `DestroySpheres'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??DestroySpheres@@YAXPAUSphereStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DestroySpheres@@YAXPAUSphereStruct@@@Z@4JA DD 06bbH ; `DestroySpheres'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?DestroySpheres@@YAXPAUSphereStruct@@@Z
_TEXT	SEGMENT
_spheres$ = 8						; size = 4
?DestroySpheres@@YAXPAUSphereStruct@@@Z PROC NEAR	; DestroySpheres, COMDAT

; 1723 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1724 : 	free(spheres);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??DestroySpheres@@YAXPAUSphereStruct@@@Z@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _spheres$[ebp]
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 1725 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroySpheres@@YAXPAUSphereStruct@@@Z ENDP		; DestroySpheres
_TEXT	ENDS
PUBLIC	?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z	; CreateCopyCollSkin
PUBLIC	?__LINE__Var@?1??CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z@4JA ; `CreateCopyCollSkin'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z@4JA DD 06c7H ; `CreateCopyCollSkin'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z
_TEXT	SEGMENT
_ii$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_collSkin$ = 8						; size = 4
?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z PROC NEAR ; CreateCopyCollSkin, COMDAT

; 1735 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1736 : 	int iSkin, ii;
; 1737 : 
; 1738 : 	// Allocate space for convex hulls
; 1739 : 	if (collSkin->NConvex > 0) {

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	test	ecx, ecx
	jle	SHORT $L82288

; 1740 : 		collSkin->WorldConvex = CreateConvex(collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	cx, WORD PTR [eax+12]
	push	ecx
	call	?CreateConvex@@YAPAUConvexStruct@@F@Z	; CreateConvex
	add	esp, 4
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1741 : 		if (collSkin->WorldConvex == NULL) {

	mov	eax, DWORD PTR _collSkin$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L82289

; 1742 : 			return FALSE;

	xor	al, al
	jmp	$L82285
$L82289:

; 1743 : 		}
; 1744 : 		collSkin->OldWorldConvex = CreateConvex(collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	cx, WORD PTR [eax+12]
	push	ecx
	call	?CreateConvex@@YAPAUConvexStruct@@F@Z	; CreateConvex
	add	esp, 4
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1745 : 		if (collSkin->OldWorldConvex == NULL) {

	mov	eax, DWORD PTR _collSkin$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L82288

; 1746 : 			DestroyConvex(collSkin->WorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1747 : 			return FALSE;

	xor	al, al
	jmp	$L82285
$L82288:

; 1748 : 		}
; 1749 : 	}
; 1750 : 
; 1751 : 	// Allocate space for the collision spheres
; 1752 : 	if (collSkin->NSpheres > 0) {

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+28]
	test	ecx, ecx
	jle	$L82291

; 1753 : 		collSkin->WorldSphere = (SPHERE *)malloc(sizeof(SPHERE) * collSkin->NSpheres);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z@4JA
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	movsx	edx, WORD PTR [ecx+28]
	shl	edx, 4
	push	edx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1754 : 		if (collSkin->WorldSphere == NULL) {

	mov	eax, DWORD PTR _collSkin$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $L82295

; 1755 : 			DestroyConvex(collSkin->OldWorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1756 : 			DestroyConvex(collSkin->WorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1757 : 			return FALSE;

	xor	al, al
	jmp	$L82285
$L82295:

; 1758 : 		}
; 1759 : 		collSkin->OldWorldSphere = (SPHERE *)malloc(sizeof(SPHERE) * collSkin->NSpheres);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z@4JA
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	movsx	edx, WORD PTR [ecx+28]
	shl	edx, 4
	push	edx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1760 : 		if (collSkin->OldWorldSphere == NULL) {

	mov	eax, DWORD PTR _collSkin$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $L82291

; 1761 : 			DestroyConvex(collSkin->OldWorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1762 : 			DestroyConvex(collSkin->WorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1763 : 			DestroySpheres(collSkin->WorldSphere);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 1764 : 			return FALSE;

	xor	al, al
	jmp	$L82285
$L82291:

; 1765 : 		}
; 1766 : 	}
; 1767 : 
; 1768 : 	// Allocate space for all points, edges and planes for each hull, and copy info across
; 1769 : 	for (iSkin = 0; iSkin < collSkin->NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82299
$L82300:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82299:
	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L82301

; 1770 : 
; 1771 : 		// Create space for all data
; 1772 : 		if (!SetupConvex(&collSkin->WorldConvex[iSkin], collSkin->Convex[iSkin].NPts, 0, collSkin->Convex[iSkin].NEdges, collSkin->Convex[iSkin].NFaces)) {

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ax, WORD PTR [edx+eax+4]
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cx, WORD PTR [eax+ecx+2]
	push	ecx
	push	0
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dx, WORD PTR [ecx+edx]
	push	edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	add	eax, DWORD PTR [ecx+4]
	push	eax
	call	?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z ; SetupConvex
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82302

; 1773 : 			DestroyConvex(collSkin->OldWorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1774 : 			DestroyConvex(collSkin->WorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1775 : 			DestroySpheres(collSkin->WorldSphere);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 1776 : 			DestroySpheres(collSkin->OldWorldSphere);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 1777 : 			return FALSE;

	xor	al, al
	jmp	$L82285
$L82302:

; 1778 : 		}
; 1779 : 		collSkin->WorldConvex[iSkin].NPts = collSkin->Convex[iSkin].NPts;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1780 : 		collSkin->WorldConvex[iSkin].NEdges = collSkin->Convex[iSkin].NEdges;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	dx, WORD PTR [edx+eax+2]
	mov	WORD PTR [esi+ecx+2], dx

; 1781 : 		collSkin->WorldConvex[iSkin].NFaces = collSkin->Convex[iSkin].NFaces;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	dx, WORD PTR [edx+eax+4]
	mov	WORD PTR [esi+ecx+4], dx

; 1782 : 
; 1783 : 		if (!SetupConvex(&collSkin->OldWorldConvex[iSkin], collSkin->Convex[iSkin].NPts, 0, collSkin->Convex[iSkin].NEdges, collSkin->Convex[iSkin].NFaces)) {

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ax, WORD PTR [edx+eax+4]
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cx, WORD PTR [eax+ecx+2]
	push	ecx
	push	0
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dx, WORD PTR [ecx+edx]
	push	edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	call	?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z ; SetupConvex
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82303

; 1784 : 			DestroyConvex(collSkin->OldWorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1785 : 			DestroyConvex(collSkin->WorldConvex, collSkin->NConvex);

	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1786 : 			DestroySpheres(collSkin->OldWorldSphere);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 1787 : 			DestroySpheres(collSkin->WorldSphere);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?DestroySpheres@@YAXPAUSphereStruct@@@Z	; DestroySpheres
	add	esp, 4

; 1788 : 			return FALSE;

	xor	al, al
	jmp	$L82285
$L82303:

; 1789 : 		}
; 1790 : 		collSkin->OldWorldConvex[iSkin].NPts = collSkin->Convex[iSkin].NPts;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1791 : 		collSkin->OldWorldConvex[iSkin].NEdges = collSkin->Convex[iSkin].NEdges;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	dx, WORD PTR [edx+eax+2]
	mov	WORD PTR [esi+ecx+2], dx

; 1792 : 		collSkin->OldWorldConvex[iSkin].NFaces = collSkin->Convex[iSkin].NFaces;

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	dx, WORD PTR [edx+eax+4]
	mov	WORD PTR [esi+ecx+4], dx

; 1793 : 
; 1794 : 		// Bounding box and offset
; 1795 : 		CopyBBox(&collSkin->Convex[iSkin].BBox, &collSkin->WorldConvex[iSkin].BBox);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [esi+ecx+8], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax+12]
	mov	DWORD PTR [esi+ecx+12], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax+16]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax+20]
	mov	DWORD PTR [esi+ecx+20], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax+24]
	mov	DWORD PTR [esi+ecx+24], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+eax+28]
	mov	DWORD PTR [esi+ecx+28], edx

; 1796 : 		//CopyVec(&collSkin->Convex[iSkin].Offset, &collSkin->WorldConvex[iSkin].Offset);
; 1797 : 		CopyBBox(&collSkin->Convex[iSkin].BBox, &collSkin->OldWorldConvex[iSkin].BBox);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [esi+ecx+8], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [edx+eax+12]
	mov	DWORD PTR [esi+ecx+12], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [edx+eax+16]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [edx+eax+20]
	mov	DWORD PTR [esi+ecx+20], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [edx+eax+24]
	mov	DWORD PTR [esi+ecx+24], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [edx+eax+28]
	mov	DWORD PTR [esi+ecx+28], edx

; 1798 : 		//CopyVec(&collSkin->Convex[iSkin].Offset, &collSkin->OldWorldConvex[iSkin].Offset);
; 1799 : 
; 1800 : 		// Vertices
; 1801 : 		for (ii = 0; ii < collSkin->Convex[iSkin].NPts; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82304
$L82305:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82304:
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+eax]
	cmp	DWORD PTR _ii$[ebp], eax
	jge	$L82306

; 1802 : 			CopyVec(&collSkin->Convex[iSkin].Pts[ii], &collSkin->WorldConvex[iSkin].Pts[ii]);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [edx+eax+32]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _ii$[ebp]
	imul	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax+32]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [edi+eax], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [edx+eax+32]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _ii$[ebp]
	imul	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax+32]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR [eax+edi+4], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [edx+eax+32]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _ii$[ebp]
	imul	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax+32]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR [eax+edi+8], ecx

; 1803 : 			CopyVec(&collSkin->Convex[iSkin].Pts[ii], &collSkin->OldWorldConvex[iSkin].Pts[ii]);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [edx+eax+32]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _ii$[ebp]
	imul	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax+32]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [edi+eax], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [edx+eax+32]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _ii$[ebp]
	imul	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax+32]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR [eax+edi+4], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [edx+eax+32]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _ii$[ebp]
	imul	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax+32]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR [eax+edi+8], ecx

; 1804 : 		}

	jmp	$L82305
$L82306:

; 1805 : 
; 1806 : 		// Edges (can be removed as never changes - just requires initialisation)
; 1807 : 		for (ii = 0; ii < collSkin->Convex[iSkin].NEdges; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82307
$L82308:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82307:
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+eax+2]
	cmp	DWORD PTR _ii$[ebp], eax
	jge	$L82309

; 1808 : 			collSkin->WorldConvex[iSkin].Edges[ii].Vtx[0] = collSkin->Convex[iSkin].Edges[ii].Vtx[0];

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _ii$[ebp]
	mov	ax, WORD PTR [eax+esi*4]
	mov	WORD PTR [ecx+edx*4], ax

; 1809 : 			collSkin->WorldConvex[iSkin].Edges[ii].Vtx[1] = collSkin->Convex[iSkin].Edges[ii].Vtx[1];

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _ii$[ebp]
	mov	ax, WORD PTR [eax+esi*4+2]
	mov	WORD PTR [ecx+edx*4+2], ax

; 1810 : 			collSkin->OldWorldConvex[iSkin].Edges[ii].Vtx[0] = collSkin->Convex[iSkin].Edges[ii].Vtx[0];

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _ii$[ebp]
	mov	ax, WORD PTR [eax+esi*4]
	mov	WORD PTR [ecx+edx*4], ax

; 1811 : 			collSkin->OldWorldConvex[iSkin].Edges[ii].Vtx[1] = collSkin->Convex[iSkin].Edges[ii].Vtx[1];

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _ii$[ebp]
	mov	ax, WORD PTR [eax+esi*4+2]
	mov	WORD PTR [ecx+edx*4+2], ax

; 1812 : 		}

	jmp	$L82308
$L82309:

; 1813 : 
; 1814 : 		// Planes
; 1815 : 		for (ii = 0; ii < collSkin->Convex[iSkin].NFaces; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82310
$L82311:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82310:
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+eax+4]
	cmp	DWORD PTR _ii$[ebp], eax
	jge	$L82312

; 1816 : 			CopyPlane(&collSkin->Convex[iSkin].Faces[ii], &collSkin->WorldConvex[iSkin].Faces[ii]);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [edi+eax], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR [eax+edi+4], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR [eax+edi+8], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR [eax+edi+12], ecx

; 1817 : 			CopyPlane(&collSkin->Convex[iSkin].Faces[ii], &collSkin->OldWorldConvex[iSkin].Faces[ii]);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [edi+eax], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR [eax+edi+4], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR [eax+edi+8], ecx
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR [edx+eax+40]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _ii$[ebp]
	shl	edi, 4
	mov	eax, DWORD PTR [esi+eax+40]
	mov	ecx, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR [eax+edi+12], ecx

; 1818 : 		}

	jmp	$L82311
$L82312:

; 1819 : 	}

	jmp	$L82300
$L82301:

; 1820 : 
; 1821 : 	// Copy all the spheres
; 1822 : 	for (iSkin = 0; iSkin < collSkin->NSpheres; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82313
$L82314:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82313:
	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+28]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L82315

; 1823 : 
; 1824 : 		CopyVec(&collSkin->Sphere[iSkin].Pos, &collSkin->WorldSphere[iSkin].Pos);

	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+esi], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+4], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [esi+ecx+8], edx

; 1825 : 		collSkin->WorldSphere[iSkin].Radius = collSkin->Sphere[iSkin].Radius;

	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+eax+12]
	mov	DWORD PTR [esi+ecx+12], edx

; 1826 : 		CopyVec(&collSkin->Sphere[iSkin].Pos, &collSkin->OldWorldSphere[iSkin].Pos);

	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+esi], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+4], edx
	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [esi+ecx+8], edx

; 1827 : 		collSkin->OldWorldSphere[iSkin].Radius = collSkin->Sphere[iSkin].Radius;

	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iSkin$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax+12]
	mov	DWORD PTR [esi+ecx+12], edx

; 1828 : 
; 1829 : 	}

	jmp	$L82314
$L82315:

; 1830 : 
; 1831 : 	return TRUE;

	mov	al, 1
$L82285:

; 1832 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateCopyCollSkin@@YA_NPAUCollSkinStruct@@@Z ENDP	; CreateCopyCollSkin
_TEXT	ENDS
PUBLIC	?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ; BuildWorldSkin
PUBLIC	?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransBBox
EXTRN	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z:NEAR ; VecMulMat
EXTRN	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z:NEAR ; RotTransPlane
; Function compile flags: /Odt /ZI
;	COMDAT ?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z
_TEXT	SEGMENT
_thisWorldSphere$ = -36					; size = 4
_thisBodySphere$ = -32					; size = 4
_thisWorldSkin$ = -28					; size = 4
_thisBodySkin$ = -24					; size = 4
_tmpVec$ = -20						; size = 12
_ii$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_bodySkin$ = 8						; size = 4
_pos$ = 12						; size = 4
_mat$ = 16						; size = 4
?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z PROC NEAR ; BuildWorldSkin, COMDAT

; 1843 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 1844 : 	int			iSkin, ii;
; 1845 : 	VEC		tmpVec;
; 1846 : 	CONVEX		*thisBodySkin, *thisWorldSkin;
; 1847 : 	SPHERE		*thisBodySphere, *thisWorldSphere;
; 1848 : 
; 1849 : 	// Transform the convex hulls 
; 1850 : 	for (iSkin = 0; iSkin < bodySkin->NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82328
$L82329:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82328:
	mov	eax, DWORD PTR _bodySkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L82330

; 1851 : 		thisBodySkin = &bodySkin->Convex[iSkin];

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _bodySkin$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _thisBodySkin$[ebp], eax

; 1852 : 		thisWorldSkin = &bodySkin->WorldConvex[iSkin];

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _bodySkin$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _thisWorldSkin$[ebp], eax

; 1853 : 
; 1854 : 		// Transfrom the offset
; 1855 : 		//VecMulMat(&thisBodySkin->Offset, mat, &thisWorldSkin->Offset);
; 1856 : 
; 1857 : 		// Vertices
; 1858 : 		for (ii = 0; ii < thisBodySkin->NPts; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82331
$L82332:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82331:
	mov	eax, DWORD PTR _thisBodySkin$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	DWORD PTR _ii$[ebp], ecx
	jge	SHORT $L82333

; 1859 : 			VecMulMat(&thisBodySkin->Pts[ii], mat, &tmpVec);

	lea	eax, DWORD PTR _tmpVec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ii$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _thisBodySkin$[ebp]
	add	edx, DWORD PTR [eax+32]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1860 : 			VecPlusVec(&tmpVec, pos, &thisWorldSkin->Pts[ii]);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _thisWorldSkin$[ebp]
	mov	eax, DWORD PTR [edx+32]
	fstp	DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+4]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _thisWorldSkin$[ebp]
	mov	eax, DWORD PTR [edx+32]
	fstp	DWORD PTR [eax+ecx+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _tmpVec$[ebp+8]
	fadd	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _ii$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _thisWorldSkin$[ebp]
	mov	eax, DWORD PTR [edx+32]
	fstp	DWORD PTR [eax+ecx+8]

; 1861 : 		}

	jmp	SHORT $L82332
$L82333:

; 1862 : 
; 1863 : 		// Planes
; 1864 : 		for (ii = 0; ii < thisBodySkin->NFaces; ii++) {

	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $L82334
$L82335:
	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$L82334:
	mov	eax, DWORD PTR _thisBodySkin$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	DWORD PTR _ii$[ebp], ecx
	jge	SHORT $L82336

; 1865 : 			RotTransPlane(&thisBodySkin->Faces[ii], mat, pos, &thisWorldSkin->Faces[ii]);

	mov	eax, DWORD PTR _ii$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _thisWorldSkin$[ebp]
	add	eax, DWORD PTR [ecx+40]
	push	eax
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ii$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _thisBodySkin$[ebp]
	add	ecx, DWORD PTR [edx+40]
	push	ecx
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H

; 1866 : 		}

	jmp	SHORT $L82335
$L82336:

; 1867 : 
; 1868 : 		// Bounding box
; 1869 : 		RotTransBBox(&thisBodySkin->BBox, mat, pos, &thisWorldSkin->BBox);

	mov	eax, DWORD PTR _thisWorldSkin$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	mov	eax, DWORD PTR _thisBodySkin$[ebp]
	add	eax, 8
	push	eax
	call	?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransBBox
	add	esp, 16					; 00000010H

; 1870 : 	}

	jmp	$L82329
$L82330:

; 1871 : 
; 1872 : 	// Transform the spheres
; 1873 : 	for (iSkin = 0; iSkin < bodySkin->NSpheres; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82337
$L82338:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82337:
	mov	eax, DWORD PTR _bodySkin$[ebp]
	movsx	ecx, WORD PTR [eax+28]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	SHORT $L82339

; 1874 : 		thisBodySphere = &bodySkin->Sphere[iSkin];

	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _bodySkin$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _thisBodySphere$[ebp], eax

; 1875 : 		thisWorldSphere = &bodySkin->WorldSphere[iSkin];

	mov	eax, DWORD PTR _iSkin$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _bodySkin$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _thisWorldSphere$[ebp], eax

; 1876 : 
; 1877 : 		// Transfrom the position (radius should already be there)
; 1878 : 		VecMulMat(&thisBodySphere->Pos, mat, &thisWorldSphere->Pos);

	mov	eax, DWORD PTR _thisWorldSphere$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _thisBodySphere$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 1879 : 		VecPlusEqVec(&thisWorldSphere->Pos, pos);

	mov	eax, DWORD PTR _thisWorldSphere$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _thisWorldSphere$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _thisWorldSphere$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _thisWorldSphere$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _thisWorldSphere$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _thisWorldSphere$[ebp]
	fstp	DWORD PTR [edx+8]

; 1880 : 	}

	jmp	SHORT $L82338
$L82339:

; 1881 : 
; 1882 : 	// Transform the overall bounding box
; 1883 : 	RotTransBBox(&bodySkin->TightBBox, mat, pos, &bodySkin->BBox);

	mov	eax, DWORD PTR _bodySkin$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mat$[ebp]
	push	edx
	mov	eax, DWORD PTR _bodySkin$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransBBox
	add	esp, 16					; 00000010H

; 1884 : 
; 1885 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildWorldSkin@@YAXPAUCollSkinStruct@@PAUVectorStruct@@PATMatrixUnion@@@Z ENDP ; BuildWorldSkin
_TEXT	ENDS
PUBLIC	?LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z ; LoadConvex
PUBLIC	?__LINE__Var@?1??LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z@4JA ; `LoadConvex'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z@4JA DD 076aH ; `LoadConvex'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z
_TEXT	SEGMENT
_collSkin$ = -48					; size = 4
_collHdr$ = -44						; size = 6
_fileHdr$ = -36						; size = 2
_offset$ = -32						; size = 12
_ptNum$ = -20						; size = 4
_nExtraPts$ = -16					; size = 4
_iPt$ = -12						; size = 4
_iEdge$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_fp$ = 8						; size = 4
_nSkins$ = 12						; size = 4
_extraPtsPerEdge$ = 16					; size = 4
?LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z PROC NEAR ; LoadConvex, COMDAT

; 1898 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 1899 : 	int iSkin, iEdge, iPt, nExtraPts, ptNum;
; 1900 : 	VEC offset;
; 1901 : 
; 1902 : 	COLLSKIN_FILEHDR	fileHdr;
; 1903 : 	COLLSKIN_COLLHDR	collHdr;
; 1904 : 	CONVEX	*collSkin;
; 1905 : 
; 1906 : 	*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1907 : 
; 1908 : 	if (fp == NULL) {

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L82354

; 1909 : 		*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1910 : 		return NULL;

	xor	eax, eax
	jmp	$L82344
$L82354:

; 1911 : 	}
; 1912 : 
; 1913 : 	// Read in how many convex hulls are in this object and create it
; 1914 : 	if (fread(&fileHdr, sizeof(COLLSKIN_FILEHDR), 1, fp) != 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _fileHdr$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $L82356

; 1915 : 		*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1916 : 		return NULL;

	xor	eax, eax
	jmp	$L82344
$L82356:

; 1917 : 	}
; 1918 : 	if ((collSkin = CreateConvex(fileHdr.NSkins)) == NULL) {

	mov	ax, WORD PTR _fileHdr$[ebp]
	push	eax
	call	?CreateConvex@@YAPAUConvexStruct@@F@Z	; CreateConvex
	add	esp, 4
	mov	DWORD PTR _collSkin$[ebp], eax
	cmp	DWORD PTR _collSkin$[ebp], 0
	jne	SHORT $L82357

; 1919 : 		*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1920 : 		return NULL;

	xor	eax, eax
	jmp	$L82344
$L82357:

; 1921 : 	}
; 1922 : 
; 1923 : 	// Get the individual convex hulls
; 1924 : 	for (iSkin = 0; iSkin < fileHdr.NSkins; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82358
$L82359:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82358:
	movsx	eax, WORD PTR _fileHdr$[ebp]
	cmp	DWORD PTR _iSkin$[ebp], eax
	jge	$L82360

; 1925 : 		
; 1926 : 		// Read size and allocate space
; 1927 : 		if (fread(&collHdr, sizeof(COLLSKIN_COLLHDR), 1, fp) != 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	6
	lea	ecx, DWORD PTR _collHdr$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $L82362

; 1928 : 			DestroyConvex(collSkin, fileHdr.NSkins);

	movsx	eax, WORD PTR _fileHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1929 : 			*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1930 : 			return NULL;

	xor	eax, eax
	jmp	$L82344
$L82362:

; 1931 : 		}
; 1932 : 		
; 1933 : 		// Calculate the number of points required 
; 1934 : 		// (may be more than in the file if extra points are inserted along each edge)
; 1935 : 		nExtraPts = collHdr.NEdges * extraPtsPerEdge;

	movsx	eax, WORD PTR _collHdr$[ebp+2]
	imul	eax, DWORD PTR _extraPtsPerEdge$[ebp]
	mov	DWORD PTR _nExtraPts$[ebp], eax

; 1936 : 
; 1937 : 		// Allocate space for the data
; 1938 : 		if (!SetupConvex(&collSkin[iSkin], collHdr.NVertices, nExtraPts, collHdr.NEdges, collHdr.NFaces)) {

	mov	ax, WORD PTR _collHdr$[ebp+4]
	push	eax
	mov	cx, WORD PTR _collHdr$[ebp+2]
	push	ecx
	mov	dx, WORD PTR _nExtraPts$[ebp]
	push	edx
	mov	ax, WORD PTR _collHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	add	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?SetupConvex@@YA_NPAUConvexStruct@@FFFF@Z ; SetupConvex
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82363

; 1939 : 			DestroyConvex(collSkin, fileHdr.NSkins);

	movsx	eax, WORD PTR _fileHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1940 : 			*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1941 : 			return NULL;

	xor	eax, eax
	jmp	$L82344
$L82363:

; 1942 : 		}
; 1943 : 
; 1944 : 		// Bounding Box and offset
; 1945 : 		if (fread(&collSkin[iSkin].BBox, sizeof(BBOX), 1, fp) != 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	24					; 00000018H
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $L82365

; 1946 : 			DestroyConvex(collSkin, fileHdr.NSkins);

	movsx	eax, WORD PTR _fileHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1947 : 			*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1948 : 			return NULL;

	xor	eax, eax
	jmp	$L82344
$L82365:

; 1949 : 		}
; 1950 : 		//if (fread(&collSkin[iSkin].Offset, sizeof(VEC), 1, fp) != 1) {
; 1951 : 		if (fread(&offset, sizeof(VEC), 1, fp) != 1) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $L82367

; 1952 : 			DestroyConvex(collSkin, fileHdr.NSkins);

	movsx	eax, WORD PTR _fileHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1953 : 			*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1954 : 			return NULL;

	xor	eax, eax
	jmp	$L82344
$L82367:

; 1955 : 		}
; 1956 : 
; 1957 : 		// Read in the vertices
; 1958 : 		if (fread(collSkin[iSkin].Pts, sizeof(VERTEX), collHdr.NVertices, fp) != (size_t)collHdr.NVertices) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	movsx	ecx, WORD PTR _collHdr$[ebp]
	push	ecx
	push	12					; 0000000cH
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+edx+32]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	movsx	edx, WORD PTR _collHdr$[ebp]
	cmp	eax, edx
	je	SHORT $L82370

; 1959 : 			DestroyConvex(collSkin, fileHdr.NSkins);

	movsx	eax, WORD PTR _fileHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1960 : 			*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1961 : 			return NULL;

	xor	eax, eax
	jmp	$L82344
$L82370:

; 1962 : 		}
; 1963 : 
; 1964 : 		// Shrink the skin about the centre
; 1965 : 		/*REAL	dist;
; 1966 : 		for (iPt = 0; iPt < collHdr.NVertices; iPt++) {
; 1967 : 			dist = VecLen(&collSkin[iSkin].Pts[iPt]);
; 1968 : 			if (dist > SMALL_REAL) {
; 1969 : 				VecMulScalar(&collSkin[iSkin].Pts[iPt], (dist - COL_PointRadius) / dist);
; 1970 : 			}
; 1971 : 		}*/
; 1972 : 
; 1973 : 
; 1974 : 		// Read in the edges
; 1975 : 		if (fread(collSkin[iSkin].Edges, sizeof(EDGE), collSkin[iSkin].NEdges, fp) != (size_t)collSkin[iSkin].NEdges) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	movsx	eax, WORD PTR [edx+ecx+2]
	push	eax
	push	4
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+ecx+36]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [edx+ecx+2]
	cmp	eax, ecx
	je	SHORT $L82373

; 1976 : 			DestroyConvex(collSkin, fileHdr.NSkins);

	movsx	eax, WORD PTR _fileHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1977 : 			*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1978 : 			return NULL;

	xor	eax, eax
	jmp	$L82344
$L82373:

; 1979 : 		}
; 1980 : 
; 1981 : 		// Read in the faces
; 1982 : 		if (fread(collSkin[iSkin].Faces, sizeof(PLANE), collSkin[iSkin].NFaces, fp) != (size_t)collSkin[iSkin].NFaces) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	movsx	eax, WORD PTR [edx+ecx+4]
	push	eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [edx+ecx+4]
	cmp	eax, ecx
	je	SHORT $L82376

; 1983 : 			DestroyConvex(collSkin, fileHdr.NSkins);

	movsx	eax, WORD PTR _fileHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _collSkin$[ebp]
	push	ecx
	call	?DestroyConvex@@YAXPAUConvexStruct@@H@Z	; DestroyConvex
	add	esp, 8

; 1984 : 			*nSkins = 0;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	WORD PTR [eax], 0

; 1985 : 			return NULL;

	xor	eax, eax
	jmp	$L82344
$L82376:

; 1986 : 		}
; 1987 : 
; 1988 : 		// Add the extra points
; 1989 : 		ptNum = collHdr.NVertices;

	movsx	eax, WORD PTR _collHdr$[ebp]
	mov	DWORD PTR _ptNum$[ebp], eax

; 1990 : 		for (iEdge = 0; iEdge < collHdr.NEdges; iEdge++) {

	mov	DWORD PTR _iEdge$[ebp], 0
	jmp	SHORT $L82377
$L82378:
	mov	eax, DWORD PTR _iEdge$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEdge$[ebp], eax
$L82377:
	movsx	eax, WORD PTR _collHdr$[ebp+2]
	cmp	DWORD PTR _iEdge$[ebp], eax
	jge	$L82379

; 1991 : 			for (iPt = 0; iPt < extraPtsPerEdge; iPt++) {

	mov	DWORD PTR _iPt$[ebp], 0
	jmp	SHORT $L82380
$L82381:
	mov	eax, DWORD PTR _iPt$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPt$[ebp], eax
$L82380:
	mov	eax, DWORD PTR _iPt$[ebp]
	cmp	eax, DWORD PTR _extraPtsPerEdge$[ebp]
	jge	$L82382

; 1992 : 				VecPlusVec(
; 1993 : 					&collSkin[iSkin].Pts[collSkin[iSkin].Edges[iEdge].Vtx[0]], 
; 1994 : 					&collSkin[iSkin].Pts[collSkin[iSkin].Edges[iEdge].Vtx[1]], 
; 1995 : 					&collSkin[iSkin].Pts[ptNum]);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	edx, DWORD PTR _iEdge$[ebp]
	movsx	ecx, WORD PTR [ecx+edx*4]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	esi, DWORD PTR _iSkin$[ebp]
	imul	esi, 44					; 0000002cH
	mov	edi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [edi+esi+36]
	mov	edi, DWORD PTR _iEdge$[ebp]
	movsx	esi, WORD PTR [esi+edi*4+2]
	imul	esi, 12					; 0000000cH
	mov	edi, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [edi+edx+32]
	fld	DWORD PTR [eax+ecx]
	fadd	DWORD PTR [edx+esi]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _ptNum$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	fstp	DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	edx, DWORD PTR _iEdge$[ebp]
	movsx	ecx, WORD PTR [ecx+edx*4]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	esi, DWORD PTR _iSkin$[ebp]
	imul	esi, 44					; 0000002cH
	mov	edi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [edi+esi+36]
	mov	edi, DWORD PTR _iEdge$[ebp]
	movsx	esi, WORD PTR [esi+edi*4+2]
	imul	esi, 12					; 0000000cH
	mov	edi, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [edi+edx+32]
	fld	DWORD PTR [eax+ecx+4]
	fadd	DWORD PTR [edx+esi+4]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _ptNum$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	fstp	DWORD PTR [eax+ecx+4]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	edx, DWORD PTR _iEdge$[ebp]
	movsx	ecx, WORD PTR [ecx+edx*4]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	esi, DWORD PTR _iSkin$[ebp]
	imul	esi, 44					; 0000002cH
	mov	edi, DWORD PTR _collSkin$[ebp]
	mov	esi, DWORD PTR [edi+esi+36]
	mov	edi, DWORD PTR _iEdge$[ebp]
	movsx	esi, WORD PTR [esi+edi*4+2]
	imul	esi, 12					; 0000000cH
	mov	edi, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [edi+edx+32]
	fld	DWORD PTR [eax+ecx+8]
	fadd	DWORD PTR [edx+esi+8]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _ptNum$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	fstp	DWORD PTR [eax+ecx+8]

; 1996 : 				VecMulScalar(&collSkin[iSkin].Pts[ptNum], HALF);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _ptNum$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	fld	DWORD PTR [eax+ecx]
	fmul	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _ptNum$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+32]
	fstp	DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _ptNum$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	fld	DWORD PTR [eax+ecx+4]
	fmul	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _ptNum$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+32]
	fstp	DWORD PTR [ecx+edx+4]
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _ptNum$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	fld	DWORD PTR [eax+ecx+8]
	fmul	DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _ptNum$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+32]
	fstp	DWORD PTR [ecx+edx+8]

; 1997 : 				ptNum++;

	mov	eax, DWORD PTR _ptNum$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptNum$[ebp], eax

; 1998 : 			}

	jmp	$L82381
$L82382:

; 1999 : 		}

	jmp	$L82378
$L82379:

; 2000 : 		Assert(ptNum == collSkin[iSkin].NPts);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z@4JA
	add	eax, 102				; 00000066H
	push	eax
	mov	ecx, DWORD PTR _iSkin$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _collSkin$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	cmp	DWORD PTR _ptNum$[ebp], eax
	sete	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 2001 : 
; 2002 : 	}

	jmp	$L82359
$L82360:

; 2003 : 
; 2004 : 	*nSkins = fileHdr.NSkins;

	mov	eax, DWORD PTR _nSkins$[ebp]
	mov	cx, WORD PTR _fileHdr$[ebp]
	mov	WORD PTR [eax], cx

; 2005 : 	return collSkin;

	mov	eax, DWORD PTR _collSkin$[ebp]
$L82344:

; 2006 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadConvex@@YAPAUConvexStruct@@PAU_iobuf@@PAFH@Z ENDP	; LoadConvex
_TEXT	ENDS
PUBLIC	?LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z ; LoadSpheres
PUBLIC	?__LINE__Var@?1??LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z@4JA ; `LoadSpheres'::`2'::__LINE__Var
;	COMDAT ?__LINE__Var@?1??LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z@4JA DD 07d9H ; `LoadSpheres'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z
_TEXT	SEGMENT
_nRead$ = -12						; size = 4
_spheres$ = -8						; size = 4
_iSphere$ = -4						; size = 2
_fp$ = 8						; size = 4
_nSpheres$ = 12						; size = 4
?LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z PROC NEAR ; LoadSpheres, COMDAT

; 2009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2010 : 	INDEX	iSphere;
; 2011 : 	SPHERE	*spheres;
; 2012 : 	size_t	nRead;
; 2013 : 
; 2014 : 	Assert(fp != NULL);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z@4JA
	add	eax, 5
	push	eax
	cmp	DWORD PTR _fp$[ebp], 0
	setne	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 2015 : 
; 2016 : 	// Read in the number of spheres
; 2017 : 	nRead = fread(nSpheres, sizeof(INDEX), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _nSpheres$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 2018 : 	if (nRead < 1) {

	cmp	DWORD PTR _nRead$[ebp], 1
	jae	SHORT $L82393

; 2019 : 		*nSpheres = 0;

	mov	eax, DWORD PTR _nSpheres$[ebp]
	mov	WORD PTR [eax], 0

; 2020 : 		return NULL;

	xor	eax, eax
	jmp	$L82387
$L82393:

; 2021 : 	}
; 2022 : 
; 2023 : 	// Allocate space for the spheres
; 2024 : 	spheres = (SPHERE *)malloc(sizeof(SPHERE) * *nSpheres);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z@4JA
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _nSpheres$[ebp]
	movsx	edx, WORD PTR [ecx]
	shl	edx, 4
	push	edx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _spheres$[ebp], eax

; 2025 : 	if (spheres == NULL) {

	cmp	DWORD PTR _spheres$[ebp], 0
	jne	SHORT $L82396

; 2026 : 		*nSpheres = 0;

	mov	eax, DWORD PTR _nSpheres$[ebp]
	mov	WORD PTR [eax], 0

; 2027 : 		return NULL;

	xor	eax, eax
	jmp	$L82387
$L82396:

; 2028 : 	}
; 2029 : 
; 2030 : //	*nSpheres = 0;
; 2031 : //	return spheres;
; 2032 : 
; 2033 : 	// Read in the spheres
; 2034 : 	for (iSphere = 0; iSphere < *nSpheres; iSphere++) {

	mov	WORD PTR _iSphere$[ebp], 0
	jmp	SHORT $L82397
$L82398:
	mov	ax, WORD PTR _iSphere$[ebp]
	add	ax, 1
	mov	WORD PTR _iSphere$[ebp], ax
$L82397:
	movsx	eax, WORD PTR _iSphere$[ebp]
	mov	ecx, DWORD PTR _nSpheres$[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	eax, edx
	jge	SHORT $L82399

; 2035 : 		nRead = fread(&spheres[iSphere], sizeof(SPHERE), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	16					; 00000010H
	movsx	ecx, WORD PTR _iSphere$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _spheres$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nRead$[ebp], eax

; 2036 : 		if (nRead < 1) {

	cmp	DWORD PTR _nRead$[ebp], 1
	jae	SHORT $L82401

; 2037 : 			*nSpheres = iSphere;

	mov	eax, DWORD PTR _nSpheres$[ebp]
	mov	cx, WORD PTR _iSphere$[ebp]
	mov	WORD PTR [eax], cx

; 2038 : 			return spheres;

	mov	eax, DWORD PTR _spheres$[ebp]
	jmp	SHORT $L82387
$L82401:

; 2039 : 		}
; 2040 : 	}

	jmp	SHORT $L82398
$L82399:

; 2041 : 
; 2042 : 	Assert(iSphere == *nSpheres);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z@4JA
	add	eax, 33					; 00000021H
	push	eax
	movsx	ecx, WORD PTR _iSphere$[ebp]
	mov	edx, DWORD PTR _nSpheres$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	ecx, eax
	sete	cl
	push	ecx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 2043 : 
; 2044 : 	return spheres;

	mov	eax, DWORD PTR _spheres$[ebp]
$L82387:

; 2045 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadSpheres@@YAPAUSphereStruct@@PAU_iobuf@@PAF@Z ENDP	; LoadSpheres
_TEXT	ENDS
PUBLIC	?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z ; PointInConvex
; Function compile flags: /Odt /ZI
;	COMDAT ?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z
_TEXT	SEGMENT
_depth$ = -8						; size = 4
_iFace$ = -4						; size = 4
_pos$ = 8						; size = 4
_skin$ = 12						; size = 4
_plane$ = 16						; size = 4
_minDepth$ = 20						; size = 4
?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z PROC NEAR ; PointInConvex, COMDAT

; 2339 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2340 : 	int		iFace;
; 2341 : 
; 2342 : 	REAL	depth;
; 2343 : 	
; 2344 : 	*minDepth = -LARGEDIST;

	mov	eax, DWORD PTR _minDepth$[ebp]
	mov	DWORD PTR [eax], -915135488		; c9742400H

; 2345 : 
; 2346 : 	//VecMinusVec(pos, &skin->Offset, &localPos);
; 2347 : 
; 2348 : 	for (iFace = 0; iFace < skin->NFaces; iFace++) {

	mov	DWORD PTR _iFace$[ebp], 0
	jmp	SHORT $L82410
$L82411:
	mov	eax, DWORD PTR _iFace$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFace$[ebp], eax
$L82410:
	mov	eax, DWORD PTR _skin$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	DWORD PTR _iFace$[ebp], ecx
	jge	$L82412

; 2349 : 		depth = VecDotPlane(pos, &skin->Faces[iFace]);

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _iFace$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+edx+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _iFace$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _skin$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+ecx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	fadd	DWORD PTR [edx+eax+12]
	fstp	DWORD PTR _depth$[ebp]

; 2350 : 		if (depth > COLL_EPSILON) return FALSE;

	fld	DWORD PTR _depth$[ebp]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82414
	xor	al, al
	jmp	SHORT $L82407
$L82414:

; 2351 : 		if (depth > *minDepth) {

	mov	eax, DWORD PTR _minDepth$[ebp]
	fld	DWORD PTR _depth$[ebp]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82415

; 2352 : 			*minDepth = depth;

	mov	eax, DWORD PTR _minDepth$[ebp]
	mov	ecx, DWORD PTR _depth$[ebp]
	mov	DWORD PTR [eax], ecx

; 2353 : 			CopyPlane(&skin->Faces[iFace], plane);

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [edx+eax+12]
	mov	DWORD PTR [ecx+12], edx
$L82415:

; 2354 : 		}
; 2355 : 	}

	jmp	$L82411
$L82412:

; 2356 : 
; 2357 : 	return TRUE;

	mov	al, 1
$L82407:

; 2358 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z ENDP ; PointInConvex
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	?LineToConvexColl@@YAPAUPlaneStruct@@PAUVectorStruct@@0PAUConvexStruct@@PAM2@Z ; LineToConvexColl
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LineToConvexColl@@YAPAUPlaneStruct@@PAUVectorStruct@@0PAUConvexStruct@@PAM2@Z
_TEXT	SEGMENT
tv199 = -148						; size = 4
tv197 = -144						; size = 4
_plane$ = -76						; size = 16
_entryPlane$ = -60					; size = 4
_nearPlane$ = -56					; size = 4
_dR$ = -52						; size = 12
_pos$ = -40						; size = 12
_timeDepth$ = -28					; size = 4
_minTime$ = -24						; size = 4
_sDist$ = -20						; size = 4
_minDepth$ = -16					; size = 4
_depth2$ = -12						; size = 4
_depth$ = -8						; size = 4
_iFace$ = -4						; size = 4
_sPos$ = 8						; size = 4
_ePos$ = 12						; size = 4
_skin$ = 16						; size = 4
_penDepth$ = 20						; size = 4
_time$ = 24						; size = 4
?LineToConvexColl@@YAPAUPlaneStruct@@PAUVectorStruct@@0PAUConvexStruct@@PAM2@Z PROC NEAR ; LineToConvexColl, COMDAT

; 2370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 2371 : 	int		iFace;
; 2372 : 	REAL	depth, depth2, minDepth, sDist;
; 2373 : 	REAL	minTime, timeDepth;
; 2374 : 	VEC		pos, dR;
; 2375 : 	PLANE	*nearPlane, *entryPlane, plane;
; 2376 : 
; 2377 : 	VecMinusVec(ePos, sPos, &dR);

	mov	eax, DWORD PTR _ePos$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _ePos$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _ePos$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 2378 : 
; 2379 : 	// See if the end-point is within the hull and remember the nearest plane
; 2380 : 	minDepth = -LARGEDIST;

	mov	DWORD PTR _minDepth$[ebp], -915135488	; c9742400H

; 2381 : 	for (iFace = 0; iFace < skin->NFaces; iFace++) {

	mov	DWORD PTR _iFace$[ebp], 0
	jmp	SHORT $L82435
$L82436:
	mov	eax, DWORD PTR _iFace$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFace$[ebp], eax
$L82435:
	mov	eax, DWORD PTR _skin$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	DWORD PTR _iFace$[ebp], ecx
	jge	$L82437

; 2382 : 		depth = VecDotPlane(ePos, &skin->Faces[iFace]);

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _ePos$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _iFace$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR _ePos$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+edx+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _iFace$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _skin$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _ePos$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+ecx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	fadd	DWORD PTR [edx+eax+12]
	fstp	DWORD PTR _depth$[ebp]

; 2383 : 		if (depth > COLL_EPSILON) return NULL;

	fld	DWORD PTR _depth$[ebp]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82439
	xor	eax, eax
	jmp	$L82422
$L82439:

; 2384 : 		if (depth > minDepth) {

	fld	DWORD PTR _depth$[ebp]
	fcomp	DWORD PTR _minDepth$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82440

; 2385 : 			minDepth = depth;

	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _minDepth$[ebp], eax

; 2386 : 			nearPlane = &skin->Faces[iFace];

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _nearPlane$[ebp], eax
$L82440:

; 2387 : 		}
; 2388 : 	}

	jmp	$L82436
$L82437:

; 2389 : 
; 2390 : 	// Find the point of entry if there is one
; 2391 : 	minTime = ZERO;

	mov	DWORD PTR _minTime$[ebp], 0

; 2392 : 	for (iFace = 0; iFace < skin->NFaces; iFace++) {

	mov	DWORD PTR _iFace$[ebp], 0
	jmp	SHORT $L82441
$L82442:
	mov	eax, DWORD PTR _iFace$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFace$[ebp], eax
$L82441:
	mov	eax, DWORD PTR _skin$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	DWORD PTR _iFace$[ebp], ecx
	jge	$L82443

; 2393 : 		if (LinePlaneIntersect(sPos, ePos, &skin->Faces[iFace], time, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFace$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _skin$[ebp]
	add	edx, DWORD PTR [eax+40]
	push	edx
	mov	ecx, DWORD PTR _ePos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sPos$[ebp]
	push	edx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	SHORT $L82444

; 2394 : 			if (*time > minTime) {

	mov	eax, DWORD PTR _time$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _minTime$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82444

; 2395 : 				VecPlusScalarVec(sPos, *time, &dR, &pos);

	mov	eax, DWORD PTR _time$[ebp]
	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _time$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fadd	DWORD PTR [ecx+4]
	fstp	DWORD PTR _pos$[ebp+4]
	mov	eax, DWORD PTR _time$[ebp]
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR _pos$[ebp+8]

; 2396 : 				if (PointInConvex(&pos, skin, &plane, &depth2)) {

	lea	eax, DWORD PTR _depth2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _plane$[ebp]
	push	ecx
	mov	edx, DWORD PTR _skin$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?PointInConvex@@YA_NPAUVectorStruct@@PAUConvexStruct@@PAUPlaneStruct@@PAM@Z ; PointInConvex
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L82444

; 2397 : 					minTime = *time;

	mov	eax, DWORD PTR _time$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _minTime$[ebp], ecx

; 2398 : 					timeDepth = depth;

	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _timeDepth$[ebp], eax

; 2399 : 					entryPlane = &skin->Faces[iFace];

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _entryPlane$[ebp], eax
$L82444:

; 2400 : 				}
; 2401 : 			}
; 2402 : 		}
; 2403 : 	}

	jmp	$L82442
$L82443:

; 2404 : 
; 2405 : 	// Decide which result to use
; 2406 : 	if (minTime < ONE) {

	fld	DWORD PTR _minTime$[ebp]
	fcomp	DWORD PTR __real@3f800000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82447

; 2407 : 		// most recent face
; 2408 : 		*penDepth = timeDepth;

	mov	eax, DWORD PTR _penDepth$[ebp]
	mov	ecx, DWORD PTR _timeDepth$[ebp]
	mov	DWORD PTR [eax], ecx

; 2409 : 		*time = minTime;

	mov	eax, DWORD PTR _time$[ebp]
	mov	ecx, DWORD PTR _minTime$[ebp]
	mov	DWORD PTR [eax], ecx

; 2410 : 		return entryPlane;

	mov	eax, DWORD PTR _entryPlane$[ebp]
	jmp	$L82422
$L82447:

; 2411 : 	} else {
; 2412 : 		// nearest face
; 2413 : 		sDist = VecDotPlane(sPos, nearPlane);

	mov	eax, DWORD PTR _sPos$[ebp]
	mov	ecx, DWORD PTR _nearPlane$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _sPos$[ebp]
	mov	eax, DWORD PTR _nearPlane$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _sPos$[ebp]
	mov	edx, DWORD PTR _nearPlane$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _nearPlane$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _sDist$[ebp]

; 2414 : 		*penDepth = minDepth;

	mov	eax, DWORD PTR _penDepth$[ebp]
	mov	ecx, DWORD PTR _minDepth$[ebp]
	mov	DWORD PTR [eax], ecx

; 2415 : 		if (ApproxEqual(sDist, minDepth)) {

	fld	DWORD PTR _sDist$[ebp]
	fsub	DWORD PTR _minDepth$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83128
	fld	DWORD PTR _sDist$[ebp]
	fsub	DWORD PTR _minDepth$[ebp]
	fstp	DWORD PTR tv197[ebp]
	jmp	SHORT $L83129
$L83128:
	fld	DWORD PTR _sDist$[ebp]
	fsub	DWORD PTR _minDepth$[ebp]
	fchs
	fstp	DWORD PTR tv197[ebp]
$L83129:
	fld	DWORD PTR tv197[ebp]
	fcomp	DWORD PTR __real@38d1b717
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83130
	mov	DWORD PTR tv199[ebp], 1
	jmp	SHORT $L83131
$L83130:
	mov	DWORD PTR tv199[ebp], 0
$L83131:
	cmp	DWORD PTR tv199[ebp], 0
	je	SHORT $L82449

; 2416 : 			*time = ZERO;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax], 0

; 2417 : 		} else {

	jmp	SHORT $L82450
$L82449:

; 2418 : 			*time = DivScalar(sDist, (sDist - minDepth));

	fld	DWORD PTR _sDist$[ebp]
	fsub	DWORD PTR _minDepth$[ebp]
	fdivr	DWORD PTR _sDist$[ebp]
	mov	eax, DWORD PTR _time$[ebp]
	fstp	DWORD PTR [eax]
$L82450:

; 2419 : 		}
; 2420 : 		return nearPlane;

	mov	eax, DWORD PTR _nearPlane$[ebp]
$L82422:

; 2421 : 	}
; 2422 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LineToConvexColl@@YAPAUPlaneStruct@@PAUVectorStruct@@0PAUConvexStruct@@PAM2@Z ENDP ; LineToConvexColl
_TEXT	ENDS
PUBLIC	?ModifyShift@@YAXPAUVectorStruct@@M0@Z		; ModifyShift
; Function compile flags: /Odt /ZI
;	COMDAT ?ModifyShift@@YAXPAUVectorStruct@@M0@Z
_TEXT	SEGMENT
tv81 = -88						; size = 4
tv82 = -84						; size = 4
tv130 = -80						; size = 4
tv77 = -80						; size = 4
tv95 = -76						; size = 4
tv78 = -76						; size = 4
_newShift$ = -8						; size = 4
_iR$ = -4						; size = 4
_shift$ = 8						; size = 4
_shiftMag$ = 12						; size = 4
_normal$ = 16						; size = 4
?ModifyShift@@YAXPAUVectorStruct@@M0@Z PROC NEAR	; ModifyShift, COMDAT

; 2435 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 2436 : #ifndef _PSX
; 2437 : 	int		iR;
; 2438 : 	REAL	newShift;
; 2439 : 
; 2440 : 	for (iR = 0; iR < 3; iR++) {

	mov	DWORD PTR _iR$[ebp], 0
	jmp	SHORT $L82458
$L82459:
	mov	eax, DWORD PTR _iR$[ebp]
	add	eax, 1
	mov	DWORD PTR _iR$[ebp], eax
$L82458:
	cmp	DWORD PTR _iR$[ebp], 3
	jge	$L82455

; 2441 : 		newShift = (shiftMag) * normal->v[iR] ;

	mov	eax, DWORD PTR _iR$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR _shiftMag$[ebp]
	fmul	DWORD PTR [ecx+eax*4]
	fstp	DWORD PTR _newShift$[ebp]

; 2442 : 		if (Sign(shift->v[iR]) == Sign(newShift)) {

	mov	eax, DWORD PTR _iR$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fld	DWORD PTR __real@00000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L83138
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L83139
$L83138:
	mov	edx, DWORD PTR _iR$[ebp]
	mov	eax, DWORD PTR _shift$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83136
	mov	DWORD PTR tv77[ebp], -1
	jmp	SHORT $L83137
$L83136:
	mov	DWORD PTR tv77[ebp], 1
$L83137:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$L83139:
	fld	DWORD PTR __real@00000000
	fld	DWORD PTR _newShift$[ebp]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L83142
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $L83143
$L83142:
	fld	DWORD PTR _newShift$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83140
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $L83141
$L83140:
	mov	DWORD PTR tv81[ebp], 1
$L83141:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv82[ebp], edx
$L83143:
	mov	eax, DWORD PTR tv78[ebp]
	cmp	eax, DWORD PTR tv82[ebp]
	jne	SHORT $L82461

; 2443 : 			if (abs(shift->v[iR]) < abs(newShift)) {

	mov	eax, DWORD PTR _iR$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83144
	mov	edx, DWORD PTR _iR$[ebp]
	mov	eax, DWORD PTR _shift$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fstp	DWORD PTR tv95[ebp]
	jmp	SHORT $L83145
$L83144:
	mov	ecx, DWORD PTR _iR$[ebp]
	mov	edx, DWORD PTR _shift$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fchs
	fstp	DWORD PTR tv95[ebp]
$L83145:
	fld	DWORD PTR _newShift$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83146
	mov	eax, DWORD PTR _newShift$[ebp]
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $L83147
$L83146:
	fld	DWORD PTR _newShift$[ebp]
	fchs
	fstp	DWORD PTR tv130[ebp]
$L83147:
	fld	DWORD PTR tv95[ebp]
	fcomp	DWORD PTR tv130[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82462

; 2444 : 				shift->v[iR] = newShift;

	mov	eax, DWORD PTR _iR$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	mov	edx, DWORD PTR _newShift$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$L82462:

; 2445 : 			}
; 2446 : 		} else {

	jmp	SHORT $L82463
$L82461:

; 2447 : 			shift->v[iR] += newShift;

	mov	eax, DWORD PTR _iR$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	fld	DWORD PTR _newShift$[ebp]
	fadd	DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _iR$[ebp]
	mov	eax, DWORD PTR _shift$[ebp]
	fstp	DWORD PTR [eax+edx*4]
$L82463:

; 2448 : 		}
; 2449 : 	}

	jmp	$L82459
$L82455:

; 2450 : #else //_PSX
; 2451 : 	int		iR;
; 2452 : 	REAL	newShift;
; 2453 : 	REAL	*normComp, *shiftComp;
; 2454 : 
; 2455 : 	normComp = &normal->v[0];
; 2456 : 	shiftComp = &shift->v[0];
; 2457 : 
; 2458 : 	for (iR = 0; iR < 3; iR++) {
; 2459 : 		newShift = MulScalar(shiftMag, *normComp);
; 2460 : 		if (Sign(*shiftComp) == Sign(newShift)) {
; 2461 : 			if (abs(*shiftComp) < abs(newShift)) {
; 2462 : 				*shiftComp = newShift;
; 2463 : 			}
; 2464 : 		} else {
; 2465 : 			*shiftComp += newShift;
; 2466 : 		}
; 2467 : 		normComp++;
; 2468 : 		shiftComp++;
; 2469 : 	}
; 2470 : #endif
; 2471 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ModifyShift@@YAXPAUVectorStruct@@M0@Z ENDP		; ModifyShift
_TEXT	ENDS
PUBLIC	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ; PointInCollPolyBounds
; Function compile flags: /Odt /ZI
;	COMDAT ?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z
_TEXT	SEGMENT
_pt$ = 8						; size = 4
_poly$ = 12						; size = 4
?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z PROC NEAR ; PointInCollPolyBounds, COMDAT

; 2483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2484 : 	if (VecDotPlane(pt, &poly->EdgePlane[0]) > COLL_EPSILON) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+36]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82469
	xor	al, al
	jmp	$L82467
$L82469:

; 2485 : 	if (VecDotPlane(pt, &poly->EdgePlane[1]) > COLL_EPSILON) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+44]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+48]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+52]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82471
	xor	al, al
	jmp	$L82467
$L82471:

; 2486 : 	if (VecDotPlane(pt, &poly->EdgePlane[2]) > COLL_EPSILON) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+60]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+64]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+68]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82473
	xor	al, al
	jmp	SHORT $L82467
$L82473:

; 2487 : 	if (IsPolyQuad(poly)) {

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	je	SHORT $L82474

; 2488 : 		if (VecDotPlane(pt, &poly->EdgePlane[3]) > COLL_EPSILON) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+76]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+80]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+84]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82474
	xor	al, al
	jmp	SHORT $L82467
$L82474:

; 2489 : 	}
; 2490 : 	/*if (VecDotPlane(pt, &poly->EdgePlane[0]) > ZERO) return FALSE;
; 2491 : 	if (VecDotPlane(pt, &poly->EdgePlane[1]) > ZERO) return FALSE;
; 2492 : 	if (VecDotPlane(pt, &poly->EdgePlane[2]) > ZERO) return FALSE;
; 2493 : 	if (IsPolyQuad(poly)) {
; 2494 : 		if (VecDotPlane(pt, &poly->EdgePlane[3]) > ZERO) return FALSE;
; 2495 : 	}*/
; 2496 : 
; 2497 : 	return TRUE;

	mov	al, 1
$L82467:

; 2498 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ENDP ; PointInCollPolyBounds
_TEXT	ENDS
PUBLIC	?SphereInCollPolyBounds@@YA_NPAUVectorStruct@@MPAUCollPolyStruct@@@Z ; SphereInCollPolyBounds
; Function compile flags: /Odt /ZI
;	COMDAT ?SphereInCollPolyBounds@@YA_NPAUVectorStruct@@MPAUCollPolyStruct@@@Z
_TEXT	SEGMENT
_pt$ = 8						; size = 4
_radius$ = 12						; size = 4
_poly$ = 16						; size = 4
?SphereInCollPolyBounds@@YA_NPAUVectorStruct@@MPAUCollPolyStruct@@@Z PROC NEAR ; SphereInCollPolyBounds, COMDAT

; 2508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2509 : #if TRUE
; 2510 : 	if (VecDotPlane(pt, &poly->EdgePlane[0]) > (COLL_EPSILON)) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+28]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+32]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+36]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82483
	xor	al, al
	jmp	$L82481
$L82483:

; 2511 : 	if (VecDotPlane(pt, &poly->EdgePlane[1]) > (COLL_EPSILON)) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+44]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+48]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+52]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82485
	xor	al, al
	jmp	$L82481
$L82485:

; 2512 : 	if (VecDotPlane(pt, &poly->EdgePlane[2]) > (COLL_EPSILON)) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+60]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+64]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+68]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82487
	xor	al, al
	jmp	SHORT $L82481
$L82487:

; 2513 : 	if (IsPolyQuad(poly)) {

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	je	SHORT $L82488

; 2514 : 		if (VecDotPlane(pt, &poly->EdgePlane[3]) > (COLL_EPSILON)) return FALSE;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	eax, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+76]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _poly$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+80]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _poly$[ebp]
	fadd	DWORD PTR [eax+84]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82488
	xor	al, al
	jmp	SHORT $L82481
$L82488:

; 2515 : 	}
; 2516 : #else
; 2517 : 	if (VecDotPlane(pt, &poly->EdgePlane[0]) > (COLL_EPSILON + radius)) return FALSE;
; 2518 : 	if (VecDotPlane(pt, &poly->EdgePlane[1]) > (COLL_EPSILON + radius)) return FALSE;
; 2519 : 	if (VecDotPlane(pt, &poly->EdgePlane[2]) > (COLL_EPSILON + radius)) return FALSE;
; 2520 : 	if (IsPolyQuad(poly)) {
; 2521 : 		if (VecDotPlane(pt, &poly->EdgePlane[3]) > (COLL_EPSILON + radius)) return FALSE;
; 2522 : 	}
; 2523 : #endif
; 2524 : 
; 2525 : 	return TRUE;

	mov	al, 1
$L82481:

; 2526 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SphereInCollPolyBounds@@YA_NPAUVectorStruct@@MPAUCollPolyStruct@@@Z ENDP ; SphereInCollPolyBounds
_TEXT	ENDS
PUBLIC	?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z ; SphereConvex
; Function compile flags: /Odt /ZI
;	COMDAT ?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z
_TEXT	SEGMENT
_maxDist$ = -16						; size = 4
_dist$ = -12						; size = 4
_iFace$ = -8						; size = 4
_collided$ = -1						; size = 1
_spherePos$ = 8						; size = 4
_sphereRad$ = 12					; size = 4
_skin$ = 16						; size = 4
_collPos$ = 20						; size = 4
_collPlane$ = 24					; size = 4
_collDepth$ = 28					; size = 4
?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z PROC NEAR ; SphereConvex, COMDAT

; 2554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2555 : 	bool	collided;
; 2556 : 	int		iFace;
; 2557 : 	REAL	dist, maxDist;
; 2558 : 
; 2559 : 	maxDist = -LARGEDIST;

	mov	DWORD PTR _maxDist$[ebp], -915135488	; c9742400H

; 2560 : 	collided = FALSE;

	mov	BYTE PTR _collided$[ebp], 0

; 2561 : 
; 2562 : 	for (iFace = 0; iFace < skin->NFaces; iFace++) {

	mov	DWORD PTR _iFace$[ebp], 0
	jmp	SHORT $L82503
$L82504:
	mov	eax, DWORD PTR _iFace$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFace$[ebp], eax
$L82503:
	mov	eax, DWORD PTR _skin$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	DWORD PTR _iFace$[ebp], ecx
	jge	$L82505

; 2563 : 		
; 2564 : 		// Check that sphere's centre falls within "sphereRadius" of skin
; 2565 : 		if ((dist = (VecDotPlane(spherePos, &skin->Faces[iFace]) - sphereRad)) > COLL_EPSILON) return FALSE;

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _spherePos$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _iFace$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR _spherePos$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+edx+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _iFace$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _skin$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _spherePos$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+ecx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	fadd	DWORD PTR [edx+eax+12]
	fsub	DWORD PTR _sphereRad$[ebp]
	fst	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR __real@40000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82507
	xor	al, al
	jmp	$L82498
$L82507:

; 2566 : 
; 2567 : 		if (maxDist < dist) {

	fld	DWORD PTR _maxDist$[ebp]
	fcomp	DWORD PTR _dist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	$L82508

; 2568 : 			
; 2569 : 			// Point on sphere nearest surface in world coords (well, not always...)
; 2570 : 			VecMinusScalarVec(spherePos, sphereRad, PlaneNormal(&skin->Faces[iFace]), collPos);

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	fld	DWORD PTR _sphereRad$[ebp]
	fmul	DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _spherePos$[ebp]
	fsubr	DWORD PTR [eax]
	mov	ecx, DWORD PTR _collPos$[ebp]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	fld	DWORD PTR _sphereRad$[ebp]
	fmul	DWORD PTR [edx+eax+4]
	mov	eax, DWORD PTR _spherePos$[ebp]
	fsubr	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _collPos$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	fld	DWORD PTR _sphereRad$[ebp]
	fmul	DWORD PTR [edx+eax+8]
	mov	eax, DWORD PTR _spherePos$[ebp]
	fsubr	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _collPos$[ebp]
	fstp	DWORD PTR [ecx+8]

; 2571 : 
; 2572 : 			maxDist = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _maxDist$[ebp], eax

; 2573 : 			collided = TRUE;

	mov	BYTE PTR _collided$[ebp], 1

; 2574 : 
; 2575 : 			// The shift required to extract sphere from skin...
; 2576 : 			*collDepth = maxDist;

	mov	eax, DWORD PTR _collDepth$[ebp]
	mov	ecx, DWORD PTR _maxDist$[ebp]
	mov	DWORD PTR [eax], ecx

; 2577 : 			// Collision Plane
; 2578 : 			CopyPlane(&skin->Faces[iFace], collPlane);

	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _collPlane$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _collPlane$[ebp]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _collPlane$[ebp]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _iFace$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _skin$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR _collPlane$[ebp]
	mov	edx, DWORD PTR [edx+eax+12]
	mov	DWORD PTR [ecx+12], edx
$L82508:

; 2579 : 		}
; 2580 : 	}

	jmp	$L82504
$L82505:

; 2581 : 
; 2582 : 	//if (*collDepth > ZERO) *collDepth = ZERO;
; 2583 : 
; 2584 : 	return collided;

	mov	al, BYTE PTR _collided$[ebp]
$L82498:

; 2585 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SphereConvex@@YA_NPAUVectorStruct@@MPAUConvexStruct@@0PAUPlaneStruct@@PAM@Z ENDP ; SphereConvex
_TEXT	ENDS
PUBLIC	?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z	; MakeTightLocalBBox
PUBLIC	?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z ; AddPosRadToBBox
PUBLIC	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
; Function compile flags: /Odt /ZI
;	COMDAT ?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z
_TEXT	SEGMENT
_iPt$ = -12						; size = 4
_iSkin$ = -8						; size = 4
_iSphere$ = -4						; size = 4
_collSkin$ = 8						; size = 4
?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z PROC NEAR	; MakeTightLocalBBox, COMDAT

; 2630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2631 : 	int iSphere, iSkin, iPt;
; 2632 : 
; 2633 : 
; 2634 : 	SetBBox(&collSkin->TightBBox, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST);

	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+40], 1232348160		; 49742400H
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+44], -915135488		; c9742400H
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+48], 1232348160		; 49742400H
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+52], -915135488		; c9742400H
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+56], 1232348160		; 49742400H
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	DWORD PTR [eax+60], -915135488		; c9742400H

; 2635 : 
; 2636 : 	// Loop over the collision spheres
; 2637 : 	for (iSphere = 0; iSphere < collSkin->NSpheres; iSphere++) {

	mov	DWORD PTR _iSphere$[ebp], 0
	jmp	SHORT $L82518
$L82519:
	mov	eax, DWORD PTR _iSphere$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSphere$[ebp], eax
$L82518:
	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+28]
	cmp	DWORD PTR _iSphere$[ebp], ecx
	jge	SHORT $L82520

; 2638 : 		AddSphereToBBox(&collSkin->TightBBox, &collSkin->Sphere[iSphere]);

	mov	eax, DWORD PTR _iSphere$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+eax+12]
	push	eax
	mov	ecx, DWORD PTR _iSphere$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _collSkin$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	eax, DWORD PTR _collSkin$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z ; AddPosRadToBBox
	add	esp, 12					; 0000000cH

; 2639 : 	}

	jmp	SHORT $L82519
$L82520:

; 2640 : 
; 2641 : 	// Loop over the skins
; 2642 : 	for (iSkin = 0; iSkin < collSkin->NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82521
$L82522:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82521:
	mov	eax, DWORD PTR _collSkin$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	$L82514

; 2643 : 
; 2644 : 		// Set the BBox to obviously wrong values
; 2645 : 		SetBBox(&collSkin->Convex[iSkin].BBox, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+8], 1232348160	; 49742400H
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+12], -915135488	; c9742400H
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+16], 1232348160	; 49742400H
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+20], -915135488	; c9742400H
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+24], 1232348160	; 49742400H
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+28], -915135488	; c9742400H

; 2646 : 
; 2647 : 		// Loop over points in collision skin
; 2648 : 		for (iPt = 0; iPt < collSkin->Convex[iSkin].NPts; iPt++) {

	mov	DWORD PTR _iPt$[ebp], 0
	jmp	SHORT $L82524
$L82525:
	mov	eax, DWORD PTR _iPt$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPt$[ebp], eax
$L82524:
	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+eax]
	cmp	DWORD PTR _iPt$[ebp], eax
	jge	SHORT $L82526

; 2649 : 
; 2650 : 			// get the bounding box in local coordinates (as if offset were zero)
; 2651 : 			AddPointToBBox(&collSkin->Convex[iSkin].BBox, &collSkin->Convex[iSkin].Pts[iPt]);

	mov	eax, DWORD PTR _iSkin$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _collSkin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iPt$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR [edx+eax+32]
	push	ecx
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _collSkin$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+8]
	push	edx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 2652 : 
; 2653 : 		}

	jmp	SHORT $L82525
$L82526:

; 2654 : 
; 2655 : 	}

	jmp	$L82522
$L82514:

; 2656 : 
; 2657 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeTightLocalBBox@@YAXPAUCollSkinStruct@@@Z ENDP	; MakeTightLocalBBox
_TEXT	ENDS
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	__real@40c90fdb
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?CorrugationAmp@@YAMPAUCorrugationStruct@@MM@Z
_TEXT	SEGMENT
tv89 = -76						; size = 4
_argZ$ = -8						; size = 4
_argX$ = -4						; size = 4
_cor$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
?CorrugationAmp@@YAMPAUCorrugationStruct@@MM@Z PROC NEAR ; CorrugationAmp, COMDAT

; 2717 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2718 : 	REAL argX, argZ;
; 2719 : 
; 2720 : #ifndef _PSX
; 2721 : 	argX = 2.0f * PI * dx / cor->Lx;

	fld	DWORD PTR __real@40c90fdb
	fmul	DWORD PTR _dx$[ebp]
	mov	eax, DWORD PTR _cor$[ebp]
	fdiv	DWORD PTR [eax+4]
	fstp	DWORD PTR _argX$[ebp]

; 2722 : 	argZ = 2.0f * PI * dy / cor->Ly;

	fld	DWORD PTR __real@40c90fdb
	fmul	DWORD PTR _dy$[ebp]
	mov	eax, DWORD PTR _cor$[ebp]
	fdiv	DWORD PTR [eax+8]
	fstp	DWORD PTR _argZ$[ebp]

; 2723 : #else 
; 2724 : 	argX = DivScalar(dx, cor->Lx) >> (FIXED_PRECISION - 12);
; 2725 : 	argZ = DivScalar(dy, cor->Ly) >> (FIXED_PRECISION - 12);
; 2726 : #endif
; 2727 : 
; 2728 : 	return MulScalar(cor->Amp, (REAL)MulScalar(cos(argX), cos(argZ)));

	mov	eax, DWORD PTR _argX$[ebp]
	push	eax
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv89[ebp]
	mov	ecx, DWORD PTR _argZ$[ebp]
	push	ecx
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fmul	DWORD PTR tv89[ebp]
	mov	edx, DWORD PTR _cor$[ebp]
	fmul	DWORD PTR [edx]

; 2729 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CorrugationAmp@@YAMPAUCorrugationStruct@@MM@Z ENDP	; CorrugationAmp
_TEXT	ENDS
PUBLIC	_cosf
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC NEAR					; cos, COMDAT

; 549  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_cosf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
EXTRN	_cos:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _cosf
_TEXT	SEGMENT
tv70 = -68						; size = 4
__X$ = 8						; size = 4
_cosf	PROC NEAR					; COMDAT

; 444  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cos
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
PUBLIC	?LineOfSight@@YA_NPAUVectorStruct@@0@Z		; LineOfSight
; Function compile flags: /Odt /ZI
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\newcoll.cpp
;	COMDAT ?LineOfSight@@YA_NPAUVectorStruct@@0@Z
_TEXT	SEGMENT
tv364 = -160						; size = 4
tv304 = -160						; size = 4
_lastGrid$ = -89					; size = 1
_poly$ = -88						; size = 4
_grid$ = -84						; size = 4
_face$ = -80						; size = 16
_intersect$ = -64					; size = 12
_dR$ = -52						; size = 12
_minT$ = -40						; size = 4
_depth$ = -36						; size = 4
_t$ = -32						; size = 4
_zGrid$ = -28						; size = 4
_xGrid$ = -24						; size = 4
_dZ$ = -20						; size = 4
_dX$ = -16						; size = 4
_endGridNum$ = -12					; size = 4
_gridNum$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?LineOfSight@@YA_NPAUVectorStruct@@0@Z PROC NEAR	; LineOfSight, COMDAT

; 2741 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi

; 2742 : 	int		iPoly;
; 2743 : 	long	gridNum, endGridNum, dX, dZ, xGrid, zGrid;
; 2744 : 	REAL	t, depth, minT;
; 2745 : 	VEC	dR, intersect;
; 2746 : 	PLANE	face;
; 2747 : 	COLLGRID	*grid;
; 2748 : 	NEWCOLLPOLY *poly;
; 2749 : 	bool	lastGrid = FALSE;

	mov	BYTE PTR _lastGrid$[ebp], 0

; 2750 : 
; 2751 : 	// Vector separation of the two points
; 2752 : 	VecMinusVec(dest, src, &dR);

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 2753 : 
; 2754 : 	// Get the starting grid location
; 2755 : 	gridNum = PosToCollGridCoords(src, &xGrid, &zGrid);

	lea	eax, DWORD PTR _zGrid$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xGrid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?PosToCollGridCoords@@YAJPAUVectorStruct@@PAJ1@Z ; PosToCollGridCoords
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _gridNum$[ebp], eax

; 2756 : 	endGridNum = PosToCollGridNum(dest);

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	?PosToCollGridNum@@YAJPAUVectorStruct@@@Z ; PosToCollGridNum
	add	esp, 4
	mov	DWORD PTR _endGridNum$[ebp], eax
$L82555:

; 2757 : 
; 2758 : 	// Loop over grids between src and dest points
; 2759 : 	do {
; 2760 : 
; 2761 : 		// make sure the grid location is valid
; 2762 : 		if ((xGrid >= NearestInt(COL_CollGridData.XNum)) || (zGrid >= NearestInt(COL_CollGridData.ZNum)) || (xGrid < 0) || (zGrid < 0))  {

	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	cmp	DWORD PTR _xGrid$[ebp], eax
	jge	SHORT $L82561
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	cmp	DWORD PTR _zGrid$[ebp], eax
	jge	SHORT $L82561
	cmp	DWORD PTR _xGrid$[ebp], 0
	jl	SHORT $L82561
	cmp	DWORD PTR _zGrid$[ebp], 0
	jge	SHORT $L82560
$L82561:

; 2763 : 			return TRUE;

	mov	al, 1
	jmp	$L82538
$L82560:

; 2764 : 		}
; 2765 : 
; 2766 : 		grid = &COL_CollGrid[gridNum];

	mov	eax, DWORD PTR _gridNum$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	DWORD PTR _grid$[ebp], eax

; 2767 : 
; 2768 : 		// Loop over grid locations which are between the start and end points
; 2769 : 		for (iPoly = 0; iPoly < grid->NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82562
$L82563:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82562:
	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR _iPoly$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$L82564

; 2770 : #ifndef _PSX
; 2771 : 			poly = grid->CollPolyPtr[iPoly];

	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iPoly$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _poly$[ebp], eax

; 2772 : #else 
; 2773 : 			poly = &COL_WorldCollPoly[grid->CollPolyIndices[iPoly]];
; 2774 : #endif
; 2775 : 			// See if there is an intersection
; 2776 : 			if (!LinePlaneIntersect(src, dest, &poly->Plane, &t, &depth)) continue;

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82565
	jmp	SHORT $L82563
$L82565:

; 2777 : 			VecPlusScalarVec(src, t, &dR, &intersect);

	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _intersect$[ebp]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _src$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _intersect$[ebp+4]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _src$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _intersect$[ebp+8]

; 2778 : 			if (!PointInCollPolyBounds(&intersect, poly)) continue;

	mov	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _intersect$[ebp]
	push	ecx
	call	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ; PointInCollPolyBounds
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82566
	jmp	$L82563
$L82566:

; 2779 : 
; 2780 : 			// Line of sight is obstructed
; 2781 : 			return FALSE;

	xor	al, al
	jmp	$L82538
$L82564:

; 2782 : 		}
; 2783 : 
; 2784 : 		// See if this is the last grid or move on to next position
; 2785 : 		if (gridNum == endGridNum) {

	mov	eax, DWORD PTR _gridNum$[ebp]
	cmp	eax, DWORD PTR _endGridNum$[ebp]
	jne	SHORT $L82567

; 2786 : 			lastGrid = TRUE;

	mov	BYTE PTR _lastGrid$[ebp], 1

; 2787 : 		} else {

	jmp	$L82556
$L82567:

; 2788 : 
; 2789 : 			// Check each face of the grid to see which the line passes through first
; 2790 : 
; 2791 : 			minT = Real(2.0);

	mov	DWORD PTR _minT$[ebp], 1073741824	; 40000000H

; 2792 : 			if (dR.v[X] < ZERO) {

	fld	DWORD PTR _dR$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82570

; 2793 : 
; 2794 : 				// Left
; 2795 : 				SetPlane(&face, ONE, ZERO, ZERO, -(COL_CollGridData.XStart + xGrid * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], 1065353216	; 3f800000H
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], 0
	fild	DWORD PTR _xGrid$[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	fchs
	fstp	DWORD PTR _face$[ebp+12]

; 2796 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82571

; 2797 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82571

; 2798 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2799 : 						dX = -1;

	mov	DWORD PTR _dX$[ebp], -1

; 2800 : 						dZ = 0;

	mov	DWORD PTR _dZ$[ebp], 0
$L82571:

; 2801 : 					}
; 2802 : 				}
; 2803 : 			} else {

	jmp	SHORT $L82573
$L82570:

; 2804 : 				// Right
; 2805 : 				SetPlane(&face, -ONE, ZERO, ZERO, (COL_CollGridData.XStart + (xGrid + 1) * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], -1082130432	; bf800000H
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], 0
	mov	eax, DWORD PTR _xGrid$[ebp]
	add	eax, 1
	mov	DWORD PTR tv304[ebp], eax
	fild	DWORD PTR tv304[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	fstp	DWORD PTR _face$[ebp+12]

; 2806 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82573

; 2807 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82573

; 2808 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2809 : 						dX = 1;

	mov	DWORD PTR _dX$[ebp], 1

; 2810 : 						dZ = 0;

	mov	DWORD PTR _dZ$[ebp], 0
$L82573:

; 2811 : 					}
; 2812 : 				}
; 2813 : 			}
; 2814 : 			if (dR.v[Z] < ZERO) {

	fld	DWORD PTR _dR$[ebp+8]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82576

; 2815 : 
; 2816 : 				// Back
; 2817 : 				SetPlane(&face, ZERO, ZERO, ONE, -(COL_CollGridData.ZStart + zGrid * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], 0
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], 1065353216	; 3f800000H
	fild	DWORD PTR _zGrid$[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4
	fchs
	fstp	DWORD PTR _face$[ebp+12]

; 2818 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82577

; 2819 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82577

; 2820 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2821 : 						dX = 0;

	mov	DWORD PTR _dX$[ebp], 0

; 2822 : 						dZ = -1;

	mov	DWORD PTR _dZ$[ebp], -1
$L82577:

; 2823 : 					}
; 2824 : 				}
; 2825 : 			} else {

	jmp	SHORT $L82579
$L82576:

; 2826 : 				// Forward
; 2827 : 				SetPlane(&face, ZERO, ZERO, -ONE, (COL_CollGridData.ZStart + (zGrid + 1) * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], 0
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], -1082130432	; bf800000H
	mov	eax, DWORD PTR _zGrid$[ebp]
	add	eax, 1
	mov	DWORD PTR tv364[ebp], eax
	fild	DWORD PTR tv364[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4
	fstp	DWORD PTR _face$[ebp+12]

; 2828 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82579

; 2829 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82579

; 2830 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2831 : 						dX = 0;

	mov	DWORD PTR _dX$[ebp], 0

; 2832 : 						dZ = 1;

	mov	DWORD PTR _dZ$[ebp], 1
$L82579:

; 2833 : 					}
; 2834 : 				}
; 2835 : 			}
; 2836 : 
; 2837 : 			xGrid += dX;

	mov	eax, DWORD PTR _xGrid$[ebp]
	add	eax, DWORD PTR _dX$[ebp]
	mov	DWORD PTR _xGrid$[ebp], eax

; 2838 : 			zGrid += dZ;

	mov	eax, DWORD PTR _zGrid$[ebp]
	add	eax, DWORD PTR _dZ$[ebp]
	mov	DWORD PTR _zGrid$[ebp], eax

; 2839 : 			if ((xGrid >= COL_CollGridData.XNum) || (zGrid >= COL_CollGridData.ZNum)) {

	fild	DWORD PTR _xGrid$[ebp]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fnstsw	ax
	test	ah, 1
	je	SHORT $L82583
	fild	DWORD PTR _zGrid$[ebp]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82582
$L82583:

; 2840 : 				gridNum = -1;

	mov	DWORD PTR _gridNum$[ebp], -1

; 2841 : 			} else {

	jmp	SHORT $L82556
$L82582:

; 2842 : 				gridNum += dX + NearestInt(COL_CollGridData.XNum) * dZ;

	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	imul	eax, DWORD PTR _dZ$[ebp]
	add	eax, DWORD PTR _dX$[ebp]
	add	eax, DWORD PTR _gridNum$[ebp]
	mov	DWORD PTR _gridNum$[ebp], eax
$L82556:

; 2843 : 			}
; 2844 : 		}
; 2845 : 
; 2846 : 	} while ((gridNum != -1) && (!lastGrid));

	cmp	DWORD PTR _gridNum$[ebp], -1
	je	SHORT $L82557
	movzx	eax, BYTE PTR _lastGrid$[ebp]
	test	eax, eax
	je	$L82555
$L82557:

; 2847 : 
; 2848 : 
; 2849 : 	// Got this far, so must have line of sight
; 2850 : 	return TRUE;

	mov	al, 1
$L82538:

; 2851 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LineOfSight@@YA_NPAUVectorStruct@@0@Z ENDP		; LineOfSight
_TEXT	ENDS
PUBLIC	?LineOfSightDist@@YA_NPAUVectorStruct@@0PAMPAPAUPlaneStruct@@@Z ; LineOfSightDist
; Function compile flags: /Odt /ZI
;	COMDAT ?LineOfSightDist@@YA_NPAUVectorStruct@@0PAMPAPAUPlaneStruct@@@Z
_TEXT	SEGMENT
tv381 = -160						; size = 4
tv353 = -160						; size = 4
_lastGrid$ = -89					; size = 1
_poly$ = -88						; size = 4
_grid$ = -84						; size = 4
_face$ = -80						; size = 16
_intersect$ = -64					; size = 12
_dR$ = -52						; size = 12
_minT$ = -40						; size = 4
_depth$ = -36						; size = 4
_t$ = -32						; size = 4
_zGrid$ = -28						; size = 4
_xGrid$ = -24						; size = 4
_dZ$ = -20						; size = 4
_dX$ = -16						; size = 4
_endGridNum$ = -12					; size = 4
_gridNum$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
_minDist$ = 16						; size = 4
_plane$ = 20						; size = 4
?LineOfSightDist@@YA_NPAUVectorStruct@@0PAMPAPAUPlaneStruct@@@Z PROC NEAR ; LineOfSightDist, COMDAT

; 2862 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi

; 2863 : 	int		iPoly;
; 2864 : 	long	gridNum, endGridNum, dX, dZ, xGrid, zGrid;
; 2865 : 	REAL	t, depth, minT;
; 2866 : 	VEC	dR, intersect;
; 2867 : 	PLANE	face;
; 2868 : 	COLLGRID	*grid;
; 2869 : 	NEWCOLLPOLY *poly;
; 2870 : 	bool	lastGrid = FALSE;

	mov	BYTE PTR _lastGrid$[ebp], 0

; 2871 : 
; 2872 : 	// Vector separation of the two points
; 2873 : 	VecMinusVec(dest, src, &dR);

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 2874 : 	*minDist = ONE;

	mov	eax, DWORD PTR _minDist$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 2875 : 
; 2876 : 	// Get the starting grid location
; 2877 : 	gridNum = PosToCollGridCoords(src, &xGrid, &zGrid);

	lea	eax, DWORD PTR _zGrid$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xGrid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?PosToCollGridCoords@@YAJPAUVectorStruct@@PAJ1@Z ; PosToCollGridCoords
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _gridNum$[ebp], eax

; 2878 : 	endGridNum = PosToCollGridNum(dest);

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	?PosToCollGridNum@@YAJPAUVectorStruct@@@Z ; PosToCollGridNum
	add	esp, 4
	mov	DWORD PTR _endGridNum$[ebp], eax
$L82609:

; 2879 : 
; 2880 : 	// Loop over grids between src and dest points
; 2881 : 	do {
; 2882 : 
; 2883 : 		// make sure the grid location is valid
; 2884 : 		if ((xGrid >= NearestInt(COL_CollGridData.XNum)) || (zGrid >= NearestInt(COL_CollGridData.ZNum)) || (xGrid < 0) || (zGrid < 0))  {

	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	cmp	DWORD PTR _xGrid$[ebp], eax
	jge	SHORT $L82615
	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	cmp	DWORD PTR _zGrid$[ebp], eax
	jge	SHORT $L82615
	cmp	DWORD PTR _xGrid$[ebp], 0
	jl	SHORT $L82615
	cmp	DWORD PTR _zGrid$[ebp], 0
	jge	SHORT $L82614
$L82615:

; 2885 : 			return TRUE;

	mov	al, 1
	jmp	$L82592
$L82614:

; 2886 : 		}
; 2887 : 
; 2888 : 		grid = &COL_CollGrid[gridNum];

	mov	eax, DWORD PTR _gridNum$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR ?COL_CollGrid@@3PAUCOLLGRID@@A ; COL_CollGrid
	mov	DWORD PTR _grid$[ebp], eax

; 2889 : 
; 2890 : 		// Loop over grid locations which are between the start and end points
; 2891 : 		for (iPoly = 0; iPoly < grid->NCollPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82616
$L82617:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82616:
	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR _iPoly$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$L82618

; 2892 : #ifndef _PSX
; 2893 : 			poly = grid->CollPolyPtr[iPoly];

	mov	eax, DWORD PTR _grid$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iPoly$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _poly$[ebp], eax

; 2894 : #else
; 2895 : 			poly = &COL_WorldCollPoly[grid->CollPolyIndices[iPoly]];
; 2896 : #endif
; 2897 : 			// See if there is an intersection
; 2898 : 			if (!LinePlaneIntersect(src, dest, &poly->Plane, &t, &depth)) continue;

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82619
	jmp	SHORT $L82617
$L82619:

; 2899 : 			if (depth > ZERO) continue;

	fld	DWORD PTR _depth$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82620
	jmp	SHORT $L82617
$L82620:

; 2900 : 			VecPlusScalarVec(src, t, &dR, &intersect);

	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _intersect$[ebp]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _src$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _intersect$[ebp+4]
	fld	DWORD PTR _t$[ebp]
	fmul	DWORD PTR _dR$[ebp+8]
	mov	eax, DWORD PTR _src$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _intersect$[ebp+8]

; 2901 : 			if (!PointInCollPolyBounds(&intersect, poly)) continue;

	mov	eax, DWORD PTR _poly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _intersect$[ebp]
	push	ecx
	call	?PointInCollPolyBounds@@YA_NPAUVectorStruct@@PAUCollPolyStruct@@@Z ; PointInCollPolyBounds
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82621
	jmp	$L82617
$L82621:

; 2902 : 
; 2903 : 			// Line of sight is obstructed - is this the nearest
; 2904 : 			if (t < *minDist) {

	mov	eax, DWORD PTR _minDist$[ebp]
	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82622

; 2905 : 				*minDist = t;

	mov	eax, DWORD PTR _minDist$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax], ecx

; 2906 : 				if (plane) {

	cmp	DWORD PTR _plane$[ebp], 0
	je	SHORT $L82622

; 2907 : 					*plane = &poly->Plane;

	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	DWORD PTR [ecx], eax
$L82622:

; 2908 : 				}
; 2909 : 			}
; 2910 : 		}

	jmp	$L82617
$L82618:

; 2911 : 
; 2912 : 		// See if this is the last grid or move on to next position
; 2913 : 		if (gridNum == endGridNum) {

	mov	eax, DWORD PTR _gridNum$[ebp]
	cmp	eax, DWORD PTR _endGridNum$[ebp]
	jne	SHORT $L82624

; 2914 : 			lastGrid = TRUE;

	mov	BYTE PTR _lastGrid$[ebp], 1

; 2915 : 		} else {

	jmp	$L82610
$L82624:

; 2916 : 
; 2917 : 			// Check each face of the grid to see which the line passes through first
; 2918 : 
; 2919 : 			minT = Real(2.0);

	mov	DWORD PTR _minT$[ebp], 1073741824	; 40000000H

; 2920 : 			if (dR.v[X] < ZERO) {

	fld	DWORD PTR _dR$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82627

; 2921 : 
; 2922 : 				// Left
; 2923 : 				SetPlane(&face, ONE, ZERO, ZERO, -(COL_CollGridData.XStart + xGrid * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], 1065353216	; 3f800000H
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], 0
	fild	DWORD PTR _xGrid$[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	fchs
	fstp	DWORD PTR _face$[ebp+12]

; 2924 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82628

; 2925 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82628

; 2926 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2927 : 						dX = -1;

	mov	DWORD PTR _dX$[ebp], -1

; 2928 : 						dZ = 0;

	mov	DWORD PTR _dZ$[ebp], 0
$L82628:

; 2929 : 					}
; 2930 : 				}
; 2931 : 			} else {

	jmp	SHORT $L82630
$L82627:

; 2932 : 				// Right
; 2933 : 				SetPlane(&face, -ONE, ZERO, ZERO, (COL_CollGridData.XStart + (xGrid + 1) * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], -1082130432	; bf800000H
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], 0
	mov	eax, DWORD PTR _xGrid$[ebp]
	add	eax, 1
	mov	DWORD PTR tv353[ebp], eax
	fild	DWORD PTR tv353[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A
	fstp	DWORD PTR _face$[ebp+12]

; 2934 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82630

; 2935 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82630

; 2936 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2937 : 						dX = 1;

	mov	DWORD PTR _dX$[ebp], 1

; 2938 : 						dZ = 0;

	mov	DWORD PTR _dZ$[ebp], 0
$L82630:

; 2939 : 					}
; 2940 : 				}
; 2941 : 			}
; 2942 : 			if (dR.v[Z] < ZERO) {

	fld	DWORD PTR _dR$[ebp+8]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82633

; 2943 : 
; 2944 : 				// Back
; 2945 : 				SetPlane(&face, ZERO, ZERO, ONE, -(COL_CollGridData.ZStart + zGrid * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], 0
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], 1065353216	; 3f800000H
	fild	DWORD PTR _zGrid$[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4
	fchs
	fstp	DWORD PTR _face$[ebp+12]

; 2946 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82634

; 2947 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82634

; 2948 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2949 : 						dX = 0;

	mov	DWORD PTR _dX$[ebp], 0

; 2950 : 						dZ = -1;

	mov	DWORD PTR _dZ$[ebp], -1
$L82634:

; 2951 : 					}
; 2952 : 				}
; 2953 : 			} else {

	jmp	SHORT $L82636
$L82633:

; 2954 : 				// Forward
; 2955 : 				SetPlane(&face, ZERO, ZERO, -ONE, (COL_CollGridData.ZStart + (zGrid + 1) * COL_CollGridData.GridSize));

	mov	DWORD PTR _face$[ebp], 0
	mov	DWORD PTR _face$[ebp+4], 0
	mov	DWORD PTR _face$[ebp+8], -1082130432	; bf800000H
	mov	eax, DWORD PTR _zGrid$[ebp]
	add	eax, 1
	mov	DWORD PTR tv381[ebp], eax
	fild	DWORD PTR tv381[ebp]
	fmul	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+16
	fadd	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+4
	fstp	DWORD PTR _face$[ebp+12]

; 2956 : 				if (LinePlaneIntersect(src, dest, &face, &t, &depth)) {

	lea	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _face$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?LinePlaneIntersect@@YA_NPAUVectorStruct@@0PAUPlaneStruct@@PAM2@Z ; LinePlaneIntersect
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	je	SHORT $L82636

; 2957 : 					if (t < minT) {

	fld	DWORD PTR _t$[ebp]
	fcomp	DWORD PTR _minT$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82636

; 2958 : 						minT = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _minT$[ebp], eax

; 2959 : 						dX = 0;

	mov	DWORD PTR _dX$[ebp], 0

; 2960 : 						dZ = 1;

	mov	DWORD PTR _dZ$[ebp], 1
$L82636:

; 2961 : 					}
; 2962 : 				}
; 2963 : 			}
; 2964 : 
; 2965 : 			xGrid += dX;

	mov	eax, DWORD PTR _xGrid$[ebp]
	add	eax, DWORD PTR _dX$[ebp]
	mov	DWORD PTR _xGrid$[ebp], eax

; 2966 : 			zGrid += dZ;

	mov	eax, DWORD PTR _zGrid$[ebp]
	add	eax, DWORD PTR _dZ$[ebp]
	mov	DWORD PTR _zGrid$[ebp], eax

; 2967 : 			if ((xGrid >= COL_CollGridData.XNum) || (zGrid >= COL_CollGridData.ZNum)) {

	fild	DWORD PTR _xGrid$[ebp]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fnstsw	ax
	test	ah, 1
	je	SHORT $L82640
	fild	DWORD PTR _zGrid$[ebp]
	fcomp	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+12
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L82639
$L82640:

; 2968 : 				gridNum = -1;

	mov	DWORD PTR _gridNum$[ebp], -1

; 2969 : 			} else {

	jmp	SHORT $L82610
$L82639:

; 2970 : 				gridNum += dX + NearestInt(COL_CollGridData.XNum) * dZ;

	fld	DWORD PTR ?COL_CollGridData@@3UCOLLGRID_DATA@@A+8
	fadd	DWORD PTR __real@3f000000
	call	__ftol2
	imul	eax, DWORD PTR _dZ$[ebp]
	add	eax, DWORD PTR _dX$[ebp]
	add	eax, DWORD PTR _gridNum$[ebp]
	mov	DWORD PTR _gridNum$[ebp], eax
$L82610:

; 2971 : 			}
; 2972 : 		}
; 2973 : 
; 2974 : 	} while ((gridNum != -1) && (!lastGrid));

	cmp	DWORD PTR _gridNum$[ebp], -1
	je	SHORT $L82611
	movzx	eax, BYTE PTR _lastGrid$[ebp]
	test	eax, eax
	je	$L82609
$L82611:

; 2975 : 
; 2976 : 
; 2977 : 	// Got this far, so must have line of sight
; 2978 : 	return TRUE;

	mov	al, 1
$L82592:

; 2979 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LineOfSightDist@@YA_NPAUVectorStruct@@0PAMPAPAUPlaneStruct@@@Z ENDP ; LineOfSightDist
_TEXT	ENDS
PUBLIC	?LineOfSightObj@@YA_NPAUVectorStruct@@0PAM@Z	; LineOfSightObj
PUBLIC	?LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z ; LineOfSightBody
PUBLIC	?LineOfSightSphere@@YA_NPAUVectorStruct@@M00PAM@Z ; LineOfSightSphere
; Function compile flags: /Odt /ZI
;	COMDAT ?LineOfSightObj@@YA_NPAUVectorStruct@@0PAM@Z
_TEXT	SEGMENT
tv190 = -108						; size = 4
tv134 = -108						; size = 4
tv71 = -108						; size = 4
_obj$ = -40						; size = 4
_bBox$ = -36						; size = 24
_dist$ = -12						; size = 4
_iWheel$ = -8						; size = 4
_los$ = -1						; size = 1
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
_minDist$ = 16						; size = 4
?LineOfSightObj@@YA_NPAUVectorStruct@@0PAM@Z PROC NEAR	; LineOfSightObj, COMDAT

; 2990 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 2991 : 	bool los;
; 2992 : 	int iWheel;
; 2993 : 	REAL dist;
; 2994 : 	BBOX bBox;
; 2995 : 	OBJECT *obj;
; 2996 : 
; 2997 : 	// Initialise
; 2998 : 	los = TRUE;

	mov	BYTE PTR _los$[ebp], 1

; 2999 : 	*minDist = ONE;

	mov	eax, DWORD PTR _minDist$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 3000 : 
; 3001 : 	SetBBox(&bBox, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST);

	mov	DWORD PTR _bBox$[ebp], 1232348160	; 49742400H
	mov	DWORD PTR _bBox$[ebp+4], -915135488	; c9742400H
	mov	DWORD PTR _bBox$[ebp+8], 1232348160	; 49742400H
	mov	DWORD PTR _bBox$[ebp+12], -915135488	; c9742400H
	mov	DWORD PTR _bBox$[ebp+16], 1232348160	; 49742400H
	mov	DWORD PTR _bBox$[ebp+20], -915135488	; c9742400H

; 3002 : 	AddPointToBBox(&bBox, src);

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3003 : 	AddPointToBBox(&bBox, dest);

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3004 : 
; 3005 : 	// Loop over objects
; 3006 : 	for (obj = OBJ_ObjectHead; obj != NULL; obj = obj->next) {

	mov	eax, DWORD PTR ?OBJ_ObjectHead@@3PAUobject_def@@A ; OBJ_ObjectHead
	mov	DWORD PTR _obj$[ebp], eax
	jmp	SHORT $L82654
$L82655:
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _obj$[ebp], ecx
$L82654:
	cmp	DWORD PTR _obj$[ebp], 0
	je	$L82656

; 3007 : 
; 3008 : 		// Check for LoS through the collision skins
; 3009 : 		switch (obj->CollType) {

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+660]
	mov	DWORD PTR tv71[ebp], ecx
	cmp	DWORD PTR tv71[ebp], 1
	je	$L82669
	cmp	DWORD PTR tv71[ebp], 2
	je	SHORT $L82661
	jmp	$L82658
$L82661:

; 3010 : 
; 3011 : 		case COLL_TYPE_CAR:
; 3012 : 			if (!BBTestXZY(&obj->player->car.BBox, &bBox)) continue;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	fld	DWORD PTR [ecx+3192]
	fcomp	DWORD PTR _bBox$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L83170
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	fld	DWORD PTR [eax+3196]
	fcomp	DWORD PTR _bBox$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83170
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	fld	DWORD PTR [edx+3208]
	fcomp	DWORD PTR _bBox$[ebp+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83170
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	fld	DWORD PTR [ecx+3212]
	fcomp	DWORD PTR _bBox$[ebp+16]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83170
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+588]
	fld	DWORD PTR [eax+3200]
	fcomp	DWORD PTR _bBox$[ebp+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83170
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	fld	DWORD PTR [edx+3204]
	fcomp	DWORD PTR _bBox$[ebp+8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83170
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $L83171
$L83170:
	mov	DWORD PTR tv134[ebp], 0
$L83171:
	cmp	DWORD PTR tv134[ebp], 0
	jne	SHORT $L82662
	jmp	$L82655
$L82662:

; 3013 : 			for (iWheel = 0; iWheel < CAR_NWHEELS; iWheel++) {

	mov	DWORD PTR _iWheel$[ebp], 0
	jmp	SHORT $L82663
$L82664:
	mov	eax, DWORD PTR _iWheel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iWheel$[ebp], eax
$L82663:
	cmp	DWORD PTR _iWheel$[ebp], 4
	jge	$L82669

; 3014 : 				if (IsWheelPresent(&obj->player->car.Wheel[iWheel])) {

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR [ecx+edx+1604]
	and	eax, 1
	je	SHORT $L82666

; 3015 : 					if (!LineOfSightSphere(&obj->player->car.Wheel[iWheel].WPos, obj->player->car.Wheel[iWheel].Radius, src, dest, &dist)) {

	lea	eax, DWORD PTR _dist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	edx, DWORD PTR _iWheel$[ebp]
	imul	edx, 360				; 00000168H
	mov	eax, DWORD PTR [ecx+edx+1624]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR _iWheel$[ebp]
	imul	eax, 360				; 00000168H
	lea	ecx, DWORD PTR [edx+eax+1764]
	push	ecx
	call	?LineOfSightSphere@@YA_NPAUVectorStruct@@M00PAM@Z ; LineOfSightSphere
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L82666

; 3016 : 						los = FALSE;

	mov	BYTE PTR _los$[ebp], 0

; 3017 : 						if (dist < *minDist) {

	mov	eax, DWORD PTR _minDist$[ebp]
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82666

; 3018 : 							*minDist = dist;

	mov	eax, DWORD PTR _minDist$[ebp]
	mov	ecx, DWORD PTR _dist$[ebp]
	mov	DWORD PTR [eax], ecx
$L82666:

; 3019 : 						}
; 3020 : 					}
; 3021 : 				}
; 3022 : 			}

	jmp	$L82664
$L82669:

; 3023 : 		case COLL_TYPE_BODY:
; 3024 : 			if (!BBTestXZY(&obj->body.CollSkin.BBox, &bBox)) continue;

	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+444]
	fcomp	DWORD PTR _bBox$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83172
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+448]
	fcomp	DWORD PTR _bBox$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83172
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+460]
	fcomp	DWORD PTR _bBox$[ebp+20]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83172
	mov	eax, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [eax+464]
	fcomp	DWORD PTR _bBox$[ebp+16]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83172
	mov	ecx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [ecx+452]
	fcomp	DWORD PTR _bBox$[ebp+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83172
	mov	edx, DWORD PTR _obj$[ebp]
	fld	DWORD PTR [edx+456]
	fcomp	DWORD PTR _bBox$[ebp+8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83172
	mov	DWORD PTR tv190[ebp], 1
	jmp	SHORT $L83173
$L83172:
	mov	DWORD PTR tv190[ebp], 0
$L83173:
	cmp	DWORD PTR tv190[ebp], 0
	jne	SHORT $L82670
	jmp	$L82655
$L82670:

; 3025 : 			if (!LineOfSightBody(&obj->body, src, dest, &dist)) {

	lea	eax, DWORD PTR _dist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z ; LineOfSightBody
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L82658

; 3026 : 				los = FALSE;

	mov	BYTE PTR _los$[ebp], 0

; 3027 : 				if (dist < *minDist) {

	mov	eax, DWORD PTR _minDist$[ebp]
	fld	DWORD PTR _dist$[ebp]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82658

; 3028 : 					*minDist = dist;

	mov	eax, DWORD PTR _minDist$[ebp]
	mov	ecx, DWORD PTR _dist$[ebp]
	mov	DWORD PTR [eax], ecx
$L82658:

; 3029 : 				}
; 3030 : 			}
; 3031 : 			break;
; 3032 : 
; 3033 : 		default:
; 3034 : 			break;
; 3035 : 		}
; 3036 : 	}

	jmp	$L82655
$L82656:

; 3037 : 
; 3038 : 	return los;

	mov	al, BYTE PTR _los$[ebp]

; 3039 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LineOfSightObj@@YA_NPAUVectorStruct@@0PAM@Z ENDP	; LineOfSightObj
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z@4JA ; `LineOfSightBody'::`2'::__LINE__Var
PUBLIC	?LineOfSightConvex@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z ; LineOfSightConvex
;	COMDAT ?__LINE__Var@?1??LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z@4JA DD 0be2H ; `LineOfSightBody'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT
_los$ = -1						; size = 1
_body$ = 8						; size = 4
_src$ = 12						; size = 4
_dest$ = 16						; size = 4
_minDist$ = 20						; size = 4
?LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z PROC NEAR ; LineOfSightBody, COMDAT

; 3042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3043 : 	bool los;
; 3044 : 	if (body->CollSkin.CollType == BODY_COLL_SPHERE) {

	mov	eax, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [eax+472], 1
	jne	SHORT $L82681

; 3045 : 		los = LineOfSightSphere(&body->CollSkin.WorldSphere[0].Pos, body->CollSkin.WorldSphere[0].Radius, src, dest, minDist);

	mov	eax, DWORD PTR _minDist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _body$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	push	ecx
	call	?LineOfSightSphere@@YA_NPAUVectorStruct@@M00PAM@Z ; LineOfSightSphere
	add	esp, 20					; 00000014H
	mov	BYTE PTR _los$[ebp], al

; 3046 : 		return los;

	mov	al, BYTE PTR _los$[ebp]
	jmp	SHORT $L82679
$L82681:

; 3047 : 	} else {
; 3048 : 		Assert(body->CollSkin.CollType == BODY_COLL_CONVEX);

	push	OFFSET FLAT:??_C@_0IM@GBNNFNEK@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z@4JA
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	cmp	DWORD PTR [ecx+472], 0
	sete	dl
	push	edx
	call	?DebugAssert@@YAX_NHPAD@Z		; DebugAssert
	add	esp, 12					; 0000000cH

; 3049 : 		los = LineOfSightConvex(body, src, dest, minDist);

	mov	eax, DWORD PTR _minDist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	?LineOfSightConvex@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z ; LineOfSightConvex
	add	esp, 16					; 00000010H
	mov	BYTE PTR _los$[ebp], al

; 3050 : 		return los;

	mov	al, BYTE PTR _los$[ebp]
$L82679:

; 3051 : 	}
; 3052 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LineOfSightBody@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z ENDP ; LineOfSightBody
_TEXT	ENDS
EXTRN	?NearPointOnLine@@YAMPAUVectorStruct@@000@Z:NEAR ; NearPointOnLine
; Function compile flags: /Odt /ZI
;	COMDAT ?LineOfSightConvex@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z
_TEXT	SEGMENT
tv130 = -136						; size = 4
_los$ = -65						; size = 1
_dR2$ = -64						; size = 12
_dR$ = -52						; size = 12
_nearPt$ = -40						; size = 12
_minDepth$ = -28					; size = 4
_dR2Len$ = -24						; size = 4
_dRLen$ = -20						; size = 4
_time$ = -16						; size = 4
_depth$ = -12						; size = 4
_dist$ = -8						; size = 4
_iSkin$ = -4						; size = 4
_body$ = 8						; size = 4
_src$ = 12						; size = 4
_dest$ = 16						; size = 4
_minDist$ = 20						; size = 4
?LineOfSightConvex@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z PROC NEAR ; LineOfSightConvex, COMDAT

; 3056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi

; 3057 : 	int iSkin;
; 3058 : 	REAL dist, depth, time, dRLen, dR2Len, minDepth;
; 3059 : 	VEC nearPt, dR, dR2;
; 3060 : 	bool los;
; 3061 : 
; 3062 : 	los = TRUE;

	mov	BYTE PTR _los$[ebp], 1

; 3063 : 	*minDist = ONE;

	mov	eax, DWORD PTR _minDist$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 3064 : 	minDepth = LARGEDIST;

	mov	DWORD PTR _minDepth$[ebp], 1232348160	; 49742400H

; 3065 : 
; 3066 : 	dist = NearPointOnLine(src, dest, &body->Centre.Pos, &nearPt);

	lea	eax, DWORD PTR _nearPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?NearPointOnLine@@YAMPAUVectorStruct@@000@Z ; NearPointOnLine
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dist$[ebp]

; 3067 : 	if (!PointInBBox(&nearPt, &body->CollSkin.BBox)) return TRUE;

	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+444]
	fcomp	DWORD PTR _nearPt$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83178
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+448]
	fcomp	DWORD PTR _nearPt$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83178
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+460]
	fcomp	DWORD PTR _nearPt$[ebp+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83178
	mov	eax, DWORD PTR _body$[ebp]
	fld	DWORD PTR [eax+464]
	fcomp	DWORD PTR _nearPt$[ebp+8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83178
	mov	ecx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [ecx+452]
	fcomp	DWORD PTR _nearPt$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L83178
	mov	edx, DWORD PTR _body$[ebp]
	fld	DWORD PTR [edx+456]
	fcomp	DWORD PTR _nearPt$[ebp+4]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L83178
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $L83179
$L83178:
	mov	DWORD PTR tv130[ebp], 0
$L83179:
	cmp	DWORD PTR tv130[ebp], 0
	jne	SHORT $L82701
	mov	al, 1
	jmp	$L82689
$L82701:

; 3068 : 	VecMinusVec(dest, src, &dR2);

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR2$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR2$[ebp+4]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR2$[ebp+8]

; 3069 : 	dR2Len = VecLen(&dR2);

	fld	DWORD PTR _dR2$[ebp]
	fmul	DWORD PTR _dR2$[ebp]
	fld	DWORD PTR _dR2$[ebp+4]
	fmul	DWORD PTR _dR2$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR2$[ebp+8]
	fmul	DWORD PTR _dR2$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dR2Len$[ebp]

; 3070 : 	VecMinusVec(&nearPt, src, &dR);

	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR _nearPt$[ebp]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR _nearPt$[ebp+4]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR _nearPt$[ebp+8]
	fsub	DWORD PTR [eax+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 3071 : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 3072 : 
; 3073 : 	for (iSkin = 0; iSkin < body->CollSkin.NConvex; iSkin++) {

	mov	DWORD PTR _iSkin$[ebp], 0
	jmp	SHORT $L82704
$L82705:
	mov	eax, DWORD PTR _iSkin$[ebp]
	add	eax, 1
	mov	DWORD PTR _iSkin$[ebp], eax
$L82704:
	mov	eax, DWORD PTR _body$[ebp]
	movsx	ecx, WORD PTR [eax+392]
	cmp	DWORD PTR _iSkin$[ebp], ecx
	jge	SHORT $L82706

; 3074 : 		if (LineToConvexColl(src, &nearPt, &body->CollSkin.WorldConvex[iSkin], &depth, &time) == NULL) continue;

	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	lea	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSkin$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _body$[ebp]
	add	edx, DWORD PTR [eax+384]
	push	edx
	lea	ecx, DWORD PTR _nearPt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?LineToConvexColl@@YAPAUPlaneStruct@@PAUVectorStruct@@0PAUConvexStruct@@PAM2@Z ; LineToConvexColl
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $L82707
	jmp	SHORT $L82705
$L82707:

; 3075 : 		
; 3076 : 		los = FALSE;

	mov	BYTE PTR _los$[ebp], 0

; 3077 : 		if (depth < minDepth) {

	fld	DWORD PTR _depth$[ebp]
	fcomp	DWORD PTR _minDepth$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82708

; 3078 : 			minDepth = depth;

	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _minDepth$[ebp], eax
$L82708:

; 3079 : 		}
; 3080 : 	}

	jmp	SHORT $L82705
$L82706:

; 3081 : 
; 3082 : 	*minDist = dist + (minDepth / dR2Len);

	fld	DWORD PTR _minDepth$[ebp]
	fdiv	DWORD PTR _dR2Len$[ebp]
	fadd	DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _minDist$[ebp]
	fstp	DWORD PTR [eax]

; 3083 : 
; 3084 : 	return los;

	mov	al, BYTE PTR _los$[ebp]
$L82689:

; 3085 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LineOfSightConvex@@YA_NPAUNewBodyStruct@@PAUVectorStruct@@1PAM@Z ENDP ; LineOfSightConvex
_TEXT	ENDS
PUBLIC	__real@40800000
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LineOfSightSphere@@YA_NPAUVectorStruct@@M00PAM@Z
_TEXT	SEGMENT
tv228 = -108						; size = 4
tv223 = -108						; size = 4
_dS$ = -40						; size = 12
_dR$ = -28						; size = 12
_dRLen$ = -16						; size = 4
_d$ = -12						; size = 4
_c$ = -8						; size = 4
_b$ = -4						; size = 4
_sphPos$ = 8						; size = 4
_rad$ = 12						; size = 4
_src$ = 16						; size = 4
_dest$ = 20						; size = 4
_minDist$ = 24						; size = 4
?LineOfSightSphere@@YA_NPAUVectorStruct@@M00PAM@Z PROC NEAR ; LineOfSightSphere, COMDAT

; 3088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 3089 : 	REAL b, c, d, dRLen;
; 3090 : 	VEC dR, dS;
; 3091 : 
; 3092 : 
; 3093 : 	VecMinusVec(dest, src, &dR);

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dR$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dR$[ebp+4]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dR$[ebp+8]

; 3094 : 	dRLen = VecLen(&dR);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dR$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dR$[ebp+8]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fstp	DWORD PTR _dRLen$[ebp]

; 3095 : 	VecDivScalar(&dR, dRLen);

	fld	DWORD PTR _dR$[ebp]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp+4]
	fld	DWORD PTR _dR$[ebp+8]
	fdiv	DWORD PTR _dRLen$[ebp]
	fstp	DWORD PTR _dR$[ebp+8]

; 3096 : 	VecMinusVec(src, sphPos, &dS);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _sphPos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _dS$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _sphPos$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _dS$[ebp+4]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _sphPos$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _dS$[ebp+8]

; 3097 : 
; 3098 : 	b = Real(2) * VecDotVec(&dR, &dS);

	fld	DWORD PTR _dR$[ebp]
	fmul	DWORD PTR _dS$[ebp]
	fld	DWORD PTR _dR$[ebp+4]
	fmul	DWORD PTR _dS$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dR$[ebp+8]
	fmul	DWORD PTR _dS$[ebp+8]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _b$[ebp]

; 3099 : 	c = VecDotVec(&dS, &dS) - rad * rad;

	fld	DWORD PTR _dS$[ebp]
	fmul	DWORD PTR _dS$[ebp]
	fld	DWORD PTR _dS$[ebp+4]
	fmul	DWORD PTR _dS$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _dS$[ebp+8]
	fmul	DWORD PTR _dS$[ebp+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _rad$[ebp]
	fmul	DWORD PTR _rad$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _c$[ebp]

; 3100 : 
; 3101 : 	d = b * b - (Real(4)  * c);

	fld	DWORD PTR _b$[ebp]
	fmul	DWORD PTR _b$[ebp]
	fld	DWORD PTR __real@40800000
	fmul	DWORD PTR _c$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _d$[ebp]

; 3102 : 
; 3103 : 	if (d < 0) {

	fld	DWORD PTR _d$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L82725

; 3104 : 		*minDist = ONE;

	mov	eax, DWORD PTR _minDist$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 3105 : 		return TRUE;

	mov	al, 1
	jmp	SHORT $L82715
$L82725:

; 3106 : 	}
; 3107 : 
; 3108 : 	if (b > 0) {

	fld	DWORD PTR _b$[ebp]
	fcomp	DWORD PTR __real@00000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L82726

; 3109 : 		*minDist = HALF * (-b + (REAL)sqrt(d)) / dRLen;

	fld	DWORD PTR _b$[ebp]
	fchs
	fstp	DWORD PTR tv223[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fadd	DWORD PTR tv223[ebp]
	fmul	DWORD PTR __real@3f000000
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _minDist$[ebp]
	fstp	DWORD PTR [ecx]

; 3110 : 	} else {

	jmp	SHORT $L82728
$L82726:

; 3111 : 		*minDist = HALF * (-b - (REAL)sqrt(d)) / dRLen;

	fld	DWORD PTR _b$[ebp]
	fchs
	fstp	DWORD PTR tv228[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fsubr	DWORD PTR tv228[ebp]
	fmul	DWORD PTR __real@3f000000
	fdiv	DWORD PTR _dRLen$[ebp]
	mov	ecx, DWORD PTR _minDist$[ebp]
	fstp	DWORD PTR [ecx]
$L82728:

; 3112 : 	}
; 3113 : 	return FALSE;

	xor	al, al
$L82715:

; 3114 : 
; 3115 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LineOfSightSphere@@YA_NPAUVectorStruct@@M00PAM@Z ENDP	; LineOfSightSphere
_TEXT	ENDS
PUBLIC	?GetCollPolyVertices@@YAHPAUCollPolyStruct@@PAUVectorStruct@@111@Z ; GetCollPolyVertices
EXTRN	?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z:NEAR ; PlaneIntersect3
; Function compile flags: /Odt /ZI
;	COMDAT ?GetCollPolyVertices@@YAHPAUCollPolyStruct@@PAUVectorStruct@@111@Z
_TEXT	SEGMENT
_poly$ = 8						; size = 4
_v0$ = 12						; size = 4
_v1$ = 16						; size = 4
_v2$ = 20						; size = 4
_v3$ = 24						; size = 4
?GetCollPolyVertices@@YAHPAUCollPolyStruct@@PAUVectorStruct@@111@Z PROC NEAR ; GetCollPolyVertices, COMDAT

; 3125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3126 : 
; 3127 : 	PlaneIntersect3(&poly->Plane, &poly->EdgePlane[0], &poly->EdgePlane[1], v0);

	mov	eax, DWORD PTR _v0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	push	eax
	call	?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z ; PlaneIntersect3
	add	esp, 16					; 00000010H

; 3128 : 	PlaneIntersect3(&poly->Plane, &poly->EdgePlane[1], &poly->EdgePlane[2], v1);

	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	push	eax
	call	?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z ; PlaneIntersect3
	add	esp, 16					; 00000010H

; 3129 : 	if (IsPolyQuad(poly)) {

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	je	SHORT $L82737

; 3130 : 		PlaneIntersect3(&poly->Plane, &poly->EdgePlane[2], &poly->EdgePlane[3], v2);

	mov	eax, DWORD PTR _v2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	push	eax
	call	?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z ; PlaneIntersect3
	add	esp, 16					; 00000010H

; 3131 : 		PlaneIntersect3(&poly->Plane, &poly->EdgePlane[3], &poly->EdgePlane[0], v3);

	mov	eax, DWORD PTR _v3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	push	eax
	call	?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z ; PlaneIntersect3
	add	esp, 16					; 00000010H

; 3132 : 	} else {

	jmp	SHORT $L82738
$L82737:

; 3133 : 		PlaneIntersect3(&poly->Plane, &poly->EdgePlane[2], &poly->EdgePlane[0], v2);

	mov	eax, DWORD PTR _v2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _poly$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	push	eax
	call	?PlaneIntersect3@@YA_NPAUPlaneStruct@@00PAUVectorStruct@@@Z ; PlaneIntersect3
	add	esp, 16					; 00000010H
$L82738:

; 3134 : 	}
; 3135 : 
; 3136 : 	return (IsPolyQuad(poly))? 4: 3;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	eax, DWORD PTR [eax]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	add	eax, 3

; 3137 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCollPolyVertices@@YAHPAUCollPolyStruct@@PAUVectorStruct@@111@Z ENDP ; GetCollPolyVertices
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z
_TEXT	SEGMENT
tv153 = -68						; size = 4
tv142 = -68						; size = 4
tv131 = -68						; size = 4
tv88 = -68						; size = 4
tv77 = -68						; size = 4
tv68 = -68						; size = 4
_bBox$ = 8						; size = 4
_pos$ = 12						; size = 4
_radius$ = 16						; size = 4
?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z PROC NEAR ; AddPosRadToBBox, COMDAT

; 3147 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3148 : 	bBox->XMin = Min(bBox->XMin, pos->v[X] - radius);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR _radius$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83188
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $L83189
$L83188:
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR _radius$[ebp]
	fstp	DWORD PTR tv68[ebp]
$L83189:
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR [edx], eax

; 3149 : 	bBox->XMax = Max(bBox->XMax, pos->v[X] + radius);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83190
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $L83191
$L83190:
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR tv77[ebp]
$L83191:
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR [edx+4], eax

; 3150 : 	bBox->YMin = Min(bBox->YMin, pos->v[Y] - radius);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _radius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83192
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $L83193
$L83192:
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR _radius$[ebp]
	fstp	DWORD PTR tv88[ebp]
$L83193:
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR [edx+8], eax

; 3151 : 	bBox->YMax = Max(bBox->YMax, pos->v[Y] + radius);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83194
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $L83195
$L83194:
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [ecx+4]
	fstp	DWORD PTR tv131[ebp]
$L83195:
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR [edx+12], eax

; 3152 : 	bBox->ZMin = Min(bBox->ZMin, pos->v[Z] - radius);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _radius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83196
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $L83197
$L83196:
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _radius$[ebp]
	fstp	DWORD PTR tv142[ebp]
$L83197:
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR [edx+16], eax

; 3153 : 	bBox->ZMax = Max(bBox->ZMax, pos->v[Z] + radius);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83198
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv153[ebp], eax
	jmp	SHORT $L83199
$L83198:
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv153[ebp]
$L83199:
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR tv153[ebp]
	mov	DWORD PTR [edx+20], eax

; 3154 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddPosRadToBBox@@YAXPAUBBOX@@PAUVectorStruct@@M@Z ENDP	; AddPosRadToBBox
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
tv139 = -68						; size = 4
tv130 = -68						; size = 4
tv89 = -68						; size = 4
tv80 = -68						; size = 4
tv71 = -68						; size = 4
tv65 = -68						; size = 4
_bBox$ = 8						; size = 4
_pos$ = 12						; size = 4
?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z PROC NEAR ; AddPointToBBox, COMDAT

; 3163 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3164 : 	bBox->XMin = Min(bBox->XMin, pos->v[X]);

	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83202
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L83203
$L83202:
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv65[ebp], edx
$L83203:
	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR [eax], ecx

; 3165 : 	bBox->XMax = Max(bBox->XMax, pos->v[X]);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _pos$[ebp]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83204
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $L83205
$L83204:
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv71[ebp], edx
$L83205:
	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3166 : 	bBox->YMin = Min(bBox->YMin, pos->v[Y]);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83206
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $L83207
$L83206:
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv80[ebp], edx
$L83207:
	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3167 : 	bBox->YMax = Max(bBox->YMax, pos->v[Y]);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83208
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $L83209
$L83208:
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv89[ebp], edx
$L83209:
	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR [eax+12], ecx

; 3168 : 	bBox->ZMin = Min(bBox->ZMin, pos->v[Z]);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L83210
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $L83211
$L83210:
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv130[ebp], edx
$L83211:
	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	DWORD PTR [eax+16], ecx

; 3169 : 	bBox->ZMax = Max(bBox->ZMax, pos->v[Z]);

	mov	eax, DWORD PTR _bBox$[ebp]
	fld	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L83212
	mov	edx, DWORD PTR _bBox$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $L83213
$L83212:
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv139[ebp], edx
$L83213:
	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3170 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ENDP	; AddPointToBBox
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z
_TEXT	SEGMENT
_destPt$ = -24						; size = 12
_pt$ = -12						; size = 12
_srcBox$ = 8						; size = 4
_mat$ = 12						; size = 4
_pos$ = 16						; size = 4
_destBox$ = 20						; size = 4
?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z PROC NEAR ; RotTransBBox, COMDAT

; 3180 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 3181 : 	VEC pt, destPt;
; 3182 : 
; 3183 : 	// Set destination box to invalid box
; 3184 : 	SetBBox(destBox, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST, LARGEDIST, -LARGEDIST);

	mov	eax, DWORD PTR _destBox$[ebp]
	mov	DWORD PTR [eax], 1232348160		; 49742400H
	mov	eax, DWORD PTR _destBox$[ebp]
	mov	DWORD PTR [eax+4], -915135488		; c9742400H
	mov	eax, DWORD PTR _destBox$[ebp]
	mov	DWORD PTR [eax+8], 1232348160		; 49742400H
	mov	eax, DWORD PTR _destBox$[ebp]
	mov	DWORD PTR [eax+12], -915135488		; c9742400H
	mov	eax, DWORD PTR _destBox$[ebp]
	mov	DWORD PTR [eax+16], 1232348160		; 49742400H
	mov	eax, DWORD PTR _destBox$[ebp]
	mov	DWORD PTR [eax+20], -915135488		; c9742400H

; 3185 : 
; 3186 : 	// Transform the corners of the source box into new frame and add to dest box
; 3187 : 	SetVec(&pt, srcBox->XMin, srcBox->YMin, srcBox->ZMin);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3188 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3189 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3190 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3191 : 
; 3192 : 	SetVec(&pt, srcBox->XMin, srcBox->YMin, srcBox->ZMax);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3193 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3194 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3195 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3196 : 
; 3197 : 	SetVec(&pt, srcBox->XMin, srcBox->YMax, srcBox->ZMin);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3198 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3199 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3200 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3201 : 
; 3202 : 	SetVec(&pt, srcBox->XMin, srcBox->YMax, srcBox->ZMax);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3203 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3204 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3205 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3206 : 
; 3207 : 	SetVec(&pt, srcBox->XMax, srcBox->YMin, srcBox->ZMin);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3208 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3209 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3210 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3211 : 
; 3212 : 	SetVec(&pt, srcBox->XMax, srcBox->YMin, srcBox->ZMax);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3213 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3214 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3215 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3216 : 
; 3217 : 	SetVec(&pt, srcBox->XMax, srcBox->YMax, srcBox->ZMin);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3218 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3219 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3220 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3221 : 
; 3222 : 	SetVec(&pt, srcBox->XMax, srcBox->YMax, srcBox->ZMax);

	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pt$[ebp], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pt$[ebp+4], ecx
	mov	eax, DWORD PTR _srcBox$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pt$[ebp+8], ecx

; 3223 : 	VecMulMat(&pt, mat, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?VecMulMat@@YAXPAUVectorStruct@@PATMatrixUnion@@0@Z ; VecMulMat
	add	esp, 12					; 0000000cH

; 3224 : 	VecPlusEqVec(&destPt, pos);

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _destPt$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+4]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _destPt$[ebp+4]
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR _destPt$[ebp+8]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR _destPt$[ebp+8]

; 3225 : 	AddPointToBBox(destBox, &destPt);

	lea	eax, DWORD PTR _destPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _destBox$[ebp]
	push	ecx
	call	?AddPointToBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; AddPointToBBox
	add	esp, 8

; 3226 : 
; 3227 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z ENDP ; RotTransBBox
_TEXT	ENDS
PUBLIC	?TransBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z	; TransBBox
; Function compile flags: /Odt /ZI
;	COMDAT ?TransBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_bBox$ = 8						; size = 4
_sPos$ = 12						; size = 4
?TransBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z PROC NEAR	; TransBBox, COMDAT

; 3230 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3231 : 	bBox->XMin += sPos->v[X];

	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [edx]

; 3232 : 	bBox->XMax += sPos->v[X];

	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [edx+4]

; 3233 : 	bBox->YMin += sPos->v[Y];

	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [edx+8]

; 3234 : 	bBox->YMax += sPos->v[Y];

	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax+12]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [edx+12]

; 3235 : 	bBox->ZMin += sPos->v[Z];

	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [edx+16]

; 3236 : 	bBox->ZMax += sPos->v[Z];

	mov	eax, DWORD PTR _bBox$[ebp]
	mov	ecx, DWORD PTR _sPos$[ebp]
	fld	DWORD PTR [eax+20]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _bBox$[ebp]
	fstp	DWORD PTR [edx+20]

; 3237 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ENDP	; TransBBox
_TEXT	ENDS
PUBLIC	?RotTransCollPolys@@YAXPAUCollPolyStruct@@HPATMatrixUnion@@PAUVectorStruct@@@Z ; RotTransCollPolys
; Function compile flags: /Odt /ZI
;	COMDAT ?RotTransCollPolys@@YAXPAUCollPolyStruct@@HPATMatrixUnion@@PAUVectorStruct@@@Z
_TEXT	SEGMENT
_bBox$ = -56						; size = 24
_plane$ = -32						; size = 16
_poly$ = -16						; size = 4
_nEdges$ = -12						; size = 4
_iEdge$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_collPoly$ = 8						; size = 4
_nPolys$ = 12						; size = 4
_rMat$ = 16						; size = 4
_dPos$ = 20						; size = 4
?RotTransCollPolys@@YAXPAUCollPolyStruct@@HPATMatrixUnion@@PAUVectorStruct@@@Z PROC NEAR ; RotTransCollPolys, COMDAT

; 3246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 3247 : 	int iPoly, iEdge, nEdges;
; 3248 : 	NEWCOLLPOLY *poly;
; 3249 : 	PLANE plane;
; 3250 : 	BBOX bBox;
; 3251 : 
; 3252 : 	for (iPoly = 0; iPoly < nPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82772
$L82773:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82772:
	mov	eax, DWORD PTR _iPoly$[ebp]
	cmp	eax, DWORD PTR _nPolys$[ebp]
	jge	$L82765

; 3253 : 		poly = &collPoly[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	add	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR _poly$[ebp], eax

; 3254 : 		nEdges = (IsPolyQuad(poly))? 4: 3;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	DWORD PTR _nEdges$[ebp], ecx

; 3255 : 
; 3256 : 		RotTransPlane(&poly->Plane, rMat, dPos, &plane);

	lea	eax, DWORD PTR _plane$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rMat$[ebp]
	push	edx
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	push	eax
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H

; 3257 : 		CopyPlane(&plane, &poly->Plane);

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp+4]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp+8]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp+12]
	mov	DWORD PTR [eax+20], ecx

; 3258 : 
; 3259 : 		for (iEdge = 0; iEdge < nEdges; iEdge++) {

	mov	DWORD PTR _iEdge$[ebp], 0
	jmp	SHORT $L82775
$L82776:
	mov	eax, DWORD PTR _iEdge$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEdge$[ebp], eax
$L82775:
	mov	eax, DWORD PTR _iEdge$[ebp]
	cmp	eax, DWORD PTR _nEdges$[ebp]
	jge	SHORT $L82777

; 3260 : 
; 3261 : 			RotTransPlane(&poly->EdgePlane[iEdge], rMat, dPos, &plane);

	lea	eax, DWORD PTR _plane$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rMat$[ebp]
	push	edx
	mov	eax, DWORD PTR _iEdge$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24]
	push	edx
	call	?RotTransPlane@@YAXPAUPlaneStruct@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransPlane
	add	esp, 16					; 00000010H

; 3262 : 			CopyPlane(&plane, &poly->EdgePlane[iEdge]);

	mov	eax, DWORD PTR _iEdge$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _poly$[ebp]
	mov	edx, DWORD PTR _plane$[ebp]
	mov	DWORD PTR [ecx+eax+24], edx
	mov	eax, DWORD PTR _iEdge$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _poly$[ebp]
	mov	edx, DWORD PTR _plane$[ebp+4]
	mov	DWORD PTR [ecx+eax+28], edx
	mov	eax, DWORD PTR _iEdge$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _poly$[ebp]
	mov	edx, DWORD PTR _plane$[ebp+8]
	mov	DWORD PTR [ecx+eax+32], edx
	mov	eax, DWORD PTR _iEdge$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _poly$[ebp]
	mov	edx, DWORD PTR _plane$[ebp+12]
	mov	DWORD PTR [ecx+eax+36], edx

; 3263 : 
; 3264 : 		}

	jmp	SHORT $L82776
$L82777:

; 3265 : 
; 3266 : 		RotTransBBox(&poly->BBox, rMat, dPos, &bBox);

	lea	eax, DWORD PTR _bBox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rMat$[ebp]
	push	edx
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	call	?RotTransBBox@@YAXPAUBBOX@@PATMatrixUnion@@PAUVectorStruct@@0@Z ; RotTransBBox
	add	esp, 16					; 00000010H

; 3267 : 		CopyBBox(&bBox, &poly->BBox);

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp]
	mov	DWORD PTR [eax+88], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp+4]
	mov	DWORD PTR [eax+92], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp+8]
	mov	DWORD PTR [eax+96], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp+12]
	mov	DWORD PTR [eax+100], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp+16]
	mov	DWORD PTR [eax+104], ecx
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _bBox$[ebp+20]
	mov	DWORD PTR [eax+108], ecx

; 3268 : 	}

	jmp	$L82773
$L82765:

; 3269 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RotTransCollPolys@@YAXPAUCollPolyStruct@@HPATMatrixUnion@@PAUVectorStruct@@@Z ENDP ; RotTransCollPolys
_TEXT	ENDS
PUBLIC	?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z ; TransCollPolys
EXTRN	?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z:NEAR ; MovePlane
; Function compile flags: /Odt /ZI
;	COMDAT ?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z
_TEXT	SEGMENT
_poly$ = -16						; size = 4
_nEdges$ = -12						; size = 4
_iEdge$ = -8						; size = 4
_iPoly$ = -4						; size = 4
_collPoly$ = 8						; size = 4
_nPolys$ = 12						; size = 4
_dPos$ = 16						; size = 4
?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z PROC NEAR ; TransCollPolys, COMDAT

; 3278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 3279 : 	int iPoly, iEdge, nEdges;
; 3280 : 	NEWCOLLPOLY *poly;
; 3281 : 
; 3282 : 	for (iPoly = 0; iPoly < nPolys; iPoly++) {

	mov	DWORD PTR _iPoly$[ebp], 0
	jmp	SHORT $L82787
$L82788:
	mov	eax, DWORD PTR _iPoly$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPoly$[ebp], eax
$L82787:
	mov	eax, DWORD PTR _iPoly$[ebp]
	cmp	eax, DWORD PTR _nPolys$[ebp]
	jge	$L82782

; 3283 : 		poly = &collPoly[iPoly];

	mov	eax, DWORD PTR _iPoly$[ebp]
	imul	eax, 112				; 00000070H
	add	eax, DWORD PTR _collPoly$[ebp]
	mov	DWORD PTR _poly$[ebp], eax

; 3284 : 		nEdges = (IsPolyQuad(poly))? 4: 3;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	add	ecx, 3
	mov	DWORD PTR _nEdges$[ebp], ecx

; 3285 : 
; 3286 : 		MovePlane(&poly->Plane, dPos);

	mov	eax, DWORD PTR _dPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	add	ecx, 8
	push	ecx
	call	?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z ; MovePlane
	add	esp, 8

; 3287 : 
; 3288 : 		for (iEdge = 0; iEdge < nEdges; iEdge++) {

	mov	DWORD PTR _iEdge$[ebp], 0
	jmp	SHORT $L82790
$L82791:
	mov	eax, DWORD PTR _iEdge$[ebp]
	add	eax, 1
	mov	DWORD PTR _iEdge$[ebp], eax
$L82790:
	mov	eax, DWORD PTR _iEdge$[ebp]
	cmp	eax, DWORD PTR _nEdges$[ebp]
	jge	SHORT $L82792

; 3289 : 
; 3290 : 			MovePlane(&poly->EdgePlane[iEdge], dPos);

	mov	eax, DWORD PTR _dPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iEdge$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _poly$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24]
	push	eax
	call	?MovePlane@@YAXPAUPlaneStruct@@PAUVectorStruct@@@Z ; MovePlane
	add	esp, 8

; 3291 : 
; 3292 : 		}

	jmp	SHORT $L82791
$L82792:

; 3293 : 
; 3294 : 		TransBBox(&poly->BBox, dPos);

	mov	eax, DWORD PTR _dPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	call	?TransBBox@@YAXPAUBBOX@@PAUVectorStruct@@@Z ; TransBBox
	add	esp, 8

; 3295 : 	}

	jmp	$L82788
$L82782:

; 3296 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransCollPolys@@YAXPAUCollPolyStruct@@HPAUVectorStruct@@@Z ENDP ; TransCollPolys
_TEXT	ENDS
PUBLIC	?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ	; NextBodyCollInfo
; Function compile flags: /Odt /ZI
;	COMDAT ?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ
_TEXT	SEGMENT
?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ PROC NEAR ; NextBodyCollInfo, COMDAT

; 3306 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3307 : 	if (COL_NBodyColls == MAX_COLLS_BODY) {

	cmp	DWORD PTR ?COL_NBodyColls@@3HA, 500	; COL_NBodyColls, 000001f4H
	jne	SHORT $L82795

; 3308 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L82794
$L82795:

; 3309 : 	} else {
; 3310 : 		COL_BodyCollInfo[COL_NBodyColls].Prev = COL_BodyCollInfo[COL_NBodyColls].Next = NULL;

	mov	eax, DWORD PTR ?COL_NBodyColls@@3HA	; COL_NBodyColls
	imul	eax, 112				; 00000070H
	mov	DWORD PTR ?COL_BodyCollInfo@@3PAUBodyCollInfoStruct@@A[eax+104], 0
	mov	ecx, DWORD PTR ?COL_NBodyColls@@3HA	; COL_NBodyColls
	imul	ecx, 112				; 00000070H
	mov	DWORD PTR ?COL_BodyCollInfo@@3PAUBodyCollInfoStruct@@A[ecx+108], 0

; 3311 : 		COL_BodyCollInfo[COL_NBodyColls].Active = FALSE;

	mov	eax, DWORD PTR ?COL_NBodyColls@@3HA	; COL_NBodyColls
	imul	eax, 112				; 00000070H
	mov	BYTE PTR ?COL_BodyCollInfo@@3PAUBodyCollInfoStruct@@A[eax], 0

; 3312 : 		return &COL_BodyCollInfo[COL_NBodyColls];

	mov	eax, DWORD PTR ?COL_NBodyColls@@3HA	; COL_NBodyColls
	imul	eax, 112				; 00000070H
	add	eax, OFFSET FLAT:?COL_BodyCollInfo@@3PAUBodyCollInfoStruct@@A ; COL_BodyCollInfo
$L82794:

; 3313 : 	}
; 3314 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextBodyCollInfo@@YAPAUBodyCollInfoStruct@@XZ ENDP	; NextBodyCollInfo
_TEXT	ENDS
PUBLIC	?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ; NextWheelCollInfo
; Function compile flags: /Odt /ZI
;	COMDAT ?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ
_TEXT	SEGMENT
?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ PROC NEAR ; NextWheelCollInfo, COMDAT

; 3323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3324 : 	if (COL_NWheelColls == MAX_COLLS_BODY) {

	cmp	DWORD PTR ?COL_NWheelColls@@3HA, 500	; COL_NWheelColls, 000001f4H
	jne	SHORT $L82799

; 3325 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L82798
$L82799:

; 3326 : 	} else {
; 3327 : 		COL_WheelCollInfo[COL_NWheelColls].Prev = COL_WheelCollInfo[COL_NWheelColls].Next = NULL;

	mov	eax, DWORD PTR ?COL_NWheelColls@@3HA	; COL_NWheelColls
	imul	eax, 112				; 00000070H
	mov	DWORD PTR ?COL_WheelCollInfo@@3PAUWheelCollInfoStruct@@A[eax+104], 0
	mov	ecx, DWORD PTR ?COL_NWheelColls@@3HA	; COL_NWheelColls
	imul	ecx, 112				; 00000070H
	mov	DWORD PTR ?COL_WheelCollInfo@@3PAUWheelCollInfoStruct@@A[ecx+108], 0

; 3328 : 		//COL_WheelCollInfo[COL_NWheelColls].Active = FALSE;
; 3329 : 		return &COL_WheelCollInfo[COL_NWheelColls];

	mov	eax, DWORD PTR ?COL_NWheelColls@@3HA	; COL_NWheelColls
	imul	eax, 112				; 00000070H
	add	eax, OFFSET FLAT:?COL_WheelCollInfo@@3PAUWheelCollInfoStruct@@A ; COL_WheelCollInfo
$L82798:

; 3330 : 	}
; 3331 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextWheelCollInfo@@YAPAUWheelCollInfoStruct@@XZ ENDP	; NextWheelCollInfo
_TEXT	ENDS
END
