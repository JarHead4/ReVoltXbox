; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\source\mirror.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IL@PDAOOPJM@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadMirrorPlanes@@YA_NPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeMirrorPlanes@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMirrorParams@@YAXPAULEVELINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMirrorPlane@@YAJPAUVectorStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??FreeMirrorPlanes@@YAXXZ@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??LoadMirrorPlanes@@YA_NPAD@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCD
INCLUDELIB OLDNAMES

PUBLIC	?MirrorPlaneNum@@3JA				; MirrorPlaneNum
PUBLIC	?MirrorPlanes@@3PAUMIRROR_PLANE@@A		; MirrorPlanes
PUBLIC	?MirrorType@@3JA				; MirrorType
PUBLIC	?MirrorAlpha@@3JA				; MirrorAlpha
PUBLIC	?MirrorHeight@@3MA				; MirrorHeight
PUBLIC	?MirrorMul@@3MA					; MirrorMul
PUBLIC	?MirrorAdd@@3MA					; MirrorAdd
PUBLIC	?MirrorDist@@3MA				; MirrorDist
_BSS	SEGMENT
?MirrorPlaneNum@@3JA DD 01H DUP (?)			; MirrorPlaneNum
?MirrorPlanes@@3PAUMIRROR_PLANE@@A DD 01H DUP (?)	; MirrorPlanes
?MirrorType@@3JA DD 01H DUP (?)				; MirrorType
?MirrorAlpha@@3JA DD 01H DUP (?)			; MirrorAlpha
?MirrorHeight@@3MA DD 01H DUP (?)			; MirrorHeight
?MirrorMul@@3MA DD 01H DUP (?)				; MirrorMul
?MirrorAdd@@3MA DD 01H DUP (?)				; MirrorAdd
?MirrorDist@@3MA DD 01H DUP (?)				; MirrorDist
_BSS	ENDS
PUBLIC	?LoadMirrorPlanes@@YA_NPAD@Z			; LoadMirrorPlanes
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?__LINE__Var@?1??LoadMirrorPlanes@@YA_NPAD@Z@4JA ; `LoadMirrorPlanes'::`2'::__LINE__Var
PUBLIC	??_C@_0IL@PDAOOPJM@c?3?2documents?5and?5settings?2jarhea@ ; `string'
PUBLIC	__real@43480000
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
EXTRN	__fltused:NEAR
EXTRN	?DebugMalloc@@YAPAXIHPAD@Z:NEAR			; DebugMalloc
;	COMDAT ??_C@_02JDPG@rb?$AA@
; File c:\documents and settings\jarhead\desktop\shit to display my love for xbox revolt and fuck you borman-ness\revolt source\source\mirror.cpp
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IL@PDAOOPJM@c?3?2documents?5and?5settings?2jarhea@
CONST	SEGMENT
??_C@_0IL@PDAOOPJM@c?3?2documents?5and?5settings?2jarhea@ DB 'c:\document'
	DB	's and settings\jarhead\desktop\shit to display my love for xb'
	DB	'ox revolt and fuck you borman-ness\revolt source\source\mirro'
	DB	'r.cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??LoadMirrorPlanes@@YA_NPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??LoadMirrorPlanes@@YA_NPAD@Z@4JA DD 014H ; `LoadMirrorPlanes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?LoadMirrorPlanes@@YA_NPAD@Z
_TEXT	SEGMENT
_fp$ = -104						; size = 4
_mpl$ = -100						; size = 92
_mph$ = -8						; size = 2
_i$ = -4						; size = 4
_file$ = 8						; size = 4
?LoadMirrorPlanes@@YA_NPAD@Z PROC NEAR			; LoadMirrorPlanes, COMDAT

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi

; 21   : 	long i;
; 22   : 	MIRROR_PLANE_HEADER mph;
; 23   : 	MIRROR_PLANE_LOAD mpl;
; 24   : 	FILE *fp;
; 25   : 
; 26   : // open file for reading
; 27   : 
; 28   : 	fp = fopen(file, "rb");

	push	OFFSET FLAT:??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 29   : 	if (!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $L80011

; 30   : 	{
; 31   : 		MirrorPlaneNum = 0;

	mov	DWORD PTR ?MirrorPlaneNum@@3JA, 0	; MirrorPlaneNum

; 32   : 		MirrorPlanes = NULL;

	mov	DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A, 0 ; MirrorPlanes

; 33   : 		return FALSE;

	xor	al, al
	jmp	$L80005
$L80011:

; 34   : 	 }
; 35   : 
; 36   : // get header info, alloc coll memory
; 37   : 
; 38   : 	fread(&mph, sizeof(mph), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _mph$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 39   : 	MirrorPlaneNum = mph.MirrorPlaneNum;

	movsx	eax, WORD PTR _mph$[ebp]
	mov	DWORD PTR ?MirrorPlaneNum@@3JA, eax	; MirrorPlaneNum

; 40   : 	MirrorPlanes = (MIRROR_PLANE*)malloc(MirrorPlaneNum * sizeof(MIRROR_PLANE));

	push	OFFSET FLAT:??_C@_0IL@PDAOOPJM@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??LoadMirrorPlanes@@YA_NPAD@Z@4JA
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ?MirrorPlaneNum@@3JA	; MirrorPlaneNum
	imul	ecx, 20					; 00000014H
	push	ecx
	call	?DebugMalloc@@YAPAXIHPAD@Z		; DebugMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A, eax ; MirrorPlanes

; 41   : 	if (!MirrorPlanes)

	cmp	DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A, 0 ; MirrorPlanes
	jne	SHORT $L80016

; 42   : 	{
; 43   : 		MirrorPlaneNum = 0;

	mov	DWORD PTR ?MirrorPlaneNum@@3JA, 0	; MirrorPlaneNum

; 44   : 		return FALSE;

	xor	al, al
	jmp	$L80005
$L80016:

; 45   : 	}
; 46   : 
; 47   : // read in polys
; 48   : 
; 49   : 	for (i = 0 ; i < MirrorPlaneNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L80017
$L80018:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L80017:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?MirrorPlaneNum@@3JA	; MirrorPlaneNum
	jge	$L80019

; 50   : 	{
; 51   : 		fread(&mpl, sizeof(mpl), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	92					; 0000005cH
	lea	ecx, DWORD PTR _mpl$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 52   : 
; 53   : 		MirrorPlanes[i].Xmin = mpl.MinX - MIRROR_PLANE_OVERLAP;

	fld	DWORD PTR _mpl$[ebp+20]
	fsub	DWORD PTR __real@43480000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fstp	DWORD PTR [ecx+eax]

; 54   : 		MirrorPlanes[i].Xmax = mpl.MaxX + MIRROR_PLANE_OVERLAP;

	fld	DWORD PTR _mpl$[ebp+24]
	fadd	DWORD PTR __real@43480000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fstp	DWORD PTR [ecx+eax+4]

; 55   : 
; 56   : 		MirrorPlanes[i].Zmin = mpl.MinZ - MIRROR_PLANE_OVERLAP;

	fld	DWORD PTR _mpl$[ebp+36]
	fsub	DWORD PTR __real@43480000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fstp	DWORD PTR [ecx+eax+8]

; 57   : 		MirrorPlanes[i].Zmax = mpl.MaxZ + MIRROR_PLANE_OVERLAP;

	fld	DWORD PTR _mpl$[ebp+40]
	fadd	DWORD PTR __real@43480000
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fstp	DWORD PTR [ecx+eax+12]

; 58   : 
; 59   : 		MirrorPlanes[i].Height = mpl.v0.v[Y];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	mov	edx, DWORD PTR _mpl$[ebp+48]
	mov	DWORD PTR [ecx+eax+16], edx

; 60   : 	}

	jmp	$L80018
$L80019:

; 61   : 
; 62   : // close file
; 63   : 
; 64   : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 65   : 
; 66   : // return OK
; 67   : 
; 68   : 	return TRUE;

	mov	al, 1
$L80005:

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadMirrorPlanes@@YA_NPAD@Z ENDP			; LoadMirrorPlanes
_TEXT	ENDS
PUBLIC	?FreeMirrorPlanes@@YAXXZ			; FreeMirrorPlanes
PUBLIC	?__LINE__Var@?1??FreeMirrorPlanes@@YAXXZ@4JA	; `FreeMirrorPlanes'::`2'::__LINE__Var
EXTRN	?DebugFree@@YAXPAXHPAD@Z:NEAR			; DebugFree
;	COMDAT ?__LINE__Var@?1??FreeMirrorPlanes@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??FreeMirrorPlanes@@YAXXZ@4JA DD 04cH	; `FreeMirrorPlanes'::`2'::__LINE__Var
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?FreeMirrorPlanes@@YAXXZ
_TEXT	SEGMENT
?FreeMirrorPlanes@@YAXXZ PROC NEAR			; FreeMirrorPlanes, COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 77   : 	free(MirrorPlanes);

	push	OFFSET FLAT:??_C@_0IL@PDAOOPJM@c?3?2documents?5and?5settings?2jarhea@
	mov	eax, DWORD PTR ?__LINE__Var@?1??FreeMirrorPlanes@@YAXXZ@4JA
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	push	ecx
	call	?DebugFree@@YAXPAXHPAD@Z		; DebugFree
	add	esp, 12					; 0000000cH

; 78   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeMirrorPlanes@@YAXXZ ENDP				; FreeMirrorPlanes
_TEXT	ENDS
PUBLIC	?SetMirrorParams@@YAXPAULEVELINFO@@@Z		; SetMirrorParams
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
EXTRN	__ftol2:NEAR
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?SetMirrorParams@@YAXPAULEVELINFO@@@Z
_TEXT	SEGMENT
_lev$ = 8						; size = 4
?SetMirrorParams@@YAXPAULEVELINFO@@@Z PROC NEAR		; SetMirrorParams, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 86   : 	MirrorType = lev->MirrorType;

	mov	eax, DWORD PTR _lev$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	mov	DWORD PTR ?MirrorType@@3JA, ecx		; MirrorType

; 87   : 	MirrorAlpha = (long)(lev->MirrorMix * 255) << 24;

	mov	eax, DWORD PTR _lev$[ebp]
	fld	DWORD PTR [eax+220]
	fmul	DWORD PTR __real@437f0000
	call	__ftol2
	shl	eax, 24					; 00000018H
	mov	DWORD PTR ?MirrorAlpha@@3JA, eax	; MirrorAlpha

; 88   : 
; 89   : 	MirrorAdd = lev->MirrorIntensity * 256;

	mov	eax, DWORD PTR _lev$[ebp]
	fld	DWORD PTR [eax+224]
	fmul	DWORD PTR __real@43800000
	fstp	DWORD PTR ?MirrorAdd@@3MA		; MirrorAdd

; 90   : 	MirrorDist = lev->MirrorDist;

	mov	eax, DWORD PTR _lev$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR ?MirrorDist@@3MA, ecx

; 91   : 	MirrorMul = (256 - MirrorAdd) / MirrorDist;

	fld	DWORD PTR __real@43800000
	fsub	DWORD PTR ?MirrorAdd@@3MA		; MirrorAdd
	fdiv	DWORD PTR ?MirrorDist@@3MA		; MirrorDist
	fstp	DWORD PTR ?MirrorMul@@3MA		; MirrorMul

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMirrorParams@@YAXPAULEVELINFO@@@Z ENDP		; SetMirrorParams
_TEXT	ENDS
PUBLIC	?GetMirrorPlane@@YAJPAUVectorStruct@@@Z		; GetMirrorPlane
; Function compile flags: /Odt /ZI
;	COMDAT ?GetMirrorPlane@@YAJPAUVectorStruct@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pos$ = 8						; size = 4
?GetMirrorPlane@@YAJPAUVectorStruct@@@Z PROC NEAR	; GetMirrorPlane, COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 100  : 	long i;
; 101  : 
; 102  : // loop thru all planes
; 103  : 
; 104  : 	for (i = 0 ; i < MirrorPlaneNum ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L80032
$L80033:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L80032:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?MirrorPlaneNum@@3JA	; MirrorPlaneNum
	jge	$L80034

; 105  : 	{
; 106  : 		if (pos->v[X] < MirrorPlanes[i].Xmin ||
; 107  : 			pos->v[X] > MirrorPlanes[i].Xmax ||
; 108  : 			pos->v[Z] < MirrorPlanes[i].Zmin ||
; 109  : 			pos->v[Z] > MirrorPlanes[i].Zmax)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+eax]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L80036
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+eax+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L80036
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+eax+8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L80036
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+eax+12]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L80035
$L80036:

; 110  : 				continue;

	jmp	$L80033
$L80035:

; 111  : 
; 112  : // found a good one
; 113  : 
; 114  : 		MirrorHeight = MirrorPlanes[i].Height;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ?MirrorPlanes@@3PAUMIRROR_PLANE@@A ; MirrorPlanes
	mov	edx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR ?MirrorHeight@@3MA, edx

; 115  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L80030
$L80034:

; 116  : 	}
; 117  : 	
; 118  : // return none
; 119  : 
; 120  : 	return FALSE;

	xor	eax, eax
$L80030:

; 121  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMirrorPlane@@YAJPAUVectorStruct@@@Z ENDP		; GetMirrorPlane
_TEXT	ENDS
END
